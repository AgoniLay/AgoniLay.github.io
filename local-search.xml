<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端综合笔记</title>
    <link href="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="html-模块"><a href="#html-模块" class="headerlink" title="html 模块"></a>html 模块</h1><h2 id="html-基本结构"><a href="#html-基本结构" class="headerlink" title="html 基本结构"></a>html 基本结构</h2><ol><li>html 标签是由&lt;&gt;包围的关键词。</li><li>html 标签通常成对出现，分为标签开头和标签结尾。</li><li>有部分标签是没有结束标签的，为单标签，单标签必须使用 / 结尾。</li><li>页面所有的内容，都在 html 标签中。</li><li>html 标签分为三部分：标签名称，标签内容，标签属性。</li><li>html 标签具有语义化，可通过标签名能够判断出该标签的内容，语义化的作 用是网页</li><li>结构层次更清晰，更容易被搜索引擎收录，更容易让屏幕阅读器读出网页内容。</li><li>标签的内容是在一对标签内部的内容。</li><li>标签的内容可以是其他标签。</li></ol><h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><ul><li>class 属性：用于定义元素的类名</li><li>id 属性：用于指定元素的唯一 id，该属性的值在整个 html 文档中具有唯一 性</li><li>style 属性：用于指定元素的行内样式，使用该属性后将会覆盖任何全局的样式设定</li><li>title 属性：用于指定元素的额外信息</li><li>accesskey 属性：用于指定激活元素的快捷键</li><li>tabindex 属性：用于指定元素在 tab 键下的次序</li><li>dir 属性：用于指定元素中内容的文本方向，属性只有<code>ltr</code>或<code>rtl</code>两种(8) lang 属性：用于指定元素内容的语言</li></ul><h2 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h2><ul><li>window 窗口事件，onload，在网页加载结束之后触发，onunload，在用户从网页离开时发生（点击跳转，页面重载，关闭浏览器窗口等）</li><li>form 表单事件：<ul><li>onblur，当元素失去焦点时触发</li><li>onchange，在元素的值被改变时触发</li><li>onfocus，当元素获得焦点时触发</li><li>onreset，当表单中的重置按钮被点击时触发</li><li>onselect，在元素中文本被选中后触发</li><li>onsubmit，在提交表单时触发</li></ul></li><li>keyboard 键盘事件：<ul><li>onkeydown，在用户按下按键时触发</li><li>onkeypress，在用户按下按键后，按着按键时触发。该属性不会对所有按键生效，不生效的有：alt, ctrl, shift, esc</li></ul></li><li>mouse 鼠标事件：<ul><li>onclick，当在元素上发生鼠标点击时触发</li><li>onblclick，当在元素上发生鼠标双击时触发</li><li>onmousedown，当元素上按下鼠标按钮时触发</li><li>onmousemove，当鼠标指针移动到元素上时触发</li><li>onmouseout，当元素指针移出元素时触发</li><li>onmouseup，当元素上释放鼠标按钮时触发</li></ul></li><li>Media 媒体事件：<ul><li>onabort，当退出时触发</li><li>onwaiting，当媒体已停止播放但打算继续播放时触发。 </li></ul></li></ul><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><ul><li>段落标签 <code>&lt;p&gt;&lt;/p&gt;</code> ，段落标签用来描述一段文字 </li><li>标题标签 <code>&lt;hx&gt;&lt;/hx&gt;</code> ，标题标签用来描述一个标题，标题标签总共有六个级别，<code>&lt;h1&gt;&lt;/h1&gt;</code> 标签在每个页面中通常只出现一次 </li><li>强调语句标签 <code>&lt;em&gt;&lt;/em&gt;</code>，用于强调某些文字的重要性 </li><li>更加强调标签，<code>&lt;strong&gt;&lt;/strong&gt;</code> 和 <code>&lt;em&gt;</code> 标签一样，用于强调文本，但它强调的程度更强一些</li><li>无语义标签 <code>&lt;span&gt;&lt;/span&gt;</code> ，标签是没有语义的 </li><li>短文本引用标签 <code>&lt;q&gt;&lt;/q&gt;</code> ，简短文字的引用 </li><li>长文本引用标签 <code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>，定义长的文本引用 </li><li>换行标签 <code>&lt;br/&gt;</code> </li></ul><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ol><li>链接标签，<a></a> </li><li>图片标签，<img> </li><li>视频标签，<video></video> </li><li>音频标签，<audio></audio> </li></ol><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>无序列表标签，ul, li，<code>&lt;ul&gt;&lt;/ul&gt;</code> 列表定义一个无序列表，<code>&lt;li&gt;&lt;/li&gt;</code> 代表无需列表中的每一个元素 </li><li>有序列表，ol, li </li><li>自定义列表，<code>&lt;dl&gt;&lt;/dl&gt;</code> ，定义列表通常和 <code>&lt;dt&gt;&lt;/dt&gt;</code> 和 <code>&lt;dd&gt;&lt;/dd&gt;</code> 标签一起使用 </li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>表格标签 <table></table> </li><li>表格的一行 <tr></tr> </li><li>表格的表头 <th></th> </li><li>单元格 <td></td> </li><li>表格合并，同一行内，合并几列 colspan=”2”，同一列内，合并几行 rowspan=”3”</li></ol><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><ol><li><p>表单标签 <form></form></p><p><code>&lt;form&gt;&lt;/form&gt;</code> 表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。 </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;传送方式&quot;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;服务器文件&quot;</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><ul><li>action，浏览者输入的数据被传送到的地方 </li><li>method，数据传送的方式 </li></ul></li><li><p>输入标签 <input></p><ul><li>name：为文本框命名，用于提交表单，后台接收数据用。 </li><li>value：为文本输入框设置默认值。 </li><li>type：通过定义不同的 type 类型，input 的功能有所不同。 <ul><li>text 单行文本输入框 </li><li>password 密码输入框（密码显示为*) </li><li>radio 单选框 （checked 属性用于显示选中状态） </li><li>checkbox 复选框（checked 属性用于显示选中状态） </li><li>file 上传文件 </li><li>button 普通按钮 </li><li>reset 重置按钮（点击按钮，会触发 form 表单的 reset 事件） </li><li>submit 提交按钮（点击按钮，会吃饭 form 表单的 submit 事件） </li><li>email 专门用于输入 e-mail </li><li>url 专门用于输入 url </li><li>number 专门用于 number </li><li>range 显示为滑动条，用于输入一定范围内的值 </li><li>date 选取日期和时间（还包含：month、week、time、datetime、datetime-local） </li><li>color 选取颜色 </li></ul></li><li>button 按钮，下拉选择框 <select></select> <ul><li><code>&lt;option value=&quot;提交值&quot;&gt;选项&lt;/option&gt;</code> 是下拉选择框里面的每一个选项</li></ul></li></ul></li><li><p>文本域：<textarea></textarea></p><p>当用户想输入大量文字的时候，使用文本域。</p><ul><li>cols，多行输入域的列数</li><li>rows，多行输入域的行数。 </li></ul></li></ol><h2 id="其他语义化标签"><a href="#其他语义化标签" class="headerlink" title="其他语义化标签"></a>其他语义化标签</h2><ul><li>盒子<div></div> </li><li>网页头部<header></header>，html5 新增语义化标签，定义网页的头部，主要用于布局，分割页面的结构 </li><li>底部信息<footer></footer>，html5 新增语义化标签，定义网页的底部，主要用于布局，分割页面的结构 </li><li>导航<nav></nav>，html5 新增语义化标签，定义一个导航，主要用于布局，分割页面的结构 </li><li>文章<article></article>，html5 新增语义化标签，定义一篇文章，主要用于布局，分割页面的结构 </li><li>侧边栏<aside></aside>，语义化标签，定义主题内容外的信息，主要用于布局，分割页面的结构。 </li><li>时间标签<time></time>，语义化标签，定义一个时间 </li></ul><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><ol><li><code> &lt;!DOCTYPE html&gt;</code> 定义文档类型，告知浏览器用哪一种标准解释 HTML </li><li><code>&lt;html&gt;&lt;/html&gt;</code> 可告知浏览器其自身是一个 HTML 文档 </li><li><code>&lt;body&gt;&lt;/body&gt;</code> 标签之间的内容是网页的主要内容 </li><li><code>&lt;head&gt;&lt;/head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器 </li><li><code>&lt;title&gt;&lt;/title&gt;</code> 元素可定义文档的标题 </li><li><code>&lt;link&gt;</code> 标签将 css 样式文件链接到 HTML 文件内 </li><li><code>&lt;meta&gt;</code> 定义文档的元数据</li></ol><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><ul><li>常见的企业网站，多由<strong>头部区</strong>，<strong>展示图片区域</strong>，<strong>主题区域</strong>，<strong>底部信息区域</strong>组成 </li><li>网页拆分原则：- 由上到下 - 由内到外 </li></ul><h1 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h1><h2 id="CSS-代码语法"><a href="#CSS-代码语法" class="headerlink" title="CSS 代码语法"></a>CSS 代码语法</h2><ul><li>CSS 全称为层叠样式表(Cascading Style Sheets)，它主要是用于定义 HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 </li><li>css 代码通常存放在 <code>&lt;style&gt;&lt;/style&gt;</code> 标签内 </li><li>css 样式由选择符和声明组成，而声明又由属性和值组成 </li><li>语法格式：<code>选择符 &#123; 属性: 值 &#125;</code> </li><li>选择符：又称选择器，指明网页中要应用样式规则的元素 </li></ul><h2 id="CSS-放置位置"><a href="#CSS-放置位置" class="headerlink" title="CSS 放置位置"></a>CSS 放置位置</h2><ol><li>行内样式，不建议使用 </li><li>内联式样式表 </li><li>外联样式表 </li></ol><h2 id="CSS-的继承"><a href="#CSS-的继承" class="headerlink" title="CSS 的继承"></a>CSS 的继承</h2><ul><li>CSS 的某些样式是具有继承性的，继承是一种规则，它允许样式不仅应用于某个特定 html 标签元素，而且应用于其后代。 </li><li>不可继承样式：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear </li><li>可以继承的样式： letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction、visibility、cursor </li></ul><h2 id="选择器的种类"><a href="#选择器的种类" class="headerlink" title="选择器的种类"></a>选择器的种类</h2><ol><li>标签选择器:通过标签的名字，修改 css 样式 </li><li>通配符选择器:选择页面中所有的元素 </li><li>属性选择器 []</li><li>后代选择器:选择某个父元素下面所有的元素 </li><li>一级子元素选则器:选择某个父元素的直接子元素，后代选择器是选择父元素的所有子孙元素，一级子元素原则器只选择第一级子元素，不会再向下查找元素 </li><li>id 选择器：通过 id 查找页面中唯一的标签 </li><li>class 选择器:通过特定的 class（类）来查找页面中对应的标签，以 .class 名称 </li><li>伪类选择器: <ul><li>:hover 鼠标移入某个元素; </li><li>:before 在某个元素的前面插入内容; </li><li>:after 在某个元素的后面插入内容 </li></ul></li><li>群组选择器:可以对多个不同的选择器设置相同的样式 </li></ol><h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><ol><li>当有不同的选择器对同一个对象进行样式指定时，并且两个选择器有相同的属性被赋予不同的值时。 </li><li>通过测算那个选择器的权重值最高，应用哪一个选择器的样式 </li><li>权重计算方式：<ul><li>标签选择器：1 </li><li>class 选择器：10 </li><li>id 选择器：100 </li><li>行内样式：1000 </li><li>!important 最高级别，提高样式权重，拥有最高级别 </li></ul></li></ol><h2 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h2><p>背景颜色 background-color </p><p>背景图片 background-image </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-image</span>:<span class="hljs-built_in">url</span>(<span class="hljs-string">bg01.jpg</span>);<br></code></pre></div></td></tr></table></figure><p>背景图片位置 background-position</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-position</span>:<span class="hljs-number">10px</span> <span class="hljs-number">100px</span>; <br>// 代表坐标 x，y 轴 <br></code></pre></div></td></tr></table></figure><p>背景图片重复 background-repeat</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-repeat</span>: no-repeat<br><br>// no-repeat 设置图像不重复，常用 <br>// round 自动缩放直到适应并填充满整个容器 <br>// space 以相同的间距平铺且填充满整个容器 <br></code></pre></div></td></tr></table></figure><p>背景图片定位 background-attachment</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-attachment</span>: fixed <br><br>// 背景图像是否固定或者随着页面的其余部分滚动 <br>// background-attachment 的值可以是 scroll（跟随滚动），fixed（固定）<br></code></pre></div></td></tr></table></figure><p>background 缩写</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background</span>:<span class="hljs-number">#ff0000</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">bg01.jpg</span>) no-repeat fixed center <br></code></pre></div></td></tr></table></figure><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p>字体族 font-family</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;微软雅黑&quot;</span>,<span class="hljs-string">&quot;黑体&quot;</span>; <br></code></pre></div></td></tr></table></figure><p>字体大小 font-size</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: <span class="hljs-number">12px</span>; <br></code></pre></div></td></tr></table></figure><blockquote><p>网页默认字体大小是 16px </p></blockquote><p>字体粗细 font-weight</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">400</span>; <br></code></pre></div></td></tr></table></figure><ul><li>normal（默认） </li><li>bold（加粗） </li><li>bolder（相当于<strong>和<b>标签） </b></strong></li><li>lighter （常规） </li><li>100 ~ 900 整百（400=normal，700=bold） </li></ul><p>字体颜色 color</p><ul><li>颜色的英文单词 <code>color:red;</code> </li><li>十六进制色：<code>color: #FFFF00;</code> </li><li>RGB(红绿蓝)：<code>color:rgb(255,255,0)</code> </li><li>RGBA（红绿蓝透明度）A 是透明度在 0~1 之间取值。<code>color:rgba(255,255,0,0.5)</code> </li></ul><p>字体斜体 font-style</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-style</span>:italic<br></code></pre></div></td></tr></table></figure><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>行高 line-height</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">line-height</span>:<span class="hljs-number">50px</span>; <br></code></pre></div></td></tr></table></figure><blockquote><p>可以将父元素的高度撑起来 </p></blockquote><p>文本水平对齐方式 text-align</p><ul><li>left 左对齐 </li><li>center 文字居中 </li><li>right 右对齐 </li></ul><p>文本所在行高的垂直对齐方式 vertical-align</p><ul><li>baseline 默认 </li><li>sub 垂直对齐文本的下标，和<sub>标签一样的效果 </sub></li><li>super 垂直对齐文本的上标，和<sup>标签一样的效果 </sup></li><li>top 对象的顶端与所在容器的顶端对齐 </li><li>text-top 对象的顶端与所在行文字顶端对齐 </li><li>middle 元素对象基于基线垂直对齐 </li><li>bottom 对象的底端与所在行的文字底部对齐 </li><li>text-bottom 对象的底端与所在行文字的底端对齐 </li></ul><p>文本缩进 text-indent</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-indent</span>:<span class="hljs-number">2em</span>; <br></code></pre></div></td></tr></table></figure><blockquote><p>通常用在段落开始位置的首行缩进 </p></blockquote><p>字母之间的间距 letter-spacing</p><p>单词之间间距 word-spacing</p><p>文本的大小写 text-transform</p><ul><li>capitalize 文本中的每个单词以大写字母开头 </li><li>uppercase 定义仅有大写字母 </li><li>lowercase 定义仅有小写字母 </li></ul><p>文本的装饰 text-decoration</p><ul><li>none 默认 </li><li>underline 下划线 </li><li>overline 上划线 </li><li>line-through 中线 </li></ul><p>自动换行 word-wrap</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-wrap</span>: break-word;<br></code></pre></div></td></tr></table></figure><h2 id="基本样式"><a href="#基本样式" class="headerlink" title="基本样式"></a>基本样式</h2><p>宽度 width</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; <span class="hljs-comment">/* 定义元素的宽度  */</span><br></code></pre></div></td></tr></table></figure><p>高度 height</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br></code></pre></div></td></tr></table></figure><ul><li>元素默认没有高度 </li><li>需要设置高度 </li><li>可以不定义高度，让元素的内容将元素撑高 </li></ul><p>鼠标样式 cursor</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">ccursor:pointer <br></code></pre></div></td></tr></table></figure><ul><li>default 默认</li><li>pointer 小手形状 </li><li>move 移动形状 </li></ul><p>透明度 opacity</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">opacity</span>: <span class="hljs-number">0.3</span> <br></code></pre></div></td></tr></table></figure><ul><li>透明度的值 0~1 之间的数字，0 代表透明，1 代表完全不透明 </li><li>透明的元素，只是看不到了，但是还占据着文档流 </li></ul><p>可见性 visibility</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">visibility</span>:hidden; <br></code></pre></div></td></tr></table></figure><ul><li>visible 元素可见 </li><li>hidden 元素不可见 </li><li>collapse 当在表格元素中使用时，此值可删除一行或一列，不会影响表格的布局。</li></ul><p>溢出隐藏 overflow</p><p>设置当对象的内容超过其指定高度及宽度时如何显示内容 </p><ul><li>visible 默认值，内容不会被修剪，会呈现在元素框之外 </li><li>hidden 内容会被修剪，并且其余内容是不可见的 </li><li>scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容 </li><li>auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容 </li></ul><p>边框颜色 outline </p><blockquote><p>input 文本输入框自带边框，且样式丑陋，我们可以通过 outline 修改边框 </p></blockquote><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br><span class="hljs-comment">/* 清除边框 */</span><br><span class="hljs-attribute">outline</span>: none ;<br></code></pre></div></td></tr></table></figure><p>样式重置</p><p>早期的网页没有 css 样式，为了界面美观，很多元素自带 margin、padding 等样式，但这些样式在不同浏览器解析的值都不一样，需要将 css 样式重置，保证在 不同浏览器显示一致。 </p><ul><li>清除元素的 margin 和 padding </li><li>去掉自带的列表符 </li><li>去掉自带的下划线 </li></ul><p>盒模型样式</p><p>块状元素、内联元素和内联块状元素。</p><ul><li>块级元素: <ul><li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。 </li><li>元素的高度、宽度、行高以及顶和底边距都可设置。 </li><li>元素宽度在不设置的情况下，是它本身父容器的 100%，除非设定一个宽度。 </li></ul></li><li>行内元素: <ul><li>和其他元素都在一行上 </li><li>元素的高度、宽度、行高及顶部和底部边距不可设置 </li><li>元素的宽度就是它包含的文字或图片的宽度，不可改变。 </li></ul></li><li>行内块状元素: <ul><li>和其他元素都在一行上 </li><li>元素的高度、宽度、行高以及顶和底边距都可设置。 </li></ul></li></ul><p>元素分类转换 <strong>display</strong> </p><ul><li>block：将元素转换为块级元素 </li><li>inline：将元素装换为行级元素 </li><li>inline-block：将元素转换为内联块元素 </li><li>none: 将元素隐藏</li></ul><p>描边 <strong>border</strong></p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#f00</span>; <br></code></pre></div></td></tr></table></figure><ul><li>线条的样式： <ul><li>dashed（虚线）| dotted（点线）| <strong>solid</strong>（实线）。 </li></ul></li></ul><blockquote><p>css 样式中允许只为一个方向的边框设置样式： </p><ul><li>下描边 border-bottom:1px solid red; </li><li>上描边 border-top:1px solid red; </li><li>右描边 border-right:1px solid red; </li><li>左描边 border-left:1px solid red; </li></ul></blockquote><p>间距 <strong>margin</strong> </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<span class="hljs-attribute">margin</span>:<span class="hljs-number">20px</span> <span class="hljs-number">10px</span> <span class="hljs-number">15px</span> <span class="hljs-number">30px</span>;&#125; <br></code></pre></div></td></tr></table></figure><p>内填充 <strong>padding</strong> </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">padding</span>:<span class="hljs-number">10px</span> <br></code></pre></div></td></tr></table></figure><p>浮动 float</p><p>（1）浮动原理 </p><ul><li>浮动使元素脱离文档普通流，漂浮在普通流之上的。 </li><li>浮动元素依然按照其在普通流的位置上出现，然后尽可能的根据设置的浮动方向向左或者向右浮动，直到浮动元素的外边缘遇到包含框或者另一个浮动元素为止，且允许文本和内联元素环绕它。 </li><li>浮动会产生块级框（相当于设置了 display:block），而不管该元素本身是什么。 </li></ul><p>（2）清除浮动带来的影响clear 清除浮动： </p><ul><li>none : 不清除（默认值）。 </li><li>left : 不允许左边有浮动对象 </li><li>right : 不允许右边有浮动对象 </li><li>both : 不允许两边有浮动对象 </li></ul><p>（3）利用伪类实现清除浮动 </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clearFix</span> &#123; <br>  <span class="hljs-attribute">content</span>=&quot;&quot;; <br>  <span class="hljs-attribute">display</span>:block; <br>  <span class="hljs-attribute">width</span>:<span class="hljs-number">0</span>; <br>  <span class="hljs-attribute">height</span>:<span class="hljs-number">0</span>; <br>  <span class="hljs-attribute">clear</span>:both; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>定位 <strong>position</strong></p><ol><li><p>定位功能可以让布局变的更加自由。 </p></li><li><p>层模型–绝对定位（相对于父类） </p><p>绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#box_relative</span> &#123; <br>  <span class="hljs-attribute">position</span>: absolute; <br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>; <br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果想为元素设置层模型中的绝对定位，需要设置 <code>position:absolute</code> (绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用 <code>left、right、top、bottom</code> 属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于 <code>body</code> 元素，即相对于浏览器窗口。 </p></li><li><p>层模型–相对定位（相对于原位置）</p><p>相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-id">#box_relative</span> &#123; <br>  <span class="hljs-attribute">position</span>: relative; <br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">30px</span>; <br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">20px</span>; <br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果想为元素设置层模型中的相对定位，需要设置 <code>position:relative</code>（相对定位），它通过 <code>left、right、top、bottom</code> 属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按<code>static(float)</code>方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于原位置移动，移动的方向和幅度由<code>left、right、top、bottom</code>属性确定，偏移前的位置保留不动。 </p></li><li><p>层模型–固定定位（相对于网页窗口） </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: fixed;<br></code></pre></div></td></tr></table></figure><p>与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与 background-attachment:fixed 属性功能相同。 </p></li></ol><p>浏览器默认样式</p><ol><li><p>页边距</p><p>IE 默认为 10px，通过 body 的 margin 属性设置要清除页边距一定要清除这两个属性值 </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">body</span> &#123; <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>; &#125; <br></code></pre></div></td></tr></table></figure></li><li><p>段间距 </p><p>IE 默认为 19px，通过 p 的 margin-top 属性设置 p 默认为块状显示，要清除段间距，一般可以设置 </p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span> &#123; <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">0</span>; <span class="hljs-attribute">margin-bottom</span>: <span class="hljs-number">0</span>; &#125;<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="html5-模块"><a href="#html5-模块" class="headerlink" title="html5 模块"></a>html5 模块</h1><h2 id="HTML5-的优势"><a href="#HTML5-的优势" class="headerlink" title="HTML5 的优势"></a>HTML5 的优势</h2><ul><li>解决跨浏览器，跨平台问题</li><li>增强了 web 的应用程序 </li></ul><h2 id="HTML5-废弃元素"><a href="#HTML5-废弃元素" class="headerlink" title="HTML5 废弃元素"></a>HTML5 废弃元素</h2><ul><li>frame frameset noframes acronym applet dir basefont big center font strike tt </li></ul><h2 id="HTML5-新增元素"><a href="#HTML5-新增元素" class="headerlink" title="HTML5 新增元素"></a>HTML5 新增元素</h2><ul><li><code>&lt;header&gt;</code> 用于定义文档或节的页眉 </li><li><code>&lt;footer&gt;</code> 用于定义文档或节的页脚 </li><li><code>&lt;article&gt;</code> 用于定义文档内的文章 </li><li><code>&lt;section&gt;</code> 用于定义文档中的一个区域（或节） </li><li><code>&lt;aside&gt;</code> 用于定义与当前页面或当前文章的内容几乎无关的附属信息 </li><li><code>&lt;figure&gt;</code> 用于定义一段独立的引用，经常与说明(caption) <code>&lt;figcaption&gt;</code> 配合使用，通常用在主文中的图片，代码，表格等。</li><li><code>&lt;figcaption&gt;</code> 用于表示是与其相关联的引用的说明/标题，用于描述其父节点 <code>&lt;figure&gt;</code>元素里的其他数据。 </li><li><code>&lt;hgroup&gt;</code> 用于对多个<h1>~<h6>元素进行组合 </h6></h1></li><li><code>&lt;nav&gt;</code> 用于定义页面上的导航链接部分 </li><li><code>&lt;mark&gt;</code> 用于定义高亮文本 </li><li><code>&lt;time&gt;</code> 用于显示被标注的内容是日期或时间（24 小时制） </li><li><code>&lt;meter&gt;</code> 用于表示一个已知最大值和最小值的计数器</li><li><code>&lt;progress&gt;</code> 用于表示一个进度条  </li><li><code>&lt;audio&gt;</code> 定义声音，比如音乐或其他音频流 </li><li><code>&lt;video&gt;</code> 定义视频，比如电影片段或其他视频流4.HTML5 表单相关元素和属性</li></ul><h2 id="input-新增-type-类型"><a href="#input-新增-type-类型" class="headerlink" title="input 新增 type 类型"></a>input 新增 type 类型</h2><ul><li>color 用来创建一个允 许用户使用颜色选择器，或输入兼容 CSS 语法的颜色代码的区域 </li><li>time 生成一个时间选择器 </li><li>datetime 生成一个 UTC 的日期时间选择器 </li><li>datetime-local 生成一个本地化的日期时间选择器 </li><li>date 显示一个日期输入区域，可同时使用日期选择器，结果值包括年、月、日，不包括时间。 </li><li>month 生成一个月份选择器，它结果值包括年份和月份， 但不包括日期 </li><li>week 生成一个选择的几周的选择器 </li><li>email 生成一个 E-mail 输入框 </li><li>number 生成一个只能输入数字的输入框 </li><li>range 生成一个拖动条，通过拖动条，使得用户只能输入指定范围，指定步长的值 </li><li>search 生成一个专门用于输入搜索关键字的文本框 </li><li>tel 生成一个只能输入电话号码的文本框 </li><li>url 生成一个 URL 输入框 </li></ul><h2 id="HTML5-input-新增属性"><a href="#HTML5-input-新增属性" class="headerlink" title="HTML5 input 新增属性"></a>HTML5 input 新增属性</h2><ul><li><strong>placeholder</strong> 主要用在文本框，规定可描述输入字段预期值的简短的提示信息 </li><li>autocomplete 为了完成表单的快速输入，一般浏览器提供了自动补全的功能选择 </li><li>autofocus 当为某个表单控件增加该属性后，当浏览器打开这个页面， 这个表单控件会自动获得焦点 </li><li>list 为文本框指定一个可用的选项列表，当用户在文本框中输 入信息时，会根据输入的字符，自动显示下拉列表提示，供用户从中选择 </li><li>pattern 用于验证表单输入的内容，通常 HTML5 的 type 属性，比如email、tel、 number、url 等，已经自带了简单的数据格式验证功能了，加上 pattern 属性后， 验证会更加高效 </li><li>novalidate 当提交表单时不对其进行验证 </li><li>required 必需在提交之前填写输入字段 </li><li>spellcheck 拼写检查，为 <input> 、 <textarea> 等元素新增属性 </textarea></li><li>formenctype 规定在发送到服务器之前应该如何对表单数据进行编码 </li><li>formtarget 带有两个提交按钮的表单，会提交到不同的目标窗口 </li><li>multiple 一次上传多个文件 </li></ul><p>textarea 新增</p><ul><li>maxlength：用于规定文本区域最大字符数。</li><li>wrap：是否包含换号符（soft/ hard） </li></ul><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="CSS3-新增选择器"><a href="#CSS3-新增选择器" class="headerlink" title="CSS3 新增选择器"></a>CSS3 新增选择器</h2><ol><li><p>兄弟选择器</p><p><code>元素 1 ~ 元素 2</code> 第 1 个元素之后，所有的元素 2 都会被选择，且这些元素和第一个元素拥有同一个父元素（两个元素之间不一定要相邻）。 </p></li><li><p>属性选择器</p><ul><li><code>E[attribute^=value]</code> 用于选取带有以指定值开头的属性值的元素 </li><li><code>E[attribute$=value]</code> 用于选取属性值以指定值结尾的元素 </li><li><code>E[attribute*=value]</code> 用于选取属性值中包含指定值的元素，位置不限，也不限制整个单词 </li></ul></li><li><p>伪类选择器</p><ul><li>:root 选择文档的根元素，HTML 里，永远是 <code>&lt;html&gt;</code> 元素 </li><li>:last-child 向元素添加样式，且该元素是它的父元素的最后一个子元素 :nth-child(n) 向元素添加样式，且该元素是它的父元素的第 n 个子元素 </li><li>:nth-last-child(n) 向元素添加样式，且该元素是它的父元素的倒数第 n 个子元素 </li><li>:only-child 向元素添加样式，且该元素是它的父元素的唯一子元素 </li><li>:first-of-type 向元素添加样式，且该元素是同级同类型元素中第一个元素 </li><li>:last-of-type 向元素添加样式，且该元素是同级同类型元素中最后一个元素 </li><li>:nth-of-type(n) 向元素添加样式，且该元素是同级同类型元素中第 n 个元素 </li><li>:nth-last-of-type(n) 向元素添加样式，且该元素是同级同类型元素中倒 数第 n 个元素 </li><li>:only-of-type 向元素添加样式，且该元素是同级同类型元素中唯一的元素 </li><li>:empty 向没有子元素（包括文本内容）的元素添加样式 </li></ul></li><li><p>伪元素选择器</p><ul><li>:enabled 向当前处于可用状态的元素添加样式，通常用于定义表单的样式或者超链接的样式 </li><li>:disabled 向当前处于不可用状态的元素添加样式，通常用于定义表单的样式或者超链接的样式 </li><li>:checked 向当前处于选中状态的元素添加样式 </li><li>:not(selector) 向不是 selector 元素的元素添加样式 </li><li>:target 向正在访问的锚点目标元素添加样式 </li><li>::selection 向用户当前选取内容所在的元素添加样式 </li></ul></li></ol><h2 id="CSS3-新增属性"><a href="#CSS3-新增属性" class="headerlink" title="CSS3 新增属性"></a>CSS3 新增属性</h2><p>新增背景属性</p><ul><li>background-cli 设置背景覆盖范围 border-box/paddingbox/content-box </li><li>background-origin 设置背景覆盖的起点 border-box/paddingbox/content-box </li><li>background-size 设置背景的大小 cover/contain/长度/百分比 </li></ul><p>新增的字体文本相关属性</p><ul><li>text-overflow 设置当文本溢出元素框时处理方式 clip/ellipsis </li><li>word-wrap 规定单词的换行方式 normal/break-word </li><li>word-break 规定自动换行的方式 normal/break-all/keep-all </li></ul><p>新增盒模型属性</p><ul><li>box-shadow 阴影 h-shadow v-shadow blur spread color inset </li><li>resize 调整尺寸 none/both/horizontal </li><li>outline-offset 轮廓的偏移量 length/inherit </li></ul><p>新增变形动画属性</p><ol><li>transform<ul><li>translate(x,y) </li><li>rotate(angle) </li><li>scale(x,y) </li><li>skew(angleX ,angleY) </li></ul></li><li>transform-origin 表示元素旋转的中心点，默认值为 50% 50%。 <ul><li>第一个值表示元素旋转中心点的水平位置，它还可以赋值 left、right、center、长度、百分比。 </li><li>第二个值表示元素旋转中心点的垂直位置，它还可以赋值 top、bottom、center、长度、百分比。</li></ul></li></ol><h2 id="3D-变形属性"><a href="#3D-变形属性" class="headerlink" title="3D 变形属性"></a>3D 变形属性</h2><ol><li><p>transform 3D 函数 </p><p>transform 增加了三个变形函数： </p><ul><li>rotateX：表示元素沿着 x 轴旋转 </li><li>rotateY：表示元素沿着 y 轴旋转 </li><li>rotateZ：表示元素沿着 z 轴旋转 </li></ul></li><li><p>transform-style 用来设置嵌套的子元素在 3D 空间中显示效果。</p></li><li><p>perspective 设置成透视效果，透视效果为近大远小。 </p></li><li><p>perspective-origin 设置 3D 元素所基于的 x 轴和 y 轴，改变 3D 元素的底部位置，该属性取值同 transform-origin，默认值为 50% 50%。 </p></li><li><p>backface-visibility 用来设置当元素背面面向屏幕时是否可见，通常用于设置 不希望用户看到旋转元素的背面。它的属性值有 visible（背面可见，默认值）、 hidden（背面不可见）两个。</p></li></ol><h2 id="CSS3-的过渡属性"><a href="#CSS3-的过渡属性" class="headerlink" title="CSS3 的过渡属性"></a>CSS3 的过渡属性</h2><ul><li>transition-delay 设置过渡的延迟时间 </li><li>transition-duration 设置过渡的过渡时间 </li><li>transition-timing-function 设置过渡的时间曲线 </li><li>transition-property 设置哪条 CSS 使用过渡 </li><li>transition 一条声明设置 所有过渡属性 </li></ul><h2 id="CSS3-的动画属性"><a href="#CSS3-的动画属性" class="headerlink" title="CSS3 的动画属性"></a>CSS3 的动画属性</h2><p>animation</p><ul><li>@keyframes 定义动画选择器 </li><li>animation-name 使用@keyframes 定义的动画 animation-delay 设置动画的持续动画时间 </li><li>animation-timing-function 设置动画的时间曲线 </li><li>animation-iteration-count 设置动画播放次数 </li><li>animation-direction 设置动画反向播放 </li><li>animation-play-state 设置动画播放状态 </li><li>transition 一条声明设置所有动画属性 </li></ul><h2 id="CSS3-新增多列属性"><a href="#CSS3-新增多列属性" class="headerlink" title="CSS3 新增多列属性"></a>CSS3 新增多列属性</h2><ul><li>column-count 设置元素应该被分隔的列数 </li><li>column-width 设置列的宽度 </li><li>columns 一条声明设置列宽和列数 <code>column</code> </li><li>column-gap 设置列之间的间隔 </li><li>column-span 设置元素应该横跨的列数 </li><li>column-rule-style 设置列之间间隔的样式 </li><li>column-rule-color 设置列之间间隔的颜色 </li><li>column-rule-width 设置列之间间隔的宽度 </li><li>column-rule 一条声明设置列之间间 隔所有属性 </li></ul><h2 id="CSS3-新增单位"><a href="#CSS3-新增单位" class="headerlink" title="CSS3 新增单位"></a>CSS3 新增单位</h2><p>px、em、rem、vh、 vw 和 % 移动端长度单位 </p><p>使用 CSS 单位 px、em、rem、vh、 vw 等实现页面布局。 </p><ul><li>px：绝对单位，页面按精确像素展示 </li><li>em：相对单位，基准点为父节点字体的大小，如果自身定义了 font-size 按自身来计算（浏览器默认字体是 16px），整个页面内 1em 不是一个固定的值。em 会根据父级元素的大小而变化，但是如果嵌套了多个元素，要计算它的大小，是很容易出错的，这样就引申出了 rem。 </li><li>rem：相对单位，可理解为”root em”, 相对根节点 html 的字体大小来计算，CSS3 新加属性。 </li><li>%：% 百分比，相对长度单位，相对于父元素的百分比值 </li></ul><p>vw、vh、vmin、vmax 主要用于页面视口大小布局 </p><ul><li>vw：viewpoint width，视窗宽度，1vw 等于视窗宽度的 1%。 </li><li>vh：viewpoint height`，视窗高度，1vh 等于视窗高度的 1%。 </li><li>vmin：vw 和 vh 中较小的那个 </li><li>vmax：vw 和 vh 中较大的那个 </li></ul><h2 id="弹性盒模型"><a href="#弹性盒模型" class="headerlink" title="弹性盒模型"></a>弹性盒模型</h2><p>弹性盒模型的语法基础概念：任何一个容器都可以指定弹性布局 </p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><ul><li>外部引入 js 文件：通过<script src="main.js"></script> </li><li>关键词 </li><li>变量名大小写敏感</li><li>命名规范 </li></ul><h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><ol><li><p>字符串(String) </p></li><li><p>数字（Number） </p></li><li><p>布尔值（Boolean） </p></li><li><p>未定义（Undefined） </p><p>undefined，表示未定义或只声明未给值的变量 </p><blockquote><p>undefined 有两种结果</p><ol><li><p>真的没定义</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">alert(<span class="hljs-keyword">typeof</span> dada); <span class="hljs-comment">//undefined </span><br></code></pre></div></td></tr></table></figure></li><li><p>定义了，但是没有放东西进去 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> dada; <br>alert(dada); <span class="hljs-comment">//undefined </span><br></code></pre></div></td></tr></table></figure></li></ol></blockquote></li><li><p>对象（Object） </p><p>js 中内置了如下的对象： </p><ul><li>Object 是所有 JS 对象的超类(基类），JS 中的所有对象都是继承自 Object 对象的 </li><li>Array 数组对象 定义数组属性和方法 </li><li>Number 数字对象 </li><li>Boolean 布尔对象 布尔值相关 </li><li>Error 错误对象 处理程序错误 </li><li>Function 函数对象 定义函数属性和方法 Math 数学对象 </li><li>Date 日期对象 </li><li>RegExp 正则表达式对象 定义文本匹配与筛选规则 </li><li>String 字符串对象 定义字符串属性和方法 </li></ul></li></ol><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p><code>+ - * / % ++ --</code> </p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ol><li>字符串转数字<code>parseInt() parseFloat() isNaN()</code> </li><li>数字转为字符串<code>toString()</code> </li></ol><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p><code>=</code> </p><p>复合的赋值运算符 <code>+= -= *= /= %=</code> </p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><ol><li>关系运算：<code>&gt; &lt; &lt;= &gt;= != == === ==和=== !=和!==</code></li><li>“=”、“==”、“===”有什么区别？<ul><li><code>=</code> 是赋值符号 </li><li><code>==</code> 忽略数据类型的判断 是否相等 </li><li><code>===</code> 数值和数据类型都要相等才判断为相等 </li></ul></li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li>逻辑与<code>&amp;&amp;</code> </li><li>逻辑或 <code>||</code> </li><li>逻辑非 <code>!</code> </li><li>复合逻辑表达式 </li></ul><h2 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h2><p>三元运算符：<code>(比较表达式)？结果 1:结果 2</code> </p><h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><p>程序运行的三大结构：顺序结构、选择结构、循环结构 </p><ul><li>单分支选择：<code>if</code>语句 </li><li>双分支选择：<code>if-else</code>语句 </li><li>多分支语句：<code>if-else if-else</code> 语句 </li></ul><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>语法格式： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>(num)&#123; <span class="hljs-comment">//表达式 </span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<span class="hljs-comment">//执行代码块 1 </span><br>    <span class="hljs-keyword">break</span>; <span class="hljs-comment">//中断执行，跳出 </span><br>    <span class="hljs-comment">// ... </span><br>  <span class="hljs-keyword">default</span>: <span class="hljs-comment">//默认，其他都不是的情况下执行 </span><br>    <span class="hljs-comment">//执行代码块 </span><br>    <span class="hljs-keyword">break</span>; <br>&#125;<br><span class="hljs-comment">//强调：break 非常重要，如果不加 break 的话，程序会一直继续往下执行</span><br></code></pre></div></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while 循环的特点：不知道具体执行的次数时，使用最合适 </p><p>语法格式: </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(条件表达式)&#123; <br>  <span class="hljs-comment">//要重复执行的代码段 - 循环体 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法格式： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">do</span>&#123;<br>  <span class="hljs-comment">//循环体 </span><br>&#125;<span class="hljs-keyword">while</span>(循环条件判断); <br></code></pre></div></td></tr></table></figure><ul><li>do-while 是先执行循环体，再检测循环条件。 </li><li>do-while 能保证循环体至少执行一次。 </li><li>其他循环无法保证循环至少执行一次。</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">for</span>(循环变量初始化; 循环条件判断; 循环变量的修改 )&#123;<br>  <span class="hljs-comment">// 循环体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><ul><li>break 退出循环 </li><li>continue 跳过本次循环，继续下一次循环 </li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>数组定义 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <br><span class="hljs-keyword">var</span> arr = []; <br></code></pre></div></td></tr></table></figure></li><li><p>字面量方式定义 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&quot;1&quot;</span>,<span class="hljs-string">&quot;2&quot;</span>]; <br></code></pre></div></td></tr></table></figure></li><li><p>向数组赋值 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">arr[<span class="hljs-number">0</span>] = <span class="hljs-string">&quot;1&quot;</span>; <br>arr[<span class="hljs-number">1</span>] = <span class="hljs-string">&quot;2&quot;</span>; <br></code></pre></div></td></tr></table></figure></li><li><p>数组索引 </p></li><li><p>数组长度 </p><ul><li>arr.length </li><li>arr.length-1 最后一个元素的索引 </li></ul></li></ol><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>indexOf：数组可以通过 indexOf(`来搜索一个指定的元素的位置，如未找到返回 -1 </p><p>concat：concat()方法把当前的 数组 和 另一个 数组连接起来，并返回一个新的 数组 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> newArr = arr1.concat(arr2,<span class="hljs-string">&quot;dada&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>push 和 pop：push()向数组的末尾添加若干元素，pop()则把 数组的最后一个元素删除掉 </p><blockquote><p>空数组继续 pop 不会报错，而是返回 undefined</p></blockquote><p>unshift 和 shift：unshift() 向数组前面添加若干元素，shift() 则把数组的第一个元素删除掉 </p><p>slice：slice() 截取数组的部分元素，然后返回一个新的数组 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>)); <span class="hljs-comment">//从索引 0 开始，到索引 3 结束，但不包括 3 </span><br><span class="hljs-built_in">console</span>.log(arr.slice(<span class="hljs-number">3</span>)); <span class="hljs-comment">//从索引 3 开始到结束 </span><br></code></pre></div></td></tr></table></figure><blockquote><p>如果不给 slice() 传递任何参数，就会从头到尾截取所有元素。利用这一点， 可以很容易的复制一份新的数组 </p></blockquote><p>sort：sort() 可以对当前数组排序 </p><p>reverse：reverse() 把整个数组的元素给掉个个（逆转） </p><p>join：join() 方法把数组的每个元素用指定的字符串连接起来 </p><p>splice：可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 </p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],[<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;b&quot;</span>,<span class="hljs-string">&quot;c&quot;</span>],<span class="hljs-string">&quot;dadaqianduan&quot;</span>]; <br><span class="hljs-keyword">var</span> x = arr[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]; <span class="hljs-comment">//b</span><br></code></pre></div></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串属性 length：字符串的长度属性 </p><p>slice()：slice(start[,end])，start–开始索引 end–结束索引 </p><p>substr() ：substr(start[,length])，start：开始，取 length 个字符 </p><p>split()：split([separator[,limit]])，按条件分割字符串，返回数组 </p><p>indexOf()：在父串中首次出现的位置，从 0 开始！没有返回-1 </p><p>lastIndexOf()：倒序查找 </p><p>charAt(index)：charAt(index) 指定索引的字符 </p><p>toLowerCase()：转小写 </p><p>toUpperCase()：转大写 </p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> reg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">&quot;a&quot;</span>,<span class="hljs-string">&quot;i&quot;</span>); <br><span class="hljs-comment">// 将匹配字母 a，第二个参数 i,表示匹配时不分大小写 </span><br></code></pre></div></td></tr></table></figure><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_1.png"></p><h2 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_2.png"></p><h2 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h2><ol><li>test 方法：检索字符串中指定的值。 </li><li>exec 方法：该方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 </li></ol><h2 id="支持正则的-String-方法"><a href="#支持正则的-String-方法" class="headerlink" title="支持正则的 String 方法"></a>支持正则的 String 方法</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_3.png"></p><h1 id="js-对象"><a href="#js-对象" class="headerlink" title="js 对象"></a>js 对象</h1><h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//使用 new 运算符 </span><br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<br><span class="hljs-comment">//字面量 </span><br><span class="hljs-keyword">var</span> obj=&#123; <br>  <span class="hljs-attr">name</span>:<span class="hljs-string">&quot;dadaqianduan&quot;</span>,<br>  <span class="hljs-attr">age</span>:<span class="hljs-number">12</span>,<br>  <span class="hljs-attr">sex</span>:<span class="hljs-string">&quot;男&quot;</span> <br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="对象的数据访问"><a href="#对象的数据访问" class="headerlink" title="对象的数据访问"></a>对象的数据访问</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//用.语法 </span><br>obj.name <br><span class="hljs-comment">//用[]语法 </span><br>obj[<span class="hljs-string">&quot;name&quot;</span>]<br></code></pre></div></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>json(JavaScript Object Notation)，是一种轻量级的数据交换格式。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> man = &#123; <br>  <span class="hljs-string">&quot;name&quot;</span>:<span class="hljs-string">&quot;dadaqianduan&quot;</span>, <br>  <span class="hljs-string">&quot;age&quot;</span>:<span class="hljs-number">12</span>, <br>  <span class="hljs-string">&quot;sex&quot;</span>:<span class="hljs-string">&quot;男&quot;</span> <br>&#125;;<br></code></pre></div></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li>Object 是所有 JS 对象的超类(基类），JS 中的所有对象都是继承自 Object对象的 </li><li>Array 数组对象 </li><li>Number 数字对象 </li><li>Boolean 布尔对象 </li><li>Error 错误对象 </li><li>Function 函数对象 </li><li>Math 数学对象 </li><li>Date 日期对象 </li><li>RegExp 对象正则表达式对象 </li><li>String 字符串对象 </li></ul><h2 id="Math-方法"><a href="#Math-方法" class="headerlink" title="Math 方法"></a>Math 方法</h2><ul><li>abs() 绝对值 （去除正负） </li><li>random()随机数，<code>0-1</code>之间的随机数，<code>1</code>不会出现 </li><li>round() 四舍五入 </li><li>floor(x) 下舍入(向下取整) </li><li>ceil(x) 上舍入(向上取整) </li><li>max(x,y) x 和 y 中的最大值 </li><li>min(x,y) x 和 y 中的最小值 </li><li>cos(x) x 的余弦 </li><li>sin(x) x 的正弦 </li><li>pow(3,4) 返回 3 的 4 次方 </li></ul><h2 id="Date-方法"><a href="#Date-方法" class="headerlink" title="Date 方法"></a>Date 方法</h2><ul><li>getFullYear() 返回 年（4 位） </li><li>getMouth() 返回 月（0–11） </li><li>getDate() 返回 日期 getDay() 返回 星期 （0-6） </li><li>getHours() 返回 小时 </li><li>getMinutes() 返回 分钟 </li><li>getSeconds() 返回秒 </li><li>getTime() 返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数 </li><li>setFullYear() 设置 年份 </li><li>setMouth() 设置 月 </li><li>setDate() 设置 天 </li><li>setHours() 设置小时 </li><li>setMinutes() 设置 分钟 </li><li>setSeconds() 设置 秒 </li><li>setTime() 使用毫秒的形式设置时间对象 </li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//判断闰年 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">runYear</span>(<span class="hljs-params">year</span>)</span>&#123; <br>  <span class="hljs-keyword">if</span>(year%<span class="hljs-number">4</span>==<span class="hljs-number">0</span> &amp;&amp; year%<span class="hljs-number">100</span>!=<span class="hljs-number">0</span> || year%<span class="hljs-number">400</span>==<span class="hljs-number">0</span>)&#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <br>  &#125; <br>&#125;;<br></code></pre></div></td></tr></table></figure><h1 id="面向对象是一种编程思想"><a href="#面向对象是一种编程思想" class="headerlink" title="面向对象是一种编程思想"></a>面向对象是一种编程思想</h1><ol><li>类是一个抽象的概念 </li><li>对象：具体的事物 </li><li>类是对象的抽象，对象是类的具体实例 </li><li>类不占用内存，对象占用内存空间 </li><li>对象的访问 声明对象 </li><li>遍历对象 – for in 循环 </li></ol><h2 id="定义对象-1"><a href="#定义对象-1" class="headerlink" title="定义对象"></a>定义对象</h2><ol><li><p>字面量创建 </p></li><li><p>工厂模式 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 工厂模式中的函数，首字母大写 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">n,c</span>)</span>&#123; <br>  <span class="hljs-keyword">return</span> &#123; <br>    <span class="hljs-attr">name</span>:n, <br>    <span class="hljs-attr">color</span>:c, <br>    <span class="hljs-attr">say</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>      alert(<span class="hljs-string">&quot;dadaqianduan&quot;</span>) <br>    &#125; <br>  &#125; <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>构造函数 </p><ul><li><p>Javascript 提供了一个构造函数（Constructor）模式。 </p></li><li><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了 this 变量。 </p></li><li><p>对构造函数使用 new 运算符，就能生成实例，并且 this 变量会绑定在实例对象上。</p></li><li><p>构造函数首字母大写</p></li><li><p>构造函数中的 this，指向的 实例化的对象 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Cat</span>(<span class="hljs-params">n,c</span>)</span>&#123; <br>  <span class="hljs-built_in">this</span>.name=n; <br>  <span class="hljs-built_in">this</span>.color=c; <br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>生成实例对象 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> cat1 = <span class="hljs-keyword">new</span> Cat(<span class="hljs-string">&quot;dadaqianduan&quot;</span>,<span class="hljs-string">&quot;黄色&quot;</span>) <br></code></pre></div></td></tr></table></figure><p>自动含有一个 constructor 属性，指向它们的构造函数 <code>alert(cat1.constructor == Cat); // true</code> </p></li></ul></li><li><p>Javascript 还提供了一个 instanceof 运算符 </p></li></ol><p>验证原型对象与实例对象之间的关系。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> txt = <span class="hljs-string">&#x27;dadaqianduan&#x27;</span>; <br>alert(txt <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>); <span class="hljs-comment">//false </span><br><span class="hljs-keyword">var</span> age = <span class="hljs-number">123123</span>; <br>alert(age <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>); <span class="hljs-comment">//false </span><br><span class="hljs-keyword">var</span> res = <span class="hljs-regexp">/\d/</span>; <br>alert(res <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">RegExp</span>); <span class="hljs-comment">//true </span><br><span class="hljs-keyword">var</span> arr = []; <br>alert(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">//true </span><br></code></pre></div></td></tr></table></figure><p>2.原型和原型链</p><ul><li>构造函数都有一个 <strong>prototype</strong> 属性，指向 另一个对象 。这个对象的所有属性和方法，都会被构造函数的实例继承。</li><li>所有的函数都是 Function 的实例。 </li><li>在构造函数上都有一个 原型 属性 prototype，prototype 也是一个对象；这个对象上有一个 constructor 属性，该属性指向的就是构造函数。 </li><li>实例对象上有一个 <code>_proto_</code> 属性，该属性也指向原型对象，该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。 </li></ul><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>constructor 是 构造函数 创建的实例的属性，该属性的作用是 指向 创建当前对象的 构造函数。  </p><p>每个原型都有一个<code>constructor</code>属性，指向该关联的构造函数。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123; <br>&#125;<br><span class="hljs-built_in">console</span>.log(Person===Person.prototype.constructor) <span class="hljs-comment">//true </span><br></code></pre></div></td></tr></table></figure><p>关系图： </p><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/constructor.png"></p><p>区分一下普通对象和函数对象：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f1</span>(<span class="hljs-params"></span>)</span>&#123;&#125;; <br><span class="hljs-keyword">var</span> f2 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;; <br><span class="hljs-keyword">var</span> f3 = <span class="hljs-keyword">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;; <br><span class="hljs-keyword">var</span> o1 = &#123;&#125;; <br><span class="hljs-keyword">var</span> o2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <br><span class="hljs-keyword">var</span> o3 = <span class="hljs-keyword">new</span> f1(); <br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f1) <span class="hljs-comment">// function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f2) <span class="hljs-comment">// function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> f3) <span class="hljs-comment">// function </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o1) <span class="hljs-comment">// object </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o2) <span class="hljs-comment">// object </span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> o3) <span class="hljs-comment">// object </span><br></code></pre></div></td></tr></table></figure><ul><li><p>在 JavaScript 中，原型是一个对象，原型的作用是 实现对象的继承。 </p></li><li><p>在 JavaScript 中的所有函数对象中，都存在一个属性 prototype 该属性对应当前对象的原型。 </p></li><li><p>所有的 JavaScript 对象，都存在一个 <code>_proto_</code> 属性，<code>_proto_</code> 属性指向实例对象的构造函数的原型。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Person(); <span class="hljs-comment">// 实例对象 </span><br><span class="hljs-built_in">console</span>.log(p._proto_ === Person.prototype); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>p 是实例对象, Person 是 p 的构造函数。p 的_proto_属性指向构造函数 Person 的原型。js 是如何通过原型进行继承的： </p></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> parent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>&#123; <br>  <span class="hljs-built_in">this</span>.name = name; <br>&#125;<br>parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123; <br>  <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.name; <br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> parent(<span class="hljs-string">&quot;dadaqianduan&quot;</span>); <br><span class="hljs-built_in">console</span>.log(son.getName()); <span class="hljs-comment">// dadaqianduan </span><br></code></pre></div></td></tr></table></figure><p>son 继承了 parent 的原型中的函数属性 getName </p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>除了 Object 的 prototype 的原型是 null 外，所有的对象和原型都有自己的原型， 对象的原型指向原型对象。 </p><p>在层级多的关系中，多个原型层层相连则构成了原型链。 </p><p>在查找一个对象的属性时，如当前对象找不到该属性，就会沿着原型链一直往上查找，直到找到为止，如果到了原型链顶端，没找到，则返回 undefined </p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li><p>所有引用类型都有一个 <code>__proto__</code> 属性 </p></li><li><p>所有函数都有一个 prototype 属性 </p></li><li><p>所有引用类型的 <code>__proto__</code> 属性指向它构造函数的 prototype构造函数和实例原型之间的关系： </p><p>Person（构造函数）的 prototype 指向 Person.prototype </p></li><li><p><code>__proto__</code> </p><p>每个对象，除 null 外，都有的属性叫__proto__，这个属性会指向该对象的原型。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123; <br>&#125;<br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(); <br><span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="hljs-comment">// true </span><br></code></pre></div></td></tr></table></figure></li></ol><p>梳理： </p><p>写一个构造函数<code>Person</code>，一般构造函数区别与普通函数要求首字母大写：function Person(){} </p><p>prototype 原型 </p><ul><li>原型是一个对象，在原型 prototype 上定义的属性，通过“继承”，实现实例也有这个属性。 </li><li>继承是在 new 操作符内部实现的。</li><li>构造函数内部有个 prototype 的属性，通过这个属性就能访问到原型。 </li><li>Person 是构造函数，Person.prototype 是原型。 </li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>有构造函数，可以在原型上创建可继承的属性，通过<code>new</code>操作符创建实例： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <br>person = <span class="hljs-keyword">new</span> Person() <br>da = person <span class="hljs-keyword">instanceof</span> Person <span class="hljs-comment">// 检查 person 是否是 Person 的实例 </span><br>da <span class="hljs-comment">// true </span><br><span class="hljs-comment">// 继承 </span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <br>Person.prototype.name = <span class="hljs-string">&#x27;dadaqianduan.cn&#x27;</span> <br>person = <span class="hljs-keyword">new</span> Person() <br>da = person.name <span class="hljs-comment">// 实例继承的属性 </span><br>da <span class="hljs-comment">// &#x27;dadaqianduan.cn&#x27; </span><br></code></pre></div></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>实例通过 <code>__proto__</code> 访问到原型。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <br>Person.prototype.name = <span class="hljs-string">&#x27;dadaqianduan.cn&#x27;</span>person = <span class="hljs-keyword">new</span> Person() <br>da = person.__proto__ === Person.prototype <br>da <span class="hljs-comment">// true </span><br></code></pre></div></td></tr></table></figure><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h2><p>原型也可以通过<code>constructor</code>访问到构造函数 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125; <br><br>Person.prototype.name = <span class="hljs-string">&#x27;dadaqianduan.cn&#x27;</span> <br>person = <span class="hljs-keyword">new</span> Person <br>da = Person.prototype.constructor === Person <br>da <span class="hljs-comment">// true </span><br></code></pre></div></td></tr></table></figure><p>小结：</p><ol><li>所有引用类型（函数，数组，对象）都拥有 <code>__proto__</code> 属性。 </li><li>所有函数拥有 prototype 属性。 </li><li>每个实例对象(Object)都有一个私有属性，为 <code>__proto__</code> 指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象 <code>__proto__</code> ，层层向上直到一个对象的原型对象为 null，null 没有原型，并作为这个原型链中的最后一个环节。 </li></ol><h1 id="常用的-JavaScript-设计模式"><a href="#常用的-JavaScript-设计模式" class="headerlink" title="常用的 JavaScript 设计模式"></a>常用的 JavaScript 设计模式</h1><p>百度百科： </p><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 </p><h2 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h2><p>单体是一个用来划分 命名空间并将一批相关的属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。 </p><p>特点： </p><ol><li>可以来划分命名空间，从而清除全局变量所带来的危险。 </li><li>利用分支技术来来封装浏览器之间的差异。 </li><li>可以把代码组织的更为一体，便于阅读和维护。 </li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式的定义： </p><p>提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。 </p><ol><li>创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。 </li><li>创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。 </li></ol><p>工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响)。 </p><p>分类： </p><ul><li>简单工厂模式：使用一个类，通常为单体，来生成实例。 </li><li>复杂工厂模式定义：将其成员对象的实列化推到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 </li></ul><p>父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 </p><p>应用场景： </p><p>以下几种情景下工厂模式特别有用： </p><ol><li>对象的构建十分复杂； </li><li>需要依赖具体环境创建不同实例； </li><li>处理大量具有相同属性的小对象。 </li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p><p>使用闭包方式来实现单例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> single = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-keyword">var</span> unique; <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getInstance</span>(<span class="hljs-params"></span>)</span>&#123; <br>    <span class="hljs-comment">// 如果该实例存在，则直接返回，否则就对其实例化 </span><br>    <span class="hljs-keyword">if</span>( unique === <span class="hljs-literal">undefined</span> )&#123; <br>      unique = <span class="hljs-keyword">new</span> Construct(); <br>    &#125;<br>    <span class="hljs-keyword">return</span> unique; <br>  &#125;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Construct</span>(<span class="hljs-params"></span>)</span>&#123; <br>    <span class="hljs-comment">// ... 生成单例的构造函数的代码 </span><br>  &#125;<br>  <span class="hljs-keyword">return</span> &#123; <br>    <span class="hljs-attr">getInstance</span> : getInstance <br>  &#125;<br>&#125;)(); <br></code></pre></div></td></tr></table></figure><p>unique 是返回对象的引用，而 getInstance 是静态方法获得实例。Construct 是创建实例的构造函数。 </p><p>可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是单例模式所实现的效果。 </p><p>应用场景： </p><ol><li>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器的 window 对象。 </li><li>借助单例模式，可以把代码组织的更为一致，方便阅读与维护。 </li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>// 使用关键字 function 定义函数 </p><p>// 定义函数，吃饭 </p><p>function dada(){ </p><p>console.log(“点餐”); </p><p>console.log(“拿筷子”); </p><p>console.log(“吃东西”)； </p><p>}</p><h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>变量的作用域</p><ul><li>函数体内的变量：局部变量，仅在函数体内可以使用</li><li>函数体外的变量：全局变量，对全局可见 </li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>return 的含义：将函数的结果返回给当前函数名</p><p>return 使用方法：</p><ul><li>return 只能返回一个数据；</li><li>如果函数中没有 return，则返回 undefined</li><li>return 可以用来结束一个函数 </li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>使用函数表达式定义函数</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> say = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;hello&quot;</span>); <br>&#125;；<br></code></pre></div></td></tr></table></figure><h2 id="自运行函数"><a href="#自运行函数" class="headerlink" title="自运行函数"></a>自运行函数</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-comment">//这里是代码 </span><br>&#125;)()<br></code></pre></div></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包 (closure) 有权访问另外一个函数作用域中的变量的函数。 </p><p>创建闭包的常见方式有：</p><ul><li>在一个函数内部创建另外一个函数，并且把这个函数 return 出去。 </li><li>用函数为元素绑定事件，当事件发生时，还可以操作该函数中的变量。 </li></ul><p>特性：</p><ol><li>可以读取其它函数内部的变量 </li><li>让这些变量的值始终保持在内存中 </li></ol><p>示例：</p><ol><li><p>函数内部 return 一个函数 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-keyword">var</span> a=<span class="hljs-number">10</span>; <br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>    a++; <br>    <span class="hljs-built_in">console</span>.log(a); <br>  &#125;; <br>&#125;;<br><span class="hljs-keyword">var</span> b=run(); <br><span class="hljs-comment">//alert(b); </span><br><span class="hljs-comment">//b 是一个函数b();//可以访问另外一个作用域中变量的函数 </span><br></code></pre></div></td></tr></table></figure></li><li><p>函数内部为绑定事件 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addClick</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-keyword">var</span> txt=<span class="hljs-string">&quot;abcd&quot;</span>; <br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;box&#x27;</span>).onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>    alert(txt); <br>  &#125; <br>&#125;;<br>addClick(); <br></code></pre></div></td></tr></table></figure></li><li><p>函数内部将变量作为回调函数的参数 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">play</span>(<span class="hljs-params">num,fn</span>)</span>&#123; <br>  <span class="hljs-keyword">if</span>(num&gt;<span class="hljs-number">10</span>)&#123; <br>    <span class="hljs-keyword">return</span> fn &amp;&amp; fn(num); <br>  &#125;; <br>&#125;;<br><span class="hljs-keyword">var</span> ss=play(<span class="hljs-number">20</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">n</span>)</span>&#123; <br>  <span class="hljs-keyword">return</span> n+<span class="hljs-number">1</span>; <br>&#125;); <br><span class="hljs-built_in">console</span>.log(ss); <br></code></pre></div></td></tr></table></figure></li></ol><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="BOM-概述"><a href="#BOM-概述" class="headerlink" title="BOM 概述"></a>BOM 概述</h2><p>BOM（browser object model）浏览器对象模型 </p><p>BOM 提供了独立于内容而与浏览器窗口进行交互的对象、载入页面的相关信息，其核心对象是 window 对象 </p><p>BOM 没有相关标准，每个浏览器都定义了自己的属性，并且，都有其自己对 BOM 的实现方式</p><p>W3C 虽然没有为 BOM 统一制定标准,但是其中的窗口对象、导航对象等，因功能趋同，实际上已经成为默认的标准</p><h2 id="window-方法"><a href="#window-方法" class="headerlink" title="window 方法"></a>window 方法</h2><ul><li>alert() 提示框 </li><li>confirm() 带有确认 取消 按钮的提示框 </li><li>prompt() 带有可输入内容的文本域的提示框 </li><li>setInterval() 间隔定时器，可按照指定的周期（以毫秒计）来调用函数或计算表达式 </li><li>setTimeout() 超时定时器，在指定的毫秒数后调用函数</li><li>clearInterval() 清除间隔定时器 </li><li>clearTimeout() 清除超时定时器 </li><li>requestAnimationFrame 帧定时器 </li></ul><h2 id="frames-框架集"><a href="#frames-框架集" class="headerlink" title="frames [ ] 框架集"></a>frames [ ] 框架集</h2><p>把浏览器窗口分成几个窗框，每个窗框同时取得多个 URL 地址，显示不同网页内容。 </p><h2 id="history-历史记录"><a href="#history-历史记录" class="headerlink" title="history 历史记录"></a>history 历史记录</h2><ul><li>window.history.go(1) 前进（跳转） </li><li>window.history.go(-1) 后退（跳转） </li><li>window.history.forward() 前进 </li><li>window.history.back() 后退 </li></ul><h2 id="location-定位"><a href="#location-定位" class="headerlink" title="location 定位"></a>location 定位</h2><ul><li>window.location.href=’…’ 页面跳转 </li><li>window.location.reload() 页面重载</li></ul><h2 id="navigator-导航"><a href="#navigator-导航" class="headerlink" title="navigator 导航"></a>navigator 导航</h2><p>window.navigator.userAgent 浏览器类型、版本、操作系统类型、浏览器引擎类型等信息 </p><h2 id="screen-屏幕"><a href="#screen-屏幕" class="headerlink" title="screen 屏幕"></a>screen 屏幕</h2><ul><li>window.screen.width 返回当前屏幕宽度(分辨率值) </li><li>window.screen.height 返回当前屏幕高度(分辨率值) </li></ul><h2 id="document-文档"><a href="#document-文档" class="headerlink" title="document 文档"></a>document 文档</h2><p>window 的 document 的属性，代表所有 html 的元素，这部分是 js 主要操作的部分，因此这部分必须规范，才能进行统一开发。因此，W3C 将这部分进行了规范 — DOM 标准。 </p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（document object model ）文档对象模型，定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。 </p><h2 id="DOM-对象方法"><a href="#DOM-对象方法" class="headerlink" title="DOM 对象方法"></a>DOM 对象方法</h2><ul><li>getElementById(id）通过 id 获取 DOM 对象（对象） </li><li>getElementsByTagName(tag) 通过标签获取 DOM 对象（“类似数组”对象） </li><li>getElementsByName(name) 通过 name 获取 DOM 对象（“类似数组”对象） </li><li>getElementsByClassName(class) 通过 class 获取 DOM 对象（IE8 以下不 支持）</li></ul><h2 id="操作-DOM-间的关系"><a href="#操作-DOM-间的关系" class="headerlink" title="操作 DOM 间的关系"></a>操作 DOM 间的关系</h2><ul><li>createElement(tag) 创建元素 </li><li>removeChild(对象) 删除元素 </li><li>appendChild(对象) 插入元素 </li><li>replaceChild(替换对象，被替换对象) 替换元素 </li><li>insertBefore(对象，目标对象) 前部插入 </li></ul><blockquote><p>appendChild replaceChild insertBefore 都具有移动对象的功能 </p></blockquote><p>节点属性：</p><ul><li>父节点 parentNode </li><li>第一级子节点 childNodes </li><li>第一个子节点 firstChild </li><li>最后一个子节点 lastChild </li><li>前一个兄弟节点 previousSbiling </li><li>后一个兄弟节点 nextSibling </li></ul><p>克隆节点：</p><p>cloneNode (布尔值) </p><ul><li>true：复制本节点以及所有子节点 </li><li>false：只复制节点本身 </li></ul><h2 id="DOM-节点属性"><a href="#DOM-节点属性" class="headerlink" title="DOM 节点属性"></a>DOM 节点属性</h2><ul><li>setAttribute(“属性名”,属性值) 设置属性</li><li>getAttribute( 属性名 ) 获取属性 </li><li>removeAttribute( 属性名 ) 删除属性: </li><li>hasAttributes(属性名) 判断属性是否存在（返回 ture / false）</li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ul><li>addEventListener( ) 增加事件监听 </li><li>removeEventListener( ) 删除事件监听 </li></ul><h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><ol><li>window 事件 <ul><li>onload 加载（某个页面或图像被完成） </li><li>onunload 用户退出页面 </li><li>onresize 窗口或框架被调整尺寸 </li><li>onscroll 滚动条事件 </li></ul></li><li>鼠标事件 <ul><li>onclick 鼠标点击 </li><li>ondblclick 鼠标双击 </li><li>onmousedown 鼠标按键按下 </li><li>onmouseup 鼠标按键被松开 </li><li>onmouseout 鼠标从某元素移开 </li><li>onmouseover 鼠标被移到某元素之上</li><li>onmouseenter 鼠标进入某元素 </li><li>onmouseleave 鼠标离开某元素 </li><li>onmousemove 鼠标移动 </li><li>oncontextmenu 右键菜单 </li></ul></li><li>input 事件 <ul><li>onblur 元素失去焦点 </li><li>onfocus 元素获得焦点</li><li>onchange 内容改变时触发 </li></ul></li><li>键盘事件 <ul><li>onkeydown 按键按下 </li><li>onkeypress 按键按下并释放 </li><li>onkeyup 按键释放 </li></ul></li><li>form 事件 <ul><li>onreset 表单重置（重置按钮） </li><li>onsubmit 表单提交(form 内有 text 被聚焦，直接回车可触发 onsubmit) </li></ul></li></ol><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>获取事件数据，不同的事件会有不同数据 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">oDiv.onclick=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123; <br>  <span class="hljs-comment">// e 就是事件对象 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流方向：捕获 → 事件目标 → 冒泡 </p><p>1）事件捕获 </p><p>2）事件目标 </p><p>3）事件冒泡 与 阻止事件冒泡 </p><h2 id="事件目标"><a href="#事件目标" class="headerlink" title="事件目标"></a>事件目标</h2><ul><li>ev.targrt </li><li>ev.target.nodeName </li><li>ev.target.tagName </li></ul><h2 id="事件委派-delegate"><a href="#事件委派-delegate" class="headerlink" title="事件委派(delegate)"></a>事件委派(delegate)</h2><p>原理：将事件绑定在父级上，利用事件冒泡原理，通过判断事件的“目标元素”来触发父级上绑定的事件 </p><p>作用： </p><ul><li>不用分别为子元素绑定事件 </li><li>为未知元素绑定事件 </li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>可以为一个元素，同时绑定多个事件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">obj.addEventListener(事件，回调函数，冒泡/捕获) ; <br><br>btn.addEventListener(<span class="hljs-string">&quot;click&quot;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ev</span>)</span>&#123; <span class="hljs-comment">//ev 事件对象 </span><br>  alert(<span class="hljs-string">&#x27;dadaqianduan&#x27;</span>); <br>&#125;,<span class="hljs-literal">false</span>) <br><span class="hljs-comment">//false 冒泡阶段</span><br></code></pre></div></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>一款轻量级的 js 库 </p><p>优点：</p><ul><li>丰富的 DOM 选择器 </li><li>简单的事件操作 </li><li>重新封装方法，让操作 DOM 属性更简单 </li><li>链式操作 </li><li>丰富的动画效果 </li><li>Ajax 操作支持 </li><li>浏览器兼容 </li><li>插件扩展开发，可扩展性强 </li></ul><p>缺点：</p><ul><li>不能向后兼容 </li><li>插件兼容性 </li><li>多个插件冲突 </li></ul><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><ol><li>id 选择器 $(‘#box’) </li><li>class 选择器 $(‘.box’) </li><li>标记选择器 $(‘p’) </li><li>* 代表所有标签</li></ol><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><ul><li>[attribute] 匹配包含给定属性的元素 </li><li>[attribute=value] 匹配给定的属性是某个特定值的元素 </li><li>[attribute!=value] 匹配给定的属性不是某个特定值的元素 </li><li>[attribute^=value] 匹配给定的属性是以某些值开始的元素 </li><li>[attribute$=value] 配给定的属性是以某些值结尾的元素 </li><li>[attribute*=value] 匹配给定的属性是以包含某些值的元素 </li></ul><h2 id="位置选择器"><a href="#位置选择器" class="headerlink" title="位置选择器"></a>位置选择器</h2><ul><li>:first 匹配第一个元素 </li><li>:last 获取最后一个元素 </li><li>:not 去除所有与给定选择器匹配的元素 </li><li>:even 匹配所有索引值为偶数的元素，从 0 开始计数 </li><li>:odd 匹配所有索引值为奇数的元素，从 0 开始计数 </li><li>:eq 匹配一个给定索引值的元素 </li><li>:gt 匹配所有大于给定索引值的元素 </li><li>:lt 匹配所有小于给定索引值的元素 </li></ul><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>$(“选择器 1 选择器 2 ……”) </p><h2 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h2><p>$(“选择器 1&gt;选择器 2&gt;……”) </p><h2 id="选择器对象"><a href="#选择器对象" class="headerlink" title="选择器对象"></a>选择器对象</h2><ul><li>$(“选择器”).each(function(index){this}) 选择器对象的遍历 </li><li>$(“选择器”).find() 找前面选择器匹配到的元素的子元素 </li><li>$(“选择器”).not() 在前面选择器匹配到的元素中去除某个或某多个 </li><li>$(“选择器”).add() 在前面选择器中在追加节点 </li></ul><h2 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h2><ul><li>:first-child 匹配第一个子元素 </li><li>:last-child 匹配最后一个子元素 </li><li>:first-of-type 选择所有相同的元素名称的第一个兄弟元素 </li><li>:last-of-type 选择所有相同的元素名称的最后一个兄弟元素 </li><li>:nth-child 匹配其父元素下的第 N 个子或奇偶元素 </li><li>:nth-last-child() 选择所有他们父元素的第 n 个子元素。计数从最后一个元素开始到第一个 </li><li>:nth-last-of-type() 选择的所有他们的父级元素的第 n 个子元素，计数从最后一个元素到第一个 </li><li>:nth-of-type() 选择同属于一个父元素之下，并且标签名相同的子元素中的第 n 个 </li><li>:only-child 如果某个元素是父元素中唯一的子元素，那将会被匹配 </li><li>:only-of-type 选择所有没有兄弟元素，且具有相同的元素名称的元素。 </li></ul><p>表单</p><ul><li>:input 匹配所有 input, textarea, select 和 button 元素 </li><li>:text 匹配所有的单行文本框 </li><li>:password 匹配所有密码框 </li><li>:radio 匹配所有单选按钮 </li><li>:checkbox 匹配所有复选框 </li><li>:submit 匹配所有提交按钮 </li><li>:image 匹配所有图像域 :reset 匹配所有重置按钮 </li><li>:button 匹配所有按钮 </li><li>:file 匹配所有文件域 </li><li>:hidden 匹配所有隐藏域 </li></ul><p>表单对象属性</p><ul><li>:enabled 匹配所有可用元素 </li><li>:disabled 匹配所有禁用元素 </li><li>:checked 匹配所有选中的被选中元素 </li><li>:selected 匹配所有选中的 option 元素 </li></ul><h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><ol><li>查找获取 <ul><li>text() - 设置或返回所选元素的文本内容 </li><li>html() - 设置或返回所选元素的内容 </li><li>val() - 设置或返回表单字段的值 </li></ul></li><li>内部插入 <ul><li>append() 向每个匹配的元素内部追加内容 </li><li>appendTo() 把所有匹配的元素追加到另一个指定的元素集合中 </li><li>prepend() 向每个匹配的元素内部前置内容 </li><li>prependTo() 把所有匹配的元素前置到另一个、指定的元素集合中 </li></ul></li><li>外部插入 <ul><li>after() 在每个匹配的元素之后插入内容 </li><li>before() 在每个匹配的元素之前插入内容 </li><li>insertAfter() 把所有匹配的元素插入到另一个、指定的元素集合的后面 </li><li>insertBefore() 把所有匹配的元素插入到另一个、指定的元素集合的前面</li></ul></li><li>包裹 <ul><li>wrap() 把所有匹配的元素用其他元素的结构化标记包裹起来 </li><li>unwrap() 这个方法将移出元素的父元素。 </li><li>wrapAll() 将所有匹配的元素用单个元素包裹起来 </li><li>wrapInner() 将每一个匹配的元素的子内容(包括文本节点)用一个 HTML 结构包裹起来 </li></ul></li><li>替换 <ul><li>replaceWith() 将所有匹配的元素替换成指定的 HTML 或 DOM 元素 </li><li>replaceAll() 用匹配的元素替换掉所有 selector 匹配到的元素 </li></ul></li><li>删除 <ul><li>empty() 删除匹配的元素集合中所有的子节点 </li><li>remove() 从 DOM 中删除所有匹配的元素 </li></ul></li><li>克隆 <ul><li>clone() 克隆匹配的 DOM 元素并且选中这些克隆的副本 </li></ul></li></ol><h2 id="JQuery-事件"><a href="#JQuery-事件" class="headerlink" title="JQuery 事件"></a>JQuery 事件</h2><p>页面载入 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$(<span class="hljs-built_in">document</span>).ready(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>&#125;)<br><span class="hljs-comment">//简写方式 </span><br>$(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>&#125;)<br></code></pre></div></td></tr></table></figure><p>事件绑定 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$(<span class="hljs-string">&quot;#box&quot;</span>).on(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <br>&#125;)<br><br>$(<span class="hljs-string">&quot;#box&quot;</span>).off(<span class="hljs-string">&quot;click, mousemove&quot;</span>); <br></code></pre></div></td></tr></table></figure><h2 id="容器适应"><a href="#容器适应" class="headerlink" title="容器适应"></a>容器适应</h2><p>获取元素的宽高有以下几种方法： </p><ul><li>$(选择器).width() | innerWidth() | outerWidth() </li><li>$(选择器).height() | innerHeight() | outerHeight() </li><li>innerWidth() 和 innerHeight() 是指元素里面内容的宽高加上内边距的宽高； </li><li>outerWidth() 和 outerHeight() 是指元素里面内容的宽高加上内边距的宽高和边框； </li></ul><p>获取窗口的宽高的方法如下：</p><ul><li>$(window).width() </li><li>$(window).height() </li></ul><h2 id="标签样式操作"><a href="#标签样式操作" class="headerlink" title="标签样式操作"></a>标签样式操作</h2><ul><li>$(选择器).css (样式属性名[,值])    方法设置或返回被选元素的一个或多个样式属性 </li><li>$(选择器).addClass(类别名)   增加类别样式 </li><li>$(选择器).removeClass(类别名)   去除类别样式 </li><li>$(选择器).toggleClass(类别名)    交替使用类别样式：有这个类别样式就去除，没有就追加；</li></ul><h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><ul><li>show() 显示元素 </li><li>hide() 隐藏元素</li></ul><ul><li>slidDown() 向下滑动显示 </li><li>slideUp() 向上滑动收起隐藏 </li><li>slideToggle() 交替滑动状态 </li></ul><ul><li>fadeIn() 淡入 </li><li>fadeOut() 淡出 </li><li>fadeTo() 动画到指定透明度 </li><li>fadeToggle() 交替淡出、淡入状态 </li></ul><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><ul><li>animate() 自定义动画 </li><li>stop() 停止所有在指定元素上正在运行的动画 </li><li>delay() 设置一个延时来推迟执行队列中之后的项目 </li><li>finish() 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画 </li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li>$.ajax() </li><li>$.get() 通过远程 HTTP GET 请求载入信息 </li><li>$.post() 通过远程 HTTP POST 请求载入信息 </li><li>$.getJSON() 通过 HTTP GET 请求载入 JSON 数据</li></ul><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX = 异步 JavaScript 和 XML </p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在浏览器中输入 url 地址请求服务器时，是通过 Ajax 发送 http 请求给服务器，服务的响应结果也是先返回给 Ajax，先 Ajax 处理之后在返回给浏览器显示在页面。 </p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>第一步： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xhr = <span class="hljs-keyword">new</span> XMLHttpRequest(); <br></code></pre></div></td></tr></table></figure><p>第二步 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xhr.open(<span class="hljs-string">&quot;post&quot;</span>, <span class="hljs-string">&quot;test.php&quot;</span>); <br></code></pre></div></td></tr></table></figure><p>第三步： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xhr.setRequestHeader(<span class="hljs-string">&quot;Content-type&quot;</span>,<span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>第四步： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xhr.send(<span class="hljs-string">&quot;a=1&amp;b=2&quot;</span>);<br></code></pre></div></td></tr></table></figure><p>第五步： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xhr.onreadystatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <br>  <span class="hljs-keyword">if</span>(xhr.status==<span class="hljs-number">200</span> &amp;&amp; xhr.readyState==<span class="hljs-number">4</span>)&#123; <br>    <span class="hljs-keyword">var</span> result=xhr.responseText;<span class="hljs-comment">//获取到结果 </span><br>    alert(result); <br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="XML-和-HTML-的区别"><a href="#XML-和-HTML-的区别" class="headerlink" title="XML 和 HTML 的区别"></a>XML 和 HTML 的区别</h2><p>XML：所有的标记必须成对出现，且区分大小写</p><p>HTML：不是所有的都需要成对出现，不区分大小写</p><h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get() 和 post()"></a>get() 和 post()</h2><p>$.get(url,data,callback,dataType) </p><p>$.post(url,data,callback,dataType) </p><p>Ajax 的基本格式如下： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$.ajax(&#123;<br>  <span class="hljs-attr">url</span>:<span class="hljs-string">&#x27;请求的资源&#x27;</span>,<br>  <span class="hljs-attr">type</span>:<span class="hljs-string">&#x27;请求方式 get|post&#x27;</span>,<br>  <span class="hljs-attr">data</span>:<span class="hljs-string">&#x27;发送数据 名=值&amp;名=值&#x27;</span>,<br>  <span class="hljs-attr">dataType</span>:<span class="hljs-string">&#x27;回传值的类型&#x27;</span>,<br>  <span class="hljs-attr">success</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)</span>&#123;<br>    <span class="hljs-comment">// res 接收返回值</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP（超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器。</p><h2 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h2><ul><li>request line <ul><li>请求行：第一行必须是请求行，用来说明请求类型、要访问的资源以及使用的HTTP 版本 </li></ul></li><li>header <ul><li>请求头：用来说明服务器要使用的附加信息 </li></ul></li><li>blank line <ul><li>空白行：请求头部与请求体之间必须有一个空白行，必不可少 </li></ul></li><li>body <ul><li>请求体：也叫请求正文，可以添加任意的其他数据 </li></ul></li></ul><p>状态行： </p><ul><li>Host 接受请求的服务器地址，可以是：IP：端口 或 域名 </li><li>User-Agent 发送请求的应用程序名称（浏览器信息） </li><li>Connection 指定与连接相关的属性，如：Connection:Keep-Alive </li><li>Accept-Charset 客户端可以接受的编码格式 </li><li>Accept-Encoding 客户端可以接受的数据压缩格式 </li><li>Accept-Language 客户端可以接受的语言 </li><li>referer 当前请求来自哪个链接（防盗连） </li><li>content-type 请求的文件类型 </li><li>cookie 该网站相关的会话信息 </li></ul><h2 id="url-请求过程"><a href="#url-请求过程" class="headerlink" title="url 请求过程"></a>url 请求过程</h2><ol><li>首先客户端与服务器需要建立连接。</li><li>建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，客户端信息和可能的内容。 </li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码（status Code 状态码），后边服务器信息、实体信息和可能的内容。 </li><li>客户端接收完, 服务器所返回的信息后，与服务器断开连接。 </li></ol><blockquote><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端。对于用户来说，这些过程是由 HTTP 自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 </p></blockquote><h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><p>预加载：将所有所需的资源提前请求加载到本地，后面在需要使用就直接从缓存中存取资源 </p><ol><li><p>使用 image 对象 </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span>/&gt;</span> <br></code></pre></div></td></tr></table></figure></li><li><p>使用 image 对象 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> image = <span class="hljs-keyword">new</span> Image(); <br>image.src=<span class="hljs-string">&quot;&quot;</span>; <br></code></pre></div></td></tr></table></figure></li><li><p>使用 XMLHttpRequest 对象 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">xmlhttprequest.onreadystatechange = callback;<br>xmlhttprequest.onprogress = progressCallback;<br>xmlhttprequest.open(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&#x27;http://xx.jpg,true&#x27;</span>);<br>xmlhttprequest.send();<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(xmlhttprequest.readyState = <span class="hljs-number">4</span> &amp;&amp; xmlhttprequest.status == <span class="hljs-number">200</span>)&#123;<br>    <span class="hljs-keyword">var</span> responseText = xmlhttprequest.responseText;<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Request was unsuccessful&quot;</span> + xmlhttprequest.status);<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">progressCallback</span>(<span class="hljs-params">e</span>)</span>&#123;<br>  c = e || event;<br>  <span class="hljs-keyword">if</span> (e.lengthComputable) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Received&quot;</span> + e.loaded + <span class="hljs-string">&quot;of&quot;</span> + e.total + <span class="hljs-string">&quot;bytes&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>首屏加载，技术上显示要用的技术就是图片懒加载，即到可视区域再加载。 </p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="JavaScript-代码优化"><a href="#JavaScript-代码优化" class="headerlink" title="JavaScript 代码优化"></a>JavaScript 代码优化</h2><ol><li>代码与结构分离 </li><li>样式与结构的分离 </li><li>数据与代码分离 </li></ol><p>AMD：Asynchronous Module Definition，即异步模块加载机制。 </p><p>CMD：Common Module Definition，即通用模块定义规范 </p><p>导出（export）与 导入（import）两个模块 </p><h2 id="提升文件加载速度"><a href="#提升文件加载速度" class="headerlink" title="提升文件加载速度"></a>提升文件加载速度</h2><ol><li>合并 JavaScript 代码，尽可能少的使用 script 标签。 </li><li>无堵塞加载 JavaScript </li><li>动态创建 script 标签来加载 </li></ol><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack 是一个 module bundler（模块构建工具），由于 JavaScript 应用程序的复杂性不断增加，构建工具已成为 web 开发中不可或缺的一部分。它帮助我们去打包、编译和管理项目需要的众多资源文件和依赖库。 </p><p>webpack 支持 CommonJS、AMD 和 ES6 模块系统，并且兼容多种 JS 书写规范，可以处理模块间的依赖关系，所以具有更强大的 JS 模块化的功能，它能压缩图片，对 CSS、js 文件进行语法检查、压缩、编译打包。 </p><h2 id="webpack-的特点"><a href="#webpack-的特点" class="headerlink" title="webpack 的特点"></a>webpack 的特点</h2><ol><li>可以很好的用于单页应用 </li><li>同时支持 require() 和 import 模块语法 </li><li>允许非常前沿的 code splitting（代码分割） 特性 </li><li>热加载可以让 React、Vue.js 和其它类似框架的本地开发更快 </li><li>它是目前最受欢迎的构建工具 </li></ol><h2 id="webpack-的缺点"><a href="#webpack-的缺点" class="headerlink" title="webpack 的缺点"></a>webpack 的缺点</h2><ol><li>不适合 web 开发的初学者 </li><li>对于 CSS、图片和其它非 JS 资源文件时，需要先混淆处理 </li><li>文档不够完善 </li><li>变化很大，不同版本的使用方法存在较大差异</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//安装全局 webpack </span><br>npm install webpack -g <br><br><span class="hljs-comment">//安装全局 webpack-cli </span><br>npm install webpack-cli -g <br></code></pre></div></td></tr></table></figure><h2 id="webpack-基本应用"><a href="#webpack-基本应用" class="headerlink" title="webpack 基本应用"></a>webpack 基本应用</h2><p>SPA（single page web application） 单页应用程序，是 webpack 打包的典型应用示例，主要的几个部分组成： </p><ul><li>index.html    主文件 </li><li>JS 文件    可能有多个 JS 文件，可通过 webpack 合并打包为一个文件 </li><li>CSS 文件    可能有多个 CSS 文件，可通过 webpack 合并打包为一个文件 </li><li>图片    可通过 webpack 压缩优化 </li></ul><p>dist 文件夹（存放打包后的文件，可以先不创建，打包时可以自动创建） </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">-dis,dist,bulit <br></code></pre></div></td></tr></table></figure><p>打包： </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">webpack --mode development <br></code></pre></div></td></tr></table></figure><h2 id="配置文件入门"><a href="#配置文件入门" class="headerlink" title="配置文件入门"></a>配置文件入门</h2><p>默认的配置文件名为：webpack.config.js </p><p>核心概念</p><p>一个配置文件的基本结构如下： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//配置项</span><br><span class="hljs-built_in">module</span>.exports=&#123;<br>  <span class="hljs-comment">//入口</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&quot;&quot;</span>,<br>  <span class="hljs-comment">//输出配置</span><br>  <span class="hljs-attr">output</span>: &#123;&#125;,<br>  <span class="hljs-comment">//模块</span><br>  <span class="hljs-attr">module</span>: &#123;&#125;,<br>  <span class="hljs-comment">//解析</span><br>  resolve：&#123;&#125;,<br>  <span class="hljs-comment">//插件（数组）</span><br>  <span class="hljs-attr">plugins</span>: [],<br>  <span class="hljs-comment">//开发服务器</span><br>  <span class="hljs-attr">devServer</span>: &#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><ul><li>entry 入口 定义入口文件，默认入口文件：./src/index.js </li><li>output 输出 定义出口文件，默认出口文件：./dist/main.js </li><li>resolve 解析 路径映射、省略后缀名等 </li><li>module 模块 定义不同 loader，让 webpack 能够处理非 JavaScript 模块 </li><li>plugins 插件 扩展 webpack 功能 </li><li>devServer 开发服务器 用于配置 webpack-dev-server 选项 </li></ul><p>设置配置文件自动完成： </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// webpack 是基于 node 构建的，只支持 CommonJS 模块 </span><br><span class="hljs-built_in">module</span>.exports=&#123;<br>  <span class="hljs-comment">// 入口配置 </span><br>  <span class="hljs-attr">entry</span>:<span class="hljs-string">&#x27;./src/js/main.js&#x27;</span>, <br>  <span class="hljs-comment">// 出口配置 </span><br>  <span class="hljs-attr">output</span>:&#123; <br>    <span class="hljs-attr">path</span>:__dirname +<span class="hljs-string">&#x27;/dist&#x27;</span>, <span class="hljs-comment">// 输出目录 </span><br>    <span class="hljs-comment">// __dirname:本文件所在硬盘 </span><br>    <span class="hljs-comment">// 路径（node 全局变量） </span><br>    <span class="hljs-attr">filename</span>:<span class="hljs-string">&#x27;js/main.js&#x27;</span> <span class="hljs-comment">// 文件名称（可以有子目录） </span><br>  &#125; <br>&#125;;<br></code></pre></div></td></tr></table></figure><p>修改 webpack.json 文件 </p><p>在 webpack.json 中的”scripts”下增加： </p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123; <br>  <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack --mode development&quot;</span>,<br>  <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span><br>&#125;, <br></code></pre></div></td></tr></table></figure><p>执行打包</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm run dev <br></code></pre></div></td></tr></table></figure><h2 id="entry-和-output"><a href="#entry-和-output" class="headerlink" title="entry 和 output"></a>entry 和 output</h2><ol><li>entry 入口配置 是指页面中的入口文件。也就是打包从哪个文件开始。默认入口文件：./src/index.js </li><li>output 出口配置 是指生成的文件输出到哪个地方去，默认出口文件：./dist/main.js，主要有以下属性：<ul><li>path 输出路径 </li><li>filename 输出文件名 </li></ul></li></ol><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack 只能打包 js 文件（只理解 JavaScript 语法），无法识别其他语法的文件，如果要让 webpack 打包其他文件，首先需要让 webpack 识别不同文件，这就需要特别的模块，这种模块统称为 loader。 </p><h3 id="loader-分类"><a href="#loader-分类" class="headerlink" title="loader 分类"></a>loader 分类</h3><ul><li>转换编译  script-loader，babel-loader，ts-loader，coffee-loader </li><li>处理样式  style-loader ， css-loader ， less-loader ， sass-loader ，postcss-loader </li><li>处理文件  raw–loader，url-loader，file-loader </li><li>处理数据  csv-loader，xml-loader </li><li>处理模板语言  html-loader，pug-loader，jade-loader，markdown-loader </li><li>清理和测试  mocha-loader，eslint-loader</li></ul><h3 id="常用-loader"><a href="#常用-loader" class="headerlink" title="常用 loader"></a>常用 loader</h3><ul><li>css-loader  解析 css 语句 </li><li>style-loader  将 css-loader 解析后的文本，添加 <code>&lt;style&gt;</code> 标签 </li><li>babel-loader  将 ES6+、JSX 语法转成 ES5 低版本语法 </li><li>url-loader  对未设置或者小于 limit byte 设置的图片以 base64 的格式进行转换，对于大于 limit byte 的图片用 file-loader 进行解析 </li><li>file-loader  解析项目中的 url 引入（包括 img 的 src 和 background 的 url）修改打包后文件引用路径，使之指向正确的文件 </li><li>less-loader less 编译器 </li><li>vue-loader  Vue 也推出了自己的 vue-loader，可以方便的打包 .vue 文件 的代码在 vue-cli（快速构建单页应用的脚手架）中得到应用。 </li></ul><h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css loader"></a>css loader</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//index.js </span><br><span class="hljs-keyword">import</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./a.js&quot;</span>; <br><span class="hljs-keyword">import</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./b.js&quot;</span>; <br><br><span class="hljs-keyword">var</span> txt = <span class="hljs-string">&quot;hello world&quot;</span>; <br>a.run(); <br>b.play(txt);<span class="hljs-comment">//打包 css 文件 </span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./style.css&quot;</span>; <span class="hljs-comment">//注意：是相对路径</span><br></code></pre></div></td></tr></table></figure><p>安装 loader（loader 也是依赖包，需要安装） </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install css-loader style-loader --save-dev <br></code></pre></div></td></tr></table></figure><p>在 module 中定义 ccs 模块相关的配置： </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">module: &#123;<br>  rules: [<br>    &#123;<br>      test: /.css$/, <span class="hljs-comment">// 正则</span><br>      <span class="hljs-comment">// 把 css 添加到 html 的 style 标签里(style-loader 要先加载)</span><br>      loader: [<span class="hljs-string">&#x27;style-loader&#x27;</span>,<span class="hljs-string">&#x27;css-loader&#x27;</span>], <span class="hljs-comment">// loader 或者 use</span><br>      exclude: /node_modules/, <span class="hljs-comment">// 正则 排除 node_modules 目录</span><br>    &#125;<br>  ] <br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel loader"></a>babel loader</h4><p>babel 是一个 js 编译器，它通过语法转换器支持最新版本的 JavaScript（包括 JSX、TypeScript 等新语法）。 这些插件允许你立刻使用新语法，无需等待浏览器支持。 </p><p>使用 Babel 首先要配置 .babelrc 文件，该文件用来设置转码规则和插件（ json 格式），存放在项目的根目录下。</p><blockquote><p>tips：在 linux 系统中，rc 结尾的文件通常代表运行时自动加载的 文件、配置 等等。 </p></blockquote><p>在 .babelrc 配置文件中，主要是对 预设（presets）和 插件（plugins）进行配置。</p><p>.babelrc 配置文件一般为如下： </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [<br>    [<span class="hljs-string">&quot;env&quot;</span>, &#123; <span class="hljs-string">&quot;modules&quot;</span>: <span class="hljs-literal">false</span> &#125; ] <span class="hljs-comment">// modules 是配置项</span><br>  ],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    [ <span class="hljs-string">&quot;transform-runtime&quot;</span>, &#123; <span class="hljs-string">&quot;polyfill&quot;</span>: <span class="hljs-literal">false</span>&#125; ] <span class="hljs-comment">// polyfill 是配置项</span><br>  ]<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>预设 对 js 最新的语法糖进行编译，并不负责转译新增的 api 和全局对象。 </li><li>插件 控制如何转换代码，babel 默认只转换新的 js 语法，而不转换新的 API </li></ul><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件（plugins）可以扩展 webpack 的功能，</p><p>loader 不能做的处理都能交给 plugin 来做。 </p><p>如：HtmlWebpackPlugin 插件简化了 HTML 文件的创建，可以通过模板文件，生成一个 HTML 文件 </p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>resolve（译：解析）配置 webpack 如何寻找模块对应的文件。 </p><p>alias（译：别名）通过别名将原来导入路径映射成一个新的导入路径 extensions（译：扩展）数组 导入模块时，可以省略的文件后缀名 </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">resolve: &#123;<br>  alias: &#123;<br>    <span class="hljs-string">&quot;@&quot;</span>: path.join(__dirname, <span class="hljs-string">&quot;./src&quot;</span>) <span class="hljs-comment">// 将项目根目录下的 src 目录，映射为 @</span><br>  &#125;,<br>  extensions: [<span class="hljs-string">&quot;.js&quot;</span>, <span class="hljs-string">&quot;.json&quot;</span>]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其他配置项示例： </p><ul><li>devtool  是否生成以及如何生成 sourcemap </li><li>devserver  开启一个本地开发服务器 </li><li>watch  监听文件变化并自动打包 </li><li>watchoption  用来定制 watch 模式的选项 </li><li>performance  打包后命令行如何展示性能提示，如果超过某个大小是警告还是报错</li></ul><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server 是一个小型的 web 服务器，可以自动监视项目文件的变化，自动刷新浏览器，其 HMR（Hot Module Replacement 热模块替换）方式只替换更新的部分，而不是重载页面，大大提高了刷新效率。 </p><p>需要本地安装 webpack 和 webpack-cli </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install webpack webpack-cli webpack-dev-server --save-dev <br></code></pre></div></td></tr></table></figure><p>webpack.config.js 配置文件：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> path=<span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;path&quot;</span>); <br><br><span class="hljs-comment">// HtmlWebpackPlugin 插件</span><br><span class="hljs-keyword">let</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">let</span> htmlPlugin = <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>  <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;index.html&quot;</span>, <span class="hljs-comment">// 生成的新文件</span><br>  <span class="hljs-attr">template</span>: __dirname + <span class="hljs-string">&quot;/src/index_temp.html&quot;</span>, <span class="hljs-comment">// 模板文件</span><br>  <span class="hljs-attr">minify</span>: &#123; <span class="hljs-comment">//压缩</span><br>    <span class="hljs-attr">removeComments</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 刪除注释</span><br>    <span class="hljs-attr">collapseWhitespace</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// 合并空格</span><br>  &#125;,<br>&#125;);<br><br><span class="hljs-comment">//配置项</span><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-comment">//输入</span><br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/js/main.js&#x27;</span>, <span class="hljs-comment">// 主入口文件 </span><br><br>  <span class="hljs-comment">//输出 </span><br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: __dirname + <span class="hljs-string">&quot;/dist&quot;</span>, <span class="hljs-comment">// 打包后的文件存放的地方</span><br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&quot;main.js&quot;</span> <span class="hljs-comment">// 打包后输出的文件名</span><br>  &#125;,<br><br>  <span class="hljs-comment">//模块</span><br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/.css$/</span>, <span class="hljs-comment">//正则 解析 css 文件</span><br>        <span class="hljs-comment">// 把 css 添加到 html 的 style 标签里(style-loader 要先加载) </span><br>        use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>],<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 正则 必须要写 exclude！！</span><br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.js$/</span>,<br>        use: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-attr">exclude</span>: <span class="hljs-regexp">/node_modules/</span>, <span class="hljs-comment">// 正则 必须要写 exclude！！</span><br>      &#125;]<br>  &#125;,<br><br>  <span class="hljs-comment">// 插件</span><br>  <span class="hljs-attr">plugins</span>:[<br>    htmlPlugin<br>  ],<br><br>  <span class="hljs-comment">// 解析</span><br>  <span class="hljs-attr">resolve</span>: &#123;<br>    <span class="hljs-attr">alias</span>: &#123;<br>      <span class="hljs-string">&quot;@&quot;</span>: path.join(__dirname, <span class="hljs-string">&quot;./src&quot;</span>) <span class="hljs-comment">// 将项目根目录下的 src 目录，映射为 &quot;@&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">extensions</span>:[<span class="hljs-string">&#x27;.js&#x27;</span>, <span class="hljs-string">&#x27;.json&#x27;</span>]<br>  &#125;,<br><br>  <span class="hljs-comment">// 开发服务器 </span><br>  <span class="hljs-attr">devServer</span>: &#123;<br>    <span class="hljs-attr">inline</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 支持 dev-server 自动刷新</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-string">&quot;8080&quot;</span>, <span class="hljs-comment">// 端口</span><br>    <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,   <span class="hljs-comment">// 自动打开默认浏览器</span><br>  &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123; <br>  <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack-dev-server --hot&quot;</span>, <br>  <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span>  <br>&#125;<br></code></pre></div></td></tr></table></figure><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式是移动最广泛的软件架构之一，把应用程序强制性地划分为三部分：模型（Model）、视图（View）和控制器（Controller）。 </p><h2 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h2><p>MVVM 模式是把 MVC 模式的 Controller 改成 ViewModel。View 的变化会自动更新 ViewModel，ViewModel 的变化也会自动同步到 View 上显示。 </p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>el   把 Vue 实例挂载到 DOM 元素上，通过 id 绑定 html 元素 </li><li>data  数据对象，Vue 实例的数据（注意：数据不要与 methods 中的方法重名）</li><li>methods  事件对象，包含事件所要触发的函数（注意：方法名不要与 data 中的数据重名） </li><li>computed  计算属性 </li><li>watch  监听器 </li><li>directives  自定义指令 </li><li>钩子（hook）函数（8 个）  hook（钩子）函数，不同生命周期引发的动作 </li><li>路由钩子函数（3 个）  路由组件在不同状态时触发 </li><li>components  组件容器 </li><li>template  定义模板，可以是字符串，也可以是”#“选择器 </li><li>props  用于接收来自父组件的数据</li><li>router  路由 </li><li>store  vuex 状态 </li></ul><h2 id="实例属性-方法"><a href="#实例属性-方法" class="headerlink" title="实例属性/方法"></a>实例属性/方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>vm.$el  Vue 实例使用的根 DOM 元素 </li><li>vm.$data  Vue 的 data 配置项 </li><li>vm.$options  用于当前 Vue 实例的初始化选项 </li><li>vm.$props  当前组件接收到的 props 对象 </li><li>vm.$parent  父实例（如果当前实例有的话） </li><li>vm.$root  当前组件树的根 Vue 实例 </li><li>vm.$children  当前实例的直接子组件 </li><li>vm.$refs  原生 DOM 元素或子组件注册引用信息 </li><li>vm.$slots  用来访问被插槽分发的内容 </li><li>vm.$router  全局路由（vue-router 插件） </li><li>vm.$store vuex  状态对象（vuex 插件）</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>vm.$emit()  子组件可以使用 $emit 触发父组件的自定义事件 </li><li>vm.$set()  Vue.set 的别名，设置对象的属性， 这个方法主要用于避开 Vue 不能检测属性被添加的限制 </li><li>vm.$watch  侦听数据变化vm.$on() 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。 </li><li>vm.$mount  可以使用 vm.$mount() 手动挂载（Vue 实例化时没有 el 选项） </li><li>vm.$destroy  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 触发 beforeDestroy 和 destroyed 的钩子。 </li></ul><h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><p>v-bind 动态改变 dom 标签上的属性</p><p><code>v-bind:class=&quot;&quot;</code>  简写  <code>:class=&quot;&quot;</code>  </p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>4 个阶段：创建 → 挂载 → 更新 → 销毁 </p><p>beforeCreate  实例创建前 </p><p>created  实例创建后 初始化数据（Ajax 数据请求，获取 Vuex 状态、路由切换等） </p><p>beforeMount  载入前 </p><p>mounted  载入后 需要操作 DOM 时（应用第三方插件等） </p><p>beforeUpdate  更新前 </p><p>updated  更新后 通过事件修改数据、v-model 引发数据变化、AJAX 异步更新数据</p><p>beforeDestroy  实例销毁前 </p><p>destroyed  实例销毁后 切换路由（组件将被销毁） </p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p><p>计算属性具有缓存 </p><h2 id="数组的更新检查"><a href="#数组的更新检查" class="headerlink" title="数组的更新检查"></a>数组的更新检查</h2><p>变异方法，可触发视图更新</p><ul><li>push()、pop()、shift()、unshift()、splice()、sort()、reverse() </li></ul><p>非变异方法，不触发视图更新 </p><ul><li>filter(), concat() 和 slice() </li><li>它们可以返回新数组，用新数组替换旧数组，就可以刷新视图 </li></ul><h2 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h2><p>event.type 触发的事件类型 </p><p>event.target 触发事件的 HTML 元素 </p><p>event.preventDefault( ) 阻止事件的默认行为 </p><p>event.stopPropagation( ) 阻止事件冒泡 </p><h2 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h2><p>创建组件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myTemp = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;#temp&#x27;</span>, <span class="hljs-comment">// 模板 id</span><br>  <span class="hljs-attr">data</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 必须为 函数(闭包)</span><br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-comment">// 必须有 return，返回值为 对象&#123;&#125;</span><br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&quot;dadaqianduan&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>注册组件 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在 components 配置项中注册组件</span><br><span class="hljs-keyword">let</span> app = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&quot;#box&quot;</span>,<br>  <span class="hljs-attr">components</span>: &#123; myTemp &#125;<br>&#125;);<br><br><span class="hljs-comment">// 全局注册组件，还可以使用 Vue.component 方法（仅限全局注册，不建议使用）</span><br>Vue.component(<span class="hljs-string">&#x27;myTemp&#x27;</span>, MyTemp);<br></code></pre></div></td></tr></table></figure><p>使用组件 </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!--在 Vue 实例中使用组件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&#x27;box&#x27;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!--组件名如果用驼峰定义，改为短横线命名--&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">my-temp</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-temp</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>事件通信 </p><p>父子组件之间的数据操作，是通过 <strong>props</strong> 属性和 <strong>$emit()</strong> 方法来实现的 </p><h2 id="路由使用"><a href="#路由使用" class="headerlink" title="路由使用"></a>路由使用</h2><p>定义路由包括路由路径（path）、路由名称（name）、路由组件对象（component） </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,<br>    <span class="hljs-comment">// 路由路径</span><br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;home&#x27;</span>,<br>    <span class="hljs-comment">// 路由名称</span><br>    <span class="hljs-attr">component</span>: Home<br>    <span class="hljs-comment">// 路由组件对象</span><br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Users&#x27;</span>,<br>    <span class="hljs-attr">component</span>: UserComponent<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;about&#x27;</span>,<br>    <span class="hljs-attr">component</span>: <span class="hljs-function">() =&gt;</span> <span class="hljs-keyword">import</span>( <span class="hljs-string">&#x27;./views/About.vue&#x27;</span>)<br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure><p>动态路由</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/users/:username/post/:postid&#x27;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Users&#x27;</span>,<br>    <span class="hljs-attr">component</span>: UserComponent,<br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure><blockquote><p>/user/:username  –&gt;  /user/tom </p><p>{ username: ‘tom’ } </p></blockquote><blockquote><p>/user/:username/post/:postId  –&gt;  /user/tom/post/3 </p><p>{ username: ‘tom’, postId: ‘3’ }</p></blockquote><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><p>路由导航守卫可以简单理解为路由组件的生命周期回调函数。 </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 作用：在第一次进入当前路由组件之前被调用</span><br><span class="hljs-comment">// 使用场景：获取 ajax 数据</span><br><span class="hljs-function"><span class="hljs-title">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>  <span class="hljs-comment">// to：表示要进入的路由组件</span><br>  <span class="hljs-comment">// from：表示将要离开的路由组件</span><br>  <span class="hljs-comment">// next：表示后续操作函数</span><br>  <span class="hljs-comment">// 此时还未进入到组件中，故不能使用 this 获取当前组件的实例</span><br>  next(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">app</span>) </span>&#123;<br>    <span class="hljs-comment">// 进入到当前组件后，才执行的回调</span><br>    <span class="hljs-comment">// 此时回调参数 app 表示当前组件的实例对象</span><br>    axios.get(<span class="hljs-string">&#x27;/users/&#x27;</span> + app.id).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>      app.user = res.data.data;<br>    &#125;);<br>  &#125;);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">beforeRouteUpdate</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>)</span> &#123;<br>  <span class="hljs-comment">// 此时，可以使用 this 表示当前组件对象</span><br>  <span class="hljs-keyword">const</span> app = <span class="hljs-built_in">this</span>;<br>  <span class="hljs-comment">// 发送 ajax 请求</span><br>  <span class="hljs-comment">// this 表示切换前的状态</span><br>  <span class="hljs-comment">// to 表示要切换到的路由对象 route</span><br>  axios.get(<span class="hljs-string">&#x27;/users/&#x27;</span> + to.params.id).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    app.user = res.data.data;<br>  &#125;); <span class="hljs-comment">// 执行后续</span><br>  next();<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><ul><li>push() 跳转到指定的路由地址， 并把当前地址写入到 history 中，参数可以是字符串路径或描述地址信息的对象 <ul><li>字符串 router.push(‘home’) </li><li>对象 router.push({path:’home’}) </li><li>命名的路由 router.push({name:user,params:{userId:1}}) </li></ul></li><li>replace( )：跳转到指定路由，它不会向 history 添加新记录，而是替换掉当前的 history 记录。 </li></ul><h3 id="全局路由导航守卫"><a href="#全局路由导航守卫" class="headerlink" title="全局路由导航守卫"></a>全局路由导航守卫</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>&#125;);<br></code></pre></div></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">children: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">component</span>: 路由名<br>  &#125;,<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;路径名&quot;</span>,<br>    <span class="hljs-attr">component</span>: 路由名<br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>使用 <code>&lt;router-view&gt;</code> 可以使用 name 属性为其设置名称，即命名路由的视图简称命名视图。 </p><p>示例： </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>/&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span> <br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./views/About.vue&#x27;</span>;<br>routes: [<br>  &#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/about&quot;</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;about&quot;</span>,<br>    <span class="hljs-attr">components</span>: &#123;<br>      <span class="hljs-attr">default</span>: About,<br>      <span class="hljs-attr">content</span>: UserComponent<br>    &#125;<br>  &#125;<br>]<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>DOM</tag>
      
      <tag>BOM</tag>
      
      <tag>HTML</tag>
      
      <tag>HTML5</tag>
      
      <tag>webpack</tag>
      
      <tag>CSS</tag>
      
      <tag>CSS3</tag>
      
      <tag>vue</tag>
      
      <tag>jQuery</tag>
      
      <tag>AJAX</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue笔记</title>
    <link href="/2021/08/14/vue%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/14/vue%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-vue"><a href="#什么是-vue" class="headerlink" title="什么是 vue"></a>什么是 vue</h3><p>官方概念：Vue（读音 /vju:/，类似于 view），是一套用于构建用户界面的前端框架</p><ol><li>构建用户界面<ul><li>用 vue 往 html 页面中填充数据，非常的方便</li></ul></li><li>框架<ul><li>框架时一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能</li><li>要学习 vue，就是在学习 vue 这个框架中规定的用法</li><li>vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库</li><li>只有把上面罗列的内容掌握以后，才有开发 vue 项目的能力</li></ul></li></ol><h3 id="vue-的特性"><a href="#vue-的特性" class="headerlink" title="vue 的特性"></a>vue 的特性</h3><p>vue 框架的特性，主要体现在两方面：</p><ol><li><p>数据驱动视图</p><ul><li>数据的变化<strong>会驱动视图</strong>自动更新</li><li>好处：当页面数据发生变化时，页面会自动重新渲染</li><li>数据驱动视图时单向的数据绑定</li></ul></li><li><p>双向数据绑定</p><blockquote><p>在网页中，form 表单负责<strong>采集数据</strong>，Ajax 负责<strong>提交数据</strong></p></blockquote><ul><li>在填写表单时，双向数据绑定额可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中</li><li>好处：开发者不需要手动操作 DOM 元素，来获取表单元素最新的值</li></ul></li></ol><blockquote><p>注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Model 数据源、View 视图、ViewModel 就是 vue 的实例）</p></blockquote><h4 id="MV-模式"><a href="#MV-模式" class="headerlink" title="MV* 模式"></a>MV* 模式</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>模型（Model）、视图（View）、控制器（Controller）</p><p>模型：代表应用程序的<strong>数据</strong>以及用于访问控制和修改这些数据的<strong>业务规则</strong>；</p><p>视图：用来组织模型的<strong>内容</strong>，发送用户的请求到控制器；</p><p>控制器：定义了应用程序的<strong>行为</strong>，将用户的请求映射到模型更新，选择视图作为请求的响应</p><h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><p>MVP（Model-View-Presenter）是由经典的 MVC 模式演变而来的，Presenter 负责逻辑的处理，Model 提供数据，View 负责显示</p><p>MVP 和 MVC 最大的区别在于：</p><ul><li>在 MVP 中 VIew 并不直接使用 Model，之间的通信通过 Presenter 进行的，所有的交互都在发生在 Presenter 内部</li><li>在 MVC 中 View 会直接从 Model 中读取数据而不是通过 Controller</li></ul><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM（Model-View-ViewModel）是一种软件架构模式，是一种简化用户界面的事件驱动编程方式</p><p>核心是 <strong>数据驱动</strong> ，即 ViewModel，ViewModel 是 View 和 Model 的关系映射</p><ul><li>ViewModel 是一个值转换器（Value Converter），负责转换 Model 中的数据对象，使数据变得更加易于管理和使用</li><li>在 MVVM 中，View 和 Model 的中间 ViewModel 充当观察者的角色，两者不可直接通信</li></ul><p>核心的特性就是 <strong>数据双向绑定</strong> </p><h3 id="vue-的版本"><a href="#vue-的版本" class="headerlink" title="vue 的版本"></a>vue 的版本</h3><p>当前，vue 共有 3 个大版本，其中：</p><ul><li>2.x 版本的 vue 是目前企业级项目开发中的主流版本</li><li>3.x 版本的 vue 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广</li><li>1.x 版本的 vue 几乎被淘汰，不再建议学习与使用</li></ul><blockquote><p> vue 作者：尤雨溪，中国人</p></blockquote><h2 id="vue-的基本使用"><a href="#vue-的基本使用" class="headerlink" title="vue 的基本使用"></a>vue 的基本使用</h2><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><ol><li>导入 vue.js 的 script 脚本文件</li><li>在页面中声明一个将要被 vue 控制的 DOM 区域</li><li>创建 vm 实例对象（vue 实例对象）</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 希望 Vue 能够控制下面这个 div，帮我们在把数据填充到 div 内部 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  &#123;&#123; username &#125;&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 1. 导入 Vue 的库文件，在 window 全局就有了 VUe 这个构造函数 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 2. 创建 Vue 的实例对象 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-comment">// 创建 Vue 的实例对象</span></span><br><span class="javascript">  <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    <span class="hljs-comment">// el 是固定的写法，表示 vm 实例要控制页面上的哪个区域，接收的值是一个选择器</span></span><br><span class="javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-comment">// data 对象就是要渲染到页面上的数据</span></span><br><span class="javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;)</span><br><span class="javascript">  </span><br><span class="javascript">  <span class="hljs-comment">// vm.$mount(&#x27;#app&#x27;) // 作用与 el 属性完全一样</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>使用 vue-devtools 调试：在 chrome 中 F12 调试面板中的 vue 一项</p></blockquote><h2 id="vue-的指令和过滤器"><a href="#vue-的指令和过滤器" class="headerlink" title="vue 的指令和过滤器"></a>vue 的指令和过滤器</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="概念和分类"><a href="#概念和分类" class="headerlink" title="概念和分类"></a>概念和分类</h4><p>指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><ul><li><p>内容渲染指令</p></li><li><p>属性绑定指令</p></li><li><p>事件绑定指令</p></li><li><p>双向绑定指令</p></li><li><p>条件渲染指令</p></li><li><p>列表渲染指令</p></li></ul><blockquote><p>注意：指令是 vue开发中最基础、最常用、最简单的知识点</p></blockquote><h4 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h4><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个：</p><ul><li><code>v-text</code> </li><li><code>&#123;&#123; &#125;&#125;</code> </li><li><code>v-html</code> </li></ul><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>更新元素的内容文本</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;username&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">&quot;gender&quot;</span>&gt;</span>性别<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;zhangsan&#x27;</span>,</span><br><span class="javascript">      <span class="hljs-attr">gender</span>: <span class="hljs-string">&#x27;男&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意缺点：v-text 指令会覆盖元素内默认的值</p></blockquote><h5 id="插值表达式语法"><a href="#插值表达式语法" class="headerlink" title="插值表达式语法 *"></a>插值表达式语法 *</h5><p>vue 提供的 <code>&#123;&#123; &#125;&#125;</code> 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 <code>&#123;&#123; &#125;&#125;</code> 语法的专业名称是<strong>插值表达式</strong>（英文名为：<strong>Mustache 语法</strong>）</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>姓名：&#123;&#123; username &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>性别：&#123;&#123; gender &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容</p><blockquote><p>在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算</p></blockquote><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>v-text 指令和 插值表达式 只能渲染纯文本内容</p><p>v-html 可以把带有标签的字符串，渲染成真正的 HTML 内容</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-html</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">      <span class="hljs-attr">info</span>: <span class="hljs-string">&#x27;&lt;h4 style=&quot;color: red; font-weight: bold;&quot;&gt;欢迎大家来学习 vue.js&lt;/h4&gt;&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>动态渲染 HTML 是非常危险的，很容易导致 XSS 攻击，永远不要在用户提交的内容上使用 v-html</p></blockquote><h5 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h5><p>可以让元素或组件只渲染一次，不需要表达式。</p><p>之后再次渲染时，元素/组件及其所有的子节点将被视为静态内容并跳过，可以用于<strong>优化更新性能</strong>。</p><h5 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h5><p>用于跳过这个元素和它的子元素的编译过程，可以用来显示原始 Mustache 标签，不需要表达式。</p><p>对于大量没有指令的节点使用 v-pre 指令可以<strong>加快编译速度</strong>。</p><h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><p>这个指令保持在元素上知道关联实例编译结束，编译结束后该指令被移除，不需要表达式。</p><p>使用场景：</p><p>浏览器在加载页面时，如果网速较慢或者页面较大，那么浏览器在构造完 DOM 树后会在页面中直接显示 <code>&#123;&#123; value &#125;&#125;</code> 字样，直到 Vue 的 JS 文件加载完成，Vue 实例创建、模板编译后，才会被替换为数据对象中的内容。在这个过程中页面是有闪烁的，给用户的体验不好。</p><p>这时，CSS 规则 <code>[v-cloak] &#123; display: none &#125;</code> 配合 v-cloak 指令一起使用，就可以<strong>解决页面数据闪烁</strong>问题。</p><blockquote><p>在 Vue.js 独立版本的页面开发中，v-cloak 是非常有效的；但在较大的项目中均为模块化开发，不需要使用 v-cloak 指令</p></blockquote><h4 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h4><blockquote><p>注意：插值表达式只能用在元素的<strong>内容节点</strong>中，不能用在元素的<strong>属性节点</strong>中！</p></blockquote><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind: | :"></a>v-bind: | :</h5><ul><li><p>在 vue 中，可以使用 <code>v-bind:</code> 指令,为元素的属性动态绑定属性值</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-bind:placeholder</span>=<span class="hljs-string">&quot;Tips&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>简写是英文的 <code>:</code> </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">:placeholder</span>=<span class="hljs-string">&quot;Tips&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>动态属性名：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">v-bind:</span>[<span class="hljs-attr">attrname</span>]=<span class="hljs-string">&quot;url&quot;</span>&gt;</span>链接<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:title</span>=<span class="hljs-string">&quot;&#x27;box&#x27; + index&quot;</span>&gt;</span>这是一个 div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>要避免没使用大写字符命名动态参数，浏览器会把元素的属性名全部强制值转换为小写字符</p></li></ul><h5 id="绑定-class"><a href="#绑定-class" class="headerlink" title="绑定 class"></a>绑定 class</h5><h6 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">hasError</span>: <span class="hljs-literal">false</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;static active&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>可以在数据属性中单独定义一个对象，然后绑定这个对象，或者考虑绑定一个返回对象的计算属性</p></blockquote><h6 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">isActive</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">activeClass</span>: <span class="hljs-string">&#x27;active&#x27;</span>,<br>    <span class="hljs-attr">errorClass</span>: <span class="hljs-string">&#x27;text-danger&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;active text-danger&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>可以在数组语法中使用对象语法来简化表达式</p></blockquote><h5 id="绑定-style"><a href="#绑定-style" class="headerlink" title="绑定 style"></a>绑定 style</h5><p>对象语法 和 数组语法 依然适用</p><ul><li><p>CSS 属性名可以用 <strong>驼峰式</strong>（camelCase）或 <strong>短横线分隔</strong>（’kebab-case’，记得用<strong>引号</strong>包起来）来命名</p></li><li><p>某些样式的不同浏览器内核前缀，在使用 :style 时 Vue.js 会<strong>自动侦测并添加相应的前缀</strong> </p></li><li><p>属性值可以包含多重值（一个数组），只会渲染数组中<strong>最后一个被浏览器支持的值</strong> </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h4><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on: | @"></a>v-on: | @</h5><p>vue 提供了 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>通过 v-on 绑定的事件处理函数，需要在 <strong>methods</strong> 节点中进行声明，methods 与 data 节点同级</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">methods: &#123;<br>  add () &#123;<br>    <span class="hljs-built_in">this</span>.count++<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li><p>需要传参在方法名后面加括号即可</p></li><li><p>如果在方法中要修改或访问 data 中的数据，可以通过 this 访问到</p></li><li><p>简写是 <code>@</code> </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><blockquote><p>注意：原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup</p></blockquote><h5 id="event"><a href="#event" class="headerlink" title="$event"></a>$event</h5><p>vue 提供了内置变量 <strong>$event</strong>，用来表示原生 DOM 的事件参数对象 event</p><p>$event 可以解决事件参数对象 event 被覆盖的问题</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add(1, $event)&quot;</span>&gt;</span>+N<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;</span><br><span class="javascript">    <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,</span><br><span class="javascript">    <span class="hljs-attr">data</span>: &#123;</span><br><span class="javascript">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">      add (n, e) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.count += n</span><br><span class="javascript">        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.count % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;</span><br><span class="javascript">          e.target.style.backgroundColor = <span class="hljs-string">&#x27;red&#x27;</span></span><br><span class="javascript">        &#125; <span class="hljs-keyword">else</span> &#123;</span><br><span class="javascript">          e.target.style.backgroundColor = <span class="hljs-string">&#x27;&#x27;</span></span><br><span class="javascript">        &#125;</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><h6 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h6><blockquote><p>在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</p></blockquote><p>vue 提供了事件修饰符的概念，来辅助程序员更方便的对事件的触发进行控制。</p><p>常用的 5 个事件修饰符如下：</p><ul><li><p><strong>.prevent</strong> ：阻止默认行为，调用 event.preventDefault()（例如：阻止 a 连接的跳转、阻止表单的提交等）</p></li><li><p><strong>.stop</strong> ：阻止事件冒泡，调用 event.stopPropagation()</p></li><li><p>.capture ：以捕获模式触发当前的事件处理函数</p><blockquote><p>捕获：由外至内，冒泡：由内至外</p></blockquote></li><li><p>.once ：绑定的事件只触发1次</p></li><li><p>.self ：只有在 event.target 是当前元素自身时触发事件处理函数</p></li><li><p><strong>.native</strong> ：监听组件根元素的原生事件</p></li><li><p>.passive ：以 { passive: true } 模式添加监听器</p></li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.baidu.com&quot;</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">&quot;show&quot;</span>&gt;</span>跳转到百度首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>修饰符可以串联一起使用，如：</p><ul><li>@click.prevent.self 会阻止所有的单击</li><li>@click.self.prevent 会阻止对元素自身的单击</li></ul></blockquote><h6 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h6><p>可以为键盘相关的事件添加按键修饰符，用的不多</p><ul><li><strong>.esc</strong>   <strong>.enter</strong>  .space  .tab  .delete（捕获删除键和退格键） </li><li>.up  .down  .left  .right    方向键</li><li>.ctrl  .alt  .shift  .meta（对应菜单键）</li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> @<span class="hljs-attr">keyup.esc</span>=<span class="hljs-string">&quot;clearInput&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意，修饰键和常见按键并不相同，在和 keyup 事件一起使用时，事件触发时修饰键必须处于按下状态，可以使用 虚拟键代码(即按键对应的数字) 代替</p><h6 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h6><p>用于精确控制系统修饰符组合触发的事件</p><p>加上 .exact 后，当且仅当满足设置的修饰键时才会触发，如：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 按下 ctrl 的同时即使按下其他键，也会触发事件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只有在按住 ctrl 键而不按其他键时才会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.ctrl.exact</span>=<span class="hljs-string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 只有在没有按下系统键时才会触发 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.exact</span>=<span class="hljs-string">&quot;onClick&quot;</span>&gt;</span>A<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h6 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h6><p>.left .middle .right  分别对应鼠标的左键、中键和右键</p><h4 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h4><h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><p>只有表单元素才可以使用 v-model 指令</p><blockquote><p>比如：input 输入框、textarea、select</p></blockquote><p>v-model 会忽略所有表单元素的 value、checked、selected 属性的初始值，而总是将 Vue 实例的数据属性作为数据来源</p><ul><li>复选框单独使用，v-model 绑定的值是一个布尔值，但多个复选框一起使用时绑定的是一个数组<ul><li>在使用单个复选框时，可以使用 true-value 和 false-value 属性来设置选中和未选中时 v-model 绑定的值</li></ul></li><li>单选按钮被选中时，v-model 绑定的数据属性的值会被设置为该单选按钮的 value 值</li><li>选择框的使用与复选框类似，单选时绑定的是选项的值（option 元素 value 属性的值），多选时绑定到一个数组</li></ul><blockquote><p>value-true、false-true、true 均可以使用 v-bind 指令绑定到数据属性上</p></blockquote><h5 id="专用修饰符"><a href="#专用修饰符" class="headerlink" title="专用修饰符"></a>专用修饰符</h5><ul><li><strong>.number</strong>：自动将用户的输入值转为数值类型</li><li><strong>.trim</strong>：自动过滤用户输入的首尾空白字符 </li><li><strong>.lazy</strong>：在 “change” 时而非 “input” 时更新</li></ul><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;n1&quot;</span>&gt;</span> + <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">v-model.number</span>=<span class="hljs-string">&quot;n2&quot;</span>&gt;</span> = <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>&#123;&#123; n1 + n2 &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h4><blockquote><p>如果需要控制多个元素的显示或隐藏、创建或删除，可以用 template 元素来包裹这些元素，然后在 template 元素上使用指令</p></blockquote><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>原理是：动态为元素添加或移除 <code>display: none</code> 样式，来实现元素的显示和隐藏</p><ul><li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li></ul><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>原理是：每次动态创建或移除元素，实现元素的显示和隐藏</p><ul><li>如果刚进入页面的时候，某些元素默认不需要显示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li></ul><blockquote><p>在实际开发中，不用考虑性能问题，直接使用 v-if 即可</p></blockquote><p>v-if 可以单独使用，或配合 v-else 指令一起使用：</p><h5 id="v-else-v-else-if"><a href="#v-else-v-else-if" class="headerlink" title="v-else v-else-if"></a>v-else v-else-if</h5><p>这两个指令均必须配合 v-if 指令一起使用，否则将并不会被识别</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else-if</span>=<span class="hljs-string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>差<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素，而不是从头开始渲染，所以有以下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;<br>&lt;label&gt;用户名：&lt;/label&gt;<br>&lt;input placeholder=&quot;请输入你的用户名&quot;&gt;<br>&lt;/template&gt;<br>&lt;template v-else&gt;<br>&lt;label&gt;Email：&lt;/label&gt;<br>&lt;input placeholder=&quot;请输入你的 Email&quot;&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure><p>当从 用户名 切换到 Email 时，原先用户名中已输入的值还会保留，因为在切换时，vue 保留了 input 元素，仅仅替换了其 placeholder 属性值</p><p>解决：可以通过为元素添加一个具有唯一值的 <strong>key</strong> 属性</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;<br>&lt;label&gt;用户名：&lt;/label&gt;<br>&lt;input placeholder=&quot;请输入你的用户名&quot; key=&quot;username-input&quot;&gt;<br>&lt;/template&gt;<br>&lt;template v-else&gt;<br>&lt;label&gt;Email：&lt;/label&gt;<br>&lt;input placeholder=&quot;请输入你的 Email&quot; key=&quot;email-input&quot;&gt;<br>&lt;/template&gt;<br></code></pre></div></td></tr></table></figure><h4 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h4><blockquote><p>如果需要控制多个元素的循环，可以用 template 元素来包裹这些元素，然后在 template 元素上使用指令</p></blockquote><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>v-for 指令需要使用 <strong>item in items</strong> 形式的特殊语法，其中：</p><ul><li>items 是待循环的数组</li><li>item 是被循环的每一项</li></ul><p>指令还支持一个可选的第二个参数，即当前项的<strong>索引</strong>，语法格式为 <strong>(item, index) in items</strong> </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">table</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">thead</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>索引<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>Id<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">th</span>&gt;</span>姓名<span class="hljs-tag">&lt;/<span class="hljs-name">th</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">thead</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">tbody</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tr</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in list&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; index &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; item.id &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">td</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">td</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tr</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">tbody</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">table</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h6 id="v-for-遍历数组"><a href="#v-for-遍历数组" class="headerlink" title="v-for 遍历数组"></a>v-for 遍历数组</h6><blockquote><p>Vue 在检测到数组变化时，并不是直接重新渲染整个列表，而是最大化地复用 DOM 元素，替换的数组中，含有相同元素的项不会被重新渲染，无需担心性能问题。</p></blockquote><p>需要注意，以下方法引起的数组变动，Vue 不能检测到：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 通过索引直接设置数组项</span><br>vm.books[<span class="hljs-number">0</span>] = &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Java Web 开发详解&#x27;</span>&#125;<br><span class="hljs-comment">// 修改数组的长度</span><br>vm.books.length = <span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>解决办法：</p><ul><li><p>使用 Vue 全局的 <strong>set()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.set(vm.books, <span class="hljs-number">0</span>, &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Java Web 开发详解&#x27;</span>&#125;)<br></code></pre></div></td></tr></table></figure></li><li><p>使用 Vue 实例的 <strong>$set()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">vm.$set(vm.books, <span class="hljs-number">0</span>, &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Java Web 开发详解&#x27;</span>&#125;)<br></code></pre></div></td></tr></table></figure></li><li><p>使用 数组的 <strong>splice()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">vm.books.splice(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, &#123;<span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Java Web 开发详解&#x27;</span>&#125;) <span class="hljs-comment">// 等同于通过索引修改数组</span><br>vm.books.splice(<span class="hljs-number">1</span>) <span class="hljs-comment">// 修改数组长度</span><br></code></pre></div></td></tr></table></figure></li></ul><h6 id="v-for-遍历对象"><a href="#v-for-遍历对象" class="headerlink" title="v-for 遍历对象"></a>v-for 遍历对象</h6><p>格式相同，为 <strong>value in object</strong>，可以按需添加参数 <strong>(value, key, index) in object</strong> </p><ul><li>value 代表属性值</li><li>key 表示属性名</li><li>index 表示索引</li></ul><p>同样需要注意，由于 JavaScript 的限制，Vue 不能检测对象属性的添加和删除</p><p>解决办法：</p><ul><li><p>使用 Vue 全局的 <strong>set()</strong> 和 <strong>delete()</strong> 方法 或 Vue 实例的 <strong>$set()</strong> 和 <strong>$delete()</strong> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.set(对象名, <span class="hljs-string">&#x27;属性名&#x27;</span>, <span class="hljs-string">&#x27;属性值&#x27;</span>)<br>vm.$set(对象名, <span class="hljs-string">&#x27;属性名&#x27;</span>, <span class="hljs-string">&#x27;属性值&#x27;</span>)<br>Vue.delete(对象名, <span class="hljs-string">&#x27;属性名&#x27;</span>)<br>vm.$delete(对象名, <span class="hljs-string">&#x27;属性名&#x27;</span>)<br></code></pre></div></td></tr></table></figure></li></ul><h6 id="v-for-遍历整数"><a href="#v-for-遍历整数" class="headerlink" title="v-for 遍历整数"></a>v-for 遍历整数</h6><p>v-for 指令也可以接受整数，会把模板重复对应次数</p><h5 id="key-1"><a href="#key-1" class="headerlink" title="key"></a>key</h5><p>官方建议：只要用到了 v-for 指令，那么一定要绑定一个 :key 属性，而且尽量把 id 作为 key 的值</p><p>key 值的要求：</p><ol><li><p><strong>字符串</strong>或<strong>数字</strong>类型</p></li><li><p>key 的值必须具有<strong>唯一性</strong>（即：key 的值不能重复，否则会报错）</p><blockquote><p>[Vue warn]: Duplicate keys detected: ‘ ‘.</p></blockquote></li><li><p>建议把数据项 <strong>id 属性</strong>的值作为 key 的值（因为 id 属性的值具有唯一性）</p></li><li><p><strong>使用 index 的值当作 key 的值没有任何意义</strong>（因为 index 的值不具有唯一性）</p><ul><li>当列表项发生变化时，索引可能会前向推进，单个不唯一</li></ul></li><li><p>建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）</p></li></ol><blockquote><p>不建议将 v-for 和 v-if 用在同一个元素上，可以用计算属性替代</p></blockquote><h3 id="filters-过滤器"><a href="#filters-过滤器" class="headerlink" title="filters 过滤器"></a>filters 过滤器</h3><blockquote><p>Vue3 中已经不可以使用内置过滤器(已删除)，Vue2 中仍可以</p></blockquote><p>过滤器（Filters）是 vue 为开发者提供的功能，常用于<strong>文本的格式化</strong>，或者数组数据的过滤与排序等。</p><p>过滤器可以用在两个地方：<strong>插值表达式</strong>和 <strong>v-bind 属性绑定</strong>；</p><p>过滤器应该被添加在 JavaScript 表达式的尾部，由 “管道符” <code>|</code> 进行调用</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 在插值表达式中调用 capitalize 过滤器，对 message 的值进行格式化 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; message | capitalize &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 在 v-bind: 中调用 formatId 过滤器，对 rawId 的值进行格式化 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:id</span>=<span class="hljs-string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>注意点：</p><ul><li>在 filters 节点中定义私有过滤器，本质是一个函数</li><li>过滤器函数形参中的第一个参数，永远都是“管道符”前面的那个值，其他参数从第二个开始接收</li><li>过滤器中必须有一个 return 值</li><li>过滤器可以多个串联使用</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 过滤器函数，定义到 filters 节点之下，是私有过滤器</span><br><span class="hljs-attr">filters</span>: &#123;<br>  <span class="hljs-comment">// 注意：过滤器函数形参中的 val，永远都是“管道符”前面的那个值</span><br>  capitalize (val) &#123;<br>    <span class="hljs-comment">// 过滤器中必须有一个返回值</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  Vue.filter(<span class="hljs-string">&#x27;capitalize&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">str</span>) =&gt;</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> str.charAt(<span class="hljs-number">0</span>).toUpperCase() + str.slice(<span class="hljs-number">1</span>)</span><br><span class="javascript">  &#125;)</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>一般使用的都是全局过滤器</p><p>全局和私有过滤器名字一致，此时按照就近原则，调用的是私有过滤器</p><h2 id="directives-自定义指令"><a href="#directives-自定义指令" class="headerlink" title="directives 自定义指令"></a>directives 自定义指令</h2><p>vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令</p><ul><li><p>在使用自定义指令时，需要加上 <strong>v-</strong> 前缀</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-volor</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在 template 结构中使用自定义指令时，可以通过等号 <strong>=</strong> 的方式，为当前指令动态绑定参数值</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">v-color</span>=<span class="hljs-string">&quot;color&quot;</span>&gt;</span>内容<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>私有自定义指令</li><li>全局自定义指令</li></ul><h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>在每个 vue 组件中，可以在 <strong>directives</strong> 节点下声明私有自定义指令</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">directives: &#123;<br>  <span class="hljs-attr">color</span>: &#123;<br>    bind (el) &#123;<br>      el.style.color = <span class="hljs-string">&#x27;pink&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>全局共享的自定义指令通过 <strong>Vue.directive()</strong> 进行声明</p><p>接受两个参数，第一个为 指令的ID（即名字），第二个是一个定义对象或者函数对象，指令要实现的功能在这个对象中定义</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.directive(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>一般使用自定义指令，都会定义在 全局上</p></blockquote><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li><strong>bind</strong>：只调用一次，当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。 </li><li>inserted：被绑定元素插入父节点时调用</li><li><strong>update</strong>：所在的组件的 VNode 更新时调用（无论指令的值是否发生了变化），但可能发生在子 VNode 更新之前</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li><li>unbind：只调用一次，指令与元素解绑时调用</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol><li><strong>el</strong> ：指令所绑定的元素，可以用来直接操作 DOM</li><li><strong>binding</strong> ：一个对象，包含以下属性：<ul><li>name：指令名，不包含 v- 前缀</li><li><strong>value</strong>：指令的绑定值，如果是表达式则 value 的值是最后的结果</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子函数中可用</li><li>expression：字符串形式的指令表达式，与 value 不同</li><li>arg：传给指令的参数，可选</li><li>modifiers：一个包含修饰符的对象</li></ul></li><li>vnode ：Vue 编译生成的虚拟节点</li><li>oldVnode ：上一个虚拟节点，仅在 update 和 componentUpdated 钩子函数中可用</li></ol><blockquote><p>除 el 参数以外，其他参数都是只读的，不可进行修改</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">directives: &#123;<br>  <span class="hljs-attr">color</span>: &#123;<br>    bind (el, binding) &#123;<br>      el.style.color = binding.value<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：第二个参数中的 expression 值代表用户在 自定义指令后面输入的内容或表达式，而 value 才是可以获取到使用的值</p></blockquote><h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p>如果 bind 和 update 函数中的逻辑完全相同，且只需要用到这两个钩子函数，则对象格式的自定义指令可以简写成函数格式：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">directives: &#123;<br>  color (el, binding) &#123;<br>    el.style.color = binding.value<br>  &#125;<br>&#125;<br>Vue.directive(<span class="hljs-string">&#x27;font-weight&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">el, binding</span>) </span>&#123;<br>  el.style.fontWeight = binding.value<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="watch-监听器"><a href="#watch-监听器" class="headerlink" title="watch 监听器"></a>watch 监听器</h2><p>在 Vue 实例的选项对象的 <strong>watch</strong> 选项中定义</p><p>当需要在数据变化时执行异步或开销较大的操作时，使用监听器是最合适的</p><h3 id="方法格式的监听器"><a href="#方法格式的监听器" class="headerlink" title="方法格式的监听器"></a>方法格式的监听器</h3><p>缺点：</p><ol><li>无法在刚进到页面的时候自动触发</li><li>如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发监听器</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123; <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;&#x27;</span> &#125;,<br> <span class="hljs-comment">// 所有的侦听器都应该被定义到 watch 节点下</span><br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-comment">// 侦听器本质上是一个函数，要监视哪个数据的变化，就把数据名作为方法名即可</span><br>    <span class="hljs-function"><span class="hljs-title">username</span>(<span class="hljs-params">newVal, oldVal</span>)</span> &#123;<br>      <span class="hljs-comment">// ...</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>如果要侦听的是对象的子属性：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">watch: &#123;<br>  <span class="hljs-comment">// 如果要侦听的是对象的子属性，则必须包裹一层单引号</span><br>  <span class="hljs-string">&#x27;info.username&#x27;</span> (newVal) &#123;<br>    <span class="hljs-built_in">console</span>.log(newVal)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>优先考虑使用方法格式的，如若满足不了需求再改用对象格式的</p></blockquote><h3 id="对象格式的监听器"><a href="#对象格式的监听器" class="headerlink" title="对象格式的监听器"></a>对象格式的监听器</h3><p>好处：</p><ol><li>可以通过 <strong>immediate</strong> 选项控制自动触发一次</li><li>可以通过 <strong>deep</strong> 选项控制开启深度侦听，可以侦听到对象中子属性的变化</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">info</span>: &#123;<br>      <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">watch</span>: &#123;<br>    <span class="hljs-comment">// 定义对象格式的侦听器</span><br>    <span class="hljs-attr">info</span>: &#123;<br>      handler (newVal, oldVal) &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;,<br>      <span class="hljs-comment">// immediate 选项的默认值是 false</span><br>      <span class="hljs-comment">// 作用是：控制侦听器是否自动触发一次</span><br>      <span class="hljs-attr">immediate</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-comment">// deep 作用是：开启深度侦听</span><br>      <span class="hljs-attr">deep</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h2><p>表达式的逻辑过于复杂时，都应当考虑使用计算属性</p><p>计算属性指的是通过一系列运算之后，最终得到一个属性值，这个动态计算出来的属性值可以被 模板结构 或 methods 方法使用</p><h3 id="定义使用"><a href="#定义使用" class="headerlink" title="定义使用"></a>定义使用</h3><ul><li>要定义在 computed 节点之下，与 data 同级</li><li>计算属性在定义时要定义成“方法格式”</li><li>return 的值就是计算结果</li><li>使用时与使用 data 中属性值一样</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">computed</span>: &#123;<br>    rgb () &#123; <span class="hljs-keyword">return</span> <span class="hljs-string">`rgb(<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.r&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.g&#125;</span>, <span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.b&#125;</span>)`</span> &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a>计算属性缓存</h3><p>计算属性是基于它的响应式依赖进行缓存的，只有在计算属性的相关响应式依赖发生改变时才会重新求值</p><h3 id="v-if-和-v-for-一起使用的替代方案"><a href="#v-if-和-v-for-一起使用的替代方案" class="headerlink" title="v-if 和 v-for 一起使用的替代方案"></a>v-if 和 v-for 一起使用的替代方案</h3><p>采用计算属性过滤后再遍历，好处：</p><ul><li>过滤后只会在要循环的数据发生变化时才被重新计算，过滤更高效</li><li>渲染只会遍历符合计算属性中条件的，渲染更高效</li><li>解耦渲染层的逻辑，可维护性（<strong>对逻辑的更改和扩展</strong>）更强</li></ul><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote><p>axios 是一个专注于网络请求的库！</p></blockquote><p>axios（发音：艾克C奥斯）是前端圈最火的库。</p><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><ol><li>调用 axios 之后，使用 async / await 进行简化</li><li>使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来</li><li>把解构出来的 data 属性，使用 : 进行重命名，一般都重命名为 <code>&#123; data: res&#125;</code> </li></ol><p>调用 axios 方法的返回值是一个 Promise 对象：</p><blockquote><p>axios 在请求到接口数据之后，在真正的数据之外，套了一层壳</p></blockquote><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  config: &#123;&#125;,<br>  data: &#123;&#x27;真正的接口数据&#x27;&#125;,<br>  headers: &#123;&#125;,<br>  request: &#123;&#125;,<br>  status: xxx,<br>  statusText: &#x27;&#x27;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="发起-GET-请求"><a href="#发起-GET-请求" class="headerlink" title="发起 GET 请求"></a>发起 GET 请求</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios(&#123;<br>  <span class="hljs-comment">// 请求方式</span><br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>  <span class="hljs-comment">// 请求的地址</span><br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-comment">// URL 中的查询参数</span><br>  <span class="hljs-attr">params</span>: &#123;<br>    <span class="hljs-attr">id</span>: <span class="hljs-number">1</span><br>  &#125;<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>也可以使用 <strong>axios.get</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios.get(<span class="hljs-string">&#x27;url地址&#x27;</span>, &#123;<br>  <span class="hljs-comment">// GET参数</span><br>  <span class="hljs-attr">params</span>: &#123;&#125; <br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="发起-POST-请求"><a href="#发起-POST-请求" class="headerlink" title="发起 POST 请求"></a>发起 POST 请求</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios(&#123;<br>  <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>  <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>  <span class="hljs-comment">// 请求体</span><br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;agoni&#x27;</span><br>  &#125;<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(res)<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>也可以使用 <strong>axios.post</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios.post(<span class="hljs-string">&#x27;url&#x27;</span>, &#123; <span class="hljs-comment">/* POST请求体数据 */</span> &#125;)<br></code></pre></div></td></tr></table></figure><h4 id="await-和-async"><a href="#await-和-async" class="headerlink" title="await 和 async"></a>await 和 async</h4><ul><li>如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await</li><li>await 只能用在被 async 修饰的方法中</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span>,<br>    <span class="hljs-attr">data</span>: &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;agoni&#x27;</span><br>    &#125;<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.log(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h4><blockquote><p>解构赋值的时候可以使用 : 进行重命名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: res &#125; = <span class="hljs-keyword">await</span> axios(&#123;<br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;&#x27;</span><br>  &#125;)<br>  <span class="hljs-built_in">console</span>.log(res.data)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="使用优化"><a href="#使用优化" class="headerlink" title="使用优化"></a>使用优化</h3><h4 id="挂载在-Vue-原型"><a href="#挂载在-Vue-原型" class="headerlink" title="挂载在 Vue 原型"></a>挂载在 Vue 原型</h4><p>使用 axios 需要各页面导入 axios 才可使用，比较麻烦</p><p>可以将 axios 挂载在 Vue 的原型上：</p><ol><li><p>在 main.js 中导入 axios</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios</span><br></code></pre></div></td></tr></table></figure></li><li><p>配置请求根路径</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios.defaults.baseURL = <span class="hljs-string">&#x27;请求根路径&#x27;</span><br></code></pre></div></td></tr></table></figure></li><li><p>把 axios 挂载到 Vue.prototype 原型上</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.prototype.$http = axios<br></code></pre></div></td></tr></table></figure><blockquote><p>一般命名为 $http，今后在每个 .vue 组件中要发起请求，直接调用 this.$http 接口即可</p></blockquote></li></ol><p>缺点：</p><ul><li>不利于 api 接口的复用，所以一般不使用，了解即可</li></ul><h4 id="增强复用"><a href="#增强复用" class="headerlink" title="增强复用 *"></a>增强复用 *</h4><p>util/request.js：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;axios&#x27;</span><br><br><span class="hljs-keyword">const</span> request = axios.create(&#123;<br>  <span class="hljs-comment">// 指定请求的根路径</span><br>  <span class="hljs-attr">baseURL</span>: <span class="hljs-string">&#x27;https://www.escook.cn&#x27;</span><br>&#125;)<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> request<br></code></pre></div></td></tr></table></figure><p>api/articleAPI.js：</p><blockquote><p>一般以 API 命名结尾</p></blockquote><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 文章相关的 API 接口</span><br><span class="hljs-keyword">import</span> request <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/utils/request.js&#x27;</span><br><br><span class="hljs-comment">// 向外按需导出一个 API 函数</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> getArticleListAPI = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_page, _limit</span>) </span>&#123;<br><span class="hljs-keyword">return</span> request.get(<span class="hljs-string">&#x27;/articles&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;<br>      _page,<br>      _limit<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>Home.vue：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 按需导入 API 接口</span><br><span class="hljs-keyword">import</span> &#123; getArticleListAPI &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/api/articleAPI.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">// 页码值</span><br>      <span class="hljs-attr">page</span>: <span class="hljs-number">1</span>,<br>      <span class="hljs-comment">// 每页显示多少条数据</span><br>      <span class="hljs-attr">limit</span>: <span class="hljs-number">8</span>,<br>      <span class="hljs-comment">// 文章列表数组</span><br>      <span class="hljs-attr">articleList</span>: []<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    <span class="hljs-comment">// 封装获取文章列表数据的方法</span><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">initArticleLsit</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">const</span> &#123; <span class="hljs-attr">data</span>: res &#125; = <span class="hljs-keyword">await</span> getArticleLsitAPI(<span class="hljs-built_in">this</span>.page, <span class="hljs-built_in">this</span>.limit)<br>      <span class="hljs-built_in">this</span>.articleList = res<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">create</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.initArticleLsit()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h2 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h2><p>单页面应用程序（Single Page Application）简称 SPA，指一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能和交互都在这唯一的一个页面完成</p><p>优点：</p><ol><li>前后端分离</li><li>良好的用户体验</li><li>减轻服务器压力</li><li>共用一套后端程序代码</li></ol><p>缺点：</p><ol><li>初次加载消耗多</li><li>前进后退有一定问题</li><li>SEO 难度较高</li></ol><h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><p>vue-cli 是 Vue.js 开发的标准工具。简化了程序员基于 webpack 创建工程化的 Vue 项目的工程</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>安装 3.x 版本的 Vue 脚手架：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install -g @vue/cli<br></code></pre></div></td></tr></table></figure><p>检查安装</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">vue -V <span class="hljs-comment">// 检查是否安装 及 版本号</span><br></code></pre></div></td></tr></table></figure><p>看到 显示 <code>@vue/cli 版本号</code> 即为安装成功</p><h3 id="创建-Vue-项目"><a href="#创建-Vue-项目" class="headerlink" title="创建 Vue 项目"></a>创建 Vue 项目</h3><ol><li><p>基于 <strong>交互式命令行</strong> 的方式，创建 新版 vue 项目</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">vue create my-project<br></code></pre></div></td></tr></table></figure><p>一般选择最后一项创建自定义</p></li><li><p>基于 <strong>图形化界面</strong> 的方式，创建 新版 vue 项目</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">vue ui<br></code></pre></div></td></tr></table></figure></li><li><p>基于 2.x 的旧模板 ，创建 旧版 vue 项目（了解）</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install -g @vue/cli-init<br>vue init webpack my-project<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><h4 id="public-文件夹"><a href="#public-文件夹" class="headerlink" title="public 文件夹"></a>public 文件夹</h4><h5 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h5><p>index.html 为项目主页面</p><p>其中 一行注释，表示生成脚本文件的将自动注入这个位置</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- built files will be auto injected --&gt;</span><br></code></pre></div></td></tr></table></figure><p>id 属性为 app 的 div 之后将会被替换掉</p><blockquote><p>不要改动 inde.html 中的内容</p></blockquote><h5 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h5><p>网页的图标</p><h4 id="src-文件夹"><a href="#src-文件夹" class="headerlink" title="src 文件夹"></a>src 文件夹</h4><figure class="highlight stylus"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs stylus">assets 文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源<br>components 文件夹：存放程序员封装的、可复用的组件<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span> 是项目的入口文件。整个项目的运行，要先执行 <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.js</span><br>App<span class="hljs-selector-class">.vue</span> 是项目的根组件<br></code></pre></div></td></tr></table></figure><h5 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h5><p>将 main.js 中 render 函数指定的结构替换掉 index.html 中指定的 el区域 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 导入 vue 这个包，得到 vue 构造函数</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-comment">// 导入 App.vue 根组件，将来要把 App.vue 中的模板结构，渲染到 HTML 页面中</span><br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App.vue&#x27;</span><br><br><span class="hljs-comment">// false 是开发模式，true 是发布模式</span><br><span class="hljs-comment">// 默认为 true</span><br>Vue.config.productionTip = <span class="hljs-literal">false</span><br><br><span class="hljs-comment">// 创建 Vue 的 实例对象</span><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-comment">// el: &#x27;#app&#x27;,  // 这个和 $mount 二选一使用即可</span><br>  <span class="hljs-comment">// 把 render 函数指定的组件，渲染到 HTML 页面中</span><br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></div></td></tr></table></figure><blockquote><p>Vue 实例的 $mount() 方法，作用和 el 属性完全一样！</p></blockquote><h5 id="components-amp-views"><a href="#components-amp-views" class="headerlink" title="components &amp; views"></a>components &amp; views</h5><p>两个文件夹都是放组件的，区别在于：</p><ul><li>components 文件夹用来放各页面复用的组件</li><li>views 文件夹用来放 <strong>使用路由切换</strong> 的组件</li></ul><h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><blockquote><p>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中</p></blockquote><ol><li>App.vue 用来编写待渲染的模板结构</li><li>index.html 中需要预留一个 el 区域</li><li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ol><h2 id="component-组件"><a href="#component-组件" class="headerlink" title="component 组件"></a>component 组件</h2><p>组件 – 对 UI 结构的复用</p><p>组件化开发 – 根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><ul><li>template -&gt; 组件的模板结构</li><li>script       -&gt; 业务逻辑区域，组件的 JavaScript 行为</li><li>style         -&gt; 样式区域</li></ul><p>语法结构</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>&lt;!-- 这里用来定义 Vue 组件的 模板内容 --&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  // 这里用来定义 Vue 组件的 业务逻辑<br>  // 默认导出，这是固定写法！<br>  export default &#123;<br>    data: () &#123; return &#123;&#125; &#125;, // 私有数据<br>   method: &#123;&#125; // 处理函数<br>  // ... 其他业务逻辑<br>  &#125;<br>&lt;/script&gt;<br><br>&lt;style lang=&quot;&quot;&gt;<br>  /* 这里用于定义Vue组件的样式 */<br>&lt;/style&gt;<br></code></pre></div></td></tr></table></figure><ul><li>.vue 组件中的 data 不能像之前一样，不能指向对象，<strong>组件中的对象必须是一个函数</strong> </li><li>在组件中，this 表示当前组件的实例对象</li><li>style 中 加 lang 属性可以使用指定语法编写样式，例： <code>&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code> </li></ul><h3 id="使用组件的步骤"><a href="#使用组件的步骤" class="headerlink" title="使用组件的步骤"></a>使用组件的步骤</h3><h4 id="1-import-导入"><a href="#1-import-导入" class="headerlink" title="1. import 导入"></a>1. import 导入</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Left <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Left.vue&#x27;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>在 vue 中 @ 默认指向 src 根目录</p></blockquote><blockquote><p>vscode 中 @ 路径提示插件：Path Intellisense</p><p>使用步骤：</p><ol><li><p>在插件中搜索 Path Intellisense 安装并启用</p></li><li><p>在 vscode 设置文件 settings.json 中添加设置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// 导入文件时是否携带文件的扩展名</span><br>  <span class="hljs-attr">&quot;path-autocomplete.extensionOnImport&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-comment">// 配置 @ 的路径显示</span><br>  <span class="hljs-attr">&quot;path-autocomplete.pathMappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;@&quot;</span>: <span class="hljs-string">&quot;$&#123;folder&#125;/src&quot;</span><br>  &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><p>注意点：要在 vue 中使用此插件，则必须保证 vscode 中打开的就是这个项目</p></blockquote><h4 id="2-注册组件"><a href="#2-注册组件" class="headerlink" title="2. 注册组件"></a>2. 注册组件</h4><p>使用 <strong>components</strong> 节点注册的是 私有子组件，只有本界面能用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">components</span>: &#123;<br>    Left<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><p>通过 <strong>Vue.component()</strong> 方法，注册全局组件</p><p>接受两个参数，第一个为组件的名字，第二个是一个函数对象（使用 Vue.extend() 方法创建的组件构造器），也可以是一个选项对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;Left&#x27;</span>, Left)<br>Vue.component(<span class="hljs-string">&#x27;name&#x27;</span>, [definition])<br></code></pre></div></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Vue.component(<span class="hljs-string">&#x27;ButtonCounter&#x27;</span>, &#123;<br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p><strong>Vue.extend()</strong> 方法接受一个参数，包含组件选项的对象，也就是 Vue.component() 方法中要接受的第二个参数格式，会生成一个<strong>组件构造器</strong> </p><h4 id="3-以标签形式使用"><a href="#3-以标签形式使用" class="headerlink" title="3. 以标签形式使用"></a>3. 以标签形式使用</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">Left</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Left</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>vscode 自动闭合标签插件：Auto Close Tag，不需要配置。</p></blockquote><h3 id="prop-props"><a href="#prop-props" class="headerlink" title="prop - props"></a>prop - props</h3><p>props 是组件的自定义属性</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">zujian</span> <span class="hljs-attr">:init</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-comment">// props 是&quot;自定义属性&quot;，允许使用者通过自定义属性，为当前组件指定初始值</span><br>  <span class="hljs-comment">// 自定义属性的名字，是封装者自定义的（只要名称合法即可）</span><br>  <span class="hljs-comment">// props 中的数据，可以直接在模板结构中被使用</span><br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;属性值1&#x27;</span>, <span class="hljs-string">&#x27;属性值2&#x27;</span>, ...]<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h4><p>props 是<strong>只读的</strong>，不能直接修改 props 的值，否则终端会报错！</p><p>要想修改 props 的值，可以</p><ol><li>把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的</li><li>如果接受数据后需要转换后使用，可以使用计算属性解决</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;init&#x27;</span>],<br>  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-comment">// 把 props 中的 init 值，转存到 count 上</span><br>      <span class="hljs-attr">count</span>: <span class="hljs-built_in">this</span>.init<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="prop-验证"><a href="#prop-验证" class="headerlink" title="prop 验证"></a>prop 验证</h4><p>可以使用 type default required 属性添加验证，或者也可以自定义验证函数</p><h5 id="type-值类型"><a href="#type-值类型" class="headerlink" title="type 值类型"></a>type 值类型</h5><p>在声明自定义属性时，可以通过 <strong>type</strong> 来定义属性的值类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">init</span>: &#123;<br>      <span class="hljs-comment">// 表示 init 的值类型必须是 Number 数字</span><br>      <span class="hljs-attr">type</span>: <span class="hljs-built_in">Number</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>仅判断类型：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">init</span>: <span class="hljs-built_in">Number</span>,<br>    <span class="hljs-comment">// 多种可能的类型</span><br>    <span class="hljs-attr">tel</span>: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>]<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注意：null 和 undefined 会通过任何类型验证</p></blockquote><p>验证的 type 可以是右侧的原生构造函数：String、Number、Boolean、Array、Object、Date、Function、Symbol</p><p>也可以是一个自定义的构造函数</p><h5 id="default-默认值"><a href="#default-默认值" class="headerlink" title="default 默认值"></a>default 默认值</h5><p>在声明自定义属性时，可以通过 <strong>default</strong> 来定义属性的默认值</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-comment">// 自定义属性A: &#123; /* 配置选项 */ &#125;</span><br>    <span class="hljs-attr">init</span>: &#123;<br>      <span class="hljs-comment">// 如果外界使用 Count 组件的时候，没有传递 init 属性，则默认值生效</span><br>      <span class="hljs-attr">default</span>: <span class="hljs-number">0</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="required-必填项"><a href="#required-必填项" class="headerlink" title="required 必填项"></a>required 必填项</h5><p>在声明自定义属性时，可以通过 <strong>required</strong> 选项，将属性设置为必填项，强制用户必须传递属性的值</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">init</span>: &#123;<br>      <span class="hljs-comment">// 必填项校验</span><br>      <span class="hljs-attr">required</span>: <span class="hljs-literal">true</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="非-prop-属性"><a href="#非-prop-属性" class="headerlink" title="非 prop 属性"></a>非 prop 属性</h4><p>在组件中定义的非 prop 属性：</p><ul><li>class 和 type 会合并</li><li>其他属性都是从外部提供给组件的值会替换掉组件内部设置好的值</li></ul><blockquote><p>如果不希望组件的根元素继承外部设置的属性，可以在组件的选项中设置： inheritAttrs: false</p></blockquote><h3 id="组件之间的样式冲突问题"><a href="#组件之间的样式冲突问题" class="headerlink" title="组件之间的样式冲突问题"></a>组件之间的样式冲突问题</h3><p>默认情况下，写在 .vue 组件中的样式会<strong>全局生效</strong>，因此很容易造成多个组件之间的样式冲突问题</p><p>导致组件之间样式冲突的根本原因是：</p><ol><li>单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的</li><li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li></ol><h4 id="scoped-解决"><a href="#scoped-解决" class="headerlink" title="scoped 解决"></a>scoped 解决</h4><p>为了提高开发效率和开发体验，vue 为 style 节点提供了 <strong>scoped</strong> 属性，从而防止组件之间的样式冲突问题</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;less&quot;</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-comment">/* 样式 */</span></span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>原理：</p><ol><li>每个组件中的元素有特定的唯一的 data-v-xxx 属性</li><li>每个组件中的样式后面均跟上 <strong>属性选择器</strong> <code>[]</code> 即可</li></ol><h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="/deep/ 样式穿透"></a>/deep/ 样式穿透</h4><p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的</p><p>如果想让某些样式对子组件生效，可以使用 <strong>/deep/</strong> 深度选择器</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  /deep/ <span class="hljs-selector-class">.title</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">color</span>: pink;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>原理：</p><ul><li>不加 /deep/ 时，生成的选择器格式为 <code>.title[data-v-xxx]</code> </li><li>加上 /deep/ 时，生成的选择器格式为 <code>[data-v-xxx] .title</code>  </li></ul><blockquote><p>注：当使用第三方组件库时，如果有修改组件默认样式的需求，需要用到 /deep/</p></blockquote><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="生命周期-amp-生命周期函数"><a href="#生命周期-amp-生命周期函数" class="headerlink" title="生命周期 &amp; 生命周期函数"></a>生命周期 &amp; 生命周期函数</h4><p>生命周期（Life Cycle）是指一个组件从 创建 -&gt; 运行 -&gt; 销毁 的整个阶段，强调的是一个时间段</p><p>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行</p><blockquote><p>注意：生命周期强调的是时间段，生命周期函数强调的是时间点</p></blockquote><h4 id="组件生命周期函数的分类"><a href="#组件生命周期函数的分类" class="headerlink" title="组件生命周期函数的分类"></a>组件生命周期函数的分类</h4><p>new Vue() -&gt;</p><p>组件创建阶段：beforeCreate -&gt; <strong>created</strong> -&gt; beforeMount -&gt; <strong>mounted</strong> -&gt;</p><p>组件运行阶段：beforeUpdate -&gt; <strong>updated</strong> -&gt;</p><p>组件销毁阶段：beforeDestory -&gt; destoryed</p><ul><li>created 生命周期函数非常常用，经常在其中调用方法请求服务器的数据</li><li>mounted：其中经常操作 DOM 元素，做大部分操作</li></ul><blockquote><p><a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a> 生命周期图示</p></blockquote><img src="/2021/08/14/vue%E7%AC%94%E8%AE%B0/lifesycle.png" class title="lifesycle"><h3 id="组件间的数据共享"><a href="#组件间的数据共享" class="headerlink" title="组件间的数据共享"></a>组件间的数据共享</h3><h4 id="组件间的关系"><a href="#组件间的关系" class="headerlink" title="组件间的关系"></a>组件间的关系</h4><blockquote><p>组件在被分装好之后，彼此之间是相互独立的，不存在关系</p></blockquote><p>在使用组件时，根据彼此的嵌套关系，形成了 父子关系、兄弟关系</p><h4 id="父子组件间数据共享"><a href="#父子组件间数据共享" class="headerlink" title="父子组件间数据共享"></a>父子组件间数据共享</h4><h5 id="父向子共享数据"><a href="#父向子共享数据" class="headerlink" title="父向子共享数据"></a>父向子共享数据</h5><p>父组件向子组件共享数据需要使用<strong>自定义属性</strong> </p><ul><li>父组件中使用 v-bind: 传递数据</li><li>子组件中通过 props 接收数据</li></ul><h5 id="子向父共享数据"><a href="#子向父共享数据" class="headerlink" title="子向父共享数据"></a>子向父共享数据</h5><p>子组件向父组件共享数据使用<strong>自定义事件</strong> </p><p>子组件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>data () &#123;<br>    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    add () &#123;<br>      <span class="hljs-built_in">this</span>.count ++<br>      <span class="hljs-comment">// 修改数据时，通过 $emit() 触发自定义事件</span><br>      <span class="hljs-built_in">this</span>.$emit(<span class="hljs-string">&#x27;numchange&#x27;</span>, <span class="hljs-built_in">this</span>.count)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Son</span> @<span class="hljs-attr">numchange</span>=<span class="hljs-string">&quot;getNewCount&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Son</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">  data () &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">countFromSon</span>: <span class="hljs-number">0</span> &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">  <span class="hljs-attr">methods</span>: &#123;</span><br><span class="javascript">    getNewCount (val) &#123;</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.countFromSon = val</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript">&#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>@click 事件是由 this.$emit(‘click’, {…}) 触发的</p></blockquote><h4 id="兄弟组件间的数据共享"><a href="#兄弟组件间的数据共享" class="headerlink" title="兄弟组件间的数据共享"></a>兄弟组件间的数据共享</h4><p>在 vue2.x 中，兄弟组件之间数据共享的方案是 <strong>EventBus</strong> </p><p>使用步骤：</p><ol><li><p>创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><br><span class="hljs-comment">// 向外共享 Vue 的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">new</span> Vue()<br></code></pre></div></td></tr></table></figure></li><li><p>在数据发送方，调用 <code>bus.$emit(&#39;事件名称&#39;, 要发送的数据)</code> 方法触发<strong>自定义事件</strong> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;hello vue.js&#x27;</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">methods</span>: &#123;<br>    sendMsg () &#123;<br>      bus.$emit(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-built_in">this</span>.msg)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在数据接收方，在 <strong>created</strong> 生命周期函数中调用 <code>bus.$on(&#39;事件名称&#39;, 事件处理函数)</code> 方法注册一个自定义事件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> bus <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./eventBus.js&#x27;</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">msgFromLeft</span>: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;,<br>  created () &#123;<br>    bus.$on(<span class="hljs-string">&#x27;share&#x27;</span>, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">this</span>.msgFromLeft = val<br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件指的是动态切换组件的显示与隐藏</p><h4 id="动态组件渲染"><a href="#动态组件渲染" class="headerlink" title="动态组件渲染"></a>动态组件渲染</h4><p>vue 提供了一个内置的 <strong><component></component></strong> 组件标签，专门用来实现动态组件的渲染</p><ol><li>component 标签是 vue 内置的，作用：组件的占位符</li><li>is 属性的值，表示要渲染的组件的名字，可以动态绑定</li><li>is 属性的值，应该是组件在 components 节点下的注册名称</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 渲染 Left 组件和 Right 组件 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;comName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> Left <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Left.vue&#x27;</span></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    data () &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-comment">// 表示要展示的组件的名字</span></span><br><span class="javascript">        <span class="hljs-attr">comName</span>: <span class="hljs-string">&#x27;Left&#x27;</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">      Left</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>默认情况下，切换动态组件时无法保持组件的状态。此时可以使用 vue 内置的 <strong><keep-alive></keep-alive></strong> 组件保持动态组 件的状态</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;xxx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br>  <br>  <br>  <br>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>当组件被缓存时，会自动触发组件的 <strong>deactivated</strong> 生命周期函数</li><li>当组件被激活时，会自动触发组件的 <strong>activated</strong> 生命周期函数</li><li>只有当组件第一次被创建时，才会触发 <strong>created</strong> 生命周期函数</li></ul><h5 id="include-amp-exclude-属性"><a href="#include-amp-exclude-属性" class="headerlink" title="include &amp; exclude 属性"></a>include &amp; exclude 属性</h5><blockquote><p>默认 keep-alive 所包含的所有组件均会被缓存！</p></blockquote><p>include 用来指定：只有名称匹配的组件会被缓存。</p><p>多个组件名之间使用 <code>,</code> 分隔</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span> <span class="hljs-attr">include</span>=<span class="hljs-string">&quot;Left, Right&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">keep-alive</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>另外还有作用相反的 exclude 属性：表示排除</p><p>注意：include 和 exclude 不可以同时使用</p><h4 id="组件的-name-属性-扩展"><a href="#组件的-name-属性-扩展" class="headerlink" title="组件的 name 属性(扩展)"></a>组件的 name 属性(扩展)</h4><p>当给组件定义了 name 属性之后，组件的名称就是 name 属性的值</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;MyLeft&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>则在 include 和 exclude 中使用 components 节点中注册的名称无效，需使用 name 属性值</li><li>在调试工具中看到的也会是 name 属性值</li><li>建议开发中给所有组件定义一个专属名称，即 name 属性值</li></ul><h2 id="ref-引用"><a href="#ref-引用" class="headerlink" title="ref 引用"></a>ref 引用</h2><p>ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用</p><blockquote><p><strong>ref 属性起名推荐使用 xxxRef 格式</strong> </p></blockquote><h3 id="使用-ref-引用-DOM-元素"><a href="#使用-ref-引用-DOM-元素" class="headerlink" title="使用 ref 引用 DOM 元素"></a>使用 ref 引用 DOM 元素</h3><p>每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下， 组件的 $refs 指向一个空对象</p><p>步骤：</p><ol><li>给需要获取的 DOM 元素设置 ref 属性，一个组件内 ref 不可以重复</li><li>通过 <code>this.$refs.对应ref值</code> 获取对应 DOM 元素</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h3</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;myh3&quot;</span>&gt;</span>MyRef 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getRef&quot;</span>&gt;</span>获取 $refs 引用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-attr">method</span>: &#123;</span><br><span class="javascript">    getRef () &#123;</span><br><span class="javascript">      <span class="hljs-comment">// 通过 this.$refs 访问</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$refs.myh3.style.color = <span class="hljs-string">&#x27;red&#x27;</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="使用-ref-引用组件实例"><a href="#使用-ref-引用组件实例" class="headerlink" title="使用 ref 引用组件实例"></a>使用 ref 引用组件实例</h3><p>步骤：</p><ol><li>给相应组件设置 ref 属性</li><li>通过 <code>this.$refs.组件对应ref值</code> 获取引用组件的实例</li><li>即可调用组件中的数据及方法</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">my-counter</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;counterRef&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">my-counter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;getRef&quot;</span>&gt;</span>获取 $refs 引用<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-attr">method</span>: &#123;</span><br><span class="javascript">    getRef () &#123;</span><br><span class="javascript">      <span class="hljs-comment">// 通过 this.$refs.引用的名称 可以引用组件的实例</span></span><br><span class="javascript">      <span class="hljs-comment">// 引用到组件的实例之后，就可以调用组件上的 数据 和 methods 方法</span></span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$refs.counterRef.add()</span><br><span class="javascript">      <span class="hljs-built_in">this</span>.$refs.counterRef.count = <span class="hljs-number">0</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="this-nextTick-cb-延迟执行"><a href="#this-nextTick-cb-延迟执行" class="headerlink" title="this.$nextTick(cb) 延迟执行"></a>this.$nextTick(cb) 延迟执行</h3><p>组件的 <strong>$nextTick(cb)</strong> 方法，会把 cb 回调推迟到<strong>下一个 DOM 更新周期之后</strong>执行</p><p>通俗的理解是：<strong>等组件的 DOM 更新完成之后，再执行 cb 回调函数</strong>。从而能保证 cb 回调函数可以操作到最新的 DOM 元素</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;inputRef&quot;</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;!inputVisible&quot;</span> @<span class="hljs-attr">blur</span>=<span class="hljs-string">&quot;inputVisible = true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-else</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;showInput&quot;</span>&gt;</span>展示 input<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">    <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">      <span class="hljs-attr">inputVisible</span>: <span class="hljs-literal">true</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;,</span><br><span class="javascript">    <span class="hljs-attr">method</span>: &#123;</span><br><span class="javascript">      showInput () &#123;</span><br><span class="javascript">        <span class="hljs-built_in">this</span>.inputVisible = <span class="hljs-literal">false</span></span><br><span class="javascript">        <span class="hljs-built_in">this</span>.$nextTick(<span class="hljs-function">() =&gt;</span> &#123;</span><br><span class="javascript">          <span class="hljs-built_in">this</span>.$refs.inputRef.focus()</span><br><span class="javascript">        &#125;)</span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h2><h3 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h3><p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽</p><p>可以把插槽认为是组件封装期间，为用户预留的内容的占位符</p><h3 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h3><p>在封装组件时，可以通过 <strong><slot></slot></strong> 元素定义插槽，从而为用户预留内容占位符</p><p>Left.vue</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Left 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 声明一个插槽区域 --&gt;</span><br>    <span class="hljs-comment">&lt;!-- vue 官方规定：每一个 slot 插槽，都要有一个 name 名称 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Left</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>用户自定义的内容，会在 slot 区域展示<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Left</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>如果在封装组件时没有预留任何 slot 插槽，则用户提供的任何自定义内容都会被丢弃</p></li><li><p>封装组件时，可以为预留的 slot 插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;default&quot;</span>&gt;</span><br>  后备内容<br><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>如果在封装组件时需要预留多个插槽节点，则需要为每个 slot 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”</p><blockquote><p>注意：没有指定 name 名称的插槽， 会有隐含的名称叫做 “default”</p></blockquote><p>在向具名插槽提供内容的时候，我们可以在一个 template 元素上使用 <strong>v-slot:</strong> 指令，并以 v-slot 的参数的形式提供其名称</p><ul><li>v-slot: 指令不能直接用用在元素身上，必须用在 template 标签上</li><li>template 这个标签，它是一个虚拟的标签，只起到包裹性质的作用，但是，不会被渲染为任何实质性的 HTML 元素</li><li>简写：把参数之前的所有内容 (v-slot:) 替换为字符 <code>#</code> </li></ul><h3 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h3><p>在封装组件的过程中，可以为预留的 slot 插槽绑定 props 数据，这种带有 props 数据的 slot 叫做“<strong>作用域插槽</strong>”</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;content&quot;</span> <span class="hljs-attr">msg</span>=<span class="hljs-string">&quot;hello AgoniLay&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p><strong>接收</strong>作用域插槽对外提供的数据:</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">content</span>=<span class="hljs-string">&quot;scope&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; scope.msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>作用域插槽对外提供的数据对象，可以使用<strong>解构赋值</strong>简化数据的接收过程</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span> #<span class="hljs-attr">content</span>=<span class="hljs-string">&quot;&#123; msg &#125;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>&#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h2 id="router-路由"><a href="#router-路由" class="headerlink" title="router 路由"></a>router 路由</h2><p>路由（router）就是对应关系</p><p>前端路由就是指：Hash 地址 与 组件 之间的对应关系</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123; path: &#x27;#/home&#x27;, component: Home &#125;,<br></code></pre></div></td></tr></table></figure><blockquote><p>Hash 地址也就是 锚链接，location.hash 获取地址栏 Hash 地址</p></blockquote><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ol><li>用户点击了页面上的路由链接</li><li>导致了 URL 地址栏中的 Hash 值发生了变化</li><li>前端路由监听了到 Hash 地址的变化</li><li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li></ol><h3 id="实现简单的前端路由"><a href="#实现简单的前端路由" class="headerlink" title="实现简单的前端路由"></a>实现简单的前端路由</h3><p>步骤1：通过 component 标签，结合 comName 动态渲染组件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">component</span> <span class="hljs-attr">:is</span>=<span class="hljs-string">&quot;comName&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home.vue&#x27;</span></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-title">data</span>(<span class="hljs-params"></span>)</span> &#123;</span><br><span class="javascript">      <span class="hljs-keyword">return</span> &#123;</span><br><span class="javascript">        <span class="hljs-attr">comName</span>: <span class="hljs-string">&#x27;Home&#x27;</span></span><br><span class="javascript">      &#125;</span><br><span class="javascript">    &#125;,</span><br><span class="javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="javascript">      Home</span><br><span class="javascript">    &#125;</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>步骤2：在 App.vue 组件中，为 <a> 链接添加对应的 hash 值</a></p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/home&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/movie&quot;</span>&gt;</span>电影<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#/about&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>步骤3：在 created 生命周期函数中，通过 window.onhashchange 函数监听浏览器地址栏中 hash 地址的变化，通过 location.hash 获取到实时hash 地址，动态切换要展示的组件的名称</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-title">created</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">window</span>.onhashchange = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">switch</span> (location.hash) &#123;<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#/home&#x27;</span>:<br>        <span class="hljs-built_in">this</span>.comName = <span class="hljs-string">&#x27;home&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#/movie&#x27;</span>:<br>        <span class="hljs-built_in">this</span>.comName = <span class="hljs-string">&#x27;movie&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;#/about&#x27;</span>:<br>        <span class="hljs-built_in">this</span>.comName = <span class="hljs-string">&#x27;about&#x27;</span><br>        <span class="hljs-keyword">break</span><br>      <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h3><p>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换</p><blockquote><p>vue-router 的官方文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></blockquote><h4 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h4><p>步骤1：安装 vue-router 包</p><blockquote><p>在 vue2 的项目中，安装 vue-router 的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs powershell">npm i vue<span class="hljs-literal">-router</span>@<span class="hljs-number">3.5</span>.<span class="hljs-number">2</span> <span class="hljs-literal">-S</span><br></code></pre></div></td></tr></table></figure></blockquote><p>步骤2：创建路由模块</p><blockquote><p>在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 导入 Vue 和 VueRouter 的包</span><br><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-router&#x27;</span><br><br><span class="hljs-comment">// 2. 调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件</span><br><span class="hljs-comment">// vue.use() 的作用就是：安装插件</span><br>Vue.use(VueRouter)<br><br><span class="hljs-comment">// 3. 创建路由的实例对象</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter()<br><br><span class="hljs-comment">// 4. 向外共享路由的实例对象</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router<br></code></pre></div></td></tr></table></figure></blockquote><p>步骤3：导入并挂载路由模块</p><blockquote><p>在 src/main.js 入口文件中配置</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./router&#x27;</span><br><br><span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">render</span>: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App),<br>  router<br>&#125;).$mount(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></div></td></tr></table></figure></blockquote><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>在 src/App.vue 组件中，使用 vue-router 提供的 <strong>router-link</strong> 和 <strong>router-view</strong> 声明路由链接和占位符</p><blockquote><p>使用 router-link 代替普通的 a 链接，to 属性内写 hash 地址，不需要写 #</p></blockquote><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;app-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>App2 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 1. 定义路由链接 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/home&quot;</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/movie&quot;</span>&gt;</span>电影<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about&quot;</span>&gt;</span>关于<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 2. 定义路由的占位符 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>在 src/router/index.js 路由模块中，通过 <strong>routes</strong> 数组声明路由的匹配规则</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 导入需要使用路由切换展示的组件</span><br><span class="hljs-keyword">import</span> Home <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Home&#x27;</span><br><span class="hljs-keyword">import</span> Movie <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/Movie&#x27;</span><br><span class="hljs-keyword">import</span> About <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/About&#x27;</span><br><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">// 在 routes 数组中，声明路由的匹配规则</span><br>    <span class="hljs-comment">// path 表示要匹配的 hash 地址，component 表示要展示的路由组件</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: Home &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie&#x27;</span>, <span class="hljs-attr">component</span>: Movie &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>, <span class="hljs-attr">component</span>: About &#125;<br>  ]<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h4><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    <span class="hljs-comment">// 在 routes 数组中，声明路由的匹配规则</span><br>    <span class="hljs-comment">// 重定向的路由规则：当用户访问 / 时，通过 redirect 属性跳转到 &#x27;/home&#x27; 对应的路由规则</span><br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/home&#x27;</span> &#125;,<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/home&#x27;</span>, <span class="hljs-attr">component</span>: Home &#125;<br>    ...<br>  ]<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h4><p>通过路由实现组件的嵌套展示，叫做嵌套路由</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123;<br>      <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/about&#x27;</span>,<br>      <span class="hljs-attr">component</span>: About,<br>      <span class="hljs-comment">// 重定向，直接去找 tab1 显示</span><br>      <span class="hljs-attr">redirect</span>: <span class="hljs-string">&#x27;/about/tab1&#x27;</span>,<br>      <span class="hljs-comment">// 通过 children 属性，嵌套声明子级路由规则</span><br>      <span class="hljs-attr">children</span>: [<br>        <span class="hljs-comment">// 子级路由不加 /</span><br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab1&#x27;</span>, <span class="hljs-attr">component</span>: Tab1 &#125;,<br>        &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;tab2&#x27;</span>, <span class="hljs-attr">component</span>: Tab2 &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;)<br></code></pre></div></td></tr></table></figure><blockquote><p>如果 children 数组中，某个路由的 path 值为空字符串，则这条路由规则叫做 默认路由，进到 根路由 就会默认显示</p><p>重定向 和 默认子路由 根据需求随便使用一个均可</p></blockquote><p>在子组件中配置子路由链接和子路由占位符</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;about-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>About 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 子级路由链接 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/tab1&quot;</span>&gt;</span>tab1<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">to</span>=<span class="hljs-string">&quot;/about/tab2&quot;</span>&gt;</span>tab2<span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">hr</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 子级路由占位符 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。 </p><p>在 vue-router 中使用英文的冒号 <code>:</code> 来定义路由的参数项</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/:id&#x27;</span>, <span class="hljs-attr">component</span>: Movie &#125;<br></code></pre></div></td></tr></table></figure><h5 id="route-params-参数对象"><a href="#route-params-参数对象" class="headerlink" title="$route.params 参数对象"></a>$route.params 参数对象</h5><p>在动态路由渲染出来的组件中，可以使用 <strong>this.$route.params</strong> 对象访问到动态匹配的参数值</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;movie-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Movie&#123;&#123; $route.params.id &#125;&#125; 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>$route   是路由的 参数对象</p><p>$router 是路由的 导航对象</p></blockquote><h5 id="props-传参"><a href="#props-传参" class="headerlink" title="props 传参"></a>props 传参</h5><p>为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/movie/:id&#x27;</span>, <span class="hljs-attr">component</span>: Movie, <span class="hljs-attr">props</span>: <span class="hljs-literal">true</span> &#125;<br>  ]<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>在 组件 中通过 props 获取数据</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;movie-container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h3</span>&gt;</span>Movie&#123;&#123; id &#125;&#125; 组件<span class="hljs-tag">&lt;/<span class="hljs-name">h3</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="javascript">    <span class="hljs-comment">// 接收 props 数据</span></span><br><span class="javascript">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;id&#x27;</span>]</span><br><span class="javascript">  &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><blockquote><p>注意：在 hash 地址中，</p><ul><li>/ 后面的参数叫做 路径参数，使用 this.$route.params 来访问路径参数</li><li>? 后面的参数叫做 查询参数，使用 this.$route.query 来访问</li><li>在 this.$route 中，path 只是路径部分，fullPath 是完整的 hash 地址</li></ul></blockquote><h4 id="声明式导航-amp-编程式导航"><a href="#声明式导航-amp-编程式导航" class="headerlink" title="声明式导航 &amp; 编程式导航"></a>声明式导航 &amp; 编程式导航</h4><p>在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如： </p><ul><li>普通网页中点击 <a> 链接、vue 项目中点击 <router-link> 都属于声明式导航 </router-link></a></li></ul><p>在浏览器中，调用 API 方法实现导航的方式，叫做编程式导航。例如： </p><ul><li>普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航</li></ul><h5 id="vue-中的编程式导航"><a href="#vue-中的编程式导航" class="headerlink" title="vue 中的编程式导航"></a>vue 中的编程式导航</h5><p>vue-router 提供了许多编程式导航的 API，其中最常用的导航 API 分别是： </p><ol><li><p><code>this.$router.push(&#39;hash 地址&#39;)</code>  </p><ul><li>跳转到指定的 hash 地址，并<strong>增加</strong>一条历史记录 </li></ul></li><li><p> <code>this.$router.replace(&#39;hash 地址&#39;)</code>  </p></li></ol><ul><li>跳转到指定的 hash 地址，并<strong>替换掉</strong>当前的历史记录 </li></ul><ol start="3"><li><p><code>this.$router.go(数值 n)</code>  </p><ul><li>实现导航历史前进、后退</li><li>go(-1) 表示后退一层</li><li>如果后退的层数超过上限，则原地不动</li></ul><blockquote><p>在实际开发中，一般只会前进一层或后退一层，因此 vue-router 提供了如下两个便捷方法</p><ul><li>$router.back() ：在历史记录中，后退到上一个页面 </li><li>$router.forward() ：在历史记录中，前进到下一个页面</li></ul></blockquote></li></ol><blockquote><p>在行内使用 编程式跳转 时，this 必须要省略，否则会报错</p></blockquote><h4 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h4><p>导航守卫可以控制路由的访问权限</p><h5 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h5><p>调用路由实例对象的 <strong>beforeEach()</strong> 方法，即可声明全局前置守卫</p><p>在 main.js 中配置：</p><p>全局前置守卫的回调函数中接收 3 个形参</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;&#125;)<br><br><span class="hljs-comment">// 每次发生路由的导航跳转时，都会自动触发 fn 这个 “回调函数”</span><br>router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-comment">// to 表示将要访问的路由信息对象</span><br>  <span class="hljs-comment">// from 表示将要离开的路由信息对象</span><br>  <span class="hljs-comment">// next 是一个方法，表示放行，允许这次路由导航</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>next 函数的三种调用方式</p><ul><li>当前用户<strong>拥有</strong>后台主页的访问权限，直接<strong>放行</strong>：==next()== </li><li>当前用户<strong>没有</strong>后台主页的访问权限，强制其<strong>跳转到登录页面</strong>：==next(‘/login’)== </li><li>当前用户<strong>没有</strong>后台主页的访问权限，<strong>不允许跳转</strong>到后台主页：==next(false)== </li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (to.path === <span class="hljs-string">&#x27;/main&#x27;</span>) &#123;<br>    <span class="hljs-comment">// 获取 token 值</span><br>    <span class="hljs-keyword">const</span> token = <span class="hljs-built_in">localStorage</span>.getItem(<span class="hljs-string">&#x27;token&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (token) next() <span class="hljs-comment">// 已登录，放行</span><br>    <span class="hljs-keyword">else</span> next(<span class="hljs-string">&#x27;/login&#x27;</span>) <span class="hljs-comment">// 未登录，跳转到指定页面，一般为登录页</span><br>  &#125; <span class="hljs-keyword">else</span> next()<br>&#125;)<br></code></pre></div></td></tr></table></figure><h1 id="Eslint"><a href="#Eslint" class="headerlink" title="Eslint"></a>Eslint</h1><p>一个插件化的javascript代码检测工具</p><h2 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h2><p>生成 .eslintrc.js 文件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">root</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">env</span>: &#123;<br>    <span class="hljs-attr">node</span>: <span class="hljs-literal">true</span><br>  &#125;,<br>  <span class="hljs-attr">extends</span>: [<br>    <span class="hljs-string">&#x27;plugin:vue/essential&#x27;</span>,<br>    <span class="hljs-string">&#x27;@vue/standard&#x27;</span><br>  ],<br>  <span class="hljs-attr">parserOptions</span>: &#123;<br>    <span class="hljs-attr">parser</span>: <span class="hljs-string">&#x27;babel-eslint&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">rules</span>: &#123;<br>    <span class="hljs-string">&#x27;no-console&#x27;</span>: process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;warn&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span>,<br>    <span class="hljs-string">&#x27;no-debugger&#x27;</span>: process.env.NODE_ENV === <span class="hljs-string">&#x27;production&#x27;</span> ? <span class="hljs-string">&#x27;warn&#x27;</span> : <span class="hljs-string">&#x27;off&#x27;</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>process.env.NODE_ENV 固定用法，获取到 webpack 的模式</li><li>在 rules 中写规则</li><li>no-console 禁用输出指令</li><li>no-debugger 禁用断点代码</li></ul><blockquote><p>想要自定义规则可以去官网上寻找</p></blockquote><h2 id="VScode-配置"><a href="#VScode-配置" class="headerlink" title="VScode 配置"></a>VScode 配置</h2><h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><h4 id="ESlint-Dirk-Baeumer"><a href="#ESlint-Dirk-Baeumer" class="headerlink" title="ESlint (Dirk Baeumer)"></a>ESlint (Dirk Baeumer)</h4><p>在 settings.json 配置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-comment">// ESLint 插件的配置</span><br>  <span class="hljs-attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;source.fixAll&quot;</span>: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="Prettier-Code-formatter-Prettier"><a href="#Prettier-Code-formatter-Prettier" class="headerlink" title="Prettier - Code formatter (Prettier)"></a>Prettier - Code formatter (Prettier)</h4><p>在 settings.json 中配置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;prettier.configPath&quot;</span>: <span class="hljs-string">&quot;C:\\Users\\AgoniLay\\.prettierrc&quot;</span>,<br><br>  <span class="hljs-attr">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;prettier.trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>  <span class="hljs-attr">&quot;prettier.semi&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-comment">// 每行文字个数超出限制将会被迫换行</span><br>  <span class="hljs-attr">&quot;prettier.printWidth&quot;</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-comment">// 使用单引号替换双引号</span><br>  <span class="hljs-attr">&quot;prettier.singleQuote&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;prettier.arrowParens&quot;</span>: <span class="hljs-string">&quot;avoid&quot;</span>,<br>  <span class="hljs-comment">// 设置 .vue 文件中，HTML代码的格式化插件</span><br>  <span class="hljs-attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="hljs-string">&quot;js-beautify-html&quot;</span>,<br>  <span class="hljs-comment">// 忽略项目中的警告弹窗</span><br>  <span class="hljs-attr">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;prettier&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span>,<br>      <span class="hljs-attr">&quot;semi&quot;</span>: <span class="hljs-literal">false</span>,<br>      <span class="hljs-attr">&quot;singleQuote&quot;</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">&quot;arrowParens&quot;</span>: <span class="hljs-string">&quot;aviod&quot;</span>,<br>      <span class="hljs-attr">&quot;printWidth&quot;</span>: <span class="hljs-number">300</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;js-beautify-html&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;wrap_attribute&quot;</span>: <span class="hljs-literal">false</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>其中也包含 vetur 插件的配置设置</p><p>在本地 C盘/用户/xxx 目录下 创建 .pretterrc 文件</p><p>在其中设置：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;semi&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;singleQuote&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;printWidth&quot;</span>: <span class="hljs-number">300</span>,<br>  <span class="hljs-attr">&quot;arrowParens&quot;</span>: <span class="hljs-string">&quot;avoid&quot;</span>,<br>  <span class="hljs-attr">&quot;trailingComma&quot;</span>: <span class="hljs-string">&quot;none&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>在项目中设置 .vue 和 .js 结尾的文件 格式化文档方式默认为  Pretter - Code - formatter</p><ul><li>右键选择 使用…格式化文档</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
      <tag>前端框架</tag>
      
      <tag>vue2</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSS笔记</title>
    <link href="/2021/08/04/CSS%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/04/CSS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>Cascading Style Sheets 层叠样式表（级联样式表）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>降低耦合度（解耦）</li><li>让分工协作更容易</li><li>提高开发效率</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>在标签内使用style属性指定css代码</p><p>适用于属性较少时</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;color:red;&quot;</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h4><p>内嵌式：在 head 标签内，定义 style 标签，style 标签的标签体内容就是 css 代码</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">        <span class="hljs-selector-tag">div</span> &#123;</span><br><span class="css">            <span class="hljs-attribute">color</span>: blue;</span><br><span class="css">        &#125;</span><br><span class="css">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h4><p>a.css 文件</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">color</span>:green;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="链接式-推荐使用"><a href="#链接式-推荐使用" class="headerlink" title="链接式 (推荐使用)"></a>链接式 (推荐使用)</h5><p>在 head 标签内，定义 link 标签，引入外部的资源文件</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;css/a.css&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>hello css<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="导入式"><a href="#导入式" class="headerlink" title="导入式"></a>导入式</h5><p>使用 <code>@import</code> 在 style 标签内导入，必须在标签内最前面</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-keyword">@import</span> <span class="hljs-string">&quot;css/a.css&quot;</span>;</span><br><span class="css">    <span class="hljs-keyword">@import</span> url(<span class="hljs-string">&quot;css/a.css&quot;</span>);</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>引号可以是单引号也可以是双引号，也可以省略引号</p><p>link 和 @import 的区别：</p><ul><li>link 是 html 标签；而 @import 是 css 提供的</li><li>link 在页面加载时加载；@import 在页面加载完再加载</li><li>@import IE5 以上才可识别；link 无兼容性问题</li><li>link 样式的权重高于 @import 的权重</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">选择器 &#123; <span class="hljs-comment">/* 样式分隔符 */</span><br>    属性名<span class="hljs-number">1</span>: 属性值<span class="hljs-number">1</span>;  <span class="hljs-comment">/* 这每一行叫声明 */</span><br>    属性名<span class="hljs-number">2</span>: 属性值<span class="hljs-number">2</span>;<br>    ...<br>&#125; <span class="hljs-comment">/* 样式分隔符 */</span><br></code></pre></div></td></tr></table></figure><ul><li>选择器：筛选具有相似特征的元素</li><li>每一对属性需要使用 <code>;</code> 隔开，最后一对属性可以不加</li></ul><h4 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h4><p>在 css 中注释使用 <code>\* 注释内容 *\</code> </p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><table><thead><tr><th align="center">名称</th><th align="center">作用</th><th align="center">语法</th><th align="center">注意</th></tr></thead><tbody><tr><td align="center">id 选择器</td><td align="center">选择具体的 id 属性值的元素</td><td align="center"><code>#id属性值 &#123;&#125;</code></td><td align="center">建议在一个 html 页面中 id 值唯一</td></tr><tr><td align="center">元素选择器</td><td align="center">选择具有相同标签名称的元素</td><td align="center"><code>标签名称 &#123;&#125;</code></td><td align="center"></td></tr><tr><td align="center">类选择器</td><td align="center">选择具有相同的 class 属性值的元素</td><td align="center"><code>.class属性值 &#123;&#125;</code></td><td align="center">类选择器选择器优先级高于元素选择器</td></tr></tbody></table><h4 id="扩展选择器"><a href="#扩展选择器" class="headerlink" title="扩展选择器"></a>扩展选择器</h4><table><thead><tr><th>名称</th><th>作用</th><th>语法</th><th>注意</th></tr></thead><tbody><tr><td>通配符选择器</td><td>选择所有元素</td><td><code>* &#123;&#125;</code></td><td></td></tr><tr><td>并集选择器(分组选择器)</td><td>同时选择多个选择器</td><td><code>选择器1, 选择器2 &#123;&#125;</code></td><td>集体声明，减少代码的书写量</td></tr><tr><td>交集选择器</td><td>更精准的找到要选择的</td><td><code>标签名.class名 &#123;&#125;</code><br><code>标签名#id名</code></td><td></td></tr><tr><td>后代选择器(包含选择器)</td><td>筛选选择器1元素下的选择器2元素</td><td><code>选择器1 选择器2 &#123;&#125;</code></td><td></td></tr><tr><td>子元素选择器(子选择器)</td><td>筛选选择器1的子元素选择器2</td><td><code>选择器1 &gt; 选择器2 &#123;&#125;</code></td><td>只选直系</td></tr><tr><td>相邻选择器</td><td>筛选选择器1的相邻元素选择器2</td><td><code>选择器1 + 选择器2 &#123;&#125;</code></td><td>选择器1 必须在 选择器2 之前</td></tr><tr><td>兄弟选择器</td><td>筛选选择器1的所有兄弟元素选择器2</td><td><code>选择器1 ~ 选择器2 &#123;&#125;</code></td><td></td></tr></tbody></table><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><p>选择元素名称，属性名=属性值的元素</p><ul><li><code>元素名称[属性名] &#123;&#125;</code> ：选择带有该属性的元素</li><li><code>元素名称[属性名=&quot;属性值&quot;] &#123;&#125;</code> ：该属性的值为该属性值的 （常用）</li><li><code>元素名称[属性名^=&quot;xxx&quot;] &#123;&#125;</code> ：属性值为 xxx 开头的</li><li><code>元素名称[属性名$=&quot;xxx&quot;] &#123;&#125;</code> ：属性值为 xxx 结尾的</li><li><code>元素名称[属性名*=&quot;xxx&quot;] &#123;&#125;</code> ：属性值的任意位置带有 xxx （常用）</li><li><code>元素名称[属性名~=&quot;xxx&quot;] &#123;&#125;</code> ：属性值是一个词列表，并且以空格隔开，其中词列表中包含了 xxx</li><li><code>元素名称[属性名|=&quot;xxx&quot;] &#123;&#125;</code> ：特定属性选择器，该属性值是 value 或者以 value- 开头的值（如 zh-cn）</li></ul><p>也可以混合使用，选择多个属性多个属性值的：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-attr">[href]</span><span class="hljs-selector-attr">[title=<span class="hljs-string">&quot;link&quot;</span>]</span> &#123;<br>    ...<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h5><p>选择一些元素具有的状态</p><p>语法： <code>E:pseudo-class &#123;property: value;&#125;</code> </p><h6 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h6><ul><li>:link ：初始化的状态</li><li>:visited ：被访问过的状态</li><li>:hover ：鼠标悬浮状态（常用）</li><li>:active ：正在访问状态</li></ul><p>注意顺序： link -&gt; visited -&gt; hover -&gt; active  不可以调换</p><p>常用于自定义超链接样式</p><ul><li>:focus ：聚焦的状态</li></ul><h6 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h6><ul><li><p>:first-child ：首个子元素</p></li><li><p>:last-child ：最后一个子元素</p></li><li><p>:nth-child(n) ：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(length) <span class="hljs-comment">/* 参数是具体数字，表示选择第几个 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(n) <span class="hljs-comment">/* 参数是 n，n 从 0 开始算,会选中所有的子元素 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(n*length) <span class="hljs-comment">/* n 的倍数选择，n 从 0 开始算 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(n+length) <span class="hljs-comment">/* 选择大于等于 length 的元素 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(-n+length) <span class="hljs-comment">/* 选择小于等于 length 的元素 */</span><br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:nth-child</span>(n*length-<span class="hljs-number">1</span>) <span class="hljs-comment">/* 表示隔几(length)选一 */</span><br></code></pre></div></td></tr></table></figure><ul><li>even === 2n –&gt; 偶数项</li><li>odd === 2n-1 –&gt; 奇数项</li><li>只能是字母 n，其他的没有效果</li></ul></li><li><p>:nth-last-child() ：从最后一个开始数，用法与 nth-child() 相同</p></li><li><p>:nth-of-type() ：用法类似 :nth-child()，但只计算选择器中指定的哪个元素，指定了子元素的类型</p></li><li><p>:nth-last-of-type() ：从最后一个开始计算</p></li><li><p>:first-of-type() :last-of-type() ：类似于 :first-child() 和 :last-child()</p></li><li><p>:only-child() ：表示一个元素是它的父元素的唯一一个子元素</p></li><li><p>:only-of-type() ：表示一个元素包含很多子元素，只有一种子元素是唯一的，那么就可以选中它</p></li><li><p>:empty() ：用来选择没有任何内容的元素，一个空格也没有</p></li></ul><p>注意：IE6~8 和 FF3及其以下版本不支持以上的结构伪类选择器</p><h6 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h6><ul><li>:not() 否定选择器，即排除或过滤掉特定元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">input</span><span class="hljs-selector-pseudo">:not</span>(<span class="hljs-selector-attr">[type=<span class="hljs-string">&quot;submit&quot;</span>]</span>) &#123; <span class="hljs-comment">/* 选择除提交按钮外的其他表单元素 */</span><br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid red;<br>&#125; <br></code></pre></div></td></tr></table></figure><p>注意：IE6~8 及其以下版本不支持否定伪类选择器</p><h6 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a>状态伪类</h6><p>UI元素（User Interface 用户界面）一般是指包含在 form 内的表单元素，其状态一般包括：可用不可用、选中未选中、获得或失去焦点、锁定、待机等</p><ul><li>:enabled() 表示匹配指定范围内所有可用 UI元素，匹配文本框，不匹配按钮</li><li>:disabled() 表示匹配指定范围内所有不可用 UI元素，匹配按钮，不匹配文本框</li><li>:checked() 表示匹配指定范围内所有可用 UI元素，匹配单选按钮</li></ul><p>注意：IE6~8 及其以下版本不支持状态伪类选择器</p><h6 id="目标伪类"><a href="#目标伪类" class="headerlink" title="目标伪类"></a>目标伪类</h6><ul><li>:target ：匹配所有指定目标元素中被相关 URL 指向的（比如锚点链接指向）</li></ul><p>注意：IE6~8 及其以下版本不支持目标伪类选择器</p><h5 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h5><p>语法： <code>元素::状态 &#123;&#125;</code> </p><ul><li>::first-letter ：选择第一个字</li><li>::first-line ：选择第一行</li><li>::selection ：选中文字时改变样式</li><li><code>::before &#123;content: &quot;xxx&quot;&#125;</code> ：在内部前面插入 xxx</li><li><code>::before &#123;after: &quot;xxx&quot;&#125;</code> ：在内部后面插入 xxx</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><h5 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h5><ul><li>in（inch，英寸）</li><li>cm（centimerter，厘米）</li><li>mm（millimeter，毫米）</li><li>pt（point，印刷的点数）</li><li>pc（pica，1pc == 12pt）</li><li>另外，xx-small | x-small | small | medium | large | x-large | xx-large 这些关键词也是绝对单位</li></ul><h5 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h5><ul><li><p>px 像素</p><ul><li>根据屏幕的像素点的尺寸变化而变化，不同分辨率的屏幕所显示的像素字体大小是不同的</li><li>屏幕分辨率越大，相同像素字体就显得越小</li></ul></li><li><p>em 相对于父辈字体的大小来定义字体大小，1em 即是 父级一个字体大小</p></li><li><p>ex 相对于父辈字体的 x 高度来定义字体大小</p><ul><li>ex 单位大小既取决于字体的大小，也取决于字体类型</li><li>在固定大小的情况下，实际的 x 高度随字体类型不同而不同</li></ul></li><li><p>% 以百分比的形式定义字体大小，于 em 效果相同，相对于父辈字体大小来定义</p></li><li><p>larger 和 smaller 将以父元素的字体大小为参考进行换算</p></li></ul><h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><ul><li>颜色名：使用颜色名，如：red，pink，skyblue</li><li>十六进制：0~F 如： #fff，#6E6E6E，#000000</li><li>RGB：rgb(0<del>255, 0</del>255, 0~255)，其中也可以是百分比值</li></ul><p>CSS3 新支持以下三种颜色表示法：</p><ul><li><p>RGBA：在 RGB 颜色的基础上增加了 Alpha 通道，起到定义半透明的颜色，取值 0~1，越低越透明</p></li><li><p>HSL：色相(Hue)、饱和度(Saturation) 和 亮度(Lightness) 表示颜色</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">hsl(&lt;length&gt;, &lt;percentage&gt;, &lt;percentage&gt;)<br></code></pre></div></td></tr></table></figure></li><li><p>HSLA：和 RGBA 同理，添加透明通道</p></li></ul><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><h5 id="Webkit-渐变"><a href="#Webkit-渐变" class="headerlink" title="Webkit 渐变"></a>Webkit 渐变</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">-webkit-gradient(&lt;type&gt;, &lt;point&gt; <span class="hljs-selector-attr">[, &lt;radius&gt;]</span>?, &lt;point&gt; <span class="hljs-selector-attr">[,&lt;radius&gt;]</span>? <span class="hljs-selector-attr">[,&lt;stop&gt;]</span>*)<br></code></pre></div></td></tr></table></figure><ul><li>type：定义渐变类型，包括线性渐变（linear）和 径向渐变（radial）</li><li>point：定义渐变起始点和结束点坐标，即开始应用渐变的 x轴 和 y轴 坐标，以及结束渐变的坐标，(0, 0)、(left, top)、top、bottom、left、right</li><li>radius：当定义径向渐变时，用来设置径向渐变的长度，为一个数值</li><li>stop：定义渐变色和步长<ul><li>from(colorvalue)：开始的颜色</li><li>to(colorvalue)：结束的颜色</li><li>color-stop(value, colorvalue)：颜色步长、包含两个参数值，第一个为数值，第二个为颜色值</li></ul></li></ul><h5 id="Gecko-渐变"><a href="#Gecko-渐变" class="headerlink" title="Gecko 渐变"></a>Gecko 渐变</h5><h6 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">-moz-linear-gradient(<span class="hljs-selector-attr">[&lt;point&gt; || &lt;angle&gt;,]</span>? &lt;stop&gt;, &lt;stop&gt; <span class="hljs-selector-attr">[,&lt;stop&gt;]</span>*)<br></code></pre></div></td></tr></table></figure><ul><li>point：定义渐变起始点</li><li>angle：定义直线渐变的角度</li><li>stop：定义步长，用法与 Webkit 的 color-stop() 函数相似</li></ul><h6 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">-moz-radial-gradient(<span class="hljs-selector-attr">[&lt;position&gt; || &lt;angle&gt;,]</span>? <span class="hljs-selector-attr">[&lt;shape&gt; || &lt;size&gt;,]</span>? &lt;stop&gt;, &lt;stop&gt; <span class="hljs-selector-attr">[,&lt;stop&gt;]</span>*)<br></code></pre></div></td></tr></table></figure><ul><li>point：定义渐变起始点</li><li>angle：定义渐变的角度</li><li>shape：定义径向渐变的形状</li><li>size：定义圆半径，或者椭圆的轴长度</li><li>stop：定义步长，用法与 Webkit 的 color-stop() 函数相似</li></ul><h5 id="W3C-渐变"><a href="#W3C-渐变" class="headerlink" title="W3C 渐变"></a>W3C 渐变</h5><p>沿袭 Gecko 引擎的渐变设计方法，语法与用法也基本相同</p><h6 id="线性渐变-1"><a href="#线性渐变-1" class="headerlink" title="线性渐变"></a>线性渐变</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">linear-gradient(<span class="hljs-selector-attr">[[angle]</span> | <span class="hljs-selector-tag">to</span>&lt;side-or-corner&gt;,]? &lt;<span class="hljs-attribute">color</span>-stop&gt;<span class="hljs-selector-attr">[, &lt;color-stop&gt;]</span>+)<br></code></pre></div></td></tr></table></figure><h6 id="径向渐变-1"><a href="#径向渐变-1" class="headerlink" title="径向渐变"></a>径向渐变</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">radial-gradient(<span class="hljs-selector-attr">[[&lt;shape&gt; || &lt;size&gt;]</span><span class="hljs-selector-attr">[at&lt;position&gt;]</span>?, | at&lt;<span class="hljs-attribute">position</span>&gt;, ]? &lt;<span class="hljs-attribute">color</span>-stop&gt;<span class="hljs-selector-attr">[, &lt;color-stop&gt;]</span>+)<br></code></pre></div></td></tr></table></figure><h4 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h4><h5 id="font-size-字体大小"><a href="#font-size-字体大小" class="headerlink" title="font-size 字体大小"></a>font-size 字体大小</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-size</span>: xx-small | x-small | small | medium | large | x-large | xx-large | larger | normal | smaller | length<br></code></pre></div></td></tr></table></figure><ul><li>前面的表示绝对字体尺寸</li><li>larger 和 smaller 表示相对的大小，根据父对象中字体尺寸进行相对增大和缩小处理</li><li>length 可以是百分数、浮点数或单位标识符组成的长度值，不可谓负值</li></ul><h5 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family 字体"></a>font-family 字体</h5><ul><li>各种字体之间用 <code>,</code> 分隔开</li><li>中文字体需要加英文引号，英文字体一般不需要加引号</li><li>如果字体中包含 <code> </code>(空格) <code>#</code> <code>$</code> 等符号，则必须加引号</li><li>Unicode 编码表示字体：<ul><li><code>\5B8B\4F53</code>  ==  SimSun  –&gt;  宋体</li><li><code>\5FAE\8F6F\96C5\9ED1</code>  ==  Microsoft YaHei  –&gt;  微软雅黑</li></ul></li></ul><h5 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight 字体粗细"></a>font-weight 字体粗细</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-weight</span>: <span class="hljs-number">100</span> | <span class="hljs-number">200</span> | <span class="hljs-number">300</span> | <span class="hljs-number">400</span> | <span class="hljs-number">500</span> | <span class="hljs-number">600</span> | <span class="hljs-number">700</span> | <span class="hljs-number">800</span> | <span class="hljs-number">900</span> | normal | bold | bolder | lighter<br></code></pre></div></td></tr></table></figure><ul><li>可以使用数字，可选数值为 100 的整数倍， 100 ~ 900，越大越粗</li><li>normal == 400；<strong>bold</strong> === 700   &lt; 较为常用</li><li>bolder：相对于 normal 字体较粗；lighter：相对于 normal 字体较细</li></ul><h5 id="font-style-字体样式"><a href="#font-style-字体样式" class="headerlink" title="font-style 字体样式"></a>font-style 字体样式</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-style</span>: normal | italic | oblique<br></code></pre></div></td></tr></table></figure><ul><li>normal：普通</li><li>italic：斜体</li><li>oblique：倾斜的字体</li></ul><p>italic 和 oblique 只能在英文等西方文字中有效</p><h5 id="color-字体颜色"><a href="#color-字体颜色" class="headerlink" title="color 字体颜色"></a>color 字体颜色</h5><p>使用相应颜色表示法即可</p><h5 id="text-decoration-字体划线效果"><a href="#text-decoration-字体划线效果" class="headerlink" title="text-decoration 字体划线效果"></a>text-decoration 字体划线效果</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-decoration</span>: normal | none | underline | blink | overline | line-through<br></code></pre></div></td></tr></table></figure><ul><li>normal：默认值</li><li>none：取消划线效果</li><li>underline：下划线效果</li><li>blink：闪烁效果</li><li>line-through：贯穿线效果（即中划线）</li><li>overline：上划线效果</li></ul><p>可以多个值混合使用，如：<code>text-decoration: line-through overline underline;</code> 达到显示上中下三条划线效果</p><p>常用：取消 a 链接 默认下划线样式：<code>text-decoration: none;</code> </p><h5 id="font-variant-定义小型大写字母"><a href="#font-variant-定义小型大写字母" class="headerlink" title="font-variant 定义小型大写字母"></a>font-variant 定义小型大写字母</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">font-variant</span>: normal | small-caps<br></code></pre></div></td></tr></table></figure><ul><li>normal：默认值，即正常的字体</li><li>snall-caps：小型的大写字母字体</li></ul><p>仅支持以英文为代表的西文字体</p><h5 id="text-transform-单词大小写"><a href="#text-transform-单词大小写" class="headerlink" title="text-transform 单词大小写"></a>text-transform 单词大小写</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-transform</span>: none | capitalize | uppercase | lowercase<br></code></pre></div></td></tr></table></figure><ul><li>none：默认值，无转换发生</li><li>capitalize：将每个单词的第一个字母转换成大写，其余无转换</li><li>uppercase：所有字母转换为大写</li><li>lowercase：所有字母转换为小写</li></ul><h5 id="font-face-自定义字体类型"><a href="#font-face-自定义字体类型" class="headerlink" title="@font-face 自定义字体类型"></a>@font-face 自定义字体类型</h5><p>能够加载服务器端的字体文件</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>    <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&quot;设置文本的字体名称&quot;</span>;<br>    <span class="hljs-attribute">font-style</span>: 设置文本样式;<br>    <span class="hljs-attribute">font-variant</span>: 设置文本是否大小写;<br>    <span class="hljs-attribute">font-weight</span>: 设置文本的粗细;<br>    <span class="hljs-attribute">font-stretch</span>: 设置文本是否横向的拉伸变形;<br>    <span class="hljs-attribute">font-size</span>： 设置文本字体大小;<br>    <span class="hljs-attribute">src</span>: 设置自定义字体的相对路径或绝对路径;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><h5 id="text-align-水平对齐"><a href="#text-align-水平对齐" class="headerlink" title="text-align 水平对齐 *"></a>text-align 水平对齐 *</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-align</span>: left | right | center | justify<br></code></pre></div></td></tr></table></figure><ul><li>left：左对齐，默认值</li><li>rigth：右对齐</li><li>center：居中对齐</li><li>justify：两端对齐</li></ul><p>CSS3 新增四个属性：</p><ul><li>start | end | match-parent | justify-all</li><li>浏览器支持不是很好</li></ul><h5 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐 *"></a>vertical-align 垂直对齐 *</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">vertical-align</span>: auto | baseline | sub | super | top | text-top | middle | bottom | text-bottom | length<br></code></pre></div></td></tr></table></figure><ul><li>auto：根据 layout-flow 的值对齐对象内容</li><li>baseline：默认值，表示将支持 valign 特性的对象内容与基线对齐</li><li>sub：表示垂直对齐文本的下标</li><li>super：表示垂直对齐文本的上标</li><li>top：对象的内容与对象顶端对齐</li><li>text-top：对象的文本与对象顶端对齐</li><li>middle：对象的内容与对象中部对齐</li><li>bottom：对象的内容与对象底端对齐</li><li>text-bottom：对象的文本与对象底端对齐</li><li>length：表示由浮点数字和单位标识符组成的长度值或百分数，可为负数，定义由基线(0,0%)算起的偏移量</li></ul><h5 id="letter-spacing-字间距"><a href="#letter-spacing-字间距" class="headerlink" title="letter-spacing 字间距"></a>letter-spacing 字间距</h5><p>取值为长度值</p><h5 id="word-spacing-词间距"><a href="#word-spacing-词间距" class="headerlink" title="word-spacing 词间距"></a>word-spacing 词间距</h5><p>取值为长度值，默认值为 normal，表示默认间隔，以空格作为识别的分界线</p><h5 id="line-height-行高"><a href="#line-height-行高" class="headerlink" title="line-height 行高 *"></a>line-height 行高 *</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">line-height</span>: normal | length;<br></code></pre></div></td></tr></table></figure><ul><li>normal：默认值，一般为 1.2em</li><li>length 为长度值，允许为负值，可以不写单位，灵活继承父级单位</li><li>一般行高的最佳设置范围为 1.2em~1.8em</li><li>可以遵循字体越大，行高越小的原则来定义</li></ul><h5 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent 首行缩进"></a>text-indent 首行缩进</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-indent</span>: length /* (<span class="hljs-number">2em</span>) */<br></code></pre></div></td></tr></table></figure><ul><li>length 为长度值，允许为负值</li><li>可以巧用：将不想显示的文本缩进出窗口外 <code>text-indent: -9999px;</code> </li><li>建议以 em 为设置单位</li></ul><h5 id="text-shadow-文字阴影"><a href="#text-shadow-文字阴影" class="headerlink" title="text-shadow 文字阴影"></a>text-shadow 文字阴影</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: none || 水平偏移值 垂直偏移值 阴影模糊值 阴影颜色<br></code></pre></div></td></tr></table></figure><ul><li>none：无阴影</li><li>前两个参数必须写，后两个可以省略</li><li>前两个参数，正值偏右或偏下，负值相反</li><li>阴影模糊值是一个长度值，不允许为负值</li><li>模糊距离越大越虚</li><li>颜色设置可以在调换到任意位置</li><li>如未设置颜色，则继承自 color 属性的颜色</li><li>设置多个阴影效果用 <code>,</code> 分隔</li><li>可以使用在 :first-letter 和 :first-line 伪元素上</li><li>在左上和右下各补一个1像素错位的补色阴影，可以起到外凸内凹的效果</li></ul><h5 id="text-overflow-溢出文本"><a href="#text-overflow-溢出文本" class="headerlink" title="text-overflow 溢出文本"></a>text-overflow 溢出文本</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-overflow</span>: clip | ellipsis | elipsis-word<br></code></pre></div></td></tr></table></figure><ul><li>clip：不显示省略标记 <code>…</code> ，简单的裁切</li><li>ellipsis：当对象文本溢出时显示省略标记 <code>…</code> ，插入位置是最后一个字符</li><li>ellipsis-word：当对象文本溢出时显示省略标记 <code>…</code> ，插入位置是最后一个词</li></ul><p>要实现已出现是省略号的效果，还需要设置两个属性：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">white-space</span>: nowrap; <span class="hljs-comment">/* 强制文本在一行内显示 */</span><span class="hljs-attribute">overflow</span>: hidden; <span class="hljs-comment">/* 溢出隐藏 */</span><br></code></pre></div></td></tr></table></figure><h5 id="word-wrap-文本换行"><a href="#word-wrap-文本换行" class="headerlink" title="word-wrap 文本换行"></a>word-wrap 文本换行</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-wrap</span>: normal | break-word<br></code></pre></div></td></tr></table></figure><ul><li>normal：表示控制连续文本换行</li><li>break-word：内容将在边界内换行</li></ul><h5 id="content-添加动态内容"><a href="#content-添加动态内容" class="headerlink" title="content 添加动态内容"></a>content 添加动态内容</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">content</span>: normal | string | <span class="hljs-built_in">attr</span>() | <span class="hljs-built_in">uri</span>() | <span class="hljs-built_in">counter</span>() | none<br></code></pre></div></td></tr></table></figure><ul><li>normal：默认值</li><li>string：插入文本内容</li><li>attr()：插入元素的属性值</li><li>uri()：插入一个外部资源，如图像、音频、视频或浏览器支持的其他任何资源</li><li>counter()：计数器，用于插入排序标识</li><li>none：无任何内容</li></ul><p>一般和 ::before 一起使用，也可以单独使用</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h5 id="border-spacing-分离单元格间距"><a href="#border-spacing-分离单元格间距" class="headerlink" title="border-spacing 分离单元格间距"></a>border-spacing 分离单元格间距</h5><ul><li>可以为一个值 或 两个值</li><li>两个值时，第一个值表示行间距，第二个值表示列间距</li></ul><h5 id="empty-cells-控制空单元格显示"><a href="#empty-cells-控制空单元格显示" class="headerlink" title="empty-cells 控制空单元格显示"></a>empty-cells 控制空单元格显示</h5><ul><li>show：显示空单元格</li><li>hide：隐藏空单元格</li><li>空单元格：指没有可视内容的单元格<ul><li>如果单元格的 visibility 属性值为 hidden，即便单元格包含内容，也认为是空单元格</li><li><code>&amp;nbsp;</code> 和 其他空白字符为可视内容</li><li>ASCII 字符中的 回车符(“\0D”)、换行符(“\0A”)、Tab键(“\09”)和空格键(“\20”)表示不可视内容</li></ul></li></ul><p>如果表格行中所有单元格的 empty-cells 属性都为 hide，且都不包含任何可视内容，那么整行就等于设置了 display: none</p><h5 id="caption-side-表格标题位置"><a href="#caption-side-表格标题位置" class="headerlink" title="caption-side 表格标题位置"></a>caption-side 表格标题位置</h5><p>定义标题的显示位置</p><ul><li>top（表格上面） | bottom（表格底部） | left | right</li></ul><h5 id="border-collapse-合并单元格边框"><a href="#border-collapse-合并单元格边框" class="headerlink" title="border-collapse 合并单元格边框"></a>border-collapse 合并单元格边框</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-collapse</span>: collapse; <span class="hljs-comment">/* 合并单元格边框 */</span><br></code></pre></div></td></tr></table></figure><h4 id="显示类型"><a href="#显示类型" class="headerlink" title="显示类型"></a>显示类型</h4><h5 id="display-显示类型"><a href="#display-显示类型" class="headerlink" title="display 显示类型"></a>display 显示类型</h5><p>css2.1 中，display 属性共有 18 个选项值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><strong>block</strong></td><td>块状显示，在元素后面添加换行符，即其他元素不能在后面并列显示</td></tr><tr><td><strong>none</strong></td><td>隐藏显示，不会为被隐藏的元素保留位置，而 visibility: hidden 会<br>表示隐藏的同时取消盒模型</td></tr><tr><td><strong>inline</strong></td><td>行内显示，在元素后面删除换行符，多个元素可以在一行内并列显示</td></tr><tr><td>inline-block</td><td>行内显示，但是元素的内容以块状显示，行内其他行内元素还会显示在同一行内</td></tr><tr><td>compact</td><td>紧凑的块状显示，基于内容上的行内显示</td></tr><tr><td>marker</td><td>在容器对象之前或之后显示，必须与 :after 或 :before 伪元素一起用</td></tr><tr><td>lnline-table</td><td>具有行内特征的表格显示</td></tr><tr><td><strong>list-item</strong></td><td>具有块状特征的列表项目显示，并可以添加可选项目标志，增加了缩进和i项目符号</td></tr><tr><td>run-in</td><td>块状显示或基于内容之上的行内显示</td></tr><tr><td>table</td><td>具有块状特征的表格显示</td></tr><tr><td>table-caption</td><td>表格标题显示</td></tr><tr><td>table-cell</td><td>表格单元格显示</td></tr><tr><td>table-column</td><td>表格列显示</td></tr><tr><td>table-column-group</td><td>表格列组显示</td></tr><tr><td>table-row</td><td>表格行显示</td></tr><tr><td>table-row-group</td><td>表格行组显示</td></tr><tr><td>table-header-group</td><td>表格标题组显示</td></tr><tr><td>table-footer-group</td><td>表格页脚组显示</td></tr></tbody></table><p>常用显示类型都可以划分为 block 和 inline 两种类型</p><h5 id="float-浮动显示"><a href="#float-浮动显示" class="headerlink" title="float 浮动显示"></a>float 浮动显示</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">float</span>: left | right | none<br></code></pre></div></td></tr></table></figure><ul><li>left：元素向左浮动</li><li>right：元素向右浮动</li><li>none：默认值，表示消除浮动</li></ul><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ol><li>浮动元素以块状显示，可以定义 height 和width</li><li>浮动元素与流动元素可以混合使用，不会重叠，都遵循向上后下的显示规则，都受到文档流影响</li><li>仅能改变水平显示方式，不能改变垂直显示方式</li><li>浮动元素可以并列显示，如果包含框宽度不够，则会错行显示</li></ol><h6 id="clear-清除浮动"><a href="#clear-清除浮动" class="headerlink" title="clear 清除浮动"></a>clear 清除浮动</h6><p>不是清除浮动元素，而是清除本身，即不允许当前元素与浮动元素并列显示</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">clear</span>: left | right | both | none <br></code></pre></div></td></tr></table></figure><ul><li>left：清除左边的浮动元素，如果左边存在浮动元素，则当前元素会换行显示</li><li>right：清除右边的浮动元素，如果右边存在浮动元素，则当前元素会换行显示</li><li>both：清除左右两边的浮动元素，不管哪边存在浮动对象，当前元素都会换行显示</li><li>none：默认值，允许两边都可以存在浮动元素，当前元素不会主动换行显示</li></ul><p>clear 属性是专门针对 float 属性而设计的，依次仅能够对左右两侧浮动元素有效，对于非浮动元素是无效的</p><p>在结构最后添加：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-id">#contain</span> &#123; <span class="hljs-attribute">background</span>: pink; &#125; <span class="hljs-comment">/* 包含元素 */</span></span><br><span class="css">    <span class="hljs-selector-tag">span</span> &#123; <span class="hljs-attribute">float</span>: left; <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>; <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; &#125; <span class="hljs-comment">/* 定义共同属性 */</span></span><br><span class="css">    <span class="hljs-selector-id">#span1</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> soild blue; &#125;</span><br><span class="css">    <span class="hljs-selector-id">#span2</span> &#123; <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> soild red; &#125;</span><br><span class="css">    <span class="hljs-selector-class">.clear</span> &#123; <span class="hljs-attribute">clear</span>: both; &#125; <span class="hljs-comment">/* 定义清除类，清除浮动 */</span></span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;contain&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;span1&quot;</span>&gt;</span>span 元素浮动<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;span2&quot;</span>&gt;</span>span 元素浮动<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;clear&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-comment">&lt;!-- 添加一个清除元素 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="position-定位显示"><a href="#position-定位显示" class="headerlink" title="position 定位显示"></a>position 定位显示</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">position</span>: static | relative | absolute | fixed<br></code></pre></div></td></tr></table></figure><ul><li>static：默认值，表示不定位，元素遵循 HTML 默认的流动模型</li><li>relative：表示相对定位，通过 top bottom left right 属性确定元素在正常文档流中的偏移位置，发生偏移后元素对象原空间保留不变</li><li>absolute：表示绝对定位，叫元素从文档流中拖出来，然后使用 top bottom left right 属性相对于其最接近的一个具有定位属性的父定位包含框进行绝对定位<ul><li>如果不存在有定位的上级元素，则相对于浏览器窗口定位，层叠顺序通过 z-index 属性来定义</li></ul></li><li>fixed：表示固定定位、粘性定位，相对于视图本身固定，不会随浏览器窗口的滚动而变化，该元素会始终位于浏览器窗口内视图的某个位置，通过 top bottom left right 属性设置位置，不会受文档流动影响，与 background-attachment: fixed 属性功能相同</li></ul><p>绝对定位元素以块状显示</p><p>设置相对定位元素在可视区之外，不会出现滚动条，而绝对元素会</p><p>一般来说：子绝（absolute）父相（relative）</p><h6 id="z-index-定位层叠"><a href="#z-index-定位层叠" class="headerlink" title="z-index 定位层叠"></a>z-index 定位层叠</h6><p>通过z-index 属性来确定定位元素的层叠等级</p><ul><li>只有在元素的 position 属性取值为 relation absolute fixed 时才可以使用</li><li>z-index 属性值越大，层叠级别就越高，如果属性值相同，则根据结构顺序层叠</li><li>未指定的默认为 0，属性值为正数的在其之上，为负数的在其之下</li><li>IE 不支持 fixed 使用 z-index</li></ul><h5 id="columns-多列布局"><a href="#columns-多列布局" class="headerlink" title="columns 多列布局"></a>columns 多列布局</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">columns</span>: column-width || column-count<br></code></pre></div></td></tr></table></figure><ul><li>column-width：定义每列的宽度</li><li>column-count：定义列数</li><li>适用于不可替换的块元素、行内块元素、单元格，但是表格元素除外</li><li>Webkit 引擎支持 -webkit-columns 私有属性</li><li>Mozilla Gecko 引擎支持 -moz-columns 私有属性</li></ul><h6 id="column-width-设置列宽"><a href="#column-width-设置列宽" class="headerlink" title="column-width 设置列宽"></a>column-width 设置列宽</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-width</span>: length | auto<br></code></pre></div></td></tr></table></figure><ul><li>length：长度值，不可为负值</li><li>auto：根据浏览器自动计算来设置</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-count-设置列数"><a href="#column-count-设置列数" class="headerlink" title="column-count 设置列数"></a>column-count 设置列数</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-count</span>: integer | auto<br></code></pre></div></td></tr></table></figure><ul><li>integer：定义栏目的列数，取值为大于 0 的整数</li><li>auto：根据浏览器计算值自动设置</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-gap-设置列间距"><a href="#column-gap-设置列间距" class="headerlink" title="column-gap 设置列间距"></a>column-gap 设置列间距</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-width</span>: normal | length<br></code></pre></div></td></tr></table></figure><ul><li>normal：根据浏览器默认设置进行解析，一般为 1em</li><li>length：长度值，不可为负值</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-rule-设置列边框样式"><a href="#column-rule-设置列边框样式" class="headerlink" title="column-rule 设置列边框样式"></a>column-rule 设置列边框样式</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-rule</span>: length | style | color | transparent<br></code></pre></div></td></tr></table></figure><ul><li>length：长度值，不可为负值，功能与 column-rule-width 属性相同</li><li>style：定义列边框样式，功能与 column-rule-style 属性相同</li><li>color：定义列边框的颜色，功能与 column-rule-color 属性相同</li><li>transparent：设置边框透明显示</li><li>派生属性：column-rule-width &amp; column-rule-style &amp; olumn-rule-color</li></ul><h6 id="column-span-设置跨列显示"><a href="#column-span-设置跨列显示" class="headerlink" title="column-span 设置跨列显示"></a>column-span 设置跨列显示</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-span</span>: none | all<br></code></pre></div></td></tr></table></figure><ul><li>none：只在本栏中显示</li><li>all：将横跨所有列</li></ul><h6 id="column-fill-设置列高度"><a href="#column-fill-设置列高度" class="headerlink" title="column-fill 设置列高度"></a>column-fill 设置列高度</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">column-fill</span>: auto | balance<br></code></pre></div></td></tr></table></figure><ul><li>auto：各列的高度随其内容的变化而自动变化</li><li>balance：初始值，各列的高度会根据内容最多的那一列的高度进行统一</li></ul><h4 id="弹性盒模型（伸缩盒模型）"><a href="#弹性盒模型（伸缩盒模型）" class="headerlink" title="弹性盒模型（伸缩盒模型）"></a>弹性盒模型（伸缩盒模型）</h4><h5 id="display-flex-定义"><a href="#display-flex-定义" class="headerlink" title="display: flex 定义"></a>display: flex 定义</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">display</span>: box | inline-box | flexbox | inline-flexbox | flex | inline-flex<br></code></pre></div></td></tr></table></figure><ul><li>box：将对象作为弹性伸缩盒显示，伸缩盒为最老版本</li><li>inline-box： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为最老版本</li><li>flexbox：将对象作为弹性伸缩盒显示，伸缩盒为过渡版本</li><li>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为过渡版本</li><li>flex：将对象作为弹性伸缩盒显示，伸缩盒为最新版本</li><li>inline-flex： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为最新版本</li></ul><p>目前最稳定最新的使用 <code>display: flex | inline-flex</code> 即可</p><p>CSS 的 colums、float、clear、vertical-align 属性在伸缩项目上没有效果</p><h5 id="flex-direction-定义伸缩方向"><a href="#flex-direction-定义伸缩方向" class="headerlink" title="flex-direction 定义伸缩方向"></a>flex-direction 定义伸缩方向</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse<br></code></pre></div></td></tr></table></figure><ul><li>row：默认值，在 ltr 排版方式下从左向右排列；在 rtl 排版方式下从右向左排列</li><li>row-reverse：与 row 排列方式相反</li><li>column：类似于 row，只不过是从上到下排列</li><li>column-reverse：与 column 排列方式相反</li></ul><h5 id="flex-wrap-定义换行"><a href="#flex-wrap-定义换行" class="headerlink" title="flex-wrap 定义换行"></a>flex-wrap 定义换行</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse<br></code></pre></div></td></tr></table></figure><ul><li>nowrap：默认值，伸缩容器单行显示</li><li>wrap：伸缩容器多行显示</li><li>wrap-reverse：伸缩容器多行显示，只不过排列方式与 wrap 相反</li></ul><h5 id="flex-flow-复合属性"><a href="#flex-flow-复合属性" class="headerlink" title="flex-flow 复合属性"></a>flex-flow 复合属性</h5><p>是 flex-direction 和 flex-wrap 属性的符合属性，适用于伸缩容器</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;<br></code></pre></div></td></tr></table></figure><p>可以同时定义伸缩容器的主轴和侧轴，其默认值为 row nowrap</p><h5 id="justify-content-主轴对齐"><a href="#justify-content-主轴对齐" class="headerlink" title="justify-content 主轴对齐"></a>justify-content 主轴对齐</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around<br></code></pre></div></td></tr></table></figure><ul><li>flex-start：默认值，伸缩项目向一行的起始位置靠齐</li><li>flex-end：伸缩项目向一行的结束位置靠齐</li><li>center：伸缩项目向一行的中间位置靠齐</li><li>space-between：平均分布在行里，第一个在开始位置，最后一个在终点位置</li><li>space-around：伸缩项目会平均分布在行里，两端也会保留相对于中间间隔一半空间</li></ul><h5 id="align-items-侧轴对齐"><a href="#align-items-侧轴对齐" class="headerlink" title="align-items 侧轴对齐"></a>align-items 侧轴对齐</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch<br></code></pre></div></td></tr></table></figure><ul><li>flex-start：伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边</li><li>flex-end：伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴终点的边</li><li>center：伸缩项目的外边距在该行的侧轴上居中显示</li><li>baseline：伸缩项目根据他们的基线对齐</li><li>stretch：默认值，伸缩项目拉伸填充整个伸缩容器</li></ul><h5 id="align-content-伸缩行对齐"><a href="#align-content-伸缩行对齐" class="headerlink" title="align-content 伸缩行对齐"></a>align-content 伸缩行对齐</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">align-contetnt: flex-start | flex-end | center | space-between | space-around | stretch<br></code></pre></div></td></tr></table></figure><ul><li>flex-start：各行向伸缩容器的起点位置堆叠</li><li>flex-end：各行向伸缩容器的终点位置堆叠</li><li>center：各行向伸缩容器的中间位置堆叠</li><li>space-between：各行在伸缩容器中平均分布</li><li>space-around：各行在伸缩容器中平均分布，在两边各有一半的空间</li><li>stretch：默认值，各行将会伸展以占用剩余的空间</li></ul><h5 id="flex-定义伸缩项目"><a href="#flex-定义伸缩项目" class="headerlink" title="flex 定义伸缩项目"></a>flex 定义伸缩项目</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">&#x27;flex-grow&#x27;</span>&gt; &lt;<span class="hljs-string">&#x27;flex-shrink&#x27;</span>&gt;? || &lt;<span class="hljs-string">&#x27;flex-basis&#x27;</span>&gt; ]<br></code></pre></div></td></tr></table></figure><p>flex 是 flex-grow、flex-shirnk 和 flex-basis 三个属性的复合属性，适用于伸缩项目</p><ul><li>后两个参数是可选参数，默认值是 “0 1 auto”</li></ul><h6 id="flex-grow-扩展空间"><a href="#flex-grow-扩展空间" class="headerlink" title="flex-grow 扩展空间"></a>flex-grow 扩展空间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-grow</span>: &lt;number&gt;<br></code></pre></div></td></tr></table></figure><p>默认值为 0，负值也可以生效，接收一个不带单位的值</p><p>决定伸缩容器剩余空间按比例应扩展多少空间</p><h6 id="flex-shrink-收缩空间"><a href="#flex-shrink-收缩空间" class="headerlink" title="flex-shrink 收缩空间"></a>flex-shrink 收缩空间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;<br></code></pre></div></td></tr></table></figure><p>默认值为 1，负值也可以生效，与 flex-grow 功能相反</p><h6 id="flex-basis-伸缩比率"><a href="#flex-basis-伸缩比率" class="headerlink" title="flex-basis 伸缩比率"></a>flex-basis 伸缩比率</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto<br></code></pre></div></td></tr></table></figure><p>默认值为 auto，负值不合法</p><h6 id="order-显示位置"><a href="#order-显示位置" class="headerlink" title="order 显示位置"></a>order 显示位置</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">order</span>: &lt;integer&gt;<br></code></pre></div></td></tr></table></figure><p>默认情况下，伸缩项目是按照文档流出现的先后顺序排列，使用 order 可以改变</p><h6 id="align-self-对齐方式"><a href="#align-self-对齐方式" class="headerlink" title="align-self 对齐方式"></a>align-self 对齐方式</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch<br></code></pre></div></td></tr></table></figure><p>属性值与 align-items 的属性值相同</p><h4 id="传统盒模型"><a href="#传统盒模型" class="headerlink" title="传统盒模型"></a>传统盒模型</h4><p>每个盒子都有 边界（外边距 margin）、边框（border）、填充（补白、内边距 padding）、内容（content）</p><h5 id="width-amp-height-宽高"><a href="#width-amp-height-宽高" class="headerlink" title="width &amp; height 宽高"></a>width &amp; height 宽高</h5><ul><li>当图像仅定义宽度或高度，则浏览器能够自动调整横纵比，使宽和高可以协调缩放</li><li>也可以设置 min-width max-width min-height max-height 灵活设置盒模型的大小</li><li>宽度 和 高度 指 content+padding+border</li></ul><h5 id="border-边框"><a href="#border-边框" class="headerlink" title="border 边框"></a>border 边框</h5><p>默认情况下不会显示边框，但是在为图片定义超链接时会自动显示 2~3 像素宽的蓝色粗边框</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border</span>： <span class="hljs-attribute">none</span>;<br></code></pre></div></td></tr></table></figure><h6 id="border-style-边框样式"><a href="#border-style-边框样式" class="headerlink" title="border-style 边框样式"></a>border-style 边框样式</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-style</span>: <span class="hljs-built_in">dotted</span>(点线) | <span class="hljs-built_in">dashed</span>(虚线) | <span class="hljs-built_in">soild</span>(实线) | <span class="hljs-built_in">double</span>(双线) | <span class="hljs-built_in">groove</span>(立体凹槽) | <span class="hljs-built_in">ridge</span>(立体凸槽) | <span class="hljs-built_in">inset</span>(立体凹边) | <span class="hljs-built_in">outset</span>(立体凸边) | none | hidden<br></code></pre></div></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>默认值，无边框，不受任何指定的 border-width 值影响</td></tr><tr><td>hidden</td><td>隐藏边框，IE 不支持</td></tr><tr><td>dotted</td><td>点线</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>soild</td><td>实线</td></tr><tr><td>double</td><td>双线边框，两线及其间隔宽度之和等于指定的 border-width 值</td></tr><tr><td>groove</td><td>3D立体凹槽</td></tr><tr><td>ridge</td><td>3D立体凸槽</td></tr><tr><td>inset</td><td>3D立体凹边</td></tr><tr><td>outset</td><td>3D立体凸边</td></tr></tbody></table><h6 id="border-color-边框颜色"><a href="#border-color-边框颜色" class="headerlink" title="border-color 边框颜色"></a>border-color 边框颜色</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-color</span>: value; <span class="hljs-comment">/* 同时设置四个边框的颜色 */</span><br><span class="hljs-attribute">border-color</span>: value value value value;<br></code></pre></div></td></tr></table></figure><p>也可以分别设置：border-top-color  border-bottom-color  border-left-color  border-right-color</p><h6 id="border-width-边框宽度"><a href="#border-width-边框宽度" class="headerlink" title="border-width 边框宽度"></a>border-width 边框宽度</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-width</span>: length; <span class="hljs-comment">/* 同时设置四个边框的宽度 */</span><br><span class="hljs-attribute">border-width</span>: length length length length;<br></code></pre></div></td></tr></table></figure><ul><li>也可以分别设置：border-top-width  border-bottom-width  border-left-width  border-right-width</li><li>可以使用关键字：thin、medium 和 thick。<ul><li>不同浏览器解析不同， 5px、3px、2px 或者 3px、2px、1px</li></ul></li></ul><h6 id="边框三角形"><a href="#边框三角形" class="headerlink" title="边框三角形"></a>边框三角形</h6><p>可以利用四个方向的 border-width border-color 设计出各种基于 CSS三角形</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.sanjiao</span> &#123;</span><br><span class="css">        <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;</span><br><span class="css">        <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;</span><br><span class="css">        <span class="hljs-attribute">border-top-width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">        <span class="hljs-comment">/* border-bottom-width: 100px; */</span></span><br><span class="css">        <span class="hljs-comment">/* border-left-width: 100px; */</span></span><br><span class="css">        <span class="hljs-attribute">border-right-width</span>: <span class="hljs-number">200px</span>;</span><br><span class="css">        <span class="hljs-attribute">border-style</span>: solid;</span><br><span class="css">        <span class="hljs-attribute">border-top-color</span>: blue;</span><br><span class="css">        <span class="hljs-attribute">border-left-color</span>: blue;</span><br><span class="css">        <span class="hljs-attribute">border-bottom-color</span>: <span class="hljs-number">#FFF</span>;</span><br><span class="css">        <span class="hljs-attribute">border-right-color</span>: <span class="hljs-number">#fff</span>;</span><br><span class="css">    &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;sanjiao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h6 id="border-image-边框背景"><a href="#border-image-边框背景" class="headerlink" title="border-image 边框背景"></a>border-image 边框背景</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-image</span>: none | &lt;image&gt; [&lt;number&gt; | &lt;percentage&gt;]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125; <span class="hljs-selector-attr">[/ &lt;border-width&gt;&#123;1,4&#125;]</span><br></code></pre></div></td></tr></table></figure><p>用法和 background-image 相似</p><ul><li>webkit 引擎 支持 -webkit-border-image 私有属性</li><li>Mozilla Gecko 引擎 支持 -moz-border-image 私有属性</li><li>Presto 引擎 支持 -o-border-image 私有属性</li><li>IE浏览器 暂不支持，也没有定义私有属性</li></ul><h5 id="border-radius-圆角边框"><a href="#border-radius-圆角边框" class="headerlink" title="border-radius 圆角边框"></a>border-radius 圆角边框</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: none | &lt;length&gt;&#123;<span class="hljs-number">1</span>,<span class="hljs-number">4</span>&#125;<span class="hljs-selector-attr">[/&lt;length&gt;&#123;1,4&#125;]</span><br></code></pre></div></td></tr></table></figure><ul><li>none：默认值，表示元素没有圆角</li><li>长度值，不可为负值</li><li>也可以包含俩个属性值，用 <code>/</code> 分隔，表示 水平半径 和 垂直半径，只有一个值的是代表这两个属性值相等</li><li>也可以分别设置：border-top-right-radius  border-bottom-right-radius  border-bottom-left-radius  border-top-left-radius </li><li>值中包含 0，则这个角就是矩形，不会显示为圆角</li></ul><h5 id="margin-定义边界"><a href="#margin-定义边界" class="headerlink" title="margin 定义边界"></a>margin 定义边界</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">margin</span>: &lt;length&gt;;<br><span class="hljs-attribute">margin</span>: top right bottom left;<br><span class="hljs-attribute">margin</span>: top left&amp;right bottom;<br><span class="hljs-attribute">margin</span>: top&amp;bottom left&amp;right;<br></code></pre></div></td></tr></table></figure><ul><li>可分别定义 margin-top margin-bottom margin-left margin-right</li><li>也可在margin中直接设定四个值，使用空格进行分隔，顺序是 上 右 下 左，即从顶部顺时针设置</li><li>某个边不定义大小，可以使用 auto(自动) 关键字代替</li><li>上下不同，左右同可省略最后一个参数</li><li>上下同，左右同，写两个参数即可</li><li>margin 可以取负值，强迫元素偏移原来位置，实现相对定位</li><li>margin: 0 auto 可以起到块状元素居中显示</li></ul><h6 id="边界重叠"><a href="#边界重叠" class="headerlink" title="边界重叠"></a>边界重叠</h6><ul><li>边界重叠只发生在块状元素怒，且只是垂直相邻边界才会发生重叠</li><li>边界重叠时，两个边界中最小的那边将被覆盖</li><li>只有边界才会出现重叠，补白和边框不会出现</li></ul><h5 id="padding-定义补白"><a href="#padding-定义补白" class="headerlink" title="padding 定义补白"></a>padding 定义补白</h5><p>属性值的设置与 margin 相同</p><ul><li>不可为负</li></ul><p>一般开发中，通常清除所有元素的预定义样式：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">* &#123;<br>    <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="opacity-透明度"><a href="#opacity-透明度" class="headerlink" title="opacity 透明度"></a>opacity 透明度</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">opacity</span>: <span class="hljs-number">0</span>~<span class="hljs-number">1</span><br></code></pre></div></td></tr></table></figure><p>数值越低越透明</p><p>早期IE使用：</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">alpha</span>(opacity=<span class="hljs-number">0</span>~<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><h5 id="box-shadow-盒子阴影"><a href="#box-shadow-盒子阴影" class="headerlink" title="box-shadow 盒子阴影"></a>box-shadow 盒子阴影</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: none | &lt;shadow&gt; [, &lt;shadow&gt;]*;<br></code></pre></div></td></tr></table></figure><p>其属性值与 text-shadow 类似</p><ul><li>shadow：<code>inset &amp;&amp; [&lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?]</code> </li><li>inset：设置时时内阴影，默认为外阴影</li><li>也可以多个阴影效果叠加，使用 <code>,</code>  分隔</li></ul><h4 id="完整盒模型-CSS3"><a href="#完整盒模型-CSS3" class="headerlink" title="完整盒模型 CSS3"></a>完整盒模型 CSS3</h4><h5 id="box-sizing-定义尺寸解析方式"><a href="#box-sizing-定义尺寸解析方式" class="headerlink" title="box-sizing 定义尺寸解析方式"></a>box-sizing 定义尺寸解析方式</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-sizing</span>: content-box | border-box | inherit<br></code></pre></div></td></tr></table></figure><ul><li>content-box：初始值，维持 CSS2.1 的组成模式，即元素 width/heigth = content+border+padding</li><li>border-box：重新定义，width/height = content</li></ul><p>webkit引擎 支持 -webkit-border-sizing 私有属性；</p><p>Mozilla Gecko引擎 支持 -moz-border-sizing 私有属性；</p><p>Prest引擎 和 IE浏览器 直接支持该属性</p><h5 id="resize-拖动改变元素尺寸"><a href="#resize-拖动改变元素尺寸" class="headerlink" title="resize 拖动改变元素尺寸"></a>resize 拖动改变元素尺寸</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">resize</span>: none | both | horizontal | vertical | inherit<br></code></pre></div></td></tr></table></figure><ul><li>none：初始值，不提供尺寸调整进制</li><li>both：提供尺寸调整机制，允许用户调节元素的宽度和高度</li><li>horizontal：提供单向水平尺寸调整机制</li><li>vertical：提供单向垂直尺寸调整机制</li><li>inherit：默认继承</li></ul><h5 id="overflow-x-overflow-y-溢出处理"><a href="#overflow-x-overflow-y-溢出处理" class="headerlink" title="overflow-x overflow-y 溢出处理"></a>overflow-x overflow-y 溢出处理</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">overflow-x</span>: visiable | hidden | scroll | auto | no-display | no-contentoverflow-y: visiable | hidden | scroll | auto | no-display | no-content<br></code></pre></div></td></tr></table></figure><ul><li>visiable：默认值，不剪切内容，也不添加滚动条，元素将会被剪切为包含对象的窗口大小，且 clip 属性设置将失效</li><li>auto：在需要时剪切内容并添加滚动条，为 body 和 textarea 的默认值</li><li>hidden：不显示超出元素尺寸的内容</li><li>scroll：当内容超出元素尺寸，则 overflow-x 显示为横向滚动条，overflow-y 显示为纵向滚动条</li><li>no-display：当内容超出元素尺寸，则不显示元素，此时类似添加了 display:none 声明。仅作为交流使用</li><li>no-content：当内容超出元素尺寸，则不显示内容，此时类似添加了 visibility:hidden 声明。仅作为交流使用</li></ul><p>使用时应同时设置 overflow-x 和 overflow-y 的属性值，不要出现一个为 hidden，而另一个为 visiable 的情况；</p><p>还要避免编写依赖指定值为 visiable 的 overflow-x 和 overflow-y 属性的计算值的代码</p><h5 id="outline-定义轮廓"><a href="#outline-定义轮廓" class="headerlink" title="outline 定义轮廓"></a>outline 定义轮廓</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline</span>: [outline-color] || [outline-style] || [outline-width] || [outline-offset] || inherit<br></code></pre></div></td></tr></table></figure><ul><li>定义颜色、轮廓样式、宽度、偏移位置的数值</li><li>可以将轮廓线理解为飘在元素上方，不占位置，显不显示轮廓线不会影响文档流，也不会破坏网页布局</li><li>轮廓线有可能是非矩形的</li></ul><h6 id="outline-width-轮廓宽度"><a href="#outline-width-轮廓宽度" class="headerlink" title="outline-width 轮廓宽度"></a>outline-width 轮廓宽度</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline-width</span>: thin | medium | thick | &lt;length&gt; | inherit<br></code></pre></div></td></tr></table></figure><p>不允许设置负值</p><h6 id="outline-style-轮廓样式"><a href="#outline-style-轮廓样式" class="headerlink" title="outline-style 轮廓样式"></a>outline-style 轮廓样式</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline-style</span>: auto | &lt;border-style&gt; | inherit<br></code></pre></div></td></tr></table></figure><ul><li>auto：根据浏览器自动设置</li><li>border-style：沿用边框样式</li><li>inherit：默认继承</li></ul><h6 id="outline-color-轮廓颜色"><a href="#outline-color-轮廓颜色" class="headerlink" title="outline-color 轮廓颜色"></a>outline-color 轮廓颜色</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline-color</span>: &lt;color&gt; | invert | inherit<br></code></pre></div></td></tr></table></figure><ul><li>color：颜色类型值</li><li>invert：执行颜色反转（逆向的颜色），确保轮廓线在不同的背景颜色中都是可见的</li><li>inherit：默认继承</li></ul><h6 id="outline-offset-轮廓偏移"><a href="#outline-offset-轮廓偏移" class="headerlink" title="outline-offset 轮廓偏移"></a>outline-offset 轮廓偏移</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">outline-offset</span>: &lt;length&gt; | inherit<br></code></pre></div></td></tr></table></figure><p>定义轮廓距离容器的值</p><h4 id="背景-background"><a href="#背景-background" class="headerlink" title="背景 background"></a>背景 background</h4><h5 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h5><p><code>background: rgba(0, 0, 0, a);</code> 可以实现半透明</p><h5 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background</span>: none | <span class="hljs-built_in">url</span>()<br></code></pre></div></td></tr></table></figure><p>CSS3 支持 渐变背景，其规则比较复杂，使用时查看文档</p><h5 id="background-repeat-显示方式"><a href="#background-repeat-显示方式" class="headerlink" title="background-repeat 显示方式"></a>background-repeat 显示方式</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-repeat</span>: repeat-x | repeat-y | [repeat | space | round | no-repeat]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>repeat-x：背景图像在横向上平铺</li><li>repeat-y：背景图像在纵向上平铺</li><li>repeat：在横向和纵向平铺</li><li>no-repeat：不平铺</li><li>round：自动缩放到直到适应且填充满整个容器</li><li>space：以相同的间距平铺且填充满整个容器或某个方向</li></ul><h5 id="background-position-显示位置"><a href="#background-position-显示位置" class="headerlink" title="background-position 显示位置"></a>background-position 显示位置</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-position</span>: [left | center | right | top | bottom]<br></code></pre></div></td></tr></table></figure><ul><li>默认值为 0% 0%，等效于 left top</li></ul><h5 id="background-attachment-背景附着"><a href="#background-attachment-背景附着" class="headerlink" title="background-attachment 背景附着"></a>background-attachment 背景附着</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-attachment</span>: fixed | local | scroll<br></code></pre></div></td></tr></table></figure><ul><li>fixed：背景图像相对于浏览器窗体固定</li><li>local：背景图像相对于元素内容固定</li><li>scroll：背景图像相对于元素固定</li></ul><h5 id="background-origin-定义坐标"><a href="#background-origin-定义坐标" class="headerlink" title="background-origin 定义坐标"></a>background-origin 定义坐标</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-origin</span>: border-box | padding-box | content-box<br></code></pre></div></td></tr></table></figure><ul><li>border-box：从边框区域开始显示背景</li><li>padding-box：从补白区域开始显示背景</li><li>content-box：仅在内容区域显示背景</li></ul><p>Webkit 引擎还支持 -webkit-backgroundorigin</p><p>Mozilla Gecko 引擎支持 -moz-background-origin</p><h5 id="background-clip-定义裁剪区域"><a href="#background-clip-定义裁剪区域" class="headerlink" title="background-clip 定义裁剪区域"></a>background-clip 定义裁剪区域</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-clip</span>: border-box | padding-box | content-box | text<br></code></pre></div></td></tr></table></figure><ul><li>border-box：从边框区域开始显示背景</li><li>padding-box：从补白区域开始显示背景</li><li>content-box | content：仅在内容区域显示背景</li><li>text：从前景内容（如文字）区域向外裁剪背景</li></ul><p>Webkit 引擎还支持 -webkit-backgroundclip</p><p>Mozilla Gecko 引擎支持 -moz-background-clip</p><p>Presto 引擎 和 IE9+ 引擎支持该属性部分取值</p><p>FireFox 不支持该 text 值</p><h5 id="background-size-背景图片大小"><a href="#background-size-背景图片大小" class="headerlink" title="background-size 背景图片大小"></a>background-size 背景图片大小</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background-size</span>: [&lt;length&gt; | &lt;percentage&gt; | auto]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125; | cover | contain;<br></code></pre></div></td></tr></table></figure><ul><li>尽量只改一个，防止图片比例被破坏</li><li>可以是百分比值</li><li>cover：图片进行等比例缩放，直到填满背景盒子</li><li>contain：图片进行等比例缩放，直到碰到背景框</li></ul><p>Webkit 引擎还支持 -webkit-backgroundsize</p><p>Mozilla Gecko 引擎支持 -moz-background-size</p><h5 id="background-break-定义循环方式"><a href="#background-break-定义循环方式" class="headerlink" title="background-break 定义循环方式"></a>background-break 定义循环方式</h5><p>定义平铺内联元素背景图像时的循环方式</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">background</span>-break: bounding-box | each-box | coninuous<br></code></pre></div></td></tr></table></figure><ul><li>Firefox 中使用 -moz-background-inline-policy</li><li>其他浏览器还不支持</li></ul><h5 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h5><p><code>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</code></p><p>例子： <code>background: #000 url() no-repeat fixed center -25px;</code> </p><p>可以设置多背景图像</p><p><code>background: url(1) ... , url(2) ...;</code> </p><ul><li>每组之间逗号分隔，有交集则前面的覆盖后面的</li><li>背景色一般设置在最后一组</li><li>允许多重指定的属性有：background-image，background-repeat，background-position，background-clip，background-origin，background-size</li></ul><h4 id="动画-transform"><a href="#动画-transform" class="headerlink" title="动画 transform"></a>动画 transform</h4><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: none | &lt;transform-function&gt; [ &lt;transform-function&gt; ]*<br></code></pre></div></td></tr></table></figure><ul><li>初始值是 none，适用于块元素和行内元素</li><li>transform-function：设置变换函数，可以是一个或多个变换函数列表</li><li>各早期版本浏览器支持的私有属性：-webkit-transform、moz-transform、-o-tranform、-ms-tranform</li></ul><h5 id="2D-变换"><a href="#2D-变换" class="headerlink" title="2D 变换"></a>2D 变换</h5><h6 id="rotate-定义旋转"><a href="#rotate-定义旋转" class="headerlink" title="rotate() 定义旋转"></a>rotate() 定义旋转</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">rotate(&lt;angle&gt;)<br></code></pre></div></td></tr></table></figure><h6 id="scale-定义缩放"><a href="#scale-定义缩放" class="headerlink" title="scale() 定义缩放"></a>scale() 定义缩放</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">scale(&lt;number&gt; <span class="hljs-selector-attr">[, &lt;number&gt;]</span>)<br></code></pre></div></td></tr></table></figure><ul><li>两个参数表示定义宽和高缩放比例，第二个参数省略表示两值相同</li><li>number 参数值可以是正数、负数和小数<ul><li>正数值基于指定的宽度和高度将放大元素</li><li>负数表示翻转元素（如文字反转），然后再缩放元素</li><li>使用小于一的正数可以缩小元素</li></ul></li><li>可以使用 <strong>scaleX()</strong> 和 <strong>scaleY()</strong> 分别设置</li></ul><h6 id="translate-定义移动"><a href="#translate-定义移动" class="headerlink" title="translate() 定义移动"></a>translate() 定义移动</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">translate(&lt;translation-value&gt; <span class="hljs-selector-attr">[, &lt;translation-value&gt;]</span>)<br></code></pre></div></td></tr></table></figure><ul><li>分别表示 x轴 和 y轴 相对于原位置的偏移距离</li><li>省略第二个参数则第二个参数默认为 0</li><li>为负值为反向偏移</li><li>可以使用 <strong>translateX()</strong> 和 <strong>translateY()</strong> 分别设置</li></ul><h6 id="skew-定义倾斜"><a href="#skew-定义倾斜" class="headerlink" title="skew() 定义倾斜"></a>skew() 定义倾斜</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">skew(&lt;angle&gt; <span class="hljs-selector-attr">[, &lt;angle&gt;]</span>)<br></code></pre></div></td></tr></table></figure><ul><li>以 x轴和 或 y轴 为轴旋转，与 rotate() 不同，这个会改变形状</li><li>可以使用 <strong>skewX()</strong> 和 <strong>skewY()</strong> 分别设置</li></ul><h6 id="matrix-定义矩阵"><a href="#matrix-定义矩阵" class="headerlink" title="matrix() 定义矩阵"></a>matrix() 定义矩阵</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)<br></code></pre></div></td></tr></table></figure><p>1 到 6 参数分别代表：x轴缩放、x轴倾斜、y轴倾斜、y轴缩放、x轴移动、y轴移动</p><h5 id="3D-变换"><a href="#3D-变换" class="headerlink" title="3D 变换"></a>3D 变换</h5><h6 id="translate3d-定义位移"><a href="#translate3d-定义位移" class="headerlink" title="translate3d() 定义位移"></a>translate3d() 定义位移</h6><p>增加了可以让元素在 3D 空间延 Z轴 进行位移</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">translate3d(tx, ty, tz)<br></code></pre></div></td></tr></table></figure><ul><li>tz：不能是一个百分比值，负责会被视为无效值</li><li>可以使用 <strong>translateZ()</strong> 单独设置 Z轴</li></ul><h6 id="scale3d-定义缩放"><a href="#scale3d-定义缩放" class="headerlink" title="scale3d() 定义缩放"></a>scale3d() 定义缩放</h6><p>增加了可以让元素在 3D 空间在 Z轴 方向上按比例缩放</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">scale3d(sx, sy, sz)<br></code></pre></div></td></tr></table></figure><ul><li>可以使用 <strong>scaleZ()</strong> 单独设置 Z轴</li><li>scaleZ(-1) 定义了一个原点在 Z轴 的对称点（按照元素的交换原点）</li></ul><h6 id="rotate3d-定义旋转"><a href="#rotate3d-定义旋转" class="headerlink" title="rotate3d() 定义旋转"></a>rotate3d() 定义旋转</h6><p>增加了可以让元素在 3D 空间在 Z轴 方向上按比例缩放</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">rotate3d(x, y, z, <span class="hljs-selector-tag">a</span>)<br></code></pre></div></td></tr></table></figure><ul><li>x, y, z 均为 0~1 之间的数值，分别描述元素围绕 x, y, z 轴旋转的矢量值</li><li>可以使用 <strong>rotateX(a)</strong> <strong>rotateY(a)</strong> 和 <strong>rotateZ(a)</strong> 分别设置</li><li>a：是一个角度值，主要用来指定元素在 3D空间旋转的角度，为正顺时针转，为负逆时针转</li></ul><h5 id="transfrom-origin-改变变换中心"><a href="#transfrom-origin-改变变换中心" class="headerlink" title="transfrom-origin 改变变换中心"></a>transfrom-origin 改变变换中心</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform-origin</span>: [ [ &lt;percentage&gt; | &lt;length&gt; | left | center | right ] [ &lt;percentage&gt; | &lt;length&gt; | top | center | bottom ]? ]<br></code></pre></div></td></tr></table></figure><ul><li>CSS 变换的原点默认为对象的中心点</li><li>接收两个参数，可以是产具体值，也可以是关键词</li></ul><h5 id="transition-设置过渡动画"><a href="#transition-设置过渡动画" class="headerlink" title="transition 设置过渡动画"></a>transition 设置过渡动画</h5><h6 id="transition-property-设置过渡属性"><a href="#transition-property-设置过渡属性" class="headerlink" title="transition-property 设置过渡属性"></a>transition-property 设置过渡属性</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-property</span>: none | all | [ &lt;IDENT&gt; ] [ <span class="hljs-string">&#x27;,&#x27;</span> &lt;IDENT&gt; ]*<br></code></pre></div></td></tr></table></figure><ul><li>none：表示没有元素</li><li>all：默认值，表示针对所有元素，包括 :before 和 :after 伪元素</li><li>IDENT：指定 CSS 属性列表，几乎所有色彩、大小或位置等相关的 CSS 属性，都可以应用过渡</li></ul><h6 id="transition-duration-设置过渡时间"><a href="#transition-duration-设置过渡时间" class="headerlink" title="transition-duration 设置过渡时间"></a>transition-duration 设置过渡时间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-duration</span>: &lt;time&gt; [, &lt;time&gt;]*<br></code></pre></div></td></tr></table></figure><p>初始值为 0，适用于所有元素，包括 :before 和 :after 伪元素</p><h6 id="transition-delay-设置延迟时间"><a href="#transition-delay-设置延迟时间" class="headerlink" title="transition-delay 设置延迟时间"></a>transition-delay 设置延迟时间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-delay</span>: &lt;time&gt; [, &lt;time&gt;]*<br></code></pre></div></td></tr></table></figure><ul><li>初始值为 0，适用于所有元素，包括 :before 和 :after 伪元素</li><li>设置时间可以为正整数、负整数和 0</li><li>为 0 时 必须设置单位是 s 或者 ms</li><li>为负数时，过渡的动作会从该时间点开始显示，之前的动作被截断</li><li>为正数时，过渡的动作会延迟触发</li></ul><h6 id="transition-timing-function-设置过渡动画类型"><a href="#transition-timing-function-设置过渡动画类型" class="headerlink" title="transition-timing-function 设置过渡动画类型"></a>transition-timing-function 设置过渡动画类型</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-timing-function</span>: ease | linear | ease-in | ease-out | ease-in-out | <span class="hljs-built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear | ease-in | ease-out | ease-in-out | <span class="hljs-built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) ]*<br></code></pre></div></td></tr></table></figure><ul><li>ease：平滑过渡，等同于 cubic-bezier(0.25, 0.1, 0.25, 1.0) 函数</li><li>linear：线性过渡，等同于 cubic-bezier(0.0, 0.0, 1.0, 1.0) 函数</li><li>ease-in：由慢到快，等同于 cubic-bezier(0.42, 0, 1.0, 1.0) 函数</li><li>ease-out：由快到慢，等同于 cubic-bezier(0, 0, 0.58, 1.0) 函数</li><li>ease-in-out：由慢到快再到慢，等同于 cubic-bezier(0.42, 0, 0.58, 1.0) 函数</li><li>cubic-bezier：特殊的立方贝塞尔曲线效果</li></ul><h6 id="设置触发效果"><a href="#设置触发效果" class="headerlink" title="设置触发效果"></a>设置触发效果</h6><p>一般通过鼠标事件或状态定义动画，如 CSS伪类 和 JavaScript 事件</p><ul><li>:link、:visited、:hover、:active、:focus、:checked</li><li>click、focus、mousemove、mouseover、mouseout 等</li></ul><h5 id="animation-设置帧动画"><a href="#animation-设置帧动画" class="headerlink" title="animation 设置帧动画"></a>animation 设置帧动画</h5><p>功能和 transition 相同，区别在于：</p><ul><li>transition 只能指定属性的开始值和结束值，及其之间的过渡效果</li><li>animation 可以定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果</li></ul><p>兼容性：</p><ul><li>-webkit-animation、-moz-animation、-o-animation</li><li>IE6~9 不支持 animation 属性</li></ul><h6 id="keyframes-设置关键帧"><a href="#keyframes-设置关键帧" class="headerlink" title="@keyframes 设置关键帧"></a>@keyframes 设置关键帧</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@keyframes</span> animationname &#123;<br>    keyframes-selector &#123;<br>        css-styles;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ul><li>animationname：定义动画名称</li><li>keyframes-selector：定义帧的事件未知，也就是动画时长的百分比<ul><li>可取值：0%~100%、from（等价于 0%）、to（等价于 100%）</li></ul></li><li>css-styles：表示一个或多个合法的 CSS 样式属性</li><li>为了避免有兼容性的问题，应始终定义 0% 和 100% 位置帧</li></ul><h6 id="animation-name-定义动画名称"><a href="#animation-name-定义动画名称" class="headerlink" title="animation-name 定义动画名称"></a>animation-name 定义动画名称</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-name</span>: none | IDENT [, none | IDENT]*<br></code></pre></div></td></tr></table></figure><p>初始值为 none，定义一个适用的动画列表</p><h6 id="animation-duration-定义动画时间"><a href="#animation-duration-定义动画时间" class="headerlink" title="animation-duration 定义动画时间"></a>animation-duration 定义动画时间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-duration</span>: &lt;time&gt; [, &lt;time&gt;]*<br></code></pre></div></td></tr></table></figure><ul><li>定义播放时间</li><li>默认属性值为 0</li><li>为负值时，被视为 0</li></ul><h6 id="animation-timing-function-设置过渡动画类型"><a href="#animation-timing-function-设置过渡动画类型" class="headerlink" title="animation-timing-function 设置过渡动画类型"></a>animation-timing-function 设置过渡动画类型</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-timing-function</span>: ease | linear | ease-in | ease-out | ease-in-out | <span class="hljs-built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear | ease-in | ease-out | ease-in-out | <span class="hljs-built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) ]*<br></code></pre></div></td></tr></table></figure><p>初始值为 ease，参数值和 transition-timing-function 相同</p><h6 id="animation-delay-定义延迟时间"><a href="#animation-delay-定义延迟时间" class="headerlink" title="animation-delay 定义延迟时间"></a>animation-delay 定义延迟时间</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-delay</span>: &lt;time&gt; [, &lt;time&gt;]*<br></code></pre></div></td></tr></table></figure><p>允许一个动画开始执行一段时间后才被应用</p><h6 id="animation-iteration-count-定义播放次数"><a href="#animation-iteration-count-定义播放次数" class="headerlink" title="animation-iteration-count 定义播放次数"></a>animation-iteration-count 定义播放次数</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-iteration-count</span>: infinite | &lt;number&gt; [, infinite | &lt;number&gt;]*<br></code></pre></div></td></tr></table></figure><ul><li>默认值为 1，动画只播放一次</li><li>infinite 表示无限次，即 CSS 动画永远重复</li><li>取值为非整数，将导致动画结束一个周期的一部分</li><li>值为负数，则在交替周期内反向播放动画</li></ul><h6 id="animation-direction-定义播放方向"><a href="#animation-direction-定义播放方向" class="headerlink" title="animation-direction 定义播放方向"></a>animation-direction 定义播放方向</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-direction</span>: normal | alternate [, normal | alternate]*<br></code></pre></div></td></tr></table></figure><ul><li>normal：默认值，每次循环都是向前播放</li><li>alternate：表示第偶数次向前播放，第奇数次项反方向播放</li></ul><h6 id="animation-play-state-定义播放状态"><a href="#animation-play-state-定义播放状态" class="headerlink" title="animation-play-state 定义播放状态"></a>animation-play-state 定义播放状态</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-play-state</span>: paused | running<br></code></pre></div></td></tr></table></figure><ul><li><p>running：初始值，定义动画正在播放</p></li><li><p>paused：定义动画已暂停</p></li><li><p>可以在 JavaScript 中使用该属性</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">object.style.animationPlayState=<span class="hljs-string">&quot;paused&quot;</span><br></code></pre></div></td></tr></table></figure></li></ul><h6 id="animation-fill-mode-定义播放外状态"><a href="#animation-fill-mode-定义播放外状态" class="headerlink" title="animation-fill-mode 定义播放外状态"></a>animation-fill-mode 定义播放外状态</h6><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-fill-mode</span>: none | forwards | backwards | both [, none | forwards | backwards | both ]*<br></code></pre></div></td></tr></table></figure><ul><li>none：初始值，不设置对象动画外的转态</li><li>forwards：设置对象状态为动画结束时的状态</li><li>backwards：设置对象状态为动画开始时的状态</li><li>both：设置对象状态为动画结束或开始的状态</li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="list-style-image-列表符号"><a href="#list-style-image-列表符号" class="headerlink" title="list-style-image 列表符号"></a>list-style-image 列表符号</h5><p>自定义项目符号，允许指定一个外部图标文件</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">list-style-image</span>: none | <span class="hljs-built_in">url</span>()<br></code></pre></div></td></tr></table></figure><ul><li>自定义项目符号存在时，会覆盖 list-style-type 设置的符号</li><li>比较简陋，可以利用背景图精确定位，然后左侧留白巧妙达到效果，需要取消默认样式</li></ul><h5 id="list-style-position-符号位置"><a href="#list-style-position-符号位置" class="headerlink" title="list-style-position 符号位置"></a>list-style-position 符号位置</h5><h5 id="list-style-type-符号类型"><a href="#list-style-type-符号类型" class="headerlink" title="list-style-type 符号类型"></a>list-style-type 符号类型</h5><table><thead><tr><th>属性值</th><th>说明</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>disc</td><td>实心圆，默认值</td><td>upper-roman</td><td>大写罗马数字</td></tr><tr><td>circle</td><td>空心圆</td><td>lower-alpha</td><td>小写英文字母</td></tr><tr><td>square</td><td>实心方块</td><td>upper-alpha</td><td>大写英文字母</td></tr><tr><td>decimal</td><td>阿拉伯数字</td><td>none *</td><td>不使用项目符号</td></tr><tr><td>lower-roman</td><td>小写罗马数字</td><td>armenian</td><td>传统的亚美尼亚数字</td></tr><tr><td>cjk-ideographic</td><td>浅白的表意数字</td><td>georgian</td><td>传统的乔治数字</td></tr><tr><td>lower-greek</td><td>基本的希腊小写字母</td><td>hebrew</td><td>传统的希伯莱数字</td></tr><tr><td>hiragana</td><td>日文平假名字符</td><td>hiragana-iroha</td><td>日文平假名序号</td></tr><tr><td>katakana</td><td>日文片假名字符</td><td>katakana-iroha</td><td>日文片假名序号</td></tr><tr><td>lower-latin</td><td>小写拉丁字母</td><td>upper-latin</td><td>大写拉丁字母</td></tr></tbody></table><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><h5 id="initial-取消样式指定"><a href="#initial-取消样式指定" class="headerlink" title="initial 取消样式指定"></a>initial 取消样式指定</h5><p>让各种属性使用默认值，例：<code>color: initial; /* 恢复到浏览器默认的黑色字体 */</code>  </p><h5 id="inherit-默认继承"><a href="#inherit-默认继承" class="headerlink" title="inherit 默认继承"></a>inherit 默认继承</h5><p>默认继承来自父辈的该属性的属性值</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="cursor-定义鼠标样式"><a href="#cursor-定义鼠标样式" class="headerlink" title="cursor 定义鼠标样式"></a>cursor 定义鼠标样式</h5><ul><li>auto：根据上下文决定应该显示什么光标</li><li>crosshair：十字线光标（+）</li><li>default：基于平台的默认光标，通常渲染为一个箭头</li><li>pointer：指针光标，表示一个超链接<ul><li><code>cursor: hand;</code> ：兼容 IE6 以下版本浏览器</li></ul></li><li>move：十字箭头光标，用于标示对象可被移动</li><li>e-resize|ne-resize|nw-resize|n-resize|se-resize|sw-resize|s-resize|resize：表示正在移动某个边或某个角的鼠标箭头样式</li><li>text：表示可以选择文本，通常渲染为 I 型光标</li><li>wait：表示程序正忙，需要用户等待，通常渲染为手表或沙漏</li><li>help：光标下的对象包含有帮助内容，通常渲染为一个问号或一个气球</li><li>&lt;url&gt;URL：自定义光标类型的图标路径<ul><li>IE 和 Opera 仅支持 *.cur 等待定的图片格式</li><li>其他几款既支持特定图片类型，也支持常见的 jpg png gif 等类型</li></ul></li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><h5 id="CSS样式表的优先级"><a href="#CSS样式表的优先级" class="headerlink" title="CSS样式表的优先级"></a>CSS样式表的优先级</h5><p>作者定义的样式 &gt; 用户设置的样式 &gt; 浏览器的默认样式 &gt; HTML的默认样式</p><p>特殊：</p><p>CSS2中，用户设置的带 !important 的样式要优先于 作者声明的 !important 样式</p><h5 id="CSS样式的优先级"><a href="#CSS样式的优先级" class="headerlink" title="CSS样式的优先级"></a>CSS样式的优先级</h5><p>计算权值的方式判断优先级</p><ul><li>权值为 0 的：通配符选择器</li><li>权值为 1 的：标签选择器、伪元素选择器、伪对象选择器</li><li>权值为 10 的：类选择器、属性选择器</li><li>权值为 100 的：ID选择器</li></ul><p>对于多个选择器组合而成的复合型选择器，分别计算后相加</p><ol><li>分值越高优先级越高</li><li>若分值相同则根据位置关系来进行判断，越靠近对象的优先级越高</li></ol><p>另外，<code>!important</code> 表示最大优先级，要放置在声明语句与分号之间</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;    <span class="hljs-attribute">font-size</span>: <span class="hljs-number">16px</span><span class="hljs-meta">!important</span>;&#125;<br></code></pre></div></td></tr></table></figure><p>被继承的值具有特殊性，权值为 0</p><p>即不管父级样式的优先级多大，被子级元素继承时，该原始的优先级权重都为 0</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css">        <span class="hljs-selector-id">#header</span> &#123;<span class="hljs-attribute">color</span>: blue;        &#125;        <span class="hljs-selector-tag">span</span> &#123;            <span class="hljs-attribute">color</span>: grey;        &#125;    </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;header&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;blue&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>遗产继承不如白手起家<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span> <span class="hljs-comment">&lt;!-- 为灰色而不是蓝色 --&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li>内联样式优先级更高</li><li>在相同特殊性下，遵循就近原则</li><li><code>!important</code> 有最大优先权，不论远近<ul><li>但继承的 <code>!important</code> 内的样式也还是 0</li></ul></li></ul><h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>指被包含的元素将拥有外层元素的样式效果</p><h4 id="显示类型-1"><a href="#显示类型-1" class="headerlink" title="显示类型"></a>显示类型</h4><h5 id="块状元素-Block"><a href="#块状元素-Block" class="headerlink" title="块状元素 Block"></a>块状元素 Block</h5><p>宽度一般为 100%，占据一行</p><p>address、blockquote、div、dl、fieldset、form、h1~h6、hr、noframes、noscript、ol、p、pre、table、ul、li、legend</p><h5 id="行内元素-Inline"><a href="#行内元素-Inline" class="headerlink" title="行内元素 Inline"></a>行内元素 Inline</h5><p>没有固定的大小，定义它的 width 和 height 属性无效，可以在行内自由流动，可以定义边界、补白、边框和背景</p><p>其显示的高度和宽度只能够根据所包含内容的高度和宽度来确定</p><p>a、abbr、acronym、b、bdo、big、br、button、cite、code、dfn、em、i、img、input、kbd、label、map、object、q、samp、script、select、small、span、strike、strong、sub、textarea、tt、var</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
      <tag>CSS3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML笔记</title>
    <link href="/2021/08/03/HTML%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/08/03/HTML%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是最基础的网页开发语言</p><p>Hyper Text Markup Language 超文本标记语言</p><ul><li>超文本:<ul><li>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</li></ul></li><li>标记语言:<ul><li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li><li>标记语言不是编程语言</li></ul></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li><p>html文档后缀名 .html 或者 .htm</p></li><li><p>标签分为</p><ol><li>围堵标签：有开始标签和结束标签。如 <code>&lt;html&gt;&lt;/html&gt;</code> </li><li>自闭合标签：开始标签和结束标签在一起。如 <code>&lt;br/&gt;</code> </li></ol></li><li><p>标签可以嵌套：</p></li></ol><p>  需要正确嵌套，不能你中有我，我中有你</p><ul><li><p>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code> </p></li><li><p>正确：<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code> </p></li></ul><ol start="4"><li><p>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p></li><li><p>html的标签不区分大小写，但是建议使用小写。</p></li></ol><ul><li>代码：  <figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">FONT</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;red&#x27;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">FONT</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&#x27;green&#x27;</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul><h3 id="标签学习"><a href="#标签学习" class="headerlink" title="标签学习"></a>标签学习</h3><h4 id="文件标签"><a href="#文件标签" class="headerlink" title="文件标签"></a>文件标签</h4><p>构成html最基 本的标签</p><ul><li>html : html文档的根标签</li><li>head : 头标签。用于指定html文档的一些属性。引入外部的资源</li><li>title : 标题标签</li><li>body : 体标签</li><li><code>&lt;!DOCTYPE html&gt;</code> : html5 中定义该文档是 html文档</li></ul><h4 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h4><p>和文本有关的标签</p><ul><li><p>注释：<!-- 注释内容 --></p></li><li><p>标题标签 : <code>&lt;h1&gt; ... &lt;h6&gt;</code></p><ul><li>h1 ~ h6 : 字体大小逐渐递减</li></ul></li><li><p><code>&lt;p&gt;&lt;/p&gt;</code> : 段落标签</p></li><li><p><code>&lt;br/&gt;</code> 或 <code>&lt;br&gt;</code> ：换行标签</p></li><li><p><code>&lt;hr&gt;</code> : 展示一条水平线</p><p>属性：</p><ul><li>color：颜色</li><li>width：宽度</li><li>size：高度</li><li>align：对其方式<ul><li>center：居中</li><li>left：左对齐</li><li>right：右对齐</li></ul></li></ul></li><li><p><code>&lt;b&gt;&lt;/b&gt;</code> : 字体加粗</p></li><li><p><code>&lt;i&gt;&lt;/i&gt;</code> : 字体斜体</p></li><li><p><code>&lt;font&gt;&lt;/font&gt;</code> : 字体标签</p><p>属性：</p><ul><li>color：颜色</li><li>size：大小</li><li>face：字体</li></ul></li><li><p><code>&lt;center&gt;&lt;/center&gt;</code> : 文本居中</p></li></ul><h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><ul><li>color：<ol><li>英文单词：red,green,blue</li><li>rgb(值1，值2，值3)：值的范围：0~255  如  rgb(0,0,255)</li><li>#值1值2值3：值的范围：00~FF之间。如： #FF00FF</li></ol></li><li>width：<ol><li>数值：<code>width=&#39;20&#39;</code> 数值的单位默认是 px(像素)</li><li>数值%：占比相对于父元素的比例</li></ol></li></ul><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><p><code>&lt;img src=&quot;&quot;&gt;</code> : 展示图片</p><div class="hljs code-wrapper"><pre><code>    * 属性：        * src：指定图片的位置</code></pre></div><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><p>有序列表：</p><p><code>&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code> </p><p>无序列表：</p><p><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code> </p><p>自定义列表：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">dl</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dt</span>&gt;</span>自定义列表题目<span class="hljs-tag">&lt;/<span class="hljs-name">dt</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>内容描述1<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dd</span>&gt;</span>内容描述2<span class="hljs-tag">&lt;/<span class="hljs-name">dd</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dl</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h4><p><code>&lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt;</code> : 定义一个超链接</p><p>属性：</p><ul><li>href：指定访问资源的URL(统一资源定位符)</li><li>target：指定打开资源的方式<ul><li><code>_self</code> : 默认值，在当前页面打开</li><li><code>_blank</code> : 在空白页面打开</li></ul></li></ul><h4 id="div-amp-span"><a href="#div-amp-span" class="headerlink" title="div &amp; span"></a>div &amp; span</h4><ul><li><code>&lt;div&gt;&lt;/div</code> : 每一个div占满一整行，块级标签；</li><li><code>&lt;span&gt;&lt;/span&gt;</code> : 文本信息在一行展示，行内标签，内联标签</li></ul><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>html5 中为了提高程序的可读性，提供了一些标签</p><ul><li><code>&lt;header&gt;&lt;/header&gt;</code> : 页眉</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code> : 页脚</li></ul><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><p><code>&lt;table&gt;&lt;/table&gt;</code> : 定义表格</p><ul><li>width：宽度</li><li>border：边框</li><li>cellpadding：定义内容和单元格的距离</li><li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条、</li><li>bgcolor：背景色</li><li>align：对齐方式</li></ul><p><code>&lt;tr&gt;&lt;/tr&gt;</code> : 定义行</p><ul><li>bgcolor：背景色</li><li>align：对齐方式</li></ul><p><code>&lt;td&gt;&lt;/td&gt;</code> : 定义单元格</p><ul><li>colspan：合并列 左右</li><li>rowspan：合并行 上下 先上 先左</li></ul><p><code>&lt;th&gt;&lt;/th&gt;</code> : 定义表头单元格</p><p><code>&lt;caption&gt;&lt;/caption&gt;</code> : 表格标题，在table内写</p><p><code>&lt;thead&gt;&lt;/thead&gt;</code> : 表示表格的头部分</p><p><code>&lt;tbody&gt;&lt;/tbody&gt;</code> : 表示表格的体部分</p><p><code>&lt;tfoot&gt;&lt;/tfoot&gt;</code> : 表示表格的脚部分</p><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>用于采集用户输入的数据的。用于和服务器进行交互。</p><p><code>&lt;form&gt;&lt;/form&gt;</code> : 用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><ul><li>属性：<ul><li>action : 指定提交数据的 URL</li><li>method : 指定提交方式，一共有七种，常用的有两种<ul><li>get：<ul><li>请求参数会在地址栏中显示。会封装到请求行中</li><li>请求参数大小是有限制的</li><li>不太安全</li></ul></li><li>post：<ul><li>请求参数不会再地址栏中显示。会封装在请求体中</li><li>请求参数的大小没有限制</li><li>较为安全</li></ul></li></ul></li></ul></li></ul><p>表单项中的数据要想被提交，必须指定其 name 属性</p><h4 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h4><h5 id="input"><a href="#input" class="headerlink" title="input"></a>input</h5><p><code>&lt;input type=&quot;&quot;&gt;&lt;/input&gt;</code> : type 属性值，改变元素展示的样式</p><p>type 的属性值：</p><table><thead><tr><th align="center">属性值</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">文本输入框</td><td align="center">默认值</td></tr><tr><td align="center">password</td><td align="center">密码输入框</td><td align="center">内容隐藏</td></tr><tr><td align="center">email</td><td align="center">邮箱格式输入框</td><td align="center"></td></tr><tr><td align="center">number</td><td align="center">仅接受数字</td><td align="center"></td></tr><tr><td align="center">search</td><td align="center">搜索框</td><td align="center">自带 X 号，可全文删除</td></tr><tr><td align="center">range</td><td align="center">滑块</td><td align="center"></td></tr><tr><td align="center">time</td><td align="center">获得小时和分钟</td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">获得年月日</td><td align="center"></td></tr><tr><td align="center">month</td><td align="center">获得年月</td><td align="center"></td></tr><tr><td align="center">week</td><td align="center">获得星期</td><td align="center"></td></tr><tr><td align="center">color</td><td align="center">获得颜色</td><td align="center"></td></tr><tr><td align="center">radio</td><td align="center">单选框</td><td align="center">多个单选框实现单选 : name属性值必须一样<br>value 属性，指定其被选中后提交的值<br>checked 属性，可以指定默认值</td></tr><tr><td align="center">checkbox</td><td align="center">复选框</td><td align="center">value 属性，指定其被选中后提交的值<br>checked 属性，可以指定默认值</td></tr><tr><td align="center">file</td><td align="center">文件选择框</td><td align="center">multiple : 多文件上传</td></tr><tr><td align="center">hidden</td><td align="center">隐藏域</td><td align="center">用于提交一些信息</td></tr><tr><td align="center">submit</td><td align="center">提交按钮</td><td align="center">点击可以提交表单</td></tr><tr><td align="center">button</td><td align="center">普通按钮</td><td align="center"></td></tr><tr><td align="center">reset</td><td align="center">重置按钮</td><td align="center">清空 from 中全文</td></tr><tr><td align="center">image</td><td align="center">图片提交按钮</td><td align="center">src : 指定图片的路径</td></tr></tbody></table><p>属性：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">maxlength</td><td align="center">控制输入最多的字符</td></tr><tr><td align="center">value</td><td align="center">默认显示数据</td></tr><tr><td align="center">placeholder</td><td align="center">指定输入框的提示信息，输入框为空时显示</td></tr><tr><td align="center">autofocus</td><td align="center">页面加载完成自动获得焦点</td></tr><tr><td align="center">autocomplete</td><td align="center">自动记录输入内容，需要提交按钮，要有name<br>参数：on || off</td></tr><tr><td align="center">require</td><td align="center">必填项</td></tr><tr><td align="center">accesskey</td><td align="center">指定聚焦到元素的快捷键，alt + 字母</td></tr><tr><td align="center">label</td><td align="center">指定输入框的文字描述信息</td></tr></tbody></table><p>注意：label 的for属性一般会和 input 的 id属性值 对应。如果对应了，则点击label区域，会让input输入框获取焦点</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>下拉列表，子元素列表选项为 <code>&lt;option&gt;&lt;/option&gt;</code></p><h5 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h5><p>下拉列表选择，子元素 option 指定列表项 与input使用id实现链接</p><h5 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h5><p>文本域</p><ul><li>cols : 指定列数，每一行有多少个字符</li><li>row : 默认多少行</li></ul><h5 id="filedset"><a href="#filedset" class="headerlink" title="filedset"></a>filedset</h5><p>打包，可以将表单内的相关元素打包，分组</p><h2 id="文档结构和基本语法"><a href="#文档结构和基本语法" class="headerlink" title="文档结构和基本语法"></a>文档结构和基本语法</h2><h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>The Extensible HyperText Markup Language  =&gt;  可扩展标识语言</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 定义文档类型 doctype -&gt; document type 使用时必须大写 --&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD XHTML1.0 Transitional//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 声明文档命名空间 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 设置文档字符编码--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=gb2312&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>XHTML 是 HTML 向 XML 过渡的标识语言</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>在文档的开头必须定义文档类型</li><li>在根元素中应声明命名空间，即设置 xmlns 属性</li><li>所有的标签都必须是闭合的</li><li>所有元素和属性都必须小写</li><li>所有的属性都必须用引号（””）括起来</li><li>所有标签都必须合理嵌套</li><li>所有属性都必须被赋值，没有值的属性就用自身来赋值 <code>&lt;td nowrap=&quot;nowrap&quot;/&gt;</code></li><li>所有特殊符号都用编码表示</li><li>不要在注释内容中使用“–”，只能出现在注释开头和结束</li><li>废除了 name 属性，而使用 id 属性作为统一的名称</li></ol><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>...<br></code></pre></div></td></tr></table></figure><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="文档类型-DOCTYPE"><a href="#文档类型-DOCTYPE" class="headerlink" title="文档类型 DOCTYPE"></a>文档类型 DOCTYPE</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ul><li><p>声明文档的类型，且必须位于代码的第一行</p></li><li><p>不需要向 XHTML 那么复杂，<code>&lt;!DOCTYPE html&gt;</code> 即可</p></li><li><p>使用工具时，在声明中加入 SYSTEM 识别符：<code>&lt;!DOCTYPE html SSYSTEM &quot;about:legacy-compat&quot;&gt;</code> </p></li><li><p>在 HTML5 中是不区分大小写的，引号也不区分单双</p></li><li><p>会触发浏览器以标准模式显示页面</p><p>浏览器显示模式：</p><ul><li>怪异模式 : Quirks</li><li>近标准模式 : Alomst Standards</li><li>标准模式（非怪异模式）: Standards</li></ul></li></ul><h5 id="字符编码-meta"><a href="#字符编码-meta" class="headerlink" title="字符编码 meta"></a>字符编码 meta</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="标记省略"><a href="#标记省略" class="headerlink" title="标记省略"></a>标记省略</h5><p>不允许写结束标记的：只允许使用 <code>&lt;br/&gt;</code> 或 <code>&lt;br&gt;</code> 这种形式</p><p>area base br col command embed hr img input keygen link meta param source track wbr</p><p>可以省略结束标记的：</p><p>li dt dd p rt rp optgroup option colgroup thead tbody tfoot tr td th</p><p>可以省略全部标记的：</p><p>html head body colgroup tbody</p><h2 id="HTML4"><a href="#HTML4" class="headerlink" title="HTML4"></a>HTML4</h2><h3 id="HTML4-元素"><a href="#HTML4-元素" class="headerlink" title="HTML4 元素"></a>HTML4 元素</h3><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">div</td><td align="center">在文档中定义一块区域，即包含框，容器</td></tr><tr><td align="center">ol</td><td align="center">有序列表</td></tr><tr><td align="center">ul</td><td align="center">无序列表</td></tr><tr><td align="center">li</td><td align="center">列表项</td></tr><tr><td align="center">dl</td><td align="center">自定义列表</td></tr><tr><td align="center">dt</td><td align="center">自定义列表中的词条</td></tr><tr><td align="center">dd</td><td align="center">对定义的词条进行解释</td></tr><tr><td align="center">del</td><td align="center">定义删除的文本</td></tr><tr><td align="center">ins</td><td align="center">定义插入的文本</td></tr><tr><td align="center">h1 ~ h6</td><td align="center">一级标题(最大) ~ 六级标题</td></tr><tr><td align="center">p</td><td align="center">定义段落结构</td></tr><tr><td align="center">hr</td><td align="center">定义水平线</td></tr></tbody></table><h4 id="内容元素"><a href="#内容元素" class="headerlink" title="内容元素"></a>内容元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">span</td><td align="center">在文本行中定义一个区域，即行内包含框</td></tr><tr><td align="center">a</td><td align="center">定义超链接</td></tr><tr><td align="center">abbr</td><td align="center">定义缩写词</td></tr><tr><td align="center">address</td><td align="center">定义地址</td></tr><tr><td align="center">dfn</td><td align="center">定义术语，以斜体显示</td></tr><tr><td align="center">kbd</td><td align="center">定义键盘键</td></tr><tr><td align="center">samp</td><td align="center">定义样本</td></tr><tr><td align="center">var</td><td align="center">定义变量</td></tr><tr><td align="center">tt</td><td align="center">定义打印机字体</td></tr><tr><td align="center">code</td><td align="center">定义计算机源代码</td></tr><tr><td align="center">pre</td><td align="center">定义预定义格式文本，保留源代码格式</td></tr><tr><td align="center">blockquote</td><td align="center">定义大块内容引用</td></tr><tr><td align="center">cite</td><td align="center">定义引文</td></tr><tr><td align="center">q</td><td align="center">定义引用短语</td></tr><tr><td align="center">strong</td><td align="center">定义重要文本</td></tr><tr><td align="center">em</td><td align="center">定义文本为重要</td></tr></tbody></table><h4 id="修饰元素"><a href="#修饰元素" class="headerlink" title="修饰元素"></a>修饰元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">粗体，视觉提醒</td></tr><tr><td align="center">i</td><td align="center">斜体，语气强调</td></tr><tr><td align="center">big</td><td align="center">定义较大文本</td></tr><tr><td align="center">small</td><td align="center">定义较小文本</td></tr><tr><td align="center">sup</td><td align="center">定义上标</td></tr><tr><td align="center">sub</td><td align="center">定义下标</td></tr><tr><td align="center">bdi &amp; bdo</td><td align="center">定义文本显示方向</td></tr><tr><td align="center">br</td><td align="center">定义换行</td></tr><tr><td align="center">u</td><td align="center">非文本注解，显示下划线</td></tr></tbody></table><p>已废用:</p><p>center(定义文本居中)</p><p>font(定义文字的样式大小颜色)</p><p>s(strike的缩写) strike(定义删除线)</p><h3 id="HTML4-属性"><a href="#HTML4-属性" class="headerlink" title="HTML4 属性"></a>HTML4 属性</h3><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><p>主要包括以下三个，为大部分元素所拥有</p><table><thead><tr><th align="center">属性名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">定义类规则或样式规则</td></tr><tr><td align="center">id</td><td align="center">定义元素的唯一标识</td></tr><tr><td align="center">style</td><td align="center">定义元素的样式声明</td></tr></tbody></table><p>没有这三个属性的元素：</p><p>html head title base meta param script style</p><h4 id="语言属性"><a href="#语言属性" class="headerlink" title="语言属性"></a>语言属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>lang</td><td>定义元素的语言代码或编码</td></tr><tr><td>dir</td><td>定义文本方向，包括 ltr(从左向右) 和 rtl 俩值</td></tr></tbody></table><p>没有语言属性的元素：</p><p>frameset frame iframe br hr base param script</p><h4 id="键盘属性"><a href="#键盘属性" class="headerlink" title="键盘属性"></a>键盘属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>accesskey</td><td>定义访问某元素的快捷键</td></tr><tr><td>tabindex</td><td>定义元素的 Tab 键索引编号</td></tr></tbody></table><p>使用 accesskey 可以通过（Alt + 字母 ）访问指定 URL，但浏览器不能很好的支持</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://agonilay.githib.io&quot;</span> <span class="hljs-attr">accesskey</span>=<span class="hljs-string">&quot;a&quot;</span>&gt;</span>按住 Alt 键，单击 A 键可以链接到我的博客<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>tabindex 用来定义元素的 Tab 键访问顺序</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;1&quot;</span>&gt;</span>Tab 1<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>Tab 3<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span> <span class="hljs-attr">tabindex</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>Tab 2<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="内容属性"><a href="#内容属性" class="headerlink" title="内容属性"></a>内容属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><strong>alt</strong></td><td>定义元素的替换文本（图片加载失败时）</td></tr><tr><td><strong>title</strong></td><td>定义元素的提示文本（鼠标悬停时）</td></tr><tr><td>longdesc</td><td>定义元素包含内容的大段描述信息</td></tr><tr><td>cite</td><td>定义元素包含内容的引用信息</td></tr><tr><td>datetime</td><td>定义元素包含内容的日期和时间</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;URL&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片无法正常显示时的替换文本&quot;</span> <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;鼠标悬停时的提示文本&quot;</span> /&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>rel</td><td>定义当前界面与其他界面的关系</td></tr><tr><td>rev</td><td>定义其他揭秘那与当前界面之间的链接关系</td></tr></tbody></table><p>区别：</p><ul><li>rel 表示从源文档到目标文档的关系</li><li>rev 表示从目标文档到源文档的关系</li></ul><p>用途：</p><ul><li>确定当前文档与目标文档之间的位置关系，并进行准确定义</li><li>方便浏览器对信息的来源进行准确判断</li></ul><h2 id="HTML5-1"><a href="#HTML5-1" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="HTML5-元素"><a href="#HTML5-元素" class="headerlink" title="HTML5 元素"></a>HTML5 元素</h3><h4 id="结构元素-1"><a href="#结构元素-1" class="headerlink" title="结构元素"></a>结构元素</h4><table><thead><tr><th>元素名</th><th>说明</th></tr></thead><tbody><tr><td>header</td><td>页面中的一个内容区块或整个页面的标题</td></tr><tr><td>footer</td><td>表示整个页面或其中一个内容区块的注脚<br>一般会包含创作者的姓名、创作日期及联系信息</td></tr><tr><td>section</td><td>表示页面中的一个内容区块，如章节、页眉页脚…</td></tr><tr><td>article</td><td>表示页面中的一块与上线问不相关的独立内容</td></tr><tr><td>aside</td><td>表示 article 元素的内容之外的，与 article 元素的内容相关的辅助信息</td></tr><tr><td>nav</td><td>表示页面中导航链接的部分</td></tr><tr><td>main</td><td>表示页面中的主要部分</td></tr><tr><td>figure</td><td>表示一段独立的流内容，一般表示一个文档主体流内容中的一个独立单元</td></tr></tbody></table><h4 id="功能元素"><a href="#功能元素" class="headerlink" title="功能元素"></a>功能元素</h4><table><thead><tr><th>元素</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>video</td><td>定义视频</td><td></td></tr><tr><td>audio</td><td>定义音频</td><td></td></tr><tr><td>embed</td><td>用于插入各种多媒体</td><td><code>&lt;embed src=&quot;horse.wav&quot;&gt;</code></td></tr><tr><td>mark</td><td>在视觉上向用户呈现那些需要突出显示或高亮显示的文字</td><td></td></tr><tr><td>dialog</td><td>定义对话框或窗口</td><td><code>&lt;dialog open&gt;这是打开的会话窗口&lt;/dialog&gt;</code></td></tr><tr><td>bdi</td><td>定义文本的文本方向，使其脱离周围文本的方向设置</td><td></td></tr><tr><td>figcaption</td><td>定义 figure 元素的标题</td><td></td></tr><tr><td>time</td><td>表示日期或时间，也可以同时表示两者</td><td></td></tr><tr><td>canvas</td><td>表示图形，如图表和其他图像</td><td></td></tr><tr><td>output</td><td>表示不同类型的输出</td><td></td></tr><tr><td>source</td><td>为媒介元素定义媒介资源</td><td>如：<code>&lt;video&gt;</code> <code>&lt;audio&gt;</code></td></tr><tr><td>menu</td><td>表示菜单列表</td><td></td></tr><tr><td>ruby</td><td>表示 ruby 注释（中文注音或字符）</td><td><code>&lt;ruby&gt;汉&lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;阿瓦达&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;ruby&gt;</code></td></tr><tr><td>rt</td><td>表示字符（中文注音或字符）的解释或发音</td><td></td></tr><tr><td>rp</td><td>在 ruby 中使用</td><td></td></tr><tr><td>wbr</td><td>表示软换行，窗口或父级元素的宽度足够时，没必要换行<br>而当宽度不够时，主动在此处进行换行</td><td></td></tr><tr><td>commend</td><td>表示命令按钮</td><td>如：单选按钮、复选框或按钮</td></tr><tr><td>details</td><td>表示用户要求得到并且可以得到的细节信息</td><td></td></tr><tr><td>summary</td><td>为<code>&lt;details&gt;</code>元素定义可见的标题</td><td></td></tr><tr><td>datalist</td><td>表示可选数据的列表，与 input 元素配合使用</td><td></td></tr><tr><td>datagrid</td><td>表示可选数据的列表，以树形列表的形式来显示</td><td></td></tr><tr><td>keygen</td><td>表示生成密钥</td><td></td></tr><tr><td>progress</td><td>表示运行中的进程</td><td></td></tr><tr><td>meter</td><td>度量给定范围内的数据</td><td></td></tr><tr><td>track</td><td>定义用在媒体播放器中的文本轨道</td><td></td></tr></tbody></table><h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><p>通过 type 属性，HTML5 为 input 元素新增了很多类型</p><ul><li>tel : 表示必须输入电话号码的文本框</li><li>search : 表示搜索文本框</li><li>url : 表示必须输入 URL 地址的文本框</li><li>email : 表示必须输入电子邮件地址的文本框</li><li>datetime : 表示日期和时间文本框</li><li>date : 表示日期文本框</li><li>month : 表示月份文本框</li><li>week : 表示星期文本框</li><li>time : 表示时间文本框</li><li>datetime-local : 表示本地日期和时间文本框</li><li>number : 表示必须输入数字的文本框</li><li>range : 表示范围文本框</li><li>color : 表示颜色文本框</li></ul><h3 id="HTML5-属性"><a href="#HTML5-属性" class="headerlink" title="HTML5 属性"></a>HTML5 属性</h3><h4 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h4><ul><li><p>autofocus ：让元素在页面打开时自动获得焦点</p><ul><li>input(type=”text”)、select、textarea、button</li></ul></li><li><p>placeholder ：对用户的输入进行提示</p><ul><li>input(type=”text”)、textarea</li></ul></li><li><p>form ：声明它属于哪个表单，然后就可以将它放在页面的任何位置，而不一定是表单之内</p><ul><li>input、output、select、textarea、button、fieldset</li></ul></li><li><p>required ：在用户提交时进行检查，检查该元素内一定要有输入内容</p><ul><li>input(type=”text”)、textarea</li></ul></li><li><p>为 input 元素增加 autocomplete、min、max、multiple(允许多文件上传)、pattern 和 step 属性</p></li><li><p>为 input 和 button 元素增加 formaction、formenctype、formmethod、formnovalidate 与 formtarget 属性</p><p>重载 form 元素的 action、enctype、method、novalidate 与 target 属性</p></li><li><p>为 fieldset 元素增加了 disabled 属性</p></li><li><p>novalidate ： 取消提交时进行的有关检查，表单可以被无条件地提交</p><ul><li>input button from</li></ul></li></ul><h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><ul><li>media ：目标 URL 是为什么类型的媒介/设备进行优化的，只能在 href 属性存在时使用<ul><li>a area</li></ul></li><li>为 area 元素增加了 hreflang 和 rel 属性，以保持与 a 元素、link 元素的一致</li><li>为 link 元素增加了新属性 sizes，该属性可以与 icon 元素结合使用(通过 rel 属性)，该属性指定关联图标(icon 元素)的大小</li><li>为 base 元素增加了 target 属性，主要目的是保持与 a 元素的一致性</li></ul><h4 id="其他属性-1"><a href="#其他属性-1" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>reversed ：ol 元素 列表项倒序显示</li><li>为 meta 增加了 charset 属性</li><li>为 menu 增加了两个新的属性 type 和 label<ul><li>label ：为菜单定义一个可见的标注</li><li>type ：让菜单可以上下文菜单、工具条与列表菜单三种形式出现</li></ul></li><li>scoped ：style 元素增加，用来规定样式的作用范围</li><li>async ：script 元素增加，定义脚本是否异步执行</li><li>manifest ：html 元素增加，开发离线 Web 应用程序时它与 API 结合使用，定义一个 URL，在这个 URL 上描述文档的缓存信息</li><li>为 iframe 增加三个属性 sandbox、seamless 与 srcdoc，用来提高页面安全性，防止不信任的 Web 页面执行某些操作</li></ul><h3 id="HTML5-全局属性"><a href="#HTML5-全局属性" class="headerlink" title="HTML5 全局属性"></a>HTML5 全局属性</h3><h4 id="contenteditable-在线编辑"><a href="#contenteditable-在线编辑" class="headerlink" title="contenteditable 在线编辑"></a>contenteditable 在线编辑</h4><p>允许用户可以在线编辑元素的内容，布尔值属性</p><ul><li>true ：允许编辑</li><li>false ：不允许编辑</li><li>inherit ：未指定 true 或 false 时，由 inherit 状态决定，看父元素是否可编辑</li></ul><p>想要保存编辑后的内容，使用 innerHTML 获取</p><p>所有主流浏览器都支持 contenteditable 属性</p><p>在 JavaScript 中，元素还有一个 isContentEditable 属性，当元素可编辑时，该属性值为 true，反之则为 false</p><h4 id="contentmenu-右击菜单"><a href="#contentmenu-右击菜单" class="headerlink" title="contentmenu 右击菜单"></a>contentmenu 右击菜单</h4><p>用于定义 div 元素的上下文菜单，在用户右键单击元素时出现</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">contextmenu</span>=<span class="hljs-string">&quot;mymenu&quot;</span>&gt;</span><br>    上下文菜单<br>    <span class="hljs-tag">&lt;<span class="hljs-name">menu</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;mymenu&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">menuitem</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;微信分享&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menuitem</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">menuitem</span> <span class="hljs-attr">label</span>=<span class="hljs-string">&quot;微博分享&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">menuitem</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">menu</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>目前只有 Firefox 支持 contentmenu 属性</p><h4 id="data-自定义属性"><a href="#data-自定义属性" class="headerlink" title="data-* 自定义属性"></a>data-* 自定义属性</h4><p>使用 data-* 可以自定义用户数据</p><ul><li><p>属性名：不应该包含任何大写字母，在前缀“data-”之后必须至少有一个字符</p><ul><li><p>多个单词使用：<code>-</code> 连接</p></li><li><p>脚本中获取或访问属性使用 <code>dataset.对应小驼峰式</code> </p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-animal-type</span>=<span class="hljs-string">&quot;bird&quot;</span>&gt;</span>鸟<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-animal-type</span>=<span class="hljs-string">&quot;fish&quot;</span>&gt;</span>鱼<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">data-animal-type</span>=<span class="hljs-string">&quot;piggy&quot;</span>&gt;</span>小猪<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> lis = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&quot;li&quot;</span>);</span><br><span class="javascript">    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(lis[i].dataset.animalType); <span class="hljs-comment">// &lt;--</span></span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>属性值：可以是任意字符串</p></li></ul><p>当浏览器（用户代理）解析时，会完全忽略前缀为“data-”的自定义属性</p><p>所有主流浏览器都支持 自定义属性</p><h4 id="draggable-可被拖动"><a href="#draggable-可被拖动" class="headerlink" title="draggable 可被拖动"></a>draggable 可被拖动</h4><p>定义元素是否可以被拖动，但不是元素位置改变</p><p>true、false、auto(定义使用浏览器的默认行为)</p><p>此属性常被用在拖放操作中</p><h4 id="dropzone-拖动操作"><a href="#dropzone-拖动操作" class="headerlink" title="dropzone 拖动操作"></a>dropzone 拖动操作</h4><p>定义在元素上拖动数据时，是否复制、移动或链接被拖动数据</p><ul><li>copy ：会产生被拖动数据的副本</li><li>move ：会导致被拖动数据被移动到新位置</li><li>link ：会产生执行原始数据的链接</li></ul><p>但是，目前主流浏览器都不支持 dropzone 属性</p><h4 id="hidden-隐藏"><a href="#hidden-隐藏" class="headerlink" title="hidden 隐藏"></a>hidden 隐藏</h4><p>所有元素都包含一个 hidden 属性，设置元素的可见状态，true不可见，false可见</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;...&quot;</span> <span class="hljs-attr">hidden</span>&gt;</span>元素隐藏<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>除了 IE 所有主流浏览器都支持 hidden 属性</p><h4 id="spellcheck-拼写-语法检查"><a href="#spellcheck-拼写-语法检查" class="headerlink" title="spellcheck 拼写 语法检查"></a>spellcheck 拼写 语法检查</h4><p>定义是否对元素进行拼写和语法检查，可以对以下内容进行拼写检查：</p><ul><li>input 元素中的文本值（非密码）</li><li>textarea 元素中的文本</li><li>可编辑元素中的文本</li></ul><p>布尔值属性，true检查，false不检查</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">spellcheck</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span> <span class="hljs-comment">&lt;!-- 必须写值，光写spellcheck错误 --&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="translate-翻译"><a href="#translate-翻译" class="headerlink" title="translate 翻译"></a>translate 翻译</h4><p>定义是否应该翻译元素内容，yes翻译，no不翻译</p><p>但目前所有主流浏览器都无法正确支持 translate 属性</p><p>HTML5 文档链接</p><p><a href="http://www.qianduankaifa.cn/exercise/html5_base/">http://www.qianduankaifa.cn/exercise/html5_base/</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTML</tag>
      
      <tag>HTML5</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>八月打卡计划</title>
    <link href="/2021/08/02/%E5%85%AB%E6%9C%88%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92/"/>
    <url>/2021/08/02/%E5%85%AB%E6%9C%88%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h2 id="0829"><a href="#0829" class="headerlink" title="0829"></a>0829</h2><h3 id="今日行思"><a href="#今日行思" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，预习下学期课程收尾，整理前端笔记完成</p><p>时间（记录行动的时间段）9：00 - 12：30，15：00 - 19：40，21：30 - 23：00</p><h3 id="今日思考"><a href="#今日思考" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务 - 调接口</p><p>前端笔记整理过程中对前端知识点的回想</p><h3 id="今日得失"><a href="#今日得失" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发，调接口</li><li>字节前端笔记整理完毕</li></ul><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续进行开发任务，深入看 vue.js 书</p><h3 id="今日获得的资源"><a href="#今日获得的资源" class="headerlink" title="今日获得的资源"></a>今日获得的资源</h3><p>前端笔记</p><h2 id="0828"><a href="#0828" class="headerlink" title="0828"></a>0828</h2><h3 id="今日行思-1"><a href="#今日行思-1" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，预习下学期课程，整理前端部分笔记</p><p>时间（记录行动的时间段）8：30 - 12：10，14：00 - 20：20，22：30 - 00：30</p><h3 id="今日思考-1"><a href="#今日思考-1" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务 - 调接口</p><p>难点：</p><ul><li>调接口时碰到了 引入路径 以及 跨域的问题</li><li>需要多积累跨域这方面的知识</li></ul><h3 id="今日得失-1"><a href="#今日得失-1" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发，调接口</li></ul><h3 id="明日计划-1"><a href="#明日计划-1" class="headerlink" title="明日计划"></a>明日计划</h3><p>下学期课程预习收尾，继续进行开发任务，整理前端笔记</p><h3 id="今日获得的资源-1"><a href="#今日获得的资源-1" class="headerlink" title="今日获得的资源"></a>今日获得的资源</h3><p>字节跳动的前端笔记文章 –&gt; 部分转化为了 自己 的 md 格式，更方便查看</p><h2 id="0827"><a href="#0827" class="headerlink" title="0827"></a>0827</h2><h3 id="明日计划-2"><a href="#明日计划-2" class="headerlink" title="明日计划"></a>明日计划</h3><p>调接口进行开发任务，下学期课程预习，过前端笔记</p><h2 id="0826"><a href="#0826" class="headerlink" title="0826"></a>0826</h2><h3 id="今日行思-2"><a href="#今日行思-2" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书，预习下学期课程</p><p>时间（记录行动的时间段）10：00 - 12：10，12：50 - 15：30</p><h3 id="今日思考-2"><a href="#今日思考-2" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务过程</p><h3 id="今日得失-2"><a href="#今日得失-2" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发</li><li>下一学期课程的预习</li><li>vue 书的学习</li></ul><h3 id="明日计划-3"><a href="#明日计划-3" class="headerlink" title="明日计划"></a>明日计划</h3><p>朋友过生日，给自己放一天假，休息休息</p><h2 id="0825"><a href="#0825" class="headerlink" title="0825"></a>0825</h2><h3 id="今日行思-3"><a href="#今日行思-3" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书，预习下学期课程</p><p>时间（记录行动的时间段）9：30 - 12：10，13：40 - 19：00，21：00 - 24：00</p><h3 id="今日思考-3"><a href="#今日思考-3" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>同样进行开发任务过程中思考代码以及组件的优化</li><li>博客同时部署到 gitee 和 github 上</li></ol><h3 id="今日得失-3"><a href="#今日得失-3" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发</li><li>下一学期课程的预习</li></ul><h3 id="明日计划-4"><a href="#明日计划-4" class="headerlink" title="明日计划"></a>明日计划</h3><p>完成开发任务，看书学习，继续预习下学期课程</p><h2 id="0824"><a href="#0824" class="headerlink" title="0824"></a>0824</h2><h3 id="今日行思-4"><a href="#今日行思-4" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书</p><p>时间（记录行动的时间段）8：40 - 12：10，15：00 - 20：00，21：20 - 23：40</p><h3 id="今日思考-4"><a href="#今日思考-4" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>vue 中的指令包括自定义指令，以及计算属性，监听器的用法</li><li>进行开发任务过程中思考代码以及组件的优化</li></ol><h3 id="今日得失-4"><a href="#今日得失-4" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>复习 vue 中基础知识点</li><li>项目的开发，一个完整的编辑页面</li></ul><h3 id="明日计划-5"><a href="#明日计划-5" class="headerlink" title="明日计划"></a>明日计划</h3><p>完成开发任务，看书学习，预习下学期课程</p><h3 id="今日积累的新学习资源"><a href="#今日积累的新学习资源" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue 笔记</p><h2 id="0823"><a href="#0823" class="headerlink" title="0823"></a>0823</h2><h3 id="今日行思-5"><a href="#今日行思-5" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：开发完整日历组件，进行开发任务，看了 vue.js 书，复习了 ES6 的知识点</p><p>时间（记录行动的时间段）9：00 - 12：30，13：50 - 19：00，21：00 - 24：00</p><h3 id="今日思考-5"><a href="#今日思考-5" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>ES6 知识点的巩固</li><li>MVC MVP MVVM 的区别</li><li>模块化开发以及单页面程序的理解</li></ol><h3 id="今日得失-5"><a href="#今日得失-5" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>复习 ES6 部分知识点</li><li>项目的完成，其中包含一个 日历的开发（难点）</li></ul><h3 id="明日计划-6"><a href="#明日计划-6" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，看书学习</p><h3 id="今日积累的新学习资源-1"><a href="#今日积累的新学习资源-1" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue 笔记</p><h2 id="0822"><a href="#0822" class="headerlink" title="0822"></a>0822</h2><h3 id="今日行思-6"><a href="#今日行思-6" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，进行小 demo 开发，开发日历模块，晚上学长讲解，看了下学期要学的课，晚上进行了项目开发</p><p>时间（记录行动的时间段）8：30 - 12：50，15：00 - 24：00</p><h3 id="今日思考-6"><a href="#今日思考-6" class="headerlink" title="今日思考"></a>今日思考</h3><p>怎么体现程序的好坏： </p><ul><li>算法和数据结构来做的 – 时间复杂度空间复杂度</li></ul><p>程序设计来讲：</p><ul><li>健壮性：点击效果</li><li>扩展性</li><li>可维护性 </li></ul><p>Vue：</p><ul><li>数据驱动 </li><li>插槽 </li><li>组件的设计和使用</li></ul><p>代码书写：判断可以错误优先处理原则</p><p>命名：遵守规范!!!</p><h3 id="今日得失-6"><a href="#今日得失-6" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>vue2 一个列表的小项目 demo</li><li>新课程的预习</li><li>晚上学长讲解代码，学到了 很多</li></ul><h3 id="明日计划-7"><a href="#明日计划-7" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，看下学期学习的课程</p><h3 id="今日积累的新学习资源-2"><a href="#今日积累的新学习资源-2" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue2 的一个项目 demo</p><h2 id="0821"><a href="#0821" class="headerlink" title="0821"></a>0821</h2><h3 id="今日行思-7"><a href="#今日行思-7" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，同时看 vue.js 书，看了下学期要学的课</p><p>时间（记录行动的时间段）8：30 - 12：50，15：00 - 19：00，21：00 - 24：00</p><h3 id="今日思考-7"><a href="#今日思考-7" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 路由 vue-router 的原理及使用</p><p>eslint 的作用及使用</p><p>vscode 中使用 eslint</p><h3 id="今日得失-7"><a href="#今日得失-7" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>vue 路由 与 eslint 的使用</li><li>新课程的预习</li></ul><h3 id="明日计划-8"><a href="#明日计划-8" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，继续向后学习 b 站 VUE 视频，看下学期学习的课程</p><h3 id="今日积累的新学习资源-3"><a href="#今日积累的新学习资源-3" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>ESLint 官方文档、VueRouter 官方文档</p><h2 id="0820"><a href="#0820" class="headerlink" title="0820"></a>0820</h2><h3 id="今日行思-8"><a href="#今日行思-8" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：vue2 学习</p><p>时间（记录行动的时间段）20：10 - 23：00</p><h3 id="今日思考-8"><a href="#今日思考-8" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue2 自定义组件和插槽的学习</p><h3 id="今日得失-8"><a href="#今日得失-8" class="headerlink" title="今日得失"></a>今日得失</h3><p>今日白天参加了 要好朋友的生日，也算给自己放了一天假</p><h3 id="明日计划-9"><a href="#明日计划-9" class="headerlink" title="明日计划"></a>明日计划</h3><p>学习 vue2 视频课程学习</p><h2 id="0819"><a href="#0819" class="headerlink" title="0819"></a>0819</h2><h3 id="今日行思-9"><a href="#今日行思-9" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：30 - 11：50，13：30 - 15：30</p><h3 id="今日思考-9"><a href="#今日思考-9" class="headerlink" title="今日思考"></a>今日思考</h3><p>今日无思考</p><h3 id="今日得失-9"><a href="#今日得失-9" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：vue2 的学习</p><h3 id="明日计划-10"><a href="#明日计划-10" class="headerlink" title="明日计划"></a>明日计划</h3><p>明天放松一天，朋友过生日</p><h2 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h2><h3 id="今日行思-10"><a href="#今日行思-10" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，做购物车案例</p><p>时间（记录行动的时间段）8：00 - 13：00，14：10 - 16：20，22：00 - 23：30</p><h3 id="今日思考-10"><a href="#今日思考-10" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 组件之间传值，包括 子向父、父向子、兄弟组件之间</p><p>使用最优的方式方法实现功能</p><h3 id="今日得失-10"><a href="#今日得失-10" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 ref 引用、动态组件以及插槽</li><li>购物车案例的完成</li></ol><h3 id="明日计划-11"><a href="#明日计划-11" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，继续向后学习 b 站 VUE 视频</p><h2 id="0817"><a href="#0817" class="headerlink" title="0817"></a>0817</h2><h3 id="今日行思-11"><a href="#今日行思-11" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，看 JS 书</p><p>时间（记录行动的时间段）9：00 - 13：50，14：40 - 19：00，20：20 - 24：00</p><h3 id="今日思考-11"><a href="#今日思考-11" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 组件之间传值，包括 子向父、父向子、兄弟组件之间</p><p>数组循环的特殊方法：forEach、some、filter、every、reduce</p><p>JS 对象的底层知识原理方法</p><h3 id="今日得失-11"><a href="#今日得失-11" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 vue 组件、数组集中循环方法 的学习</li><li>JS 对象的深度剖析</li></ol><h3 id="明日计划-12"><a href="#明日计划-12" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，进行购物车案例的开发，继续向后学习 b 站 VUE 视频</p><h2 id="0816"><a href="#0816" class="headerlink" title="0816"></a>0816</h2><h3 id="今日行思-12"><a href="#今日行思-12" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）15：50 - 19：00，20：20 - 24：00</p><h3 id="今日思考-12"><a href="#今日思考-12" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 项目中的 组件化开发 尤为重要</p><p>vue 组件的组成结构，语法结构，组件间的关系</p><h3 id="今日得失-12"><a href="#今日得失-12" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 vue-cli vue 组件的部分学习</li></ol><p>失：</p><ol><li>今天上午和朋友有事处理，下午回到家</li></ol><h3 id="明日计划-13"><a href="#明日计划-13" class="headerlink" title="明日计划"></a>明日计划</h3><p>有开发任务完成，继续向后学习 b 站 VUE 视频</p><h2 id="0815"><a href="#0815" class="headerlink" title="0815"></a>0815</h2><h3 id="今日行思-13"><a href="#今日行思-13" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行了开发任务，学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：10 - 12：30；13：50 - 19：00</p><h3 id="今日思考-13"><a href="#今日思考-13" class="headerlink" title="今日思考"></a>今日思考</h3><p>侦听器及计算属性</p><p>开发过程中的规范，要求要严格遵循</p><h3 id="今日得失-13"><a href="#今日得失-13" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>完善了一些之前的开发任务中的缺陷和不足，以及规范的实施</li><li>vue2 的学习，包括 侦听器 计算属性 vue-cli vue 组件的部分学习</li></ul><h3 id="明日计划-14"><a href="#明日计划-14" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续向后学习 b 站 VUE 视频</p><h2 id="0814"><a href="#0814" class="headerlink" title="0814"></a>0814</h2><h3 id="今日行思-14"><a href="#今日行思-14" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：完成了开发任务，学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：40 - 12：30；13：50 - 17：00；18：20 - 24：00</p><h3 id="今日思考-14"><a href="#今日思考-14" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 中指令的作用以及区分，要多练习，多使用，多回看笔记巩固</p><h3 id="今日得失-14"><a href="#今日得失-14" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>完成了行得每日打卡的任务开发</li><li>vue2 的基础巩固，零碎知识点的学习</li></ul><h3 id="明日计划-15"><a href="#明日计划-15" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-4"><a href="#今日积累的新学习资源-4" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTTP 权威指南，webpack 笔记补充，vue2部分笔记、dayjs 网站 - JS时间第三方库</p><h2 id="0813"><a href="#0813" class="headerlink" title="0813"></a>0813</h2><h3 id="今日行思-15"><a href="#今日行思-15" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，学习 黑马的 vue 课程</p><p>时间（记录行动的时间段）8：20 - 12：30；14：40 - 18：30；20：00 - 23：30</p><h3 id="今日思考-15"><a href="#今日思考-15" class="headerlink" title="今日思考"></a>今日思考</h3><p>难点：</p><p>开发过程中的 上传选择图片以及选择资源部分是一个难点</p><h3 id="今日得失-15"><a href="#今日得失-15" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>进行了行得的任务开发</li><li>积累了难点中叙述的功能开发方式</li></ul><h3 id="明日计划-16"><a href="#明日计划-16" class="headerlink" title="明日计划"></a>明日计划</h3><p>明日完成开发任务，继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-5"><a href="#今日积累的新学习资源-5" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><h2 id="0812"><a href="#0812" class="headerlink" title="0812"></a>0812</h2><h3 id="今日行思-16"><a href="#今日行思-16" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，学习 黑马的 vue 课程</p><p>时间（记录行动的时间段）10：00 - 12：00；13：00 - 19：20；20：30 - 00：30</p><h3 id="今日思考-16"><a href="#今日思考-16" class="headerlink" title="今日思考"></a>今日思考</h3><p>使用 webpack 打包的方法，流程</p><h3 id="今日得失-16"><a href="#今日得失-16" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习了部分 webpack 的知识，也算是复习巩固之前学过的一点皮毛</li><li>进行了行得的任务开发</li></ul><p>失：</p><ul><li>上午家里有些事，帮了帮忙，耗了一些时间</li></ul><h3 id="明日计划-17"><a href="#明日计划-17" class="headerlink" title="明日计划"></a>明日计划</h3><p>明日完成开发任务，继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-6"><a href="#今日积累的新学习资源-6" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><h2 id="0811"><a href="#0811" class="headerlink" title="0811"></a>0811</h2><h3 id="今日行思-17"><a href="#今日行思-17" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行了开发</p><p>时间（记录行动的时间段）8：50 - 12：00；13：30 - 18：00；19：30 - 23：00</p><h3 id="今日思考-17"><a href="#今日思考-17" class="headerlink" title="今日思考"></a>今日思考</h3><p>开发过程中尽量简化，要复用</p><h3 id="明日计划-18"><a href="#明日计划-18" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-7"><a href="#今日积累的新学习资源-7" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 权威指南</p><h2 id="0810"><a href="#0810" class="headerlink" title="0810"></a>0810</h2><h3 id="今日行思-18"><a href="#今日行思-18" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3弹性盒模型和动画学习，进行开发任务</p><p>时间（记录行动的时间段）8：30 - 12：20；14：30 - 18：50；20：30 - 24：00</p><h3 id="今日思考-18"><a href="#今日思考-18" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 弹性盒模型，动画</li><li>难点：<ol><li>弹性盒模型</li><li>动画</li></ol></li></ol><h3 id="今日得失-17"><a href="#今日得失-17" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS 的内容</li><li>完成了行得的任务开发</li></ul><h3 id="明日计划-19"><a href="#明日计划-19" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，开始学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-8"><a href="#今日积累的新学习资源-8" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS(包含CSS3) 完整笔记，已上传</p><h2 id="0809"><a href="#0809" class="headerlink" title="0809"></a>0809</h2><h3 id="今日行思-19"><a href="#今日行思-19" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3浮动学习，弹性盒模型学习了一部分，完成了开发任务</p><p>时间（记录行动的时间段）8：30 - 11：30；14：00 - 18：20；20：20 - 24：00</p><h3 id="今日思考-19"><a href="#今日思考-19" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 布局及盒模型的学习，开发任务中样式设计时的简便方式，积累经验</li></ol><h3 id="今日得失-18"><a href="#今日得失-18" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS3 浮动，弹性盒模型学习了一部分</li></ul><h3 id="明日计划-20"><a href="#明日计划-20" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 弹性盒模型学习要结束，开始学习 CSS 及 CSS3 动画</p><h3 id="今日积累的新学习资源-9"><a href="#今日积累的新学习资源-9" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>深入浅出 React 和 Redux 书</p><h2 id="0808"><a href="#0808" class="headerlink" title="0808"></a>0808</h2><h3 id="今日行思-20"><a href="#今日行思-20" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3布局及盒模型学习，完成开发任务，修改博客</p><p>时间（记录行动的时间段）8：10 - 11：50；14：00 - 18：20；19：20 - 23：30</p><h3 id="今日思考-20"><a href="#今日思考-20" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 布局及盒模型的学习，开发任务中样式设计时的简便方式，积累经验</li><li>难点：</li></ol><h3 id="今日得失-19"><a href="#今日得失-19" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS3 布局</li><li>完成了行得的任务开发</li></ul><h3 id="明日计划-21"><a href="#明日计划-21" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS浮动学习，</p><h3 id="今日积累的新学习资源-10"><a href="#今日积累的新学习资源-10" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>java 数据结构与算法书、vue.js 深入浅出书</p><h2 id="0807"><a href="#0807" class="headerlink" title="0807"></a>0807</h2><h3 id="今日行思-21"><a href="#今日行思-21" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3难点学习</p><p>时间（记录行动的时间段）8：00 - 12：20；16：30 - 17：00；20：30 - 23：00</p><h3 id="今日思考-21"><a href="#今日思考-21" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 样式属性的复习</li><li>难点：表单、表格的新增元素和属性的使用和分类</li></ol><h3 id="今日得失-20"><a href="#今日得失-20" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：学习结束了 CSS3 样式</p><h3 id="明日计划-22"><a href="#明日计划-22" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 样式今天已复习结束，JS 先延后，先学习 CSS3 布局，盒模型内容</p><h3 id="今日积累的新学习资源-11"><a href="#今日积累的新学习资源-11" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS笔记内CSS3样式完善</p><h2 id="0806"><a href="#0806" class="headerlink" title="0806"></a>0806</h2><h3 id="今日行思-22"><a href="#今日行思-22" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：我部分草稿箱开发完成，CSS复习完毕，CSS3样式属性难点学习</p><p>时间（记录行动的时间段）9：30 - 12：20；14：30 - 18：30；20：00 - 23：00</p><h3 id="今日思考-22"><a href="#今日思考-22" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 样式属性的复习</li><li>难点：<ol><li>图片属性和文字属性中，各自有易混淆的，要着重去记忆</li><li>渐变背景是一个难点，要多去回顾，练习</li></ol></li></ol><h3 id="今日得失-21"><a href="#今日得失-21" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>学习了 CSS3 新的属性及样式，包括</li><li>下午进行了 行得 的开发，”我” 界面开发完成 草稿箱 界面所有内容</li></ol><p>失：</p><ol><li>昨晚没睡好，早上四点多被肚子疼起来，有一些闹肚子，可能是昨天着凉了，上午吃了药，好转了一些，状态不太好</li></ol><h3 id="明日计划-23"><a href="#明日计划-23" class="headerlink" title="明日计划"></a>明日计划</h3><p>依旧按质按量按时完成开发任务，CSS3 样式明天复习结束，并要开始 JS 的复习</p><h3 id="今日积累的新学习资源-12"><a href="#今日积累的新学习资源-12" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS笔记内CSS3部分完善</p><h2 id="0805"><a href="#0805" class="headerlink" title="0805"></a>0805</h2><h3 id="今日行思-23"><a href="#今日行思-23" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：我部分开发完成，CSS复习完毕，CSS3样式已经开始一部分</p><p>时间（记录行动的时间段）8：30 - 12：30；14：30 - 18：00；20：00 - 23：00</p><h3 id="今日思考-23"><a href="#今日思考-23" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS 中文本相关的属性深入掌握及区分</li><li>HTML5 新增标签及属性值的了解及记录</li></ol><h3 id="今日得失-22"><a href="#今日得失-22" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习了 CSS 基础内容</li><li>上午及下午一部分时间进行了 行得 的开发，”我” 界面开发完成 我的收藏 我的发布 界面所有内容</li></ol><p>失：</p><ol><li>晚上又老朋友来看望我，延误了一部分学习计划，不过问题不大，也差不多是吃饭时间，看了中国乒乓女团的决赛</li></ol><h3 id="明日计划-24"><a href="#明日计划-24" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 样式复习继续</p><h3 id="今日积累的新学习资源-13"><a href="#今日积累的新学习资源-13" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS笔记 和 HTML笔记的完善</p><p>网上淘了一些前端有关书籍，包括 vue.js、react.js、js、css、node的书籍</p><h2 id="0804"><a href="#0804" class="headerlink" title="0804"></a>0804</h2><h3 id="今日行思-24"><a href="#今日行思-24" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：过CSS基础，行得APP界面开发</p><p>时间（记录行动的时间段）8：00 - 12：30；14：00 - 18：00；17：00 - 24：00</p><h3 id="今日思考-24"><a href="#今日思考-24" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS 中基础的属性以及属性值</li><li>CSS 中选择器的分类以及熟练掌握使用</li><li>使用 vue 开发中组件要设计完善，考虑之后开发</li></ol><h3 id="今日得失-23"><a href="#今日得失-23" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习了 CSS 基础内容</li><li>下午进行了 行得 的开发，”我” 界面开发完成 我的关注 我的粉丝 我的收藏 三个界面</li></ol><h3 id="明日计划-25"><a href="#明日计划-25" class="headerlink" title="明日计划"></a>明日计划</h3><p>“我”界面要开发完毕，CSS要复习完毕，并且尽可能的向后进行 CSS3 的内容复习与拓展</p><h3 id="今日积累的新学习资源-14"><a href="#今日积累的新学习资源-14" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS笔记</p><h2 id="0803"><a href="#0803" class="headerlink" title="0803"></a>0803</h2><h3 id="今日行思-25"><a href="#今日行思-25" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：HTML基础过一遍</p><p>时间（记录行动的时间段）8：00 - 12：00；14：30 - 17：00；晚上</p><h3 id="今日思考-25"><a href="#今日思考-25" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>HTML 每个重要标签的作用，以及其所有可以使用的属性，包括在那些浏览器中不兼容</li><li>HTML4 中的标签、元素、属性</li><li>HTML5 新增的所有内容功能以及与之前的关系、区别和配合使用的方法</li></ol><h3 id="今日得失-24"><a href="#今日得失-24" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习结束了HTML的基础，也包括 HTML4 以及 HTML5 的内容</li><li>学会了给博客指定文章置顶</li></ol><p>失：今天未达到早起训练一小时的目标，只进行了二十分钟，要逐渐调节生物钟</p><h3 id="明日计划-26"><a href="#明日计划-26" class="headerlink" title="明日计划"></a>明日计划</h3><p>在完成任务的基础上，CSS 以及 CSS3的复习与巩固</p><h3 id="今日积累的新学习资源-15"><a href="#今日积累的新学习资源-15" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTML笔记完整，已上传至博客</p><p>另外得到了一个 HTML5 的API文档，可以查看所有的标签及属性，在 HTML笔记 博客末尾</p><h2 id="0802"><a href="#0802" class="headerlink" title="0802"></a>0802</h2><h3 id="今日行思-26"><a href="#今日行思-26" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：完成学长安排的任务，开始过一遍前端最基础的东西</p><p>时间（记录行动的时间段）11：00 - 12：30；13：30 - 17：00；20：00 - 23：30</p><h3 id="今日思考-26"><a href="#今日思考-26" class="headerlink" title="今日思考"></a>今日思考</h3><p>1、HTML 的重要性</p><p>2、下拉触底功能的原理</p><h3 id="今日得失-25"><a href="#今日得失-25" class="headerlink" title="今日得失"></a>今日得失</h3><p>学会了在移动端实现下拉触底加载</p><p>复习了HTML的一部分基础，包括标签以及一些属性</p><h3 id="明日计划-27"><a href="#明日计划-27" class="headerlink" title="明日计划"></a>明日计划</h3><p>在完成任务的基础上，继续复习HTML内容，明天把HTML的内容复习完</p><h3 id="今日积累的新学习资源-16"><a href="#今日积累的新学习资源-16" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTML学习笔记</p>]]></content>
    
    
    <categories>
      
      <category>打卡</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Webpack笔记</title>
    <link href="/2021/07/30/Webpack%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/30/Webpack%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>使用 Webpack </p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>当前 Web开发 面临的困境：</p><ul><li>文件以来关系错综复杂</li><li>静态资源请求效率低</li><li>模块化支持不友好</li><li>浏览器对高级 JavaScript 特性兼容程度较低</li></ul><h4 id="webpack-概述"><a href="#webpack-概述" class="headerlink" title="webpack 概述"></a>webpack 概述</h4><p>webpack 是一个流行的前端项目构建工具（打包工具），可以解决当前 web 开发中所面临的困境。</p><p>提供了友好的模块化支持，以及<strong>代码压缩混淆</strong>、<strong>处理 js 兼容问题</strong>、<strong>性能优化</strong>等强大的功能，提高了开发效率和项目的可维护性。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="1-创建列表隔行变色项目"><a href="#1-创建列表隔行变色项目" class="headerlink" title="1.创建列表隔行变色项目"></a>1.创建列表隔行变色项目</h5><ol><li>创建项目空白目录，并运行 <code>npm init -y</code> 命令，进行初始化包管理配置文件 package.json</li><li>新建 src 源代码目录</li><li>新建 src -&gt; index.html 首页</li><li>初始化首页基本结构</li><li>运行 <code>npm install jquery -S</code> 命令， 安装 jQuery</li><li>通过模块化的形式，实现列表隔行变色效果</li></ol><h5 id="2-在项目中安装和配置-webpack"><a href="#2-在项目中安装和配置-webpack" class="headerlink" title="2. 在项目中安装和配置 webpack"></a>2. 在项目中安装和配置 webpack</h5><ol><li><p>运行 <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code> 命令，安装 webpack 相关的包</p></li><li><p>在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件</p></li><li><p>在 webpack 的配置文件中，初始化如下基本配置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br><span class="hljs-attr">mode</span>: <span class="hljs-string">&#x27;development&#x27;</span> <span class="hljs-comment">// mode 用来指定构建模式</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>mode 节点的可选值有两个，分别是：</p><ul><li>development<ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul></li><li>production<ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，仅适合在项目发布阶段使用</li></ul></li></ul></li><li><p>在 package.json 配置文件中的 scripts 节点下，新增 dev 脚本如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack&quot;</span> <span class="hljs-comment">// script 节点下的脚本，可以通过 npm run 执行</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在终端中运行 <code>npm run dev</code> 命令，启动 webpack 进行项目打包。</p></li></ol><p>注意：主页面中导入的应该为打包生成后的 dist 文件夹下的 js 文件</p><h5 id="3-配置打包的入口和出口"><a href="#3-配置打包的入口和出口" class="headerlink" title="3. 配置打包的入口和出口"></a>3. 配置打包的入口和出口</h5><p>webpack 的 4.x 版本中默认约定：</p><ul><li>打包的 入口文件 为 src -&gt; index.js</li><li>打包的 输出文件 为 dist -&gt; main.js</li></ul><p>修改打包的入口(entry)和出口(output)，可以在 webpack.config.js 中增加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">entry</span>: path.join(__dirname, <span class="hljs-string">&#x27;./src/index.js&#x27;</span>), <span class="hljs-comment">// 打包入口文件的路径</span><br>    <span class="hljs-attr">output</span>: &#123;<br>        <span class="hljs-attr">path</span>: path.join(__dirname, <span class="hljs-string">&#x27;./dist&#x27;</span>), <span class="hljs-comment">// 输出文件的存放路径</span><br>        <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;bundle.js&#x27;</span> <span class="hljs-comment">// 输出文件的名称</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="4-配置-webpack-的自动打包功能"><a href="#4-配置-webpack-的自动打包功能" class="headerlink" title="4. 配置 webpack 的自动打包功能"></a>4. 配置 webpack 的自动打包功能</h5><ol><li><p>运行 <code>npm install webpack-dev-server@3.11.2 -D</code> 命令，安装支持项目自动打包的工具</p></li><li><p>修改   package.json   -&gt;   scripts   中的  dev  命令如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack server&quot;</span><br>&#125;,<br></code></pre></div></td></tr></table></figure></li><li><p>将 src -&gt; index.html 中，script 脚本的引用路径，修改为 “/bundle.js”</p></li><li><p>运行 <code>npm run dev</code> 命令，重新进行打包</p></li><li><p>在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果。</p></li></ol><h5 id="5-配置-html-webpack-plugin-生成预览页面"><a href="#5-配置-html-webpack-plugin-生成预览页面" class="headerlink" title="5. 配置 html-webpack-plugin 生成预览页面"></a>5. 配置 html-webpack-plugin 生成预览页面</h5><ol><li><p>运行 <code>npm install html-webpack-plugin@5.3.2 -D</code> 命令，安装生成预览页面的插件</p></li><li><p>修改 webpack.config.js 文件头部区域，添加如下配置信息：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>)<br><br><span class="hljs-keyword">const</span> htmlPlugin = <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>    <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;./src/index.html&#x27;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;index.html&#x27;</span><br>&#125;)<br></code></pre></div></td></tr></table></figure></li><li><p>修改 webpack.config.js  文件中向外暴露的配置对象，新增如下配置节点：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">plugins</span>: [ htmlPlugin ] <span class="hljs-comment">// plugins 数组时 webpack 打包期间会用到的一些插件列表</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h5 id="6-配置自动打包相关的参数"><a href="#6-配置自动打包相关的参数" class="headerlink" title="6. 配置自动打包相关的参数"></a>6. 配置自动打包相关的参数</h5><p>安装插件 <code>npm install webpack-dev-server -D</code> </p><p>在 package.json 中配置：</p><ul><li>–open  打包完成自动打开浏览器页面</li><li>–host   配置 IP 地址</li><li>–port   配置端口</li></ul><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;webpack server --open --host 127.0.0.1 --port 8080&quot;</span><br>&#125;,<br></code></pre></div></td></tr></table></figure><p>在 webpack.config.js 中配置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;<br>    <span class="hljs-attr">devServer</span>: &#123;<br>        <span class="hljs-attr">open</span>: <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;127.0.0.1&#x27;</span>,<br>        <span class="hljs-attr">port</span>: <span class="hljs-number">8080</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="webpack-中的加载器"><a href="#webpack-中的加载器" class="headerlink" title="webpack 中的加载器"></a>webpack 中的加载器</h4><ol><li>webpack 默认只能打包处理 .js 结尾的文件，处理不了其他后缀的文件</li><li>代码中包含了其他文件，因此 webpack 默认处理不了</li><li>会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器</li><li>找到后，将文件转交给最后一个 loader 进行处理</li><li>处理完毕后，会把处理的结果转交给上一个 loader</li><li>到最后，前面没有下一个 loader 了，就把最后的结果转交给了 webpack</li><li>webpack 将结果合并到 /dist/bundle.js 中，最终生成打包好的文件</li></ol><h5 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h5><p>控制台报错： </p><p>DevTools failed to load SourceMap: Could not load content for webpack:///node_modules/sockjs-client/ </p><p>解决：</p><p>webpack.config.js 中配置一项</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;inline-source-map&#x27;</span>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="通过-loader-打包非-js-模块"><a href="#通过-loader-打包非-js-模块" class="headerlink" title="通过 loader 打包非 js 模块"></a>通过 loader 打包非 js 模块</h5><ul><li>less-loader   可以打包处理 .less 相关的文件</li><li>sass-loader  可以打包处理 .scss 相关的文件</li><li>url-loader     可以打包处理 css 中与 url 路径相关的文件</li></ul><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><h6 id="1-打包处理-css-文件"><a href="#1-打包处理-css-文件" class="headerlink" title="1. 打包处理 css 文件"></a>1. 打包处理 css 文件</h6><ol><li><p>运行 <code>npm install style-loader@3.0.0 css-loader@5.2.6 -D</code> 命令，安装处理 css 文件的 loader</p></li><li><p>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    <span class="hljs-attr">rules</span>: [        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>]&#125;    ]&#125;<br></code></pre></div></td></tr></table></figure><p>其中，test 表示匹配的文件类型，use 表示对应要调用的 loader</p></li></ol><p>注意：</p><ul><li>use 数组中指定的 loader 顺序是固定的</li><li>多个 loader 的调用顺序是：从后往前调用</li></ul><h6 id="2-打包处理-less-文件"><a href="#2-打包处理-less-文件" class="headerlink" title="2. 打包处理 less 文件"></a>2. 打包处理 less 文件</h6><ol><li><p>运行 <code>npm i less-loader less -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    <span class="hljs-attr">rules</span>: [        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;less-loader&#x27;</span>]&#125;    ]&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h6 id="3-打包处理-scss-文件"><a href="#3-打包处理-scss-文件" class="headerlink" title="3. 打包处理 scss 文件"></a>3. 打包处理 scss 文件</h6><ol><li><p>运行 <code>npm i sass-loader node-sass -D</code> 命令，</p><p>运行不通使用：</p><ol><li><p>首先删除 node_modules 中的 sass-loader 和 node-sass 目录</p></li><li><p>配置淘宝镜像</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code> </p></li><li><p>用 cnpm 重新安装一次<br><code>cnpm install node-sass -D</code><br><code>cnpm install sass-loader -D</code> </p></li></ol></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    <span class="hljs-attr">rules</span>: [        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>, use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;sass-loader&#x27;</span>]&#125;    ]&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h6 id="4-配置-postCSS-自动添加-css-的兼容前缀"><a href="#4-配置-postCSS-自动添加-css-的兼容前缀" class="headerlink" title="4. 配置 postCSS 自动添加 css 的兼容前缀"></a>4. 配置 postCSS 自动添加 css 的兼容前缀</h6><ol><li><p>运行 <code>npm i postcss-loader autoprefixer -D</code> 命令，</p></li><li><p>在项目根目录中创建 postcss 的配置文件 postcss.config.js，并初始化如下配置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 导入自动添加前缀的插件const autoprefixer = require(&#x27;autoprefixer&#x27;)module.exports = &#123;    plugins: [ autoprefixer ] // 挂载插件&#125;</span><br></code></pre></div></td></tr></table></figure></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，修改 css 的 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    <span class="hljs-attr">rules</span>: [        &#123;<span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, use: [<span class="hljs-string">&#x27;style-loader&#x27;</span>, <span class="hljs-string">&#x27;css-loader&#x27;</span>, <span class="hljs-string">&#x27;postcss-loader&#x27;</span>]&#125;    ]&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h6 id="5-打包样式表中的图片和字体文件"><a href="#5-打包样式表中的图片和字体文件" class="headerlink" title="5. 打包样式表中的图片和字体文件"></a>5. 打包样式表中的图片和字体文件</h6><ol><li><p>运行 <code>npm i url-loader file-loader -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123;    <span class="hljs-attr">rules</span>: [        &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>, use: <span class="hljs-string">&#x27;url-loader?limit=32417&amp;outputPath=images&#x27;</span> &#125;,    ]&#125;<br></code></pre></div></td></tr></table></figure><p>注：</p><ul><li>? 后 limit参数是文件的大小（单位是字节），小于此大小 才会编译为 base64 格式</li><li>outputPath 参数是该类型文件打包后存放的文件夹</li></ul></li></ol><h6 id="6-打包处理-js-文件中的高级语法"><a href="#6-打包处理-js-文件中的高级语法" class="headerlink" title="6. 打包处理 js 文件中的高级语法"></a>6. 打包处理 js 文件中的高级语法</h6><ol><li><p>运行 </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i babel-loader@<span class="hljs-number">8.2</span>.<span class="hljs-number">2</span> @babel/core@<span class="hljs-number">7.14</span>.<span class="hljs-number">6</span> @babel/runtime@<span class="hljs-number">7.14</span>.<span class="hljs-number">5</span> -D<br></code></pre></div></td></tr></table></figure><p> 命令，安装 babel 转换器相关的包</p></li><li><p>运行 </p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-<span class="hljs-class"><span class="hljs-keyword">class</span>-<span class="hljs-title">properties</span> -<span class="hljs-title">D</span></span><br></code></pre></div></td></tr></table></figure><p>命令，安装babel语法插件相关的包</p></li><li><p>在项目根目录下，创建 babel 配置文件 babel.config.js 并初始化基本配置如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/env&#x27;</span>],  <span class="hljs-attr">plugins</span>: [<span class="hljs-string">&#x27;@babel/plugin-transform-rutime&#x27;</span>, <span class="hljs-string">&#x27;@babel/plugin-proposal-class-properties&#x27;</span>]&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件module: &#123;    rules: [        &#123; test: /\.js$/, use: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125;    ]&#125;</span><br></code></pre></div></td></tr></table></figure></li></ol><h6 id="7-配置-vue-组件的加载器"><a href="#7-配置-vue-组件的加载器" class="headerlink" title="7. 配置 vue 组件的加载器"></a>7. 配置 vue 组件的加载器</h6><ol><li><p>运行 <code>npm i vue-loader vue-template-compiler -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> VueLoaderPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vue-loader/lib/plugin&#x27;</span>)<span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-attr">module</span>: &#123;        <span class="hljs-attr">rules</span>: [            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.vue$/</span>, use: <span class="hljs-string">&#x27;vue-loader&#x27;</span> &#125;        ]    &#125;,    <span class="hljs-attr">plugin</span>: [        <span class="hljs-keyword">new</span> VueLoaderPlugin()    ]&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><p>在 package.json 的 scripts 节点下，新增 build 命令如下：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;webpack --mode production&quot;</span>&#125;,<br></code></pre></div></td></tr></table></figure><p>–mode 用来指定 webpack 的运行模式</p><h5 id="自动删除-dist-目录"><a href="#自动删除-dist-目录" class="headerlink" title="自动删除 dist 目录"></a>自动删除 dist 目录</h5><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i clean-webpack-plugin -D<br></code></pre></div></td></tr></table></figure><p>导入</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 左侧的 &#123;&#125; 是解构赋值const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)plugins: [    new CleanWebPlugin()]</span><br></code></pre></div></td></tr></table></figure><h5 id="source-Map"><a href="#source-Map" class="headerlink" title="source Map"></a>source Map</h5><p>开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题</p><p>解决：在 webpack.config.js 中增加如下的配置，即可使得运行时报错的行数与源代码的行数保存一致</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">module.exports = &#123;    devtool: &#x27;eval-source-map&#x27;,&#125;<br></code></pre></div></td></tr></table></figure><p><strong>折中方法</strong>，只定位行数不暴露源码：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">module.exports = &#123;    devtool: &#x27;nosources-source-map&#x27;&#125;<br></code></pre></div></td></tr></table></figure><p>不推荐的参数 source-map 坚决不要使用</p><ul><li>在生产环境下，设置成 nosources-source-map 或 直接关闭 Source Map</li><li>开发调试阶段，建议把 devtool 的值设置为 eval-source-map</li></ul><h4 id="webpack-中的"><a href="#webpack-中的" class="headerlink" title="webpack 中的 @"></a>webpack 中的 @</h4><p>@ 表示 src 源代码目录，从外往里查找；不要使用 ../ 从里往外查找</p><p>需要在 webpack.config.js 中进行配置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-attr">resolve</span>: &#123;        <span class="hljs-attr">alias</span>: &#123;            <span class="hljs-comment">// 告诉 webpack 程序员写的代码中 @ 表示 src 这一层目录            &#x27;@&#x27;: path.join(__dirname, &#x27;./src&#x27;)        &#125;    &#125;&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="webpack-中使用-Vue"><a href="#webpack-中使用-Vue" class="headerlink" title="webpack 中使用 Vue"></a>webpack 中使用 Vue</h4><ol><li>运行 <code>npm i vue -S</code> 安装 vue</li><li>在 src -&gt; index.js 入口文件中，通过 <code>ipmort Vue from &#39;vue&#39; </code> 来导入 vue 构造函数</li><li>创建 vue 的实例对象，并且要控制的 el 区域</li><li>通过 render 函数渲染 App 根组件</li></ol><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><span class="hljs-comment">// 导入 单文件组件import App from &#x27;./components/App.vue&#x27;const vm = new Vue(&#123;  el: &#x27;#app&#x27;,  render: h =&gt; h(App)&#125;)</span><br></code></pre></div></td></tr></table></figure><p><strong>报错处理</strong>：</p><p>Error: Cannot find module ‘@babel/preset-preset.env’</p><p>解决：</p><p>将 babel.config.js 配置文件中的 <code>preset-env</code> ，改为  <code>env</code> </p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
      <tag>前端工程化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES8笔记</title>
    <link href="/2021/07/30/ES8%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/30/ES8%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><h5 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h5><p>返回值是 Promise 对象</p><ul><li>只要 return 返回的结果不是一个 Promise 类型的对象，则这个结果就是一个成功的 Promise</li><li>抛出错误，返回的结果是一个失败的 Promise </li><li>返回的结果是一个 Promise 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// async 函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 返回正常</span><br>    <span class="hljs-comment">// return &#x27;字符串&#x27;;</span><br>    <span class="hljs-comment">// 抛出错误</span><br>    <br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦！！&#x27;)</span><br>    <span class="hljs-comment">// 返回的是Promise</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&#x27;成功的数据&#x27;</span>);<br>        <span class="hljs-comment">// reject(&#x27;失败的数据&#x27;);</span><br>    &#125;)<br>&#125;<br><br><span class="hljs-keyword">const</span> result = fn();<br><span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// Promise 对象</span><br></code></pre></div></td></tr></table></figure><h5 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h5><ul><li>await 必须写在 async 函数中</li><li>await 右侧的表达式一般为 promise 对象</li><li>await 返回的是 promise 成功的值</li><li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建 Promise 对象</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// resolve(&#x27;成功的值&#x27;)</span><br>    reject(<span class="hljs-string">&#x27;失败啦&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// await 要放在 async 函数中</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> p;<br>        <span class="hljs-comment">// </span><br>        <span class="hljs-built_in">console</span>.log(result);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>        <span class="hljs-built_in">console</span>.log(e);<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 调用函数</span><br>main();<br></code></pre></div></td></tr></table></figure><h5 id="async-amp-await-获取文件"><a href="#async-amp-await-获取文件" class="headerlink" title="async &amp; await 获取文件"></a>async &amp; await 获取文件</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 引入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 读取 为学</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readWeiXue</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.readFile(<span class="hljs-string">&#x27;./resources/为学.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 如果失败</span><br>            <span class="hljs-keyword">if</span> (err) reject(err)<br>            <span class="hljs-comment">// 如果成功</span><br>            resolve(data)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 读取 插秧诗</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readChaYang</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.readFile(<span class="hljs-string">&#x27;./resources/插秧诗.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 如果失败</span><br>            <span class="hljs-keyword">if</span> (err) reject(err)<br>            <span class="hljs-comment">// 如果成功</span><br>            resolve(data)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 读取 观书有感</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">readGuanShu</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.readFile(<span class="hljs-string">&#x27;./resources/观书有感.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-comment">// 如果失败</span><br>            <span class="hljs-keyword">if</span> (err) reject(err)<br>            <span class="hljs-comment">// 如果成功</span><br>            resolve(data)<br>        &#125;)<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// 声明一个 async 函数</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 获取 为学</span><br>    <span class="hljs-keyword">let</span> weixue = <span class="hljs-keyword">await</span> readWeiXue();<br>    <span class="hljs-comment">// 获取 插秧诗</span><br>    <span class="hljs-keyword">let</span> chayang = <span class="hljs-keyword">await</span> readChaYang();<br>    <span class="hljs-comment">// 获取 观书有感</span><br>    <span class="hljs-keyword">let</span> guanshu = <span class="hljs-keyword">await</span> readGuanShu();<br>    <span class="hljs-built_in">console</span>.log(weixue);<br>&#125;<br><br>main();<br></code></pre></div></td></tr></table></figure><h5 id="async-amp-await-封装-AJAX-请求"><a href="#async-amp-await-封装-AJAX-请求" class="headerlink" title="async &amp; await 封装 AJAX 请求"></a>async &amp; await 封装 AJAX 请求</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 发送 AJAX 请求，返回的结果是 Promise 对象</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sendAJAX</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 1. 创建对象</span><br>        <span class="hljs-keyword">const</span> x = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>        <span class="hljs-comment">// 2. 初始化</span><br>        x.open(<span class="hljs-string">&#x27;GET&#x27;</span>, url);<br><br>        <span class="hljs-comment">// 3. 发送</span><br>        x.send();<br><br>        <span class="hljs-comment">// 4. 事件绑定</span><br>        x.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            <span class="hljs-keyword">if</span> (x.readyState === <span class="hljs-number">4</span>) &#123;<br>                <span class="hljs-keyword">if</span> (x.status &gt;= <span class="hljs-number">200</span> &amp;&amp; x.status &lt; <span class="hljs-number">300</span>) &#123;<br>                    <span class="hljs-comment">// 成功</span><br>                    resolve(x.response)<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// 如果失败</span><br>                    reject(x.status)<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;)<br>&#125;<br><br><span class="hljs-comment">// Promise then 方法测试</span><br><span class="hljs-comment">// const result = sendAJAX(&#x27;https://api.apiopen.top/getJoke&#x27;).then(value =&gt; &#123;</span><br><span class="hljs-comment">//   console.log(value);</span><br><span class="hljs-comment">// &#125;, reason =&gt; &#123;&#125;)</span><br><br><span class="hljs-comment">// async 与 await 测试</span><br><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">main</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 发送 AJAX 请求</span><br>    <span class="hljs-keyword">let</span> result = <span class="hljs-keyword">await</span> sendAJAX(<span class="hljs-string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.log(result);<br>&#125;<br><br>main();<br></code></pre></div></td></tr></table></figure><h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回一个给定对象的所有可枚举属性值的数组</p><ul><li>获取一个对象所有的键<code>Object.key(对象名)</code></li><li>获取一个对象所有的值<code>Object.values(对象名)</code></li></ul><h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个给定对象自身可遍历属性 [key,value] 的数组</p><ul><li>获取一个对象所有的键值对，一个键值对就是一个数组元素</li></ul><h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h5><p>该方法返回指定对象所有自身属性的描述对象</p><ul><li>value：值</li><li>writable：是否可写</li><li>configurable：是否可以删除</li><li>enumerable：是否可以枚举</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>ES8</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES7笔记</title>
    <link href="/2021/07/30/ES7%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/30/ES7%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>Includes 方法用来检测数组中是否包含某个元素，返回 boolean 类型值</p><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> ** <span class="hljs-number">10</span>); <span class="hljs-comment">// 1024</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Math</span>.pow(<span class="hljs-number">2</span>, <span class="hljs-number">10</span>)); <span class="hljs-comment">// 1024</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ES7</tag>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6笔记</title>
    <link href="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/30/ES6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="第一章-ECMASript-相关介绍"><a href="#第一章-ECMASript-相关介绍" class="headerlink" title="第一章 ECMASript 相关介绍"></a>第一章 <strong>ECMASript</strong> 相关介绍</h2><h3 id="1-1-什么是-ECMA"><a href="#1-1-什么是-ECMA" class="headerlink" title="1.1 什么是 ECMA"></a>1.1 什么是 ECMA</h3><p>ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。</p><h3 id="1-2-什么是-ECMAScript"><a href="#1-2-什么是-ECMAScript" class="headerlink" title="1.2 什么是 ECMAScript"></a>1.2 什么是 ECMAScript</h3><p>ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。</p><h3 id="1-3-为什么要学习-ES6"><a href="#1-3-为什么要学习-ES6" class="headerlink" title="1.3 为什么要学习 ES6"></a>1.3 为什么要学习 ES6</h3><ul><li>ES6 的版本变动内容最多，具有里程碑意义</li><li>ES6 加入许多新的语法特性，编程实现更简单、高效</li><li>ES6 是前端发展趋势，就业必备技能</li></ul><h3 id="1-4-ES6-兼容性"><a href="#1-4-ES6-兼容性" class="headerlink" title="1.4 ES6 兼容性"></a>1.4 ES6 兼容性</h3><p><a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a> 可查看兼容性</p><h2 id="第二章-ECMAScript-6-新特性"><a href="#第二章-ECMAScript-6-新特性" class="headerlink" title="第二章 ECMAScript 6 新特性"></a>第二章 ECMAScript 6 新特性</h2><h3 id="2-1-let-关键字"><a href="#2-1-let-关键字" class="headerlink" title="2.1 let 关键字"></a>2.1 let 关键字</h3><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>变量不能重复声明</li><li>块儿级作用域</li><li>不存在变量提升(不允许在变量声明之前使用变量)</li><li>不影响作用域链</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>​    以后声明变量使用 let 就对了</p><h3 id="2-2-const-关键字"><a href="#2-2-const-关键字" class="headerlink" title="2.2 const 关键字"></a>2.2 const 关键字</h3><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li>声明必须赋初始值</li><li>标识符一般为大写</li><li>不允许重复声明</li><li>值不允许修改</li><li>块儿级作用域</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>​    对象属性修改和数组元素变化不会出发 const 错误</p><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>​    声明对象类型使用 const，非对象类型声明选择 let</p><h3 id="2-3-变量的解构赋值"><a href="#2-3-变量的解构赋值" class="headerlink" title="2.3 变量的解构赋值"></a>2.3 变量的解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//数组的解构赋值</span><br><span class="hljs-keyword">const</span> arr = [<span class="hljs-string">&#x27;张学友&#x27;</span>, <span class="hljs-string">&#x27;刘德华&#x27;</span>, <span class="hljs-string">&#x27;黎明&#x27;</span>, <span class="hljs-string">&#x27;郭富城&#x27;</span>];<br><span class="hljs-keyword">let</span> [zhang, liu, li, guo] = arr;<br><span class="hljs-built_in">console</span>.log(zhang); <span class="hljs-comment">// 张学友</span><br><br><span class="hljs-comment">//对象的解构赋值</span><br><span class="hljs-keyword">const</span> lin = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;林志颖&#x27;</span>,<br>    <span class="hljs-attr">tags</span>: [<span class="hljs-string">&#x27;车手&#x27;</span>, <span class="hljs-string">&#x27;歌手&#x27;</span>, <span class="hljs-string">&#x27;小旋风&#x27;</span>, <span class="hljs-string">&#x27;演员&#x27;</span>],<br>    <span class="hljs-attr">changge</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以唱歌&#x27;</span>);<br>    &#125;<br>&#125;;<br><span class="hljs-keyword">let</span> &#123;name, tags&#125; = lin;<br><span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 林志颖</span><br><span class="hljs-keyword">let</span> &#123;cahngge&#125; = lin;<br>changge(); <span class="hljs-comment">// 我可以唱歌</span><br></code></pre></div></td></tr></table></figure><h3 id="2-4-模板字符串"><a href="#2-4-模板字符串" class="headerlink" title="2.4 模板字符串"></a>2.4 模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用一对反引号（`）标识</p><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h5><ul><li>字符串中可以出现换行符</li><li>可以使用 ${xxx} 的输出变量</li></ul><h3 id="2-5-简化对象写法"><a href="#2-5-简化对象写法" class="headerlink" title="2.5 简化对象写法"></a>2.5 简化对象写法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> name = <span class="hljs-string">&#x27;尚硅谷&#x27;</span>;<br><span class="hljs-keyword">let</span> slogon = <span class="hljs-string">&#x27;永远追求行业更高标准&#x27;</span>;<br><span class="hljs-keyword">let</span> improve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;可以提高你的技能&#x27;</span>);<br>&#125;<br><span class="hljs-comment">//属性和方法简写</span><br><span class="hljs-keyword">let</span> atguigu = &#123;<br>    name,<br>    slogon,<br>    improve,<br>    <span class="hljs-function"><span class="hljs-title">change</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;可以改变你&#x27;</span>)<br>    &#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="2-6-箭头函数"><a href="#2-6-箭头函数" class="headerlink" title="2.6 箭头函数"></a>2.6 箭头函数</h3><p>ES6 允许使用「箭头」  <code>=&gt;</code>  定义函数。</p><p>ES6 允许给函数参数赋初始值</p><ul><li>具有默认值的参数，一般靠后</li><li>可以与解构赋值结合</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>如果形参只有一个，则小括号可以省略</li><li>函数体如果只有一条语句，则花括号可以省略，此时 return 必须省略，而且函数的返回值为该条语句的执行结果</li><li>箭头函数 this 是静态的，始终指向声明时所在作用域下 this 的值</li><li>箭头函数不能作为构造函数实例化</li><li>不能使用 arguments</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 通用写法</span><br><span class="hljs-keyword">let</span> fn = <span class="hljs-function">(<span class="hljs-params">arg1, arg2, arg3</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> arg1 + arg2 + arg3;<br>&#125;<br><span class="hljs-comment">// 省略花括号的情况</span><br><span class="hljs-keyword">let</span> fn3 = <span class="hljs-function"><span class="hljs-params">score</span> =&gt;</span> score * <span class="hljs-number">20</span>;<br></code></pre></div></td></tr></table></figure><h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>适合与 this 无关的回调  定时器、数组的方法回调</p><p>不适合与 this 有关的回调  事件回调、对象的方法</p><h3 id="2-7-rest-参数"><a href="#2-7-rest-参数" class="headerlink" title="2.7 rest 参数"></a>2.7 rest 参数</h3><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p><ul><li><code>...args</code></li><li>rest参数必须要放到最后</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/**</span><br><span class="hljs-comment">* 作用与 arguments 类似</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">...args</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">// [1,2,3,4,5]</span><br>&#125;<br>add(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">* rest 参数必须是最后一个形参</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">minus</span>(<span class="hljs-params">a,b,...args</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">// 100</span><br>    <span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">// 1</span><br>    <span class="hljs-built_in">console</span>.log(args);<span class="hljs-comment">// [2,3,4,5,19]</span><br>&#125;<br>minus(<span class="hljs-number">100</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">19</span>);<br></code></pre></div></td></tr></table></figure><h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><p>rest 参数非常适合不定个数参数函数的场景</p><h3 id="2-8-spread-运算符"><a href="#2-8-spread-运算符" class="headerlink" title="2.8 spread 运算符"></a>2.8 spread 运算符</h3><p>扩展运算符（spread）也是三个点<code>...</code>。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol><li><p>数组的合并</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>];<br><span class="hljs-comment">// const hebing = arr1.concat(arr2); 原先api函数</span><br><span class="hljs-keyword">const</span> hebing = [...arr1, ...arr2]<br></code></pre></div></td></tr></table></figure></li><li><p>数组的克隆</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-comment">// 注意是 浅克隆</span><br><span class="hljs-keyword">const</span> hebing = [...arr1,]<br></code></pre></div></td></tr></table></figure></li><li><p>将伪数组转为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> divs = <span class="hljs-built_in">document</span>.querySelectAll(<span class="hljs-string">&#x27;div&#x27;</span>); <span class="hljs-comment">// 伪数组</span><br><span class="hljs-keyword">const</span> divArr = [...divs]<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="2-9-Symbol"><a href="#2-9-Symbol" class="headerlink" title="2.9 Symbol"></a>2.9 Symbol</h3><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 值不能与其他数据进行运算</li><li>Symbol 定义的 对象属性 不能使用 for…in 循环遍历 ，但是可以 使用 Reflect.ownKeys 来获取对象的所有键名</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建 Symbol</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-built_in">Symbol</span>();<br><span class="hljs-built_in">console</span>.log(s, <span class="hljs-keyword">typeof</span> s); <span class="hljs-comment">// Symbol() &quot;symbol&quot;</span><br><span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;张艺兴&#x27;</span>); <span class="hljs-comment">// 注释作用</span><br><span class="hljs-keyword">let</span> s3 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">&#x27;张艺兴&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(s2 === s3); <span class="hljs-comment">// false</span><br><span class="hljs-comment">// Symbol.for 创建</span><br><span class="hljs-keyword">let</span> s4 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;张艺兴&#x27;</span>);<br><span class="hljs-keyword">let</span> s5 = <span class="hljs-built_in">Symbol</span>.for(<span class="hljs-string">&#x27;张艺兴&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(s4, <span class="hljs-keyword">typeof</span> s4); <span class="hljs-comment">// Symbol(张艺兴) &quot;symbol&quot;</span><br><span class="hljs-built_in">console</span>.log(s4 === s5); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p><code>Symbol[&#39;say&#39;]: function () &#123;&#125;</code></p><h5 id="内置值"><a href="#内置值" class="headerlink" title="内置值"></a>内置值</h5><h4 id="JS-数据类型总结"><a href="#JS-数据类型总结" class="headerlink" title="JS 数据类型总结"></a>JS 数据类型总结</h4><p><strong>USONB</strong> (you are so niubility)</p><ul><li>u : undefined</li><li>s : string Symbol</li><li>o : object</li><li>n : null number</li><li>b : boolean</li></ul><h3 id="2-10-迭代器"><a href="#2-10-迭代器" class="headerlink" title="2.10 迭代器"></a>2.10 迭代器</h3><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p><ul><li><p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个数组</span><br><span class="hljs-keyword">const</span> xiyou = [<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;4&#x27;</span>];<br><br><span class="hljs-comment">// 使用 for...of 遍历数组</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> xiyou) &#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>原生具备 iterator 接口的数据(可用 for of 遍历)</p><ul><li>Array</li><li>Arguments</li><li>Set</li><li>Map</li><li>String</li><li>TypedArray</li><li>NodeList</li></ul></li><li><p>工作原理</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> iterator = xiyou[<span class="hljs-built_in">Symbol</span>.iterator]();<br><br><span class="hljs-comment">// 调用对象的 next 方法</span><br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br></code></pre></div></td></tr></table></figure><p>运行结果：</p><p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622185251823.png"></p></li></ul><h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><p>需要自定义遍历数据的时候，要想到迭代器。</p><h5 id="自定义遍历对象"><a href="#自定义遍历对象" class="headerlink" title="自定义遍历对象"></a>自定义遍历对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个对象</span><br><span class="hljs-keyword">const</span> banji = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;终极一班&#x27;</span>,<br>    <span class="hljs-attr">stus</span>: [<br>        <span class="hljs-string">&#x27;xiaoming&#x27;</span>,<br>        <span class="hljs-string">&#x27;xiaoning&#x27;</span>,<br>        <span class="hljs-string">&#x27;xiaotian&#x27;</span>,<br>        <span class="hljs-string">&#x27;knight&#x27;</span><br>    ],<br>    [<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>        <span class="hljs-comment">// 索引变量</span><br>        <span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">let</span> _this = <span class="hljs-built_in">this</span>;<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-attr">next</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>                <span class="hljs-keyword">if</span> (index &lt; _this.stus.length) &#123;<br>                    <span class="hljs-keyword">const</span> result = &#123;<span class="hljs-attr">value</span>: _this.stus[index], <span class="hljs-attr">done</span>: <span class="hljs-literal">false</span>&#125;<br>                    <span class="hljs-comment">// 下表自增</span><br>                    index++;<br>                    <span class="hljs-comment">// 返回结果</span><br>                    <span class="hljs-keyword">return</span> result<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: <span class="hljs-literal">undefined</span>, <span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>&#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 遍历这个对象</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> banji) &#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-11-生成器"><a href="#2-11-生成器" class="headerlink" title="2.11 生成器"></a>2.11 生成器</h3><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，起其实就是一个特殊的函数。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// yield 函数代码的分隔符</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// console.log(111);</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有耳朵&#x27;</span>;<br>    <span class="hljs-comment">// console.log(222);</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有尾巴&#x27;</span>;<br>    <span class="hljs-comment">// console.log(333);</span><br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span>;<br>    <span class="hljs-comment">// console.log(444);</span><br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = gen();<br><span class="hljs-comment">// 调用 next() 方法才会执行方法</span><br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> gen()) &#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行截图：</p><p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622193807793.png"></p><h5 id="生成器函数参数"><a href="#生成器函数参数" class="headerlink" title="生成器函数参数"></a>生成器函数参数</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> * <span class="hljs-title">gen</span>(<span class="hljs-params">arg</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(arg);<br>    <span class="hljs-keyword">let</span> one = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有耳朵&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(one);<br>    <span class="hljs-keyword">let</span> two = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;一只没有尾巴&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(two);<br>    <span class="hljs-keyword">let</span> three = <span class="hljs-keyword">yield</span> <span class="hljs-string">&#x27;真奇怪&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.log(three);<br>&#125;<br><br><span class="hljs-keyword">let</span> iterator = gen(<span class="hljs-string">&#x27;AAA&#x27;</span>);<br><span class="hljs-comment">// 调用 next() 方法才会执行方法</span><br><span class="hljs-built_in">console</span>.log(iterator.next());<br><span class="hljs-built_in">console</span>.log(iterator.next(<span class="hljs-string">&#x27;BBB&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(iterator.next(<span class="hljs-string">&#x27;CCC&#x27;</span>));<br><span class="hljs-built_in">console</span>.log(iterator.next(<span class="hljs-string">&#x27;DDD&#x27;</span>));<br></code></pre></div></td></tr></table></figure><p>运行截图：</p><p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622194527052.png"></p><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>…</p><h3 id="2-12-Promise"><a href="#2-12-Promise" class="headerlink" title="2.12 Promise"></a>2.12 Promise</h3><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><h5 id="Promise-构造方法"><a href="#Promise-构造方法" class="headerlink" title="Promise 构造方法"></a>Promise 构造方法</h5><p><code>const promise = new Promise(function(resolve, reject) &#123;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 实例化 Promise 对象</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">// let data = &#x27;数据库中的用户数据&#x27;</span><br>        <span class="hljs-comment">// resolve(data); // 调用 then 中第一个方法</span><br><br>        <span class="hljs-keyword">let</span> err = <span class="hljs-string">&#x27;数据读取失败&#x27;</span>;<br>        reject(err); <span class="hljs-comment">// 调用 then 中第二个方法</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 调用 Promise 对象的 then 方法</span><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 数据库中的用户数据</span><br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(reason); <span class="hljs-comment">// 数据读取失败</span><br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="Promise-读取文件"><a href="#Promise-读取文件" class="headerlink" title="Promise 读取文件"></a>Promise 读取文件</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 引入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    fs.readFile(<span class="hljs-string">&#x27;./resources/为学.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) reject(err);<br>        <span class="hljs-comment">// 如果成功</span><br>        resolve(data);<br>    &#125;)<br>&#125;)<br><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;读取失败&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="Promise-封装-AJAX"><a href="#Promise-封装-AJAX" class="headerlink" title="Promise 封装 AJAX"></a>Promise 封装 AJAX</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 接口地址 http://api.apiopen.top/getJoke</span><br><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>    <span class="hljs-comment">// 1. 创建对象</span><br>    <span class="hljs-keyword">const</span> xhr = <span class="hljs-keyword">new</span> XMLHttpRequest();<br><br>    <span class="hljs-comment">// 2. 初始化</span><br>    xhr.open(<span class="hljs-string">&#x27;GET&#x27;</span>, <span class="hljs-string">&#x27;https://api.apiopen.top/getJoke&#x27;</span>);<br><br>    <span class="hljs-comment">// 3. 发送</span><br>    xhr.send();<br><br>    <span class="hljs-comment">// 4. 绑定事件，处理响应结果</span><br>    xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (xhr.readyState === <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">if</span> (xhr.status &gt;= <span class="hljs-number">200</span> &amp;&amp; xhr.status &lt; <span class="hljs-number">300</span>) &#123;<br>                resolve(xhr.response)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                reject()<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;)<br><br><span class="hljs-comment">// 指定回调</span><br>p.then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">reason</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;获取失败&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建 promise 对象</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        resolve(<span class="hljs-string">&#x27;用户数据&#x27;</span>);<br>        <span class="hljs-comment">// reject(&#x27;出错啦&#x27;);</span><br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;);<br><br><span class="hljs-comment">// 调用 then 方法  then方法的返回结果是 Promise 对象，对象状态又回调函数的执行结果决定</span><br><span class="hljs-comment">// 1. 如果回调函数中返回的结果是一个 非Promise 类型的数据，状态为成功，返回值为对象那个的成功值</span><br><span class="hljs-keyword">const</span> result = p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>    <span class="hljs-comment">// 1. 非 Promise 类型的数据</span><br>    <span class="hljs-comment">// return 123;</span><br>    <span class="hljs-comment">// 2. 是 Promise 对象</span><br>    <span class="hljs-comment">// return new Promise((resolve, reject) =&gt; &#123;</span><br>    <span class="hljs-comment">//   // resolve(&#x27;ok&#x27;);</span><br>    <span class="hljs-comment">//   reject(&#x27;出错&#x27;)</span><br>    <span class="hljs-comment">// &#125;)</span><br>    <span class="hljs-comment">// 3. 抛出错误</span><br>    <span class="hljs-comment">// throw new Error(&#x27;出错啦&#x27;)</span><br>&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.warn(reason);<br>&#125;);<br><span class="hljs-built_in">console</span>.log(result);<br></code></pre></div></td></tr></table></figure><h6 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 链式调用 可以避免回调地狱的形成</span><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><br>&#125;,<span class="hljs-function"><span class="hljs-params">reason</span>=&gt;</span>&#123;<br><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span>=&gt;</span>&#123;<br><br>&#125;)<br></code></pre></div></td></tr></table></figure><p>另外，then 方法中的两个方法 不一定需要全有</p><h6 id="案例-读取多个文件"><a href="#案例-读取多个文件" class="headerlink" title="案例-读取多个文件"></a>案例-读取多个文件</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 引入 fs 模块</span><br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><br><span class="hljs-comment">// 之前的方法 - 回调地狱</span><br><span class="hljs-comment">// fs.readFile(&#x27;./resources/为学.md&#x27;, &#x27;utf8&#x27;, (err, data1) =&gt; &#123;</span><br><span class="hljs-comment">//   fs.readFile(&#x27;./resources/插秧诗.md&#x27;, &#x27;utf8&#x27;, (err, data2) =&gt; &#123;</span><br><span class="hljs-comment">//     fs.readFile(&#x27;./resources/观书有感.md&#x27;, &#x27;utf8&#x27;, (err, data3) =&gt; &#123;</span><br><span class="hljs-comment">//       let result = data1 + &#x27;\r\n&#x27; + data2 + &#x27;\r\n&#x27; + data3;</span><br><span class="hljs-comment">//       console.log(result);</span><br><span class="hljs-comment">//     &#125;)</span><br><span class="hljs-comment">//   &#125;)</span><br><span class="hljs-comment">// &#125;)</span><br><br><span class="hljs-comment">// 使用 Promise 实现</span><br><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    fs.readFile(<span class="hljs-string">&#x27;./resources/为学.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>        resolve(data);<br>    &#125;)<br>&#125;)<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.readFile(<span class="hljs-string">&#x27;./resources/插秧诗.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            resolve([value, data]);<br>        &#125;)<br>    &#125;)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        fs.readFile(<span class="hljs-string">&#x27;./resources/观书有感.md&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>            value.push(data);<br>            resolve(value);<br>        &#125;)<br>    &#125;)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value.join(<span class="hljs-string">&#x27;\r\n&#x27;</span>));<br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="Promise-catch-方法"><a href="#Promise-catch-方法" class="headerlink" title="Promise catch 方法"></a>Promise catch 方法</h5><p>不用不影响开发，catch 的作用只是简化，可以只写后面错误的函数，不需要写前面的。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> p = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-comment">// 设置 p 对象的状态为失败，并设置失败的值</span><br>        reject(<span class="hljs-string">&#x27;出错啦！&#x27;</span>)<br>    &#125;, <span class="hljs-number">1000</span>);<br>&#125;)<br><br>p.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;&#125;, <span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(reason);<br>&#125;)<br><br>p.catch(<span class="hljs-function"><span class="hljs-params">reason</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.warn(reason);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="2-13-Set"><a href="#2-13-Set" class="headerlink" title="2.13 Set"></a>2.13 Set</h3><p>ES6 提供了新的数据结构 Set（集合）。</p><p>它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。</p><h5 id="属性-amp-方法"><a href="#属性-amp-方法" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h5><ul><li>size     返回集合的元素个数</li><li>add     增加一个新元素，返回当前集合</li><li>delete 删除元素，返回 boolean 值</li><li>has      检测集合中是否包含某个元素，返回 boolean 值</li><li>clear    清空集合，返回 undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 声明一个 Set</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();<br><span class="hljs-keyword">let</span> s2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>([<span class="hljs-string">&#x27;大事儿&#x27;</span>, <span class="hljs-string">&#x27;小事儿&#x27;</span>, <span class="hljs-string">&#x27;好事儿&#x27;</span>, <span class="hljs-string">&#x27;坏事儿&#x27;</span>, <span class="hljs-string">&#x27;小事儿&#x27;</span>]);<br><span class="hljs-built_in">console</span>.log(s, <span class="hljs-keyword">typeof</span> s);<br><span class="hljs-built_in">console</span>.log(s2); <span class="hljs-comment">// 自动去重 &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;&#125;</span><br><br><span class="hljs-comment">// 元素的个数</span><br><span class="hljs-built_in">console</span>.log(s2.size); <span class="hljs-comment">// 4</span><br><span class="hljs-comment">// 添加新的元素</span><br>s2.add(<span class="hljs-string">&#x27;喜事儿&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(s2); <span class="hljs-comment">// &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;, &quot;喜事儿&quot;&#125;</span><br><span class="hljs-comment">// 删除元素</span><br>s2.delete(<span class="hljs-string">&#x27;坏事儿&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(s2); <span class="hljs-comment">// &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;喜事儿&quot;&#125;</span><br><span class="hljs-comment">// 检测</span><br><span class="hljs-built_in">console</span>.log(s2.has(<span class="hljs-string">&#x27;好事儿&#x27;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 清空</span><br>s2.clear();<br><span class="hljs-built_in">console</span>.log(s2); <span class="hljs-comment">// &#123;&#125;</span><br><br><span class="hljs-comment">// 也可实现 for...of 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> s2) &#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="Set-集合实践"><a href="#Set-集合实践" class="headerlink" title="Set 集合实践"></a>Set 集合实践</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>];<br><span class="hljs-comment">// 1. 数组去重</span><br><span class="hljs-comment">// let result = [...new Set(arr)];</span><br><span class="hljs-comment">// console.log(result);</span><br><span class="hljs-comment">// 2. 交集</span><br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>];<br><span class="hljs-comment">// let result = [...new Set(arr)].filter(item =&gt; &#123;</span><br><span class="hljs-comment">//   let s2 = new Set(arr2);</span><br><span class="hljs-comment">//   if (s2.has(item)) &#123;</span><br><span class="hljs-comment">//     return true;</span><br><span class="hljs-comment">//   &#125; else &#123;</span><br><span class="hljs-comment">//     return false;</span><br><span class="hljs-comment">//   &#125;</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// 简化</span><br><span class="hljs-keyword">let</span> result = [...new <span class="hljs-built_in">Set</span>(arr)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2).has(item))<br><span class="hljs-built_in">console</span>.log(result); <span class="hljs-comment">// [4, 5]</span><br><br><span class="hljs-comment">// 3. 并集</span><br><span class="hljs-keyword">let</span> union = [...new <span class="hljs-built_in">Set</span>([...arr, ...arr2])]<br><span class="hljs-built_in">console</span>.log(union);  <span class="hljs-comment">// [1, 2, 3, 4, 5, 6]</span><br><br><span class="hljs-comment">// 4. 差集</span><br><span class="hljs-keyword">let</span> diff = [...new <span class="hljs-built_in">Set</span>(arr)].filter(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> !(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(arr2).has(item)))<br><span class="hljs-built_in">console</span>.log(diff);   <span class="hljs-comment">// [1, 2, 3]</span><br></code></pre></div></td></tr></table></figure><h3 id="2-14-Map"><a href="#2-14-Map" class="headerlink" title="2.14 Map"></a>2.14 Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”<br>的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。</p><h5 id="属性-amp-方法-1"><a href="#属性-amp-方法-1" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h5><ul><li>size     返回 Map 的元素个数</li><li>add     增加一个新元素，返回当前 Map</li><li>get      返回键名对象的键值</li><li>has      检测 Map 中是否包含某个元素，返回 boolean 值</li><li>clear    清空集合，返回 undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 声明 Map</span><br><span class="hljs-keyword">let</span> m = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br><br><span class="hljs-comment">// 添加元素</span><br>m.set(<span class="hljs-string">&#x27;name&#x27;</span>, <span class="hljs-string">&#x27;张艺兴&#x27;</span>)<br>m.set(<span class="hljs-string">&#x27;change&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;张艺兴是最帅的&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">let</span> key = &#123;<br>    <span class="hljs-attr">school</span> : <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>&#125;<br>m.set(key, [<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>])<br><br><span class="hljs-comment">// size</span><br><span class="hljs-built_in">console</span>.log(m.size); <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 删除</span><br>m.delete(<span class="hljs-string">&#x27;name&#x27;</span>)<br><br><span class="hljs-comment">// 获取</span><br><span class="hljs-comment">// console.log(m.get(&#x27;change&#x27;));</span><br><span class="hljs-built_in">console</span>.log(m.get(key)); <span class="hljs-comment">// [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]</span><br><br><span class="hljs-comment">// 清空</span><br><span class="hljs-comment">// m.clear();</span><br><br><span class="hljs-comment">// 遍历</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> v <span class="hljs-keyword">of</span> m) &#123;<br>    <span class="hljs-built_in">console</span>.log(v);<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(m);<br></code></pre></div></td></tr></table></figure><h3 id="2-15-Class-类"><a href="#2-15-Class-类" class="headerlink" title="2.15 Class 类"></a>2.15 Class 类</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对<br>象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul><li>class 声明类</li><li>constructor 定义构造函数初始化</li><li>extends 继承父类</li><li>super 调用父级构造方法</li><li>static 定义静态方法和属性</li><li>父类方法可以重写</li></ul><h5 id="ES5-方法"><a href="#ES5-方法" class="headerlink" title="ES5 方法"></a>ES5 方法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ES5</span><br><span class="hljs-comment">// 手机</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Phone</span>(<span class="hljs-params">brand, price</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.brand = brand;<br>    <span class="hljs-built_in">this</span>.price = price;<br>&#125;<br><br><span class="hljs-comment">// 添加方法</span><br>Phone.prototype.call = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);<br>&#125;<br><br><span class="hljs-comment">// 实例化对象</span><br><span class="hljs-keyword">let</span> huawei = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&#x27;华为&#x27;</span>, <span class="hljs-number">5999</span>);<br><br><span class="hljs-built_in">console</span>.log(huawei);<br><span class="hljs-comment">// huawei.call();</span><br></code></pre></div></td></tr></table></figure><h5 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shouji</span> </span>&#123;<br>    <span class="hljs-comment">// 构造方法 名字不能修改</span><br>    <span class="hljs-title">constructor</span> (<span class="hljs-params">brand, price</span>) &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-comment">// 方法必须使用该语法，不能使用 ES5 的对象完整形式</span><br>    call () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">let</span> onePlus = <span class="hljs-keyword">new</span> Shouji(<span class="hljs-string">&#x27;1+&#x27;</span>, <span class="hljs-number">1999</span>);<br><span class="hljs-built_in">console</span>.log(onePlus);<br></code></pre></div></td></tr></table></figure><h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-comment">// 静态属性</span><br>    <span class="hljs-keyword">static</span> name = <span class="hljs-string">&#x27;手机&#x27;</span>;<br><span class="hljs-keyword">static</span> change = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以改变世界&#x27;</span>);<br>&#125;;<br>&#125;<br><br><span class="hljs-keyword">let</span> nokia = <span class="hljs-keyword">new</span> Phone();<br><span class="hljs-built_in">console</span>.log(nokia.name); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.log(Phone.name); <span class="hljs-comment">// 手机</span><br></code></pre></div></td></tr></table></figure><h5 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-title">constructor</span> (<span class="hljs-params">brand, price</span>) &#123;<br>        <span class="hljs-built_in">this</span>.brand = brand;<br>        <span class="hljs-built_in">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-comment">// 父类的成员属性</span><br>    call () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我可以打电话&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartPhone</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-comment">// 构造方法</span><br>    <span class="hljs-title">constructor</span> (<span class="hljs-params">brand, price, color, size</span>) &#123;<br>        <span class="hljs-built_in">super</span>(brand, price);<br>        <span class="hljs-built_in">this</span>.color = color;<br>        <span class="hljs-built_in">this</span>.size = size;<br>    &#125;<br><br>    photo () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;拍照&#x27;</span>);<br>    &#125;<br><br>    playGame () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;打游戏&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> xiaomi = <span class="hljs-keyword">new</span> SmartPhone(<span class="hljs-string">&#x27;小米&#x27;</span>, <span class="hljs-number">799</span>, <span class="hljs-string">&#x27;黑色&#x27;</span>, <span class="hljs-string">&#x27;4.7inch&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(xiaomi);<br>xiaomi.call();<br>xiaomi.photo();<br>xiaomi.playGame();<br></code></pre></div></td></tr></table></figure><p>子类可以进行对父类方法的重写</p><p>注：但是不能通过<code>super()</code>调用父类重名方法</p><h5 id="set-和-get"><a href="#set-和-get" class="headerlink" title="set 和 get"></a>set 和 get</h5><p>获取时，触发 get 方法</p><p>修改赋值时，触发 set 方法</p><p>注：set 方法必须有一个参数</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    get price () &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;价格属性被读取了&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">111</span><br>    &#125;<br><br>    set price (newV) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;价格属性被修改了&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化对象</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-keyword">new</span> Phone();<br><span class="hljs-built_in">console</span>.log(s.price); <span class="hljs-comment">// 111// 触发 get</span><br>s.price = <span class="hljs-string">&#x27;free&#x27;</span>;<span class="hljs-comment">// 触发 set</span><br></code></pre></div></td></tr></table></figure><h3 id="2-16-数值扩展"><a href="#2-16-数值扩展" class="headerlink" title="2.16 数值扩展"></a>2.16 数值扩展</h3><h5 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h5><p>Number.EPSILON 是 JavaScript 表示的最小精度   <code>ε</code> </p><p>EPSILON属性的值接近于：2.2204460492503130808472633361816E-16</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span> == <span class="hljs-number">0.3</span>); <span class="hljs-comment">// false</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">equal</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Math</span>.abs(a - b) &lt; <span class="hljs-built_in">Number</span>.EPSILON) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(equal(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>));<span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><h5 id="二进制和八进制"><a href="#二进制和八进制" class="headerlink" title="二进制和八进制"></a>二进制和八进制</h5><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> b = <span class="hljs-number">0b1010</span>;<span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> b = <span class="hljs-number">0o777</span>;<span class="hljs-comment">// 八进制</span><br><br><span class="hljs-keyword">let</span> d = <span class="hljs-number">100</span>;<span class="hljs-comment">// 十进制</span><br><span class="hljs-keyword">let</span> x = <span class="hljs-number">0xff</span>;<span class="hljs-comment">// 十六进制</span><br></code></pre></div></td></tr></table></figure><h5 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h5><p>用来检查一个数值是否为有限的，返回 boolean</p><h5 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h5><p>用来检查一个值是否为 NaN，返回 boolean</p><h5 id="Number-parseInt-amp-Number-parseFloat"><a href="#Number-parseInt-amp-Number-parseFloat" class="headerlink" title="Number.parseInt() &amp; Number.parseFloat()"></a>Number.parseInt() &amp; Number.parseFloat()</h5><p>移植到了 Number 对象下，使用不变，（截取整数，截取浮点数）</p><h5 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h5><p>用来判断一个数值是否为整数， 返回 boolean</p><h5 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h5><p>将数字的小数部分抹掉</p><h5 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h5><p>判断一个数是 正数(1) 负数(-1) 还是 0(0)   括号内为相应的返回值</p><h3 id="2-17-对象方法"><a href="#2-17-对象方法" class="headerlink" title="2.17 对象方法"></a>2.17 对象方法</h3><h5 id="Object-is-a-b"><a href="#Object-is-a-b" class="headerlink" title="Object.is(a,b)"></a>Object.is(a,b)</h5><p>判断两个值是否完全相等</p><p>与全等号 <code>===</code> 区别：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.is(<span class="hljs-literal">NaN</span>, <span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>);   <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><h5 id="Object-assign-a-b"><a href="#Object-assign-a-b" class="headerlink" title="Object.assign(a,b)"></a>Object.assign(a,b)</h5><p>对象的合并，后面的将前面的覆盖掉</p><p>可以用于更新对象</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> config1 = &#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    <span class="hljs-attr">prot</span>: <span class="hljs-number">3306</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">pass</span>: <span class="hljs-string">&#x27;root&#x27;</span>,<br>    <span class="hljs-attr">test</span>: <span class="hljs-string">&#x27;test&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> config2 = &#123;<br>    <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;http://www.baidu.com&#x27;</span>,<br>    <span class="hljs-attr">prot</span>: <span class="hljs-number">33060</span>,<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span>,<br>    <span class="hljs-attr">pass</span>: <span class="hljs-string">&#x27;020316&#x27;</span><br>&#125;<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.assign(config1, config2));<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">host: &quot;http://www.baidu.com&quot;</span><br><span class="hljs-comment">    name: &quot;AgoniLay&quot;</span><br><span class="hljs-comment">    pass: &quot;020316&quot;</span><br><span class="hljs-comment">    prot: 33060</span><br><span class="hljs-comment">    test: &quot;test&quot;</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h5 id="Object-setPrototypeof-amp-Object-getPrototypeof"><a href="#Object-setPrototypeof-amp-Object-getPrototypeof" class="headerlink" title="Object.setPrototypeof &amp; Object.getPrototypeof"></a>Object.setPrototypeof &amp; Object.getPrototypeof</h5><p>设置原型对象，一般不使用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.assign(config1, config2));<br><span class="hljs-comment">// Object.setPrototypeof  Object.getPrototypeof</span><br><span class="hljs-keyword">const</span> school = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span><br>&#125;<br><span class="hljs-keyword">const</span> cities = &#123;<br>    <span class="hljs-attr">xiaoqu</span>: [<span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-string">&#x27;上海&#x27;</span>, <span class="hljs-string">&#x27;深圳&#x27;</span>]<br>&#125;<br><br><span class="hljs-built_in">Object</span>.setPrototypeOf(school, cities)<br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf(school));<br><span class="hljs-built_in">console</span>.log(school);<br></code></pre></div></td></tr></table></figure><h3 id="2-18-模块化"><a href="#2-18-模块化" class="headerlink" title="2.18 模块化"></a>2.18 模块化</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>模块功能主要由两个命令构成：export 和 import</p><ul><li>export 命令用于规定模块的对外接口</li><li>import 命令用于输入其他模块提供的功能</li></ul><h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><h5 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h5><ol><li>AMD：Request.js (<a href="http://www.requirejs.cn/">http://www.requirejs.cn/</a>)</li><li>CMD：Sea.js (<a href="https://seajs.github.io/seajs/docs/">https://seajs.github.io/seajs/docs/</a>)</li></ol><h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><ul><li>CommonJS：NodeJS<ol><li>模块分为 单文件模块 与 包</li><li>模块成员导出：module.exports 和 exports</li><li>模块成员导入：require(‘模块标识符’)</li></ol></li></ul><h3 id="2-19-大一统的模块化规范-ES6模块化"><a href="#2-19-大一统的模块化规范-ES6模块化" class="headerlink" title="2.19 大一统的模块化规范 - ES6模块化"></a>2.19 大一统的模块化规范 - ES6模块化</h3><p>是 浏览器端 与 服务器端 通用的模块化开发规范</p><ul><li>每一个 js 文件都是一个独立的模块</li><li>导入模块成员使用 import 关键字</li><li>暴露模块成员使用 export 关键字</li></ul><h4 id="Node-js-中-babel-体验-ES6-模块化"><a href="#Node-js-中-babel-体验-ES6-模块化" class="headerlink" title="Node.js 中 babel 体验 ES6 模块化"></a>Node.js 中 babel 体验 ES6 模块化</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>安装工具</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node<br></code></pre></div></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install --save @babel/polyfill<br></code></pre></div></td></tr></table></figure></li><li><p>根目录下新建 babel.config.js 文件 写入：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> presets = [<br>    [<span class="hljs-string">&quot;@babel/env&quot;</span>, &#123;<br>        <span class="hljs-attr">targets</span>: &#123;<br>            <span class="hljs-attr">edge</span>: <span class="hljs-string">&quot;17&quot;</span>,<br>            <span class="hljs-attr">firefox</span>: <span class="hljs-string">&quot;60&quot;</span>,<br>            <span class="hljs-attr">chrome</span>: <span class="hljs-string">&quot;67&quot;</span>,<br>            <span class="hljs-attr">safari</span>: <span class="hljs-string">&quot;11.1&quot;</span><br>        &#125;<br>    &#125;]<br>]<br><br><span class="hljs-built_in">module</span>.exports = &#123; presets &#125;<br></code></pre></div></td></tr></table></figure></li><li><p>执行代码</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npx babel-node index.js<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="默认导出-与-默认导入"><a href="#默认导出-与-默认导入" class="headerlink" title="默认导出 与 默认导入"></a>默认导出 与 默认导入</h5><ul><li>默认导出：<code>export default 默认导出的成员</code> </li><li>默认导入：<code>import 接收名称 from &#39;模块标识符/路径&#39;</code> </li></ul><p>注意点：</p><ol><li>在每个模块中，只允许使用唯一的一次 export default，否则会报错</li><li>在模块中如果没有默认导出，那么将会 是一个空对象 <code>&#123;&#125;</code> </li></ol><h5 id="按需导出-与-按需导入"><a href="#按需导出-与-按需导入" class="headerlink" title="按需导出 与 按需导入"></a>按需导出 与 按需导入</h5><ul><li>按需导出：<code>export let s1 = 10</code> </li><li>按需导入：<code>import &#123; s1 &#125; from &#39;模块标识符/路径&#39;</code> </li></ul><p>注意点：</p><ol><li>在一个模块中，可以使用多次按需导出</li></ol><h5 id="直接导入并执行模块代码"><a href="#直接导入并执行模块代码" class="headerlink" title="直接导入并执行模块代码"></a>直接导入并执行模块代码</h5><p><code>import &#39;模块标识符/路径&#39;</code> </p><p>直接执行代码，没有导出。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>ES6</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(四)</title>
    <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/"/>
    <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model</p><p>定义了浏览器的接口</p><p>BOM对象：Window，History，Navigator，Screen，Location</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="滚动条滚动距离"><a href="#滚动条滚动距离" class="headerlink" title="滚动条滚动距离"></a>滚动条滚动距离</h4><h5 id="pageXOffset-pageYOffset"><a href="#pageXOffset-pageYOffset" class="headerlink" title="pageXOffset / pageYOffset"></a>pageXOffset / pageYOffset</h5><p>求滚动条滚动距离，返回 number 类型的数值，单位是像素</p><ul><li>pageXOffset  –&gt;  横向</li><li>pageYOffset  –&gt;  纵向</li></ul><p>兼容性：IE9以下不兼容</p><ul><li>document.body/documentElement.scorllLeft  –&gt;  求横向滚动条滚动距离</li><li>document.body/documentElement.scorllTop  –&gt;  纵向</li></ul><p>有兼容性混乱，不同浏览器可用的方法不同，但只会有一种方法有值，另一个值为0，处理兼容性的话让这两种值相加即可。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.scrollLeft + <span class="hljs-built_in">document</span>.documentElement.scrollLeft;<br><span class="hljs-built_in">document</span>.body.scrollTop + <span class="hljs-built_in">document</span>.documentElement.scrollTop;<br></code></pre></div></td></tr></table></figure><h4 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a>查看视口的尺寸</h4><h5 id="innerWidth-innerHeight"><a href="#innerWidth-innerHeight" class="headerlink" title="innerWidth / innerHeight"></a>innerWidth / innerHeight</h5><p>获取试图窗口的尺寸</p><p>兼容性：IE9以下不兼容</p><p>浏览器标准模式下使用：</p><ul><li><p>document.documentElement.clientWidth</p></li><li><p>document.documentElement.clientHeight</p></li></ul><p>怪异模式下使用：</p><ul><li>document.body.clientWidth</li><li>document.body.clientHeight</li></ul><h4 id="查看元素几何尺寸"><a href="#查看元素几何尺寸" class="headerlink" title="查看元素几何尺寸"></a>查看元素几何尺寸</h4><p>获得关于这个元素的 尺寸、位置 信息</p><h5 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect();"></a>getBoundingClientRect();</h5><ol><li>兼容性很好</li><li>所有元素节点都有此方法</li><li>left 和 top 表示该元素左上角的 X 和 Y 坐标，right 和 bottom 表示该元素右下角的 X 和 Y 坐标</li><li>返回的结果并不是实时的</li><li>width 和 height 老版本 IE 不兼容</li><li>使用并不多</li></ol><p><img src="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/1627039991064.png"></p><h5 id="offsetWidth-offsetHeight"><a href="#offsetWidth-offsetHeight" class="headerlink" title="offsetWidth / offsetHeight"></a>offsetWidth / offsetHeight</h5><p>查看元素的尺寸（视觉尺寸：包含 padding, border）</p><h5 id="offsetLeft-offsetTop"><a href="#offsetLeft-offsetTop" class="headerlink" title="offsetLeft / offsetTop"></a>offsetLeft / offsetTop</h5><p>查看元素的位置（距离他有定位的父级的距离）</p><h5 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h5><p>返回最近的有定位的父级，若没有，则返回 body</p><h4 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h4><h5 id="scroll-scrollTo-scrollBy"><a href="#scroll-scrollTo-scrollBy" class="headerlink" title="scroll(),scrollTo() / scrollBy()"></a>scroll(),scrollTo() / scrollBy()</h5><p><code>scroll(x, y)</code> &amp; <code>scrollTo(x, y)</code> 没有任何区别：使滚动条滚到指定位置</p><p><code>scrollBy(x, y)</code> 累加滚动距离，有正负，多次调用多次执行</p><h4 id="浏览器编译模式"><a href="#浏览器编译模式" class="headerlink" title="浏览器编译模式"></a>浏览器编译模式</h4><h5 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h5><p>html页面顶部添加下面一行开启</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;!DOCTYPE html&gt;<br></code></pre></div></td></tr></table></figure><h5 id="怪异模式"><a href="#怪异模式" class="headerlink" title="怪异模式"></a>怪异模式</h5><p>兼容之前的几个版本，向后兼容</p><h5 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h5><p><code>document.compatMode</code> 属性，返回值：</p><ul><li><code>CSS1Compat</code> ：标准模式</li><li><code>BackCompat</code> ：怪异模式</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="绑定事件方法"><a href="#绑定事件方法" class="headerlink" title="绑定事件方法"></a>绑定事件方法</h4><ol><li><p><code>ele.onxxx = function (event) &#123;&#125;</code></p><ul><li>兼容性很好，但同一个事件上只能绑定一个处理函数</li><li>基本等同于写在 HTML 行间</li></ul></li><li><p>行间写，不需要写 function</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;a&#x27;);&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>obj.addEventListener(type, fn, false);</code> </p><ul><li>(事件类型, 事件处理函数, false)</li><li>IE9 以下不兼容</li><li>可以为一个事件绑定多个处理程序</li><li>绑定事件时，若在循环中，注意闭包问题</li><li>false：冒泡模型；true：捕获模型</li></ul></li><li><p><code>obj.attachEvent(onxxx, fn);</code></p><ul><li>IE 独有</li></ul></li></ol><p>事件对象，在函数的括号中写入 e 或者 event，记载了事件发生时的一些列数据和信息</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><ul><li><p>前三种方法进行事件绑定后 this 指向的是绑定的元素本身</p></li><li><p>attachEvent 绑定事件后，this 指向的是 window</p><p>解决：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br>div.attachEvent(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    handle.call(div);<br>&#125;);<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 事件处理程序</span><br>    <span class="hljs-built_in">this</span>. ...<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><h4 id="兼容性解决"><a href="#兼容性解决" class="headerlink" title="兼容性解决"></a>兼容性解决</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">addEvent</span>(<span class="hljs-params">elem, type, handle</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (elem.addEventListener) &#123;<br>        elem.addEventListener(type, handle, <span class="hljs-literal">false</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (elem.attachEvent) &#123;<br>        elem.attachEvent(<span class="hljs-string">&#x27;on&#x27;</span> + type, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>            handle.call(elem);<br>        &#125;)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        elem[<span class="hljs-string">&#x27;on&#x27;</span> + type] = handle;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="解除事件处理程序"><a href="#解除事件处理程序" class="headerlink" title="解除事件处理程序"></a>解除事件处理程序</h4><ul><li><code>ele.onclick = null;</code></li><li><code>ele.removeListener(type, fn, false);</code> </li><li><code>ele.detachEvent(&#39;on&#39; + type, fn)</code><ul><li>如果绑定的函数是匿名函数，则无法解除</li></ul></li></ul><h4 id="事件处理模型"><a href="#事件处理模型" class="headerlink" title="事件处理模型"></a>事件处理模型</h4><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素。（自顶向下）</p><ul><li>将 addEventListener() 内第三个参数 false 改为 true，即成了捕获模型</li><li>IE 没有捕获事件</li></ul><p>顺序：</p><ul><li>先捕获，后冒泡</li><li>事件执行看绑定顺序</li></ul><p>focus, blur, change, submit, reset, select 等事件不冒泡</p><h6 id="特殊："><a href="#特殊：" class="headerlink" title="特殊："></a>特殊：</h6><p>setCapture()：只能在 ie 中使用，给元素使用</p><p>使用后，该元素会捕获页面上发生的所有时间</p><p>releaseCapture()：取消上述捕获</p><h5 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h5><ul><li><code>e.stopPropagation();</code> W3C标准 –&gt; 但不支持 IE9 以下版本</li><li><code>e.cancelBubble = true;</code> IE 使用</li></ul><h6 id="兼容性处理解决"><a href="#兼容性处理解决" class="headerlink" title="兼容性处理解决"></a>兼容性处理解决</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">stopBubble</span>(<span class="hljs-params">event</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (event.stopPropagation) &#123;<br>        event.stopPropagation();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        event.cancelBubble = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><p>默认事件 – 表单提交，a标签跳转，右键菜单等。</p><ul><li>a 标签跳转</li><li>右键菜单事件 <code>oncontextmenu</code> </li></ul><p>阻止方法：</p><ol><li><code>return false;</code> –&gt; 兼容性特别好，以对象属性的方式注册的事件才生效（onxxx）</li><li><code>e.preventDefault();</code> –&gt; W3C标准</li><li><code>e.returnValue = false;</code> –&gt; IE 使用</li></ol><h6 id="兼容性处理解决-1"><a href="#兼容性处理解决-1" class="headerlink" title="兼容性处理解决"></a>兼容性处理解决</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">cancelHandler</span>(<span class="hljs-params">event</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (event.preventDefault) &#123;<br>        event.preventDefault();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        event.returnValue = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><h5 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h5><p><code>var event = event || window.event</code> </p><h5 id="事件源对象"><a href="#事件源对象" class="headerlink" title="事件源对象"></a>事件源对象</h5><ul><li><code>event.target</code>  –&gt;  火狐</li><li><code>event.srcElement</code>  –&gt;  IE</li></ul><p>以上两个 chorme 都有</p><h6 id="兼容-1"><a href="#兼容-1" class="headerlink" title="兼容"></a>兼容</h6><p><code>var target = event.target || event.srcElement</code> </p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>4<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>5<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.getElementsBytagName(<span class="hljs-string">&#x27;ul&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="javascript">    ul.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> event = e || <span class="hljs-built_in">window</span>.event;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> target = event.target || event.srcElement;</span><br><span class="javascript">        <span class="hljs-built_in">console</span>.log(target.innerText);</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><ol><li>效率高：不需要循环所有的元素一个个绑定</li><li>可扩展：当有新的子元素时不需要重新绑定事件</li></ol><h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">click</td><td align="center">鼠标点击</td><td align="center">mousedown + mouseup</td></tr><tr><td align="center">mousedown</td><td align="center">鼠标点下</td><td align="center"></td></tr><tr><td align="center">mousemove</td><td align="center">鼠标移动</td><td align="center"></td></tr><tr><td align="center">mouseup</td><td align="center">鼠标抬起</td><td align="center"></td></tr><tr><td align="center">contextmenu</td><td align="center">右键菜单事件</td><td align="center">仅用于取消右键菜单</td></tr><tr><td align="center">mouseover</td><td align="center">鼠标进入</td><td align="center"></td></tr><tr><td align="center">mouseout</td><td align="center">鼠标离开</td><td align="center"></td></tr><tr><td align="center">mouseenter</td><td align="center">鼠标进入</td><td align="center">HTML5 新规范，同 mouseover</td></tr><tr><td align="center">mouseleave</td><td align="center">鼠标离开</td><td align="center">HTML5 新规范，同 mouseout</td></tr></tbody></table><h6 id="区分鼠标左右键"><a href="#区分鼠标左右键" class="headerlink" title="区分鼠标左右键"></a>区分鼠标左右键</h6><p><code>event.button</code> 属性</p><ul><li>0：左键</li><li>1：点击滚轮</li><li>2：右键</li></ul><p>仅在 mousedown 和 mouseup 事件上可用，click 事件不可用</p><h6 id="区分拖拽和点击"><a href="#区分拖拽和点击" class="headerlink" title="区分拖拽和点击"></a>区分拖拽和点击</h6><p>长时间按是长按，短时间按才触发 click 事件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> firstTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> lastTime = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">var</span> key = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">document</span>.onmousedown = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    firstTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>&#125;<br><span class="hljs-built_in">document</span>.onmouseup = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    lastTime = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>().getTime();<br>    <span class="hljs-keyword">if</span> (lastTime - firstTime &lt; <span class="hljs-number">300</span>) &#123;<br>        key = <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">document</span>.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (key) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;click&#x27;</span>);<br>        key = <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="移动端事件"><a href="#移动端事件" class="headerlink" title="移动端事件"></a>移动端事件</h6><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">touchstart</td><td align="center">触摸开始</td></tr><tr><td align="center">touchmove</td><td align="center">触摸移动</td></tr><tr><td align="center">touchend</td><td align="center">触摸结束</td></tr></tbody></table><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">keydown</td><td align="center">按键按下</td></tr><tr><td align="center">keypress</td><td align="center">按键按下</td></tr><tr><td align="center">keyup</td><td align="center">按键抬起</td></tr></tbody></table><h6 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h6><p>keydown &gt; keypress &gt; keyup</p><h6 id="keydown-amp-keypress"><a href="#keydown-amp-keypress" class="headerlink" title="keydown &amp; keypress"></a>keydown &amp; keypress</h6><ul><li>keydown：能够监测到所有按键，除 Fn 辅助键外<ul><li>大小写没有区别</li><li>没有 <code>e.charCode</code> 属性</li></ul></li><li>keypress：只能检测到 ASCII表 中有的值（字符类按键）<ul><li>可以区分大小写</li></ul></li></ul><h6 id="转换字符方法"><a href="#转换字符方法" class="headerlink" title="转换字符方法"></a>转换字符方法</h6><p><code>String.fromCahrCode(e.charCode)</code> </p><h5 id="文本操作事件"><a href="#文本操作事件" class="headerlink" title="文本操作事件"></a>文本操作事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">input</td><td align="center">只要文本框值发生改变触发</td></tr><tr><td align="center">change</td><td align="center">获取焦点和失去焦点的值发生改变触发</td></tr><tr><td align="center">focus</td><td align="center">获取焦点</td></tr><tr><td align="center">blur</td><td align="center">失去焦点</td></tr></tbody></table><h5 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">scroll</td><td align="center">页面发生滚动</td></tr><tr><td align="center">load</td><td align="center">页面所有加载项均完成后触发</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];</span><br><span class="javascript">    &#125; <span class="hljs-comment">// 绑定 onload 后会等页面渲染、下载完后才会执行，就可以获取到之后的元素</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span> <span class="hljs-comment">&lt;!-- 正常上方 js 无法获取到这个div --&gt;</span><br></code></pre></div></td></tr></table></figure><p>缺点：</p><ol><li>效率低</li><li>没必要</li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>前后端之间联系一种数据纽带，通常叫做接口，一种就是叫做 json 类型的数据</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;deng&quot;</span>,<br>    <span class="hljs-attr">&quot;age&quot;</span>: <span class="hljs-number">123</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="类型转换方法"><a href="#类型转换方法" class="headerlink" title="类型转换方法 *"></a>类型转换方法 *</h4><p><code>JSON.stringify(obj)</code>  –&gt;  将对象类型转换为 json 格式的字符串</p><p><code>JSON.parse(obj)</code>  –&gt;  将字符串转换为对象类型</p><p>博客笔记地址（四）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077901">https://blog.csdn.net/qq_58163927/article/details/119077901</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>BOM</tag>
      
      <tag>JSON</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(三)</title>
    <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
    <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>Document Object Model</p><p>用来操作 html 和 xml 功能的一类对象的集合</p><p>document 代表整个文档</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h5 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h5><p>通过元素的 id 属性值选择</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div =  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;only&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>定义在了 Document.prototype 上</p><p>ie8以下的浏览器，不区分 id 大小写，而且 name 和 id 一样的元素，也可以选出来</p><h5 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName() *"></a>getElementsByTagName() *</h5><p>通过标签名的方式选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div =  <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;current&#x27;</span>)[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure><p>定义在了 Document.prototype 和 Element.prototype 上</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> span = div.document.getElementsByTagName(<span class="hljs-string">&#x27;span&#x27;</span>)[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure><p>还可以使用 通配符 <code>*</code> 选择全部选择器；</p><p>无任何兼容性问题，较为常用</p><h5 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h5><p>t通过 name 属性值选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div =  <span class="hljs-built_in">document</span>.getElementsByName(<span class="hljs-string">&#x27;current&#x27;</span>)[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure><p>定义在了 HTMLDocument.prototype 上，即 XML 不能可用</p><p>name 并不是在所有标签内都好使</p><h5 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h5><p>通过类名 class 选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div =  <span class="hljs-built_in">document</span>.getElementsByClassName(<span class="hljs-string">&#x27;current&#x27;</span>)[<span class="hljs-number">0</span>];<br></code></pre></div></td></tr></table></figure><p>ie8和ie8以下的ie版本中没有</p><h5 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h5><p>选一个</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strong = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;div &gt; span strong.demo&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h5 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h5><p>选一组</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> strong = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div &gt; span strong.demo&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>以上两个 query 的选择器的缺点：</p><ol><li>在ie7 和 ie7以下版本中没有</li><li>不是实时的，选出来的是静态的，相当于选出来的就是个副本，元素发生改变不会发生改变</li></ol><h3 id="遍历节点树"><a href="#遍历节点树" class="headerlink" title="遍历节点树"></a>遍历节点树</h3><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><p>均无兼容性问题</p><h5 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h5><p>一个元素只有一个父节点，document 就是最高的</p><p>null &gt; document &gt; html &gt; body &gt; …</p><h5 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes *"></a>childNodes *</h5><p>获取一个元素所有的<strong>子节点</strong>，包括 文本、注释、属性、元素等</p><h5 id="firstChild"><a href="#firstChild" class="headerlink" title="firstChild"></a>firstChild</h5><p>获取元素的第一个子节点</p><h5 id="lastChild"><a href="#lastChild" class="headerlink" title="lastChild"></a>lastChild</h5><p>获取元素的最后一个子节点</p><h5 id="nextSibling"><a href="#nextSibling" class="headerlink" title="nextSibling"></a>nextSibling</h5><p>获取元素的后一个兄弟节点</p><h5 id="previousSibling"><a href="#previousSibling" class="headerlink" title="previousSibling"></a>previousSibling</h5><p>获取元素的前一个兄弟节点</p><h4 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h4><p>除 children 无兼容性问题外，其他的均是 ie9及ie9以下不兼容</p><h5 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h5><p>父元素节点，没有到 document</p><p>null &gt; html &gt; body &gt; …</p><h5 id="children"><a href="#children" class="headerlink" title="children *"></a>children *</h5><p>获取元素的所有<strong>元素子节点</strong> </p><h5 id="childElementCount"><a href="#childElementCount" class="headerlink" title="childElementCount"></a>childElementCount</h5><p>元素的元素字节点的个数</p><p><code>node.childElementCount === node.children.length</code> </p><h5 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title="firstElementChild"></a>firstElementChild</h5><p>第一个元素子节点</p><h5 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title="lastElementChild"></a>lastElementChild</h5><p>最后一个元素子节点</p><h5 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h5><p>上一个兄弟元素节点</p><h5 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h5><p>后一个兄弟元素节点</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 返回指定兄弟节点</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retSibling</span>(<span class="hljs-params">e, n</span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (e &amp;&amp; n) &#123;<br>        <span class="hljs-keyword">if</span> (n &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (e.nextElementSibling) &#123;<br>                e = e.nextElementSibling;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (e = e.nextSibling; e &amp;&amp; e.nodeType != <span class="hljs-number">1</span>; e = e.nextSibling);<br>            &#125;<br>            n--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (e.previousElementSibling;) &#123;<br>            e = e.previousElementSibling;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">for</span> (e = e.previousElementSibling; e &amp;&amp; e.nodeType != <span class="hljs-number">1</span>; e = e.previousSibling);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> e;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>节点的四个属性：</p><h5 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h5><ul><li>元素的标签名，以大写形式表示，只读</li></ul><h5 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h5><ul><li>文本节点 和 注释节点的文本内容，可读写</li><li>只有 Text节点 和 Comment节点 </li></ul><h5 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType *"></a>nodeType *</h5><ul><li>该节点的类型，只读</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 自定义 获取所有元素子节点</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retElementChild</span>(<span class="hljs-params">node</span>) </span>&#123;<br>    <span class="hljs-comment">// no children</span><br>    <span class="hljs-keyword">var</span> temp = &#123;<br>            <span class="hljs-attr">length</span> : <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">push</span> : <span class="hljs-built_in">Array</span>.prototype.push,<br>        <span class="hljs-attr">splice</span> : <span class="hljs-built_in">Array</span>.prototype.splice<br>        &#125;,<br>        child = node.childNodes,<br>        len = child.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (child[i].nodeType === <span class="hljs-number">1</span>) &#123;<br>            temp.push(child[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> temp;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h5><ul><li>Element 节点的属性集合</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="hasChildNodes"><a href="#hasChildNodes" class="headerlink" title="hasChildNodes()"></a>hasChildNodes()</h5><p>判断元素是否具有子节点，返回 boolean值</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>后面的数字是 nodeType 属性返回的值</p><p>元素节点 – 1</p><p>属性节点 – 2</p><p>文本节点 – 3</p><p>注释节点 – 8</p><p>document – 9</p><h3 id="DOM结构树"><a href="#DOM结构树" class="headerlink" title="DOM结构树"></a>DOM结构树</h3><p>document  –&gt;  HTMLDocument  –&gt;  Document  –&gt;  Node  –&gt;  EventTarget  –&gt;  Object</p><ul><li>document.documentElement 指代的是 html</li><li>HTMLDocumnet.head 指代的是 head</li><li>HTMLDocumnet.body 指代的是 body</li></ul><p>domTree + cssTree = rangerTree</p><p>重排（reflow）：整个界面进行重构，效率很低，要尽量避免</p><ol><li>dom节点的删除，添加</li><li>dom节点的宽高变化，位置变化，display none –&gt;  block</li><li>offsetWidth offsetLeft –&gt; 获取实时数据，也会触发重排</li></ol><p>重绘（repaint）：效率相对消耗比较少，对应位置改变</p><h3 id="DOM基本操作"><a href="#DOM基本操作" class="headerlink" title="DOM基本操作"></a>DOM基本操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><h5 id="createElement"><a href="#createElement" class="headerlink" title="createElement() *"></a>createElement() *</h5><p>创建元素节点，括号内写标签名</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElment(<span class="hljs-string">&#x27;div&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h5 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode()"></a>createTextNode()</h5><p>创建文本节点</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h5 id="createComment"><a href="#createComment" class="headerlink" title="createComment()"></a>createComment()</h5><p>创建注释节点</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> comment = <span class="hljs-built_in">document</span>.createComment(<span class="hljs-string">&#x27;This is AgoniLay！&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="插"><a href="#插" class="headerlink" title="插"></a>插</h4><h5 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild() *"></a>appendChild() *</h5><p>将节点添加到调用者中，类似于 push</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">var</span> text = <span class="hljs-built_in">document</span>.createTextNode(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>);<br>div.appendChild(text);<br></code></pre></div></td></tr></table></figure><p>将已在界面内的节点添加到别的中去</p><p>是剪切效果，原先的会被剪切到要添加的地方</p><h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore() *"></a>insertBefore() *</h5><p>将要插入的 插入到元素中去，并且插入到 第二个参数所代表元素 之前</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.insertBefore(strong, span);<br></code></pre></div></td></tr></table></figure><h5 id="insertAfter-自定义"><a href="#insertAfter-自定义" class="headerlink" title="insertAfter() 自定义"></a>insertAfter() 自定义</h5><p>自己封装 insertAfter() 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Element.prototype.insertAfter = funtion (targetNode, afterNode) &#123;<br>    <span class="hljs-keyword">var</span> beforeNode = afterNode.nextElementSibling;<br>    <span class="hljs-keyword">if</span> (beforeNode == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-built_in">this</span>.appendChild(targetNode);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">this</span>.insertBefore(targetNode, beforeNode);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><h5 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild() *"></a>removeChild() *</h5><p>父节点剪切出自己的子节点，作为返回值返回出来</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove() *"></a>remove() *</h5><p>自己将自己本身销毁，无返回值</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><h5 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild()"></a>replaceChild()</h5><p>由父节点调用，用新的 替换 旧的，并将旧的返回出来</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">parentNode.replaceChild(<span class="hljs-keyword">new</span>, origin)<br></code></pre></div></td></tr></table></figure><h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><h5 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML() *"></a>innerHTML() *</h5><p>改变一个元素中的 <strong>html</strong> 内容</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.innerHTML = <span class="hljs-string">&#x27;123&#x27;</span>; <span class="hljs-comment">// 会将原来里面的所有值覆盖</span><br>div.innerHTML += <span class="hljs-string">&#x27;456&#x27;</span>; <span class="hljs-comment">// 先取值，在追加 --&gt; 可读可写</span><br></code></pre></div></td></tr></table></figure><p>会识别括号内的一系列 html 文本</p><h5 id="innerText"><a href="#innerText" class="headerlink" title="innerText()"></a>innerText()</h5><p>读写标签内的文本，但是会覆盖</p><p>innerText() 方法 老版本火狐不兼容，火狐中有 textContent() 方法，但此方法 老版本ie 不好使</p><h4 id="节点方法"><a href="#节点方法" class="headerlink" title="节点方法"></a>节点方法</h4><h5 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h5><p>设置行间属性</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.setAttribute(<span class="hljs-string">&#x27;class&#x27;</span>, <span class="hljs-string">&#x27;demo&#x27;</span>);<br><span class="hljs-comment">// div --&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;</span><br>div.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;only&#x27;</span>);<br><span class="hljs-comment">// div --&gt; &lt;div class=&quot;demo&quot; id=&quot;only&quot;&gt;&lt;/div&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute()"></a>getAttribute()</h5><p>取到行内属性</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.getAttribute(<span class="hljs-string">&#x27;id&#x27;</span>); <span class="hljs-comment">// --&gt; only</span><br></code></pre></div></td></tr></table></figure><h5 id="className"><a href="#className" class="headerlink" title="className()"></a>className()</h5><p>可以读写元素节点的 class 属性</p><h3 id="脚本化CSS"><a href="#脚本化CSS" class="headerlink" title="脚本化CSS"></a>脚本化CSS</h3><h4 id="读写css属性"><a href="#读写css属性" class="headerlink" title="读写css属性"></a>读写css属性</h4><h5 id="dom-style"><a href="#dom-style" class="headerlink" title="dom.style *"></a>dom.style *</h5><ul><li>如果属性名中带有 <code>-</code> ，则换成小驼峰式：<code>background-color</code> –&gt; <code>backgroundColor</code> </li><li>碰到 float 这样的保留字属性，尽量前面加 css：<code>float</code> –&gt; <code>cssFloat</code> </li><li>复合属性建议拆解：<code>border: 1px soild red;</code> –&gt; <code>borderWidth=&quot;1px&quot;; borderStyle=&quot;soild&quot;; borderColor=&quot;red&quot;</code></li><li>可读可写，但只能读取到行间样式，写也是添加到行间，无兼容性问题</li><li>只有这一种方法可以写入 css 值</li></ul><h5 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle() *"></a>getComputedStyle() *</h5><p>获取当前元素所展示出的一切 css 属性的显式值（最终显示出来的，包括默认值）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.getComputedStyle(ele, <span class="hljs-literal">null</span>)[prop];<br></code></pre></div></td></tr></table></figure><ul><li><p>只读</p></li><li><p>返回的样式都是绝对值</p><ul><li>颜色：rgb 形式</li><li>尺寸：px 单位</li></ul></li><li><p>第二个参数 null 的作用：获取伪元素的属性表</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.getElementByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>];<br><span class="hljs-built_in">window</span>.getComputedStyle(div, <span class="hljs-string">&quot;after&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>IE8及IE8以下不兼容</p><ul><li><code>div.currentStyle</code> –&gt; <code>CSSStyleDeclaration</code> </li></ul></li></ul><p>兼容性问题解决：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getStyle</span>(<span class="hljs-params">elem, prop</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.getComputedStyle) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">window</span>.getComputedStyle(elem, <span class="hljs-literal">null</span>)[prop];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> elem.currentStyle[prop];<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>博客笔记地址（三）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077863">https://blog.csdn.net/qq_58163927/article/details/119077863</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>DOM</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(二)</title>
    <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
    <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>客户端脚本语言的标准</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="与html结合方式"><a href="#与html结合方式" class="headerlink" title="与html结合方式"></a>与html结合方式</h4><ol><li><p>内部JS：</p><ul><li><p>标签体内容就是js代码</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">text</span>=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 内容</span></span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li></ul></li><li><p>外部JS：</p><ul><li><p>通过src属性引入外部的js文件</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&lt;script text=<span class="hljs-string">&quot;text/javascript&quot;</span> src=<span class="hljs-string">&quot;location&quot;</span>&gt;<br>    <span class="hljs-comment">// 内容</span><br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure></li></ul></li></ol><p>注意：</p><ol><li>可以定义在html页面的任何地方。但是定义的位置会影响执行顺序；</li><li>可以定义多个；</li><li>同一个标签不能同时引入外部 同时有内部的，这样的话只有外部的好使。</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>单行注释：//注释内容</li><li>多行注释：/<em>注释内容</em>/</li></ol><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="原始数据类型-基本数据类型"><a href="#原始数据类型-基本数据类型" class="headerlink" title="原始数据类型(基本数据类型)"></a>原始数据类型(基本数据类型)</h5><h6 id="number"><a href="#number" class="headerlink" title="number"></a>number</h6><p>数字类型，整数 / 小数 / NaN(not a number 一个不是数字的数字类型)</p><p><code>toFixed(x)</code> 小数点后保留 x 位小数</p><p>问题 bug：</p><ul><li><p>浮点数精度不准</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">0.14</span> * <span class="hljs-number">100</span>); <span class="hljs-comment">// 14.000000000000002</span><br></code></pre></div></td></tr></table></figure></li><li><p>小数点前 以及 小数点后 位数大于 16 会出现精度问题</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1000000000000001</span> + <span class="hljs-number">1000000000000001</span>) <span class="hljs-comment">// 2000000000000002</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">10000000000000001</span> + <span class="hljs-number">10000000000000001</span>) <span class="hljs-comment">// 20000000000000000</span><br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1.000000000000001</span> + <span class="hljs-number">1.000000000000001</span>) <span class="hljs-comment">// 2.000000000000002</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1.0000000000000001</span> + <span class="hljs-number">1.0000000000000001</span>) <span class="hljs-comment">// 2</span><br></code></pre></div></td></tr></table></figure></li></ul><p><img src="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20210714200731388.png"></p><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><p>字符串类型，字符串  “abc” “a” ‘abc’</p><h6 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h6><p>布尔类型，true 和 false</p><ol><li>null：一个对象为空的占位符</li><li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为undefined</li></ol><p>存放在 <strong>栈</strong> 里，规则 先进后出</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ol><li><p>Array：数组。</p></li><li><p>Object：对象。</p></li><li><p>function：函数。</p><p>…</p></li></ol><p>存放在 <strong>堆</strong> 里，拷贝的是地址</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>一小块存储数据的内存空间</p><h5 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h5><p>Java语言是强类型语言，而JavaScript是弱类型语言。</p><ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li></ul><h5 id="全局-amp-局部变量"><a href="#全局-amp-局部变量" class="headerlink" title="全局&amp;局部变量"></a>全局&amp;局部变量</h5><p>访问规则</p><ul><li>里面的可以访问到外面的，外面的不能访问里面的</li></ul><h5 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 变量名 = 初始化值;<br><br><span class="hljs-comment">// 定义多个遍历并赋值</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>,<br>    b = <span class="hljs-number">20</span>,<br>    c = <span class="hljs-number">30</span>,<br>    d = <span class="hljs-number">40</span>,<br>    e;<br><span class="hljs-built_in">document</span>.write(a,b,c,d,e);<br></code></pre></div></td></tr></table></figure><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ol><li>变量名必须以英文字母、_  、$ 开头；</li><li>变量名可以包括英文字母、_ 、$ 、数字；</li><li>不可以用系统的关键字、保留字作为变量名。</li></ol><h5 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h5><p>获取变量的类型。</p><p>number  string  boolean  object  undefined  function</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// string</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-literal">true</span>)); <span class="hljs-comment">// boolean</span><br></code></pre></div></td></tr></table></figure><p>用法：</p><ul><li><code>typeof(值)</code> </li><li><code>typeof 值</code> </li></ul><p>注：</p><ol><li><p><strong>null</strong>、array 运算后得到的是object</p></li><li><p>typeof() 返回的值是字符串类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(<span class="hljs-keyword">typeof</span>(a))); <span class="hljs-comment">// string</span><br></code></pre></div></td></tr></table></figure></li></ol><p>特殊：</p><p>变量不定义就使用必定会报错，只有一种情况下不会</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(a)); <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><p>自定义 type 方法：区分所有类别</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ret = <span class="hljs-keyword">typeof</span>(target);<br>    <span class="hljs-keyword">var</span> template = &#123;<br>        <span class="hljs-string">&quot;[object Array]&quot;</span> : <span class="hljs-string">&quot;array&quot;</span>,<br>        <span class="hljs-string">&quot;[object Object]&quot;</span> : <span class="hljs-string">&quot;object&quot;</span>,<br>        <span class="hljs-string">&quot;[object Number]&quot;</span> : <span class="hljs-string">&quot;number - object&quot;</span>,<br>        <span class="hljs-string">&quot;[object Boolean]&quot;</span> : <span class="hljs-string">&quot;boolean - object&quot;</span>,<br>        <span class="hljs-string">&quot;[object String]&quot;</span> : <span class="hljs-string">&quot;string - object&quot;</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (target === <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;null&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret == <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>        <span class="hljs-keyword">var</span> str = <span class="hljs-built_in">Object</span>.prototype.toString.call(target);<br>        <span class="hljs-keyword">return</span> template[str];<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><h6 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">NaN</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-number">123</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;123&quot;</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-string">&quot;abc&quot;</span>)); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">null</span>)); <span class="hljs-comment">// false</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">isNaN</span>(<span class="hljs-literal">undefined</span>)); <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>isNaN() 之前会先 Number()</p><p>模拟 isNaN() 方法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myIsNaN</span>(<span class="hljs-params">num</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> ret = <span class="hljs-built_in">Number</span>(num);<br>    ret += <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-string">&quot;NaN&quot;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="–"><a href="#–" class="headerlink" title="++ – + -"></a>++ – + -</h6><p>(自增 自减 正负号)</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;123&quot;</span>;<br>a ++; <span class="hljs-comment">// 124</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = +<span class="hljs-string">&quot;123&quot;</span>; <span class="hljs-comment">// +123</span><br><span class="hljs-keyword">var</span> b = +<span class="hljs-string">&quot;abc&quot;</span>; <span class="hljs-comment">// NaN</span><br></code></pre></div></td></tr></table></figure><h6 id><a href="#" class="headerlink" title="+"></a>+</h6><p>(加号)</p><p>两侧没有字符串，则正常数字相加，调用 Number() 方法将不是 number 的隐式转换</p><p>当加号两侧至少有一侧是字符串时，会调用 String() 方法把两侧均转换为字符串</p><p>当加号左侧是引用类型值时，调用的是 String() 方法隐式转换</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">[] + <span class="hljs-number">1</span>;  <span class="hljs-comment">// --&gt; String([]) + 1 --&gt; &quot;1&quot;</span><br>[] + <span class="hljs-string">&quot;&quot;</span>; <span class="hljs-comment">// &quot;&quot;</span><br>&#123;&#125; + <span class="hljs-number">1</span>;  <span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure><p>但引用值的隐式类型转换不用知道，规则较多。</p><h6 id="-1"><a href="#-1" class="headerlink" title="- * / %"></a>- * / %</h6><p>(运算符号)</p><p>调用 Number() 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-string">&quot;2&quot;</span> * <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// number : 2</span><br><span class="hljs-keyword">var</span> num = <span class="hljs-string">&quot;a&quot;</span> * <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// number : NaN</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">[] - <span class="hljs-number">1</span>; <span class="hljs-comment">// -1</span><br></code></pre></div></td></tr></table></figure><h6 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp; || !"></a>&amp;&amp; || !</h6><p>判断调用 Boolean() 方法</p><h6 id="lt-gt-…"><a href="#lt-gt-…" class="headerlink" title="&lt; &gt; …"></a>&lt; &gt; …</h6><p>(比较符号)</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">3</span> &gt; <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-comment">// boolean: true</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-string">&quot;3&quot;</span> &gt; <span class="hljs-string">&quot;2&quot;</span>; <span class="hljs-comment">// 会比较对应的 ASCII码 值</span><br></code></pre></div></td></tr></table></figure><p>特殊</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-literal">undefined</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">// false 不转换，系统规定 undefined 和 null 不能和数进行比较</span><br><span class="hljs-literal">null</span> &gt; <span class="hljs-number">0</span>; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><h6 id="-2"><a href="#-2" class="headerlink" title="== !="></a>== !=</h6><p>调用 Boolean() 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span> == <span class="hljs-literal">true</span>; <span class="hljs-comment">// boolean: true</span><br></code></pre></div></td></tr></table></figure><p>引用值比较的是地址：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">&#123;&#125; == &#123;&#125;; <span class="hljs-comment">// false</span><br>[] == []; <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">var</span> obj = &#123;&#125;;<br><span class="hljs-keyword">var</span> obj1 = obj;<br>obj == obj1; <span class="hljs-comment">// true</span><br>obj === obj1; <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>特殊：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-literal">undefined</span> == <span class="hljs-literal">null</span>; <span class="hljs-comment">// true</span><br><span class="hljs-literal">NaN</span> == <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><h6 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h6><p>把里面的东西转换为数字型</p><p>null  false  =&gt;  0</p><p>undefined =&gt;  NaN</p><h6 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h6><p>把里面的数转换为整数</p><p>注：看到非数字位截止</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123&quot;</span>); <span class="hljs-comment">// 123</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;123abc&quot;</span>); <span class="hljs-comment">// 123</span><br><span class="hljs-comment">// 用途</span><br><span class="hljs-comment">// 把像素值从 100px 中取出来</span><br></code></pre></div></td></tr></table></figure><p><code>parseInt(值, radix)</code> radix: 2 - 36</p><p>后面的第二个参数表示此数所表示的进制</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">parseInt</span>(<span class="hljs-string">&quot;B&quot;</span>, <span class="hljs-number">16</span>); <span class="hljs-comment">// 11</span><br></code></pre></div></td></tr></table></figure><p>后面填 0 </p><ul><li>有的浏览器是 原样转换整型输出</li><li>有的是输出 NaN</li></ul><h6 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h6><p>注：看到除了第一个 .  的非数字位截止</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">parseFloat</span>(<span class="hljs-string">&quot;123.12abc&quot;</span>); <span class="hljs-comment">// 123.12</span><br></code></pre></div></td></tr></table></figure><h6 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h6><h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h6><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> demo = <span class="hljs-number">10</span><br><span class="hljs-keyword">var</span> str = demo.toString(); <span class="hljs-comment">// &quot;10</span><br><span class="hljs-comment">// 转换进制</span><br><span class="hljs-keyword">var</span> num = demo.toString(<span class="hljs-number">8</span>); <span class="hljs-comment">// 12</span><br></code></pre></div></td></tr></table></figure><p>注：undefined 和 null 不能用 toSting() 方法</p><p>例子：</p><p>二进制 转 十六进制</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">10000</span>;<br><span class="hljs-keyword">var</span> test = <span class="hljs-built_in">parseInt</span>(num, <span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.log(test.toString(<span class="hljs-number">16</span>)); <span class="hljs-comment">// aa</span><br></code></pre></div></td></tr></table></figure><h5 id="不发生类型转换"><a href="#不发生类型转换" class="headerlink" title="不发生类型转换"></a>不发生类型转换</h5><h6 id="-3"><a href="#-3" class="headerlink" title="=== !=="></a>=== !==</h6><p>数值 和 类型 均相等才可</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-number">1</span> === <span class="hljs-number">1</span>; <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> === <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// false</span><br><span class="hljs-number">1</span> !== <span class="hljs-string">&quot;1&quot;</span>; <span class="hljs-comment">// true</span><br><span class="hljs-number">1</span> !== <span class="hljs-number">1</span>; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><p>特殊：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-literal">NaN</span> === <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// false</span><br></code></pre></div></td></tr></table></figure><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str  = <span class="hljs-literal">false</span> + <span class="hljs-number">1</span>;<br><span class="hljs-built_in">document</span>.write(str); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> demo = <span class="hljs-literal">false</span> == <span class="hljs-number">1</span>;<br><span class="hljs-built_in">document</span>.write(demo); <span class="hljs-comment">// false</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span>(a) &amp;&amp; -<span class="hljs-literal">true</span> + (+<span class="hljs-literal">undefined</span>) + <span class="hljs-string">&quot;&quot;</span>) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;基础扎实！&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-number">11</span> + <span class="hljs-string">&quot;11&quot;</span> * <span class="hljs-number">2</span> == <span class="hljs-number">33</span>) &#123;<br>    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;基础扎实！&#x27;</span>);<br>&#125;<br>!!<span class="hljs-string">&quot; &quot;</span> + !!<span class="hljs-string">&quot;&quot;</span> - !!<span class="hljs-literal">false</span> || <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&#x27;你觉得能打印，你就是🐖&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h5><p>只有一个运算数的运算符<br>    ++，– ， +(正号)  </p><ul><li>++ –: 自增(自减)<ul><li>++(–) 在前，先自增(自减)，再运算</li><li>++(–) 在后，先运算，再自增(自减)</li></ul></li><li>+(-)：正负号</li></ul><p>注意：在JS中，如果运算数不是运算符所要求的类型，那么js引擎会自动的将运算数进行类型转换</p><ul><li>其他类型转number：<ul><li>string转number：按照字面值转换。如果字面值不是数字，则转为NaN（不是数字的数字）</li><li>boolean转number ：true转为1，false转为0</li></ul></li></ul><h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p>​    + - * / %</p><p>注：</p><ol><li>1/0 会得 Infinity（无穷）</li><li>1/0 会得 -Infinity</li><li>0/0 会得 NaN</li></ol><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>​    =  +=  -=  *=  /=  %=</p><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>​    &lt;  &gt;=  &lt;=  ==  ===(全等于)</p><p>比较方式：</p><ol><li><p>类型相同：直接比较</p><p>​    字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。即 ASCII码 值</p></li><li><p>类型不同：先进行类型转换，再比较</p><p>​    ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回false</p></li></ol><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>​    &amp;&amp; ||  !</p><ul><li><p>&amp;&amp;（与）：先看第一个表达式转化为 boolean 值是否为真，结果为真，则依次往后看每个表达式转换为boolean值的结果，直到碰到结果为 false 的表达式，返回该表达式的值。</p><p>用法：（短路语句）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> data = ...;<br><span class="hljs-comment">// data &amp;&amp; 执行一个语句，会用到data;</span><br>data &amp;&amp; fn(data);<br></code></pre></div></td></tr></table></figure></li><li><p>||（或）：碰到表达式的结果 boolean值为真则返回该表达式的值</p><p>用法：（兼容）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// 兼容 IE 浏览器</span><br>    <span class="hljs-keyword">var</span> event = e || <span class="hljs-built_in">window</span>.event;<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>! （非）：将表达式的值转换为 boolean值 再取反，返回该 boolean值。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = !!<span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-comment">// !! 可以让一个值转换为 boolean值</span><br></code></pre></div></td></tr></table></figure></li></ul><p>注意：</p><p>undefined、null、NaN、””、0、false  ==&gt;  false</p><p>除了以上六个值以外，其他的转换为 boolean 类型均为 true</p><p>练习：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-built_in">window</span>.foo || (<span class="hljs-built_in">window</span>.foo = <span class="hljs-string">&#x27;bar&#x27;</span>));<br><span class="hljs-comment">// window.foo = &#x27;bar&#x27;</span><br><span class="hljs-comment">// 先读小括号内的，即先赋值</span><br></code></pre></div></td></tr></table></figure><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">表达式 ? 值<span class="hljs-number">1</span> : 值<span class="hljs-number">2</span>;<br></code></pre></div></td></tr></table></figure><p>判断表达式的值，如果是 true 则取值1，如果是 false 则取值2；</p><h5 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h5><p>会将后面的结果返回出去</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = (<span class="hljs-number">1</span> - <span class="hljs-number">1</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);<br>a --&gt; <span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><h5 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h5><ol><li><p>优先运算</p><p>将里面的内容变为表达式</p><p><code>(function () &#123;&#125;)</code> 函数声明失效，变为表达式</p></li><li><p>立即执行</p><p><code>(function () &#123;&#125;)()</code> </p></li></ol><h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><ol><li><p>if…else…</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span>(判断语句) &#123;<br>    条件体<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>switch:</p></li></ol><ul><li><p>在java中，switch语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)</p></li><li><p>在JS中,switch语句可以接受任意的原始数据类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> () &#123;<br>    <span class="hljs-keyword">case</span> 判断条件<span class="hljs-number">1</span>:<br>    执行语句<span class="hljs-number">1</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 判断条件<span class="hljs-number">2</span>:<br>    执行语句<span class="hljs-number">2</span>; <span class="hljs-keyword">break</span>;<br>    <span class="hljs-keyword">case</span> 判断条件<span class="hljs-number">3</span>:<br>        执行语句<span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;<br>    ...<br>    <span class="hljs-attr">default</span>:<br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><ol start="3"><li><p>while</p><p>底层机制就是 for 循环：for 循环括号内两边不写语句就是 while 循环：<code>for (;条件语句;) &#123;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">while</span>(条件语句) &#123;<br>    循环语句<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>do…while</p><p>先执行一次，再判断条件语句</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;<br>    循环体<br>&#125; <span class="hljs-keyword">while</span> (条件语句)<br></code></pre></div></td></tr></table></figure></li><li><p>for</p></li><li><p>break</p><p>跳出循环或者 switch</p></li><li><p>continue</p><p>终止本次循环进行下次循环</p></li></ol><h4 id="JS特殊语法"><a href="#JS特殊语法" class="headerlink" title="JS特殊语法"></a>JS特殊语法</h4><ol><li>语句以 ; 结尾，如果一行只有一条语句则 ; 可以省略 (不建议)</li><li>变量的定义使用 var 关键字，也可以不使用</li></ol><ul><li>用：定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ul><ol start="3"><li>练习：99乘法表</li></ol><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>99乘法表<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">            <span class="hljs-selector-tag">td</span>&#123;</span><br><span class="css">                <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid;</span><br><span class="css">            &#125;</span><br><span class="css">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript"></span><br><span class="javascript">            <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;table  align=&#x27;center&#x27;&gt;&quot;</span>);</span><br><span class="javascript">            <span class="hljs-comment">//1.完成基本的for循环嵌套，展示乘法表</span></span><br><span class="javascript">            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">9</span> ; i++) &#123;</span><br><span class="javascript">                <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="javascript">                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;=i ; j++) &#123;</span><br><span class="javascript">                    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;td&gt;&quot;</span>);</span><br><span class="javascript"></span><br><span class="javascript">                    <span class="hljs-comment">//输出  1 * 1 = 1</span></span><br><span class="javascript">                    <span class="hljs-built_in">document</span>.write(i + <span class="hljs-string">&quot; * &quot;</span> + j + <span class="hljs-string">&quot; = &quot;</span> + ( i*j) +<span class="hljs-string">&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span>);</span><br><span class="javascript"></span><br><span class="javascript">                    <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="javascript">                &#125;</span><br><span class="javascript">                <span class="hljs-comment">/*//输出换行</span></span><br><span class="hljs-comment"><span class="javascript">document.write(&quot;&lt;br&gt;&quot;);*/</span></span><br><span class="javascript"></span><br><span class="javascript">                <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="javascript">            &#125;</span><br><span class="javascript"></span><br><span class="javascript">            <span class="hljs-comment">//2.完成表格嵌套</span></span><br><span class="javascript">            <span class="hljs-built_in">document</span>.write(<span class="hljs-string">&quot;&lt;/table&gt;&quot;</span>);</span><br><span class="javascript"></span><br><span class="javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h3 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>使用包装类对象创建的以下三种对象，依然还带有原本的数据类型的特点，不同在于可以有属性和方法</p><p>但是 undefined 和 null 不可以设置属性</p><h5 id="Number-数字对象"><a href="#Number-数字对象" class="headerlink" title="Number:数字对象"></a>Number:数字对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-number">123</span>);<br></code></pre></div></td></tr></table></figure><h5 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String:字符串对象"></a>String:字符串对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-keyword">new</span> Stirng(<span class="hljs-string">&#x27;abcd&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h5 id="Boolean-布尔对象"><a href="#Boolean-布尔对象" class="headerlink" title="Boolean:布尔对象"></a>Boolean:布尔对象</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> bol = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-string">&#x27;true&#x27;</span>);<br></code></pre></div></td></tr></table></figure><h5 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h5><p>原始数据类型不能有自己的属性和方法</p><h6 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h6><p>但下面这个却不报错：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">4</span>;<br>num.len = <span class="hljs-number">3</span>; <span class="hljs-comment">// 不报错</span><br><span class="hljs-built_in">console</span>.log(num.len) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><p>原因：（包装类）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = <span class="hljs-number">4</span>;<br>num.len = <span class="hljs-number">3</span>; <span class="hljs-comment">// 不报错</span><br><span class="hljs-comment">// new Number(4).len = 3;</span><br><span class="hljs-comment">// delete</span><br><span class="hljs-comment">// new Number(4).len --&gt; undefined</span><br><span class="hljs-built_in">console</span>.log(num.len) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><h6 id="length问题"><a href="#length问题" class="headerlink" title="length问题"></a>length问题</h6><p>在数组中：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-comment">// arr.length --&gt; 5</span><br>arr.length = <span class="hljs-number">2</span><br><span class="hljs-comment">// arr.length --&gt; 2</span><br><span class="hljs-comment">// arr --&gt; [1, 2]</span><br></code></pre></div></td></tr></table></figure><p>但是，在字符串中</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abcd&#x27;</span>;<br><span class="hljs-comment">// str.length --&gt; 4</span><br>str.length = <span class="hljs-number">2</span>;<br><span class="hljs-comment">// new String(&#x27;abcd&#x27;).length = 2;</span><br><span class="hljs-comment">// delete</span><br><span class="hljs-built_in">console</span>.log(str); <span class="hljs-comment">// abcd</span><br><span class="hljs-comment">// new String(&#x27;abcd&#x27;).length</span><br><span class="hljs-built_in">console</span>.log(str.length); <span class="hljs-comment">// 4</span><br></code></pre></div></td></tr></table></figure><p>字符串对象 本身就有 length属性，调用时是从包装类对象中返回的属性值</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&#x27;abc&#x27;</span>;<br>str += <span class="hljs-number">1</span>;<br><span class="hljs-keyword">var</span> test = <span class="hljs-keyword">typeof</span> str; <span class="hljs-comment">// test --&gt; &#x27;string&#x27;</span><br><span class="hljs-keyword">if</span> (test.length == <span class="hljs-number">6</span>) &#123;<br>    test.sign = <span class="hljs-string">&#x27;typeof的返回结果可能为String&#x27;</span>;<br>    <span class="hljs-comment">// new String(test).sign = &#x27;xxx&#x27;;</span><br>&#125;<br><span class="hljs-comment">// new String(test).sign</span><br><span class="hljs-built_in">console</span>.log(test.sign);<br></code></pre></div></td></tr></table></figure><h4 id="Function-函数对象"><a href="#Function-函数对象" class="headerlink" title="Function:函数对象"></a>Function:函数对象</h4><p>高内聚，弱耦合</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Function</span>(形式参数列表，方法体)；<span class="hljs-comment">//忘掉吧</span><br><br><span class="hljs-comment">// 函数声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> 方法名称(<span class="hljs-params">形式参数列表</span>) </span>&#123;<br>    方法体<br>&#125;<br><br><span class="hljs-comment">// 命名函数表达式</span><br><span class="hljs-keyword">var</span> 方法名 = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">abc</span>(<span class="hljs-params"></span>) </span>&#123;<br>    方法体<br>&#125;<br><span class="hljs-comment">// 匿名函数表达式 --- 函数表达式</span><br><span class="hljs-keyword">var</span> 方法名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    方法体<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 形式参数（形参）</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> c = a + b;<br>    <span class="hljs-built_in">document</span>.write(c);<br>&#125;<br><span class="hljs-comment">// 实际参数（实参）</span><br>sum(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure><p>参数不限制位数</p><h6 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h6><p>表示实参列表，也有一些属性</p><ul><li><p>arguments.length  实参个数</p></li><li><p>arguments.callee 指向这个函数自身引用 –&gt; 即函数本身</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> num = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> n * <span class="hljs-built_in">arguments</span>.callee(n - <span class="hljs-number">1</span>);<br>&#125;(<span class="hljs-number">100</span>))<br></code></pre></div></td></tr></table></figure></li></ul><p>函数名.length  形参个数</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a</span>) </span>&#123;<br>    <span class="hljs-comment">// arguments -- [11,2,3] 实参列表</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>); <span class="hljs-comment">// [11,2,3]</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>.length); <span class="hljs-comment">// 3</span><br>    <span class="hljs-comment">// 函数名.length -- 形参长度</span><br>    concole.log(sum.length); <span class="hljs-comment">// 1</span><br>&#125;<br>sum(<span class="hljs-number">11</span>, <span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br></code></pre></div></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 求不定参数个数的和</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> result = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i++) &#123;<br>        result += <span class="hljs-built_in">arguments</span>[i];<br>    &#125;<br>    <span class="hljs-built_in">document</span>.write(result);<br>&#125;<br>sum(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>);<br></code></pre></div></td></tr></table></figure><p>arguments里面的值 和 形参的值 之间有映射关系，但只是在形参和实参对应时才生效</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-comment">// arguments  --&gt;  [1]</span><br>    a = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>]); <span class="hljs-comment">// 2</span><br>    <span class="hljs-built_in">arguments</span>[<span class="hljs-number">0</span>] = <span class="hljs-number">3</span>;<br>    <span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// 3</span><br>    <br>    b = <span class="hljs-number">2</span>;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]); <span class="hljs-comment">// undefined</span><br>&#125;<br>sum(<span class="hljs-number">1</span>);<br></code></pre></div></td></tr></table></figure><h5 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h5><p>函数的一个属性：表示被调用的环境</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;<br>    demo();<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">demo</span>(<span class="hljs-params"></span>) </span>&#123;<br>    demo,caller; <span class="hljs-comment">// --&gt; test --&gt; function test() &#123;demo();&#125;</span><br>&#125;<br>test();<br></code></pre></div></td></tr></table></figure><p>不怎么用，但会和 arguments.callee 一块出现做区分</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>方法定义时，形参的类型不用写，返回值类型也不写</li><li>方法时一个对象，如果定义名称相同的方法，会覆盖</li><li>在JS中，方法的调用只与方法的名称有关，和参数列表无关</li><li>在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数</li></ol><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5>  <figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">方法名称(实际参数列表);<br></code></pre></div></td></tr></table></figure><h6 id="连续调用"><a href="#连续调用" class="headerlink" title="连续调用"></a>连续调用</h6><p>模拟 jQuery 连续调用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> deng = &#123;<br>    <span class="hljs-attr">smoke</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Somking...&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>    <span class="hljs-attr">drink</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Drinking...&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;,<br>    <span class="hljs-attr">perm</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Perming...&#x27;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>;<br>    &#125;            <br>&#125;<br><br>deng.smoke().drink().perm();<br></code></pre></div></td></tr></table></figure><h5 id="结束条件和返回值"><a href="#结束条件和返回值" class="headerlink" title="结束条件和返回值"></a>结束条件和返回值</h5><ul><li>return 语句后的内容将不再执行，终止函数</li><li>返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">myNumber</span>(<span class="hljs-params">target</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> +target;<br>&#125;<br><span class="hljs-keyword">var</span> num = myNumber(<span class="hljs-string">&#x27;123&#x27;</span>);<br><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span>(num) + <span class="hljs-string">&quot; &quot;</span> + num); <span class="hljs-comment">// number 123</span><br></code></pre></div></td></tr></table></figure><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><h6 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 求阶乘方法</span><br><span class="hljs-comment">// n! = n * (n-1)!</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">mul</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> n * mul(n - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">var</span> n = <span class="hljs-built_in">parseInt</span>(prompt(<span class="hljs-string">&#x27;input&#x27;</span>));<br>mul(n);<br><span class="hljs-comment">// 递归</span><br><span class="hljs-comment">/* </span><br><span class="hljs-comment">mul(5);</span><br><span class="hljs-comment">    5 * mul(4);</span><br><span class="hljs-comment">    5 * 4 * mul(3);</span><br><span class="hljs-comment">    5 * 4 * 3 * mul(2);</span><br><span class="hljs-comment">    5 * 4 * 3 * 2 * 1; </span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><h6 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 斐波那契数列</span><br><span class="hljs-comment">// fb(n) == fb(n - 1) + fb(n - 2)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fb</span>(<span class="hljs-params">n</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span> || n == <span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> fb(n - <span class="hljs-number">1</span>) + fb(n - <span class="hljs-number">2</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h5><p>原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该圆心的属性和方法。原型也是对象。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.LastName = <span class="hljs-string">&quot;Agoni&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-keyword">var</span> person1 = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// person.LastName --&gt; &quot;Agoni&quot;</span><br><span class="hljs-comment">// person1.LastName --&gt; &quot;Agoni&quot;</span><br></code></pre></div></td></tr></table></figure><p>对象中固定不变的属性（公有的内容）可以提取出来放到原型中，避免代码多次执行造成冗余。</p><h6 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h6><p>删</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">delete</span> Person.prototype.LastName;<br></code></pre></div></td></tr></table></figure><p>经过了 var 给 window 上增加的属性为不可配置性属性，delete无法删除。</p><p>增改查</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.LastName = <span class="hljs-string">&quot;Agoni&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>设置属性（可以多个一起设置）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype = &#123;<br>    <span class="hljs-attr">height</span>: <span class="hljs-number">1400</span>,<br>    lang, <span class="hljs-number">4900</span>,<br>    <span class="hljs-attr">carName</span>: <span class="hljs-string">&quot;BMW&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>和 <code>Person.prototype.name = &quot;&quot;</code> 的区别：</p><ul><li>上面的那一种是重新放一个空间，如之前已设置过且已经生成了对象，则 <code>__proto__</code> 所指向的还是原先的那个空间；</li><li>下面的是在原先的空间中设置或修改属性，使得 <code>__proto__</code> 的访问数据变更</li></ul><h6 id="构造器-constructor"><a href="#构造器-constructor" class="headerlink" title="构造器 constructor"></a>构造器 constructor</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> Car();<br><span class="hljs-comment">// car.constructor --&gt; funciton Car() &#123;&#125;</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>Car.prototype = &#123;<br>    <span class="hljs-attr">constructor</span> : Person<br>&#125;<br><span class="hljs-comment">// car.constructor --&gt; function Person() &#123;&#125;</span><br></code></pre></div></td></tr></table></figure><h6 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h6><p>隐式属性 <code>__proto__</code> 内就放着原型，在控制台展开可以查看</p><p>原理：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.name = <span class="hljs-string">&quot;abc&quot;</span>;<br>funciton <span class="hljs-function"><span class="hljs-title">Person</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-comment">// var this = &#123;</span><br>    <span class="hljs-comment">//     __proto__ : Person.prototype</span><br><span class="hljs-comment">// &#125;</span><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br></code></pre></div></td></tr></table></figure><p>原型也可以改变：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 代码接上一部分</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;sunny&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// person.name --&gt; &quot;abc&quot;</span><br>Person.__proto__ = obj;<br><span class="hljs-comment">// person.name --&gt; &quot;sunny&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Grand.prototype.lastName = <span class="hljs-string">&quot;agoni&quot;</span>;<br>funciton <span class="hljs-function"><span class="hljs-title">Grand</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> grand = <span class="hljs-keyword">new</span> Grand();<br><br>Father.prototype = grand;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&quot;Lay&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> father = <span class="hljs-keyword">new</span> Father();<br><br>Son.prototype = fatehr;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.hobbit = <span class="hljs-string">&quot;smoke&quot;</span><br>&#125;<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son();<br><span class="hljs-comment">// son.hobbit --&gt; &quot;smoke&quot;</span><br><span class="hljs-comment">// son.name --&gt; &quot;Lay&quot;</span><br><span class="hljs-comment">// son.lastName --&gt; &quot;Agoni&quot;</span><br></code></pre></div></td></tr></table></figure><p>查找属性，依照 <code>son --&gt; father --&gt; grand</code>  顺序依次查找，这个链就叫 原型链。</p><p>链顶并不是最末的：</p><h6 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h6><p>是<strong>绝大多数</strong>对象的最终原型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// Grand.prototype.__proto__  --&gt;  Object.prototype</span><br><br><span class="hljs-comment">// son.toString() --&gt; function toString() &#123; [native code] &#125; // 最终终端的方法</span><br><br><span class="hljs-comment">// Object.prototype.__proto__  --&gt;  null</span><br></code></pre></div></td></tr></table></figure><p>Object.prototype 里面没有 __proto__ 了</p><h6 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h6><p>括号内填原型：只能是 对象 或 null</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype.name = <span class="hljs-string">&quot;sunny&quot;</span>;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-built_in">Object</span>.create(Person.prototype)<br></code></pre></div></td></tr></table></figure><p>特殊点：</p><p>原型最终不会指向 Object.prototype</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-comment">// obj.toString() --&gt; 访问不到，报错</span><br></code></pre></div></td></tr></table></figure><p>语法：</p><p><code>Object.create(prototype, definedProperty&lt;特性&gt;)</code></p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Person.prototype = &#123;<br>    <span class="hljs-attr">toString</span> : <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hehe&#x27;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person();<br><span class="hljs-comment">// person.toString(); --&gt; &quot;hehe&quot;</span><br></code></pre></div></td></tr></table></figure><p>发生截断，不会访问到终端 Object.prototype 的 toSting() 方法</p><p>Number Array Boolean String 都对 toSting() 方法进行了重写</p><h6 id="document-write-原理"><a href="#document-write-原理" class="headerlink" title="document.write 原理"></a>document.write 原理</h6><p>会隐式调用 toSting() 方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(<span class="hljs-literal">null</span>);<br><span class="hljs-built_in">document</span>.write(obj); <span class="hljs-comment">// 报错，因为自己创建的对象值为 null 且 Object.create() 创建的没有原型链，没有 toString() 方法，所以报错</span><br><br>obj.toStirng = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;AgoniLay&#x27;</span>;<br>&#125;<br><span class="hljs-built_in">document</span>.write(obj); <span class="hljs-comment">// AgoniLay --&gt; 调用了 AgoniLay 方法</span><br></code></pre></div></td></tr></table></figure><h5 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h5><h6 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">test(); <span class="hljs-comment">// --&gt; test.call();</span><br></code></pre></div></td></tr></table></figure><p>call 带参数</p><p>根本作用：<strong>改变 tihs 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;deng&#x27;</span>, <span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <br>&#125;<br><span class="hljs-comment">// 第一个参数指 this 的指向，之后的依次代表 实参 对应 形参</span><br>Person.call(obj, <span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">19</span>);<br><span class="hljs-comment">// obj --&gt; &#123;name: &#x27;agoni&#x27;, age: 19&#125;</span><br></code></pre></div></td></tr></table></figure><p>使用实例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span>(<span class="hljs-params">name, age, sex</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.age = age;<br>    <span class="hljs-built_in">this</span>.sex = sex;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Student</span>(<span class="hljs-params">name, age, sex, tel, grade</span>) </span>&#123;<br>    Person.call(<span class="hljs-built_in">this</span>, name, age, sex);<br>    <span class="hljs-built_in">this</span>.tel = tel;<br>    <span class="hljs-built_in">this</span>.grade = grade;<br>&#125;<br><br><span class="hljs-keyword">var</span> student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;sunny&#x27;</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&#x27;male&#x27;</span>, <span class="hljs-number">1309</span>, <span class="hljs-number">2017</span>);<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Wheel</span>(<span class="hljs-params">wheelSize, style</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.style = style;<br>    <span class="hljs-built_in">this</span>.wheelSize = wheelSize;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Sit</span>(<span class="hljs-params">c, sitColor</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.c = c;<br>    <span class="hljs-built_in">this</span>.sitColor = sitColor;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Model</span>(<span class="hljs-params">height, width, len</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.height = height;<br>    <span class="hljs-built_in">this</span>.width = width;<br>    <span class="hljs-built_in">this</span>.len = len;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">wheelSize, style, c, sitColor, height, width, len</span>) </span>&#123;<br>    Wheel.call(<span class="hljs-built_in">this</span>, wheelSize, style);<br>    Sit.call(<span class="hljs-built_in">this</span>, c, sitColor);<br>    Model.call(<span class="hljs-built_in">this</span>, height, width, len);<br>&#125;<br><span class="hljs-keyword">var</span> car = <span class="hljs-keyword">new</span> Car(<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;花里胡哨&#x27;</span>, <span class="hljs-string">&#x27;真皮&#x27;</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-number">1800</span>, <span class="hljs-number">1900</span>, <span class="hljs-number">4900</span>);<br><span class="hljs-comment">// car &#123;style: &quot;花里胡哨&quot;, wheelSize: 100, c: &quot;真皮&quot;, sitColor: &quot;red&quot;, height: 1800, …&#125;</span><br></code></pre></div></td></tr></table></figure><h6 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h6><p>和 call() 区别：</p><ul><li>传参列表不同：apply 第一个参数还是 this 所指对象，第二个参数是一个数组，数组里面是所有的实参<ul><li>call 需要把实参按照形参的个数传进去</li><li>apply 需要传一个 arguments</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Car</span>(<span class="hljs-params">wheelSize, style, c, sitColor, height, width, len</span>) </span>&#123;<br>    Wheel.apply(<span class="hljs-built_in">this</span>, [wheelSize, style]);<br>    Sit.call(<span class="hljs-built_in">this</span>, [c, sitColor]);<br>    Model.call(<span class="hljs-built_in">this</span>, [height, width, len]);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="继承-–-gt-圣杯模式"><a href="#继承-–-gt-圣杯模式" class="headerlink" title="继承 –&gt; 圣杯模式"></a>继承 –&gt; 圣杯模式</h5><ol><li><p>传统形式 –&gt;  原型链</p><ul><li>过多的继承了没用的属性</li></ul></li><li><p>借用构造函数 call()/apply()</p><ul><li>不能继承借用构造函数的原型</li><li>每次构造函数都要多走一个函数（视觉上减少代码，但多走了方法）</li></ul></li><li><p>共享原型</p><p><code>son.prototype = father.prototype</code> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Father.prototype.lastName = <span class="hljs-string">&quot;AgoniLay&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br>funciton <span class="hljs-function"><span class="hljs-title">inherit</span>(<span class="hljs-params">Target, Origin</span>)</span> &#123;<br>    Target.prototype = Origin.prototype;<br>&#125;<br><span class="hljs-comment">// 先继承，后用</span><br>inherit(Son, Father);<br><br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son();<br><span class="hljs-comment">// son.lastName --&gt; &quot;AgoniLay&quot;</span><br><span class="hljs-comment">// father.lastName --&gt; &quot;AgoniLay&quot;</span><br><br>Son.prototype.sex = <span class="hljs-string">&quot;male&quot;</span>; <span class="hljs-comment">// 添加后，son 和 father 都有了这个属性</span><br><span class="hljs-comment">// son.sex --&gt; &quot;male&quot;</span><br><span class="hljs-comment">// father.sex --&gt; &quot;male&quot;</span><br></code></pre></div></td></tr></table></figure></li><li><p><strong>圣杯模式</strong> *</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 通俗写法</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inherit</span>(<span class="hljs-params">Target, Origin</span>) </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<br>    <span class="hljs-comment">// 以下两行顺序不能颠倒</span><br>    F.prototype = Origin.prototype;<br>    Target.prototype = <span class="hljs-keyword">new</span> F();<br>    <span class="hljs-comment">// 优化</span><br>    Target.prototype.constuctor = Target;<br>    Target.prototype.uber = Origin.prototype;<br>&#125;<br><br>Father.prototype.lastName = <span class="hljs-string">&quot;AgoniLay&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><br>inherit(Son, Father);<br><span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son();<br><span class="hljs-keyword">var</span> father = <span class="hljs-keyword">new</span> Father();<br><span class="hljs-comment">// father.lastName --&gt; &quot;AgoniLay&quot;</span><br><span class="hljs-comment">// son.lastName --&gt; &quot;AgoniLay&quot;</span><br><br>Son.prototype.sex = <span class="hljs-string">&quot;male&quot;</span>;<br><span class="hljs-comment">// son.sex --&gt; &quot;male&quot;</span><br><span class="hljs-comment">// father.sex --&gt; undifined</span><br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 雅虎的</span><br><span class="hljs-keyword">var</span> inherit = (<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;; <span class="hljs-comment">// 闭包应用 -- 私有化变量</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">Target, Origin</span>) </span>&#123;<br>        F.prototype = Origin.prototype;<br>        Target.prototype = <span class="hljs-keyword">new</span> F();<br>        Target.prototype.constructor = Target;<br>        Target.prototype.uber = Origin.prototype;<br>    &#125;<br>&#125;());<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a>Array:数组对象</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><ol><li><p><code>var arr = [];</code>  数组字面量 – 推荐使用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br><br><span class="hljs-keyword">var</span> arr = [,,]; <span class="hljs-comment">// [undefined * 2]</span><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,,<span class="hljs-number">2</span>]; <span class="hljs-comment">// [1, undefined, 2] --&gt; 稀松数组</span><br></code></pre></div></td></tr></table></figure></li><li><p><code>var arr = new Array();</code> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>);<br></code></pre></div></td></tr></table></figure><p>和 数组字面量 区别：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 只传一个参数，代表数组的长度</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10</span>); <span class="hljs-comment">// [undefined * 10]</span><br><span class="hljs-comment">// 但不能只传一个小数</span><br><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">10.2</span>); <span class="hljs-comment">// 报错</span><br></code></pre></div></td></tr></table></figure></li></ol><h5 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h5><p>溢出读是 undefined，可以溢出写</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr[<span class="hljs-number">0</span>] = <span class="hljs-number">2</span> <span class="hljs-comment">// [2,2,3]</span><br><span class="hljs-built_in">console</span>.log(arr[<span class="hljs-number">10</span>]); <span class="hljs-comment">// undefined 不会报错</span><br>arr[<span class="hljs-number">10</span>] = <span class="hljs-string">&quot;aa&quot;</span>; <span class="hljs-comment">// 可以添加 --&gt; [1,2,3,undefined * 7,&quot;aa&quot;]</span><br></code></pre></div></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>可以改变原数组的方法开始：只有七个</p><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p>在数组<strong>最后</strong>添加数据，不仅可以添加一个，返回值是添加后的数组长度</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 自己写 push() 方法</span><br><span class="hljs-keyword">var</span> arr = [];<br><span class="hljs-built_in">Array</span>.prototype.push = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">arguments</span>.length; i ++) &#123;<br>        <span class="hljs-built_in">this</span>[<span class="hljs-built_in">this</span>.length] = <span class="hljs-built_in">arguments</span>[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.length;<br>&#125;<br>arr.push(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>); <span class="hljs-comment">// 3 --&gt; [1,2,3]</span><br></code></pre></div></td></tr></table></figure><p>但 push 的原理是取决于属性中 length 值，与 length 值有关</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>把数组的<strong>最后一位</strong>剪切出来返回</p><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p>在数组<strong>开头</strong>添加数据，不仅可以添加一个，返回值是添加后的数组长度</p><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p>把数组的<strong>第一位</strong>剪切出来返回</p><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>把数组<strong>逆转</strong>，把原数组返回</p><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p><code>arr.splice(从第几位开始, 截取多少的长度, 在切口处添加新的数据)</code> </p><p>返回截取的数组</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];<br>arr.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>); <span class="hljs-comment">// [1,2] --&gt; [1,2,3,3]</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">3</span>];<br>arr.splice(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">// [1,2] --&gt; [1,0,0,0,2,3,3]</span><br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 不截取，只是向中间插入数据 例：向上面数组 3 后面添加一个 0</span><br>arr.splice(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-comment">// 截取的位置可以是负数，表示从倒数开始</span><br>arr.splice(-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>); <span class="hljs-comment">// [4] --&gt; [1,2,3]</span><br><span class="hljs-comment">// 实现</span><br>splice = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">pos, ...</span>) </span>&#123;<br>    pos += pos &gt; <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-built_in">this</span>.length; <span class="hljs-comment">// -1 + 4 = 3</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="sort"><a href="#sort" class="headerlink" title="sort() *"></a>sort() *</h6><p>在原数组上将原数组内元素升序排列（但并不是数字值的大小）</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">9</span>];<br>arr.sort(); <span class="hljs-comment">// [-1,0,1,3,4,9]</span><br><span class="hljs-comment">// 降序</span><br>arr.sort().reverse();<br></code></pre></div></td></tr></table></figure><p>为了解决这个问题，sort 留了一个接口让用户自定义排序方式</p><p>规则：</p><ol><li>必须写俩形参</li><li>看返回值<ol><li>当返回值为负数时，那么前面的数放在前面</li><li>为正数，那么后面的数在前</li><li>为 0，不动</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">10</span>];<br><span class="hljs-comment">// 传参顺序 1,3  1,5  1,4  1,10  3,5</span><br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-comment">// 函数体</span><br>    <span class="hljs-comment">// if (a &gt; b) &#123;</span><br>    <span class="hljs-comment">//    return 1;</span><br>    <span class="hljs-comment">//&#125; else &#123;</span><br>    <span class="hljs-comment">//    return -1;</span><br>    <span class="hljs-comment">//&#125;</span><br>    <span class="hljs-comment">// 简化</span><br>    <span class="hljs-keyword">return</span> a - b; <span class="hljs-comment">// 升序</span><br>    <span class="hljs-comment">// return b - a; // 降序</span><br>&#125;) <span class="hljs-comment">// [1, 3, 4, 5, 10]</span><br></code></pre></div></td></tr></table></figure><p>运用：</p><p>给一个有序的数组，乱序</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.random() - <span class="hljs-number">0.5</span>;<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>给一个对象数组，按某一属性排</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> cheng = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;cheng&quot;</span>,<br>    <span class="hljs-attr">age</span> : <span class="hljs-number">30</span>,<br>&#125;<br><span class="hljs-keyword">var</span> deng = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;deng&quot;</span>,<br>    <span class="hljs-attr">age</span> : <span class="hljs-number">60</span>,<br>&#125;<br><span class="hljs-keyword">var</span> zhang = &#123;<br>    <span class="hljs-attr">name</span> : <span class="hljs-string">&quot;zhang&quot;</span>,<br>    <span class="hljs-attr">age</span> : <span class="hljs-number">19</span>,<br>&#125;<br><span class="hljs-keyword">var</span> arr = [cheng, deng, zhang];<br><span class="hljs-comment">// 按年龄升序排列</span><br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a.age - b.age;<br>&#125;) <span class="hljs-comment">// [&quot;zhang&quot;, &quot;cheng&quot;, &quot;deng&quot;]</span><br></code></pre></div></td></tr></table></figure><p>按字符串长度排序</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;as&#x27;</span>, <span class="hljs-string">&#x27;asdad&#x27;</span>, <span class="hljs-string">&#x27;s&#x27;</span>, <span class="hljs-string">&#x27;sjdfhakjsdfhlkajsd&#x27;</span>, <span class="hljs-string">&#x27;asdjhajsk&#x27;</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> a.length - b.length;<br>&#125;) <span class="hljs-comment">// [&#x27;s&#x27;, &#x27;as&#x27;, &#x27;asdad&#x27;, &#x27;asdjhajsk&#x27;, &#x27;sjdfhakjsdfhlkajsd&#x27;]</span><br></code></pre></div></td></tr></table></figure><p>按字节长度排序</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">retBytes</span>(<span class="hljs-params">str</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> num = str.length;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; str.length; i ++) &#123;<br>        <span class="hljs-keyword">if</span> (str.charCodeAt(i) &gt; <span class="hljs-number">255</span>) &#123;<br>            num++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> num++;<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">&#x27;赛的环境asdj&#x27;</span>, <span class="hljs-string">&#x27;asd&#x27;</span>, <span class="hljs-string">&#x27;啥的， 爱睡觉的&#x27;</span>, <span class="hljs-string">&#x27;a saa&#x27;</span>];<br>arr.sort(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> retBytes(a) - retBytes(b);<br>&#125;) <span class="hljs-comment">// [&quot;asd&quot;, &quot;a saa&quot;, &quot;赛的环境asdj&quot;, &quot;啥的， 爱睡觉的&quot;]</span><br></code></pre></div></td></tr></table></figure><p>不改变原数组的方法开始：调用完使用 变量 接收，否则没有意义</p><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p>把括号内的数组拼接到前面数组的后面，不在原数组上修改，返回拼接后的数组</p><h6 id="toString"><a href="#toString" class="headerlink" title="toString()"></a>toString()</h6><p>将数组返回为字符串类型的字符串</p><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p><code>arr.slice(&#39;从该位开始截取&#39;, &#39;截取到该位&#39;)</code></p><p><code>arr.slice(1)</code> 从第 1 位截取，截取到最后，也可以填负数（规则 + length）</p><p><code>arr.slice()</code> 整个截取</p><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>将数组中元素按规定连接起来，返回一个字符串</p><p>参数可以传所有原始值，但最好传字符串</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>];<br>arr.join(<span class="hljs-string">&quot;&amp;&quot;</span>); <span class="hljs-comment">// &quot;1&amp;2&amp;3&quot;</span><br>arr.join(); <span class="hljs-comment">// &quot;1,2,3&quot;</span><br></code></pre></div></td></tr></table></figure><h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>是字符串的方法，是 join() 的可逆方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;1-2-3-4-5&quot;</span>;<br>str.split(<span class="hljs-string">&quot;-&quot;</span>); <span class="hljs-comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span><br></code></pre></div></td></tr></table></figure><p>自定义方法：</p><h6 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.unique = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> temp = &#123;&#125;;<br>    <span class="hljs-keyword">var</span> arr = [];<br>    <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">this</span>.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!temp[<span class="hljs-built_in">this</span>[i]]) &#123;<br>            temp[<span class="hljs-built_in">this</span>[i]] = <span class="hljs-string">&#x27;agoni&#x27;</span>;<br>            arr.push(<span class="hljs-built_in">this</span>[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>类数组有要求：</p><ol><li>属性要为索引（数组）属性</li><li>必须有 length 属性</li></ol><h4 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h4><h4 id="Date对象"><a href="#Date对象" class="headerlink" title="Date对象"></a>Date对象</h4><h4 id="Reg正则表达式对象"><a href="#Reg正则表达式对象" class="headerlink" title="Reg正则表达式对象"></a>Reg正则表达式对象</h4><h3 id="JS-运行"><a href="#JS-运行" class="headerlink" title="JS 运行"></a>JS 运行</h3><p>this</p><p>闭包</p><p>with</p><p>eval</p><p>预编译    </p><p>try…catch</p><p>有待更新…</p><p>博客笔记地址（二）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077465">https://blog.csdn.net/qq_58163927/article/details/119077465</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>ECMAScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript笔记(一)</title>
    <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
    <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h1 id="浏览器及其内核"><a href="#浏览器及其内核" class="headerlink" title="浏览器及其内核"></a>浏览器及其内核</h1><table><thead><tr><th align="center">主流浏览器</th><th align="center">内核</th></tr></thead><tbody><tr><td align="center">IE</td><td align="center">trident</td></tr><tr><td align="center">Chorme</td><td align="center">webkit/blink</td></tr><tr><td align="center">firefox</td><td align="center">Gecko</td></tr><tr><td align="center">Opera</td><td align="center">presto</td></tr><tr><td align="center">Safari</td><td align="center">webkit</td></tr></tbody></table><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p> 一门客户端脚本语言</p><ul><li>运行在客户端浏览器中的。每一个浏览器都有JavaScript的解析引擎</li><li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</li></ul><h3 id="JavaScript发展史"><a href="#JavaScript发展史" class="headerlink" title="JavaScript发展史"></a>JavaScript发展史</h3><ol><li>1992年，Nombase公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C–    ，后来更名为：ScriptEase</li><li>1995年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来SUN公司的专家，修改LiveScript，命名为JavaScript</li><li>1996年，微软抄袭 JavaScript 开发出JScript语言</li><li>1997年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</li></ol><p>注：JavaScript = ECMAScript + JavaScript自己特有的东西(BOM+DOM)</p><p>博客笔记地址（一）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077397">https://blog.csdn.net/qq_58163927/article/details/119077397</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>前端</tag>
      
      <tag>浏览器内核</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript笔记</title>
    <link href="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在线文档：<a href="https://24kcs.github.io/vue3_study">https://24kcs.github.io/vue3_study</a></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript是一种由微软开发的开源、跨平台的编程语言。它是JavaScript的超集，最终会被编译为JavaScript代码</p><p><strong>TypeScript 是 JavaScript 的一个超集</strong>，主要提供了<strong>类型系统</strong>和<strong>对 ES6+ 的支持</strong>，它由 Microsoft 开发，代码 <a href="https://github.com/Microsoft/TypeScript">开源于 GitHub (opens new window)</a> 上</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>始于JavaScript，归于JavaScript</li><li>强大的类型系统</li><li>先进的 JavaScript</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>命令行输入：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i -g typescript<br></code></pre></div></td></tr></table></figure><p>检查安装：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">tsc -V<br>    &gt; Version <span class="hljs-number">4.3</span>.<span class="hljs-number">4</span><br></code></pre></div></td></tr></table></figure><h3 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h3><p>01_第一次的ts.ts</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">(<span class="hljs-function">()=&gt;</span> &#123;<br>    <span class="hljs-comment">// str这个参数是string类型的</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sayHi</span>(<span class="hljs-params">str:<span class="hljs-built_in">String</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;您好啊&#x27;</span> + str<br>    &#125;<br>    <span class="hljs-keyword">let</span> text = <span class="hljs-string">&#x27;张艺兴&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(sayHi(text));<br>&#125;)()<br></code></pre></div></td></tr></table></figure><p>index.html 中直接引入了 ts 的文件，浏览器是会报错的（如果 ts 文件中只有单纯的 js 代码，是可以正常的引入及使用的）</p><p>如果有ts的语法，可以进行编译代码：</p><h4 id="手动编译代码"><a href="#手动编译代码" class="headerlink" title="手动编译代码"></a>手动编译代码</h4><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">tsc 文件名<br></code></pre></div></td></tr></table></figure><p>将会生成对应的 js 文件，然后再 index.html 直接引入 js 文件即可</p><h4 id="自动编译代码（vccode中）"><a href="#自动编译代码（vccode中）" class="headerlink" title="自动编译代码（vccode中）"></a>自动编译代码（vccode中）</h4><ol><li><p>文件目录下终端运行：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">tsc --init<br></code></pre></div></td></tr></table></figure><p>自动初始化生成 tsconfig.json 文件</p></li><li><p>在其中做修改：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;compilerOptions&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;outDir&quot;</span>: <span class="hljs-string">&quot;./js&quot;</span>, <span class="hljs-comment">/* 把 ts 文件最终编译后，放在js的目录中 */</span><br>    <span class="hljs-attr">&quot;strict&quot;</span>: <span class="hljs-literal">false</span>,  <span class="hljs-comment">/* 不使用严格模式 */</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>启动监视任务，终端运行</p><p>单击 项目文件夹 选中，找到上方终端打开 运行任务    选择 tsc:监视 打开运行</p></li></ol><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>一种轻量级的为函数或者变量添加的约束</p><figure class="highlight typescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs typescript">(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// str 是string类型的</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMsg</span>(<span class="hljs-params">str:<span class="hljs-built_in">String</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;床前明月光，&#x27;</span> + str<br>    &#125;<br>    <span class="hljs-comment">// msg 是一个数组</span><br>    <span class="hljs-keyword">let</span> msg = <span class="hljs-string">&#x27;疑似地上霜&#x27;</span><br>    <span class="hljs-comment">// let msg = 22</span><br>    <span class="hljs-comment">// 智能的错误提示信息</span><br>    <span class="hljs-built_in">console</span>.log(showMsg(msg))<br>&#125;)()<br></code></pre></div></td></tr></table></figure><h4 id="接口-类"><a href="#接口-类" class="headerlink" title="接口 - 类"></a>接口 - 类</h4><p>是一种能力，一种约束而已</p><h4 id="使用-webpack-打包-TS"><a href="#使用-webpack-打包-TS" class="headerlink" title="使用 webpack 打包 TS"></a>使用 webpack 打包 TS</h4><p>安装依赖</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i -D typescript<br>    <br>npm i -D webpack webpack-cli@<span class="hljs-number">3.3</span>.<span class="hljs-number">12</span> <br>webpack-dev-server<br>    <br>npm i -D html-webpack-plugin clean-webpack-plugin ts-loader cross-env<br></code></pre></div></td></tr></table></figure><p>配置打包命令</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;dev&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js&quot;</span>,<br>        <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span><br>    &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>运行出现错误，尝试：</p><p>错误：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">internal/modules/cjs/loader.js:<span class="hljs-number">888</span><br>    <span class="hljs-keyword">throw</span> err;<br>^<br><br><span class="hljs-built_in">Error</span>: Cannot find module <span class="hljs-string">&#x27;webpack-cli/bin/config-yargs&#x27;</span><br></code></pre></div></td></tr></table></figure><p>处理：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm uninstall webpack-cli<br>cnpm i webpack-cli@<span class="hljs-number">3.3</span>.<span class="hljs-number">12</span> -D<br></code></pre></div></td></tr></table></figure><p>报错：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">× ｢wds｣: Invalid configuration <span class="hljs-keyword">object</span>. Webpack has been initialized using a configuration <span class="hljs-keyword">object</span> that does not <span class="hljs-keyword">match</span> the API schema.<br>  - configuration.devtool should <span class="hljs-keyword">match</span> pattern <span class="hljs-string">&quot;^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$&quot;</span>.<br>    BREAKING CHANGE since webpack <span class="hljs-number">5</span>: The devtool option is more strict.<br>    Please strictly follow the order of the keywords in the pattern.<br></code></pre></div></td></tr></table></figure><p>处理：</p><p>webpack.config.js 文件中修改配置</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">devtool: &#x27;eval-cheap-module-source-map&#x27;<br></code></pre></div></td></tr></table></figure><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><p>总结：ts 中变量一开始是声明类型，那么后期赋值的时候，只能用这个类型的数据，是不允许用其他类型的数据赋值给当前的这个变量中</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 布尔类型   ------&gt; boolean</span><br><span class="hljs-comment">// let 变量名:数据类型 = 值</span><br><span class="hljs-keyword">let</span> flag:boolean = <span class="hljs-literal">true</span><br><span class="hljs-built_in">console</span>.log(flag);<br></code></pre></div></td></tr></table></figure><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 数字类型   ------&gt; number</span><br><span class="hljs-keyword">let</span> a1: number = <span class="hljs-number">10</span>      <span class="hljs-comment">// 十进制</span><br><span class="hljs-keyword">let</span> a2: number = <span class="hljs-number">0b1010</span>  <span class="hljs-comment">// 二进制</span><br><span class="hljs-keyword">let</span> a3: number = <span class="hljs-number">0o12</span>    <span class="hljs-comment">// 八进制</span><br><span class="hljs-keyword">let</span> a4: number = <span class="hljs-number">0xa</span>     <span class="hljs-comment">// 十六进制</span><br></code></pre></div></td></tr></table></figure><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 字符串类型 ------&gt; string</span><br><span class="hljs-keyword">let</span> str1:string = <span class="hljs-string">&#x27;床前明月光&#x27;</span><br><span class="hljs-keyword">let</span> str2:string = <span class="hljs-string">&#x27;小明去开窗&#x27;</span><br><span class="hljs-keyword">let</span> str3:string = <span class="hljs-string">&#x27;遇到一耳光&#x27;</span><br><span class="hljs-keyword">let</span> str4:string = <span class="hljs-string">&#x27;牙齿掉光光&#x27;</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;str1&#125;</span>,<span class="hljs-subst">$&#123;str2&#125;</span>,<span class="hljs-subst">$&#123;str3&#125;</span>,<span class="hljs-subst">$&#123;str4&#125;</span>`</span>);<br></code></pre></div></td></tr></table></figure><h5 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> nud: <span class="hljs-literal">undefined</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-keyword">let</span> nll: <span class="hljs-literal">null</span> = <span class="hljs-literal">null</span><br><span class="hljs-built_in">console</span>.log(nud);<br><span class="hljs-built_in">console</span>.log(nll);<br><span class="hljs-comment">// undefined 和 null 都可以做为其他类型的子类型，把 undefined 和 null 赋值给其他类型的变量</span><br><span class="hljs-keyword">let</span> num2: number = <span class="hljs-literal">undefined</span><br><span class="hljs-built_in">console</span>.log(num2); <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><p>赋值后报错是因为：在 tsconfig.js 中开启了严格模式</p><p>将 <code>&quot;strict&quot;: true</code> 更改为 <code>&quot;strict&quot;: false</code> 即可</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 数组定义方式1</span><br><span class="hljs-comment">// let 变量名: 数据类型[] = [值1，值2]</span><br><span class="hljs-keyword">let</span> arr1: number[] = [<span class="hljs-number">10</span>,<span class="hljs-number">20</span>,<span class="hljs-number">30</span>,<span class="hljs-number">40</span>,<span class="hljs-number">50</span>]<br><span class="hljs-built_in">console</span>.log(arr1);<br><span class="hljs-comment">// 数组定义方式2：泛型方式</span><br><span class="hljs-comment">// let 变量名: Array&lt;数据类型&gt; = [值1，值2]</span><br><span class="hljs-keyword">let</span> arr2: <span class="hljs-built_in">Array</span>&lt;number&gt; = [<span class="hljs-number">100</span>,<span class="hljs-number">200</span>,<span class="hljs-number">300</span>]<br><span class="hljs-built_in">console</span>.log(arr2);<br></code></pre></div></td></tr></table></figure><p>数组定义后，里面的数据的类型必须和定义数组的时候的类型是一致的，否则有错误提示信息，也不会编译通过的</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 元组类型：在定义数组的时候，类型和数据的个数一开始就已经限定了</span><br><span class="hljs-keyword">let</span> arr3: [string,number,boolean] = [<span class="hljs-string">&#x27;张艺兴&#x27;</span>, <span class="hljs-number">18.232</span>, <span class="hljs-literal">true</span>]<br><span class="hljs-built_in">console</span>.log(arr3);<br></code></pre></div></td></tr></table></figure><p>注意问题：元组类型在使用的时候，数据的类型的位置和数据的个数 应该和在定义元组时的数据类型及位置应该是一致的</p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。</p><p>枚举里面的每个数据值都可以叫元素，每个元素都有自己的编号，编号是默认从 0 开始的，依次递增加 1</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">enum Color &#123;<br>    <span class="hljs-comment">// 枚举中的元素可以是中文的数据值，但是不推荐</span><br>    red = <span class="hljs-number">2</span>,<br>    green,<br>    blue<br>&#125;<br><span class="hljs-comment">// 定义一个 Color  的枚举类型的变量来接受枚举的值</span><br><span class="hljs-keyword">let</span> color: Color = Color.red<br><span class="hljs-built_in">console</span>.log(color); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.log(Color.red, Color.green, Color.blue); <span class="hljs-comment">// 2 3 4</span><br><span class="hljs-built_in">console</span>.log(Color[<span class="hljs-number">3</span>]); <span class="hljs-comment">// green</span><br></code></pre></div></td></tr></table></figure><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> str: any = <span class="hljs-number">100</span><br><span class="hljs-built_in">console</span>.log(str) <span class="hljs-comment">// 100</span><br>str = <span class="hljs-string">&#x27;年少不知富婆好，错把少女当成宝&#x27;</span><br><span class="hljs-built_in">console</span>.log(str) <span class="hljs-comment">// 年少不知富婆好，错把少女当成宝</span><br><span class="hljs-comment">// 当一个数组中要存储多个数据，个数不确定，类型不确定，此时也可以使用 any 类型来定义数组</span><br><span class="hljs-keyword">let</span> arr: any[] = [<span class="hljs-number">100</span>, <span class="hljs-string">&#x27;张艺兴&#x27;</span>, <span class="hljs-literal">true</span>]<br><span class="hljs-built_in">console</span>.log(arr); <span class="hljs-comment">// [100, &quot;张艺兴&quot;, true]</span><br><span class="hljs-comment">// 这种情况下也没有错误的提示信息</span><br><span class="hljs-comment">// console.log(arr[0].split(&#x27;&#x27;)); // 报错</span><br></code></pre></div></td></tr></table></figure><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>在函数声明的时候，小括号的后面使用 :void ，代表的时该函数没有任何的返回值</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMsg</span>(<span class="hljs-params"></span>):<span class="hljs-title">void</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;只要富婆把握住，连夜搬进大别墅&#x27;</span>)<br>    <span class="hljs-comment">// return null // 可行</span><br>&#125;<br>showMsg();<br><span class="hljs-built_in">console</span>.log(showMsg()); <span class="hljs-comment">// undifined</span><br><span class="hljs-comment">// 定义 void 类型的值，可以接收一个 undefined 的值，但是意义不大</span><br><span class="hljs-keyword">let</span> vd:<span class="hljs-keyword">void</span> = <span class="hljs-literal">undefined</span><br><span class="hljs-built_in">console</span>.log(vd) <span class="hljs-comment">// undefined</span><br></code></pre></div></td></tr></table></figure><h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个函数 参数是 object 类型，返回值也是 object 类型</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getObj</span>(<span class="hljs-params">obj:object</span>):<span class="hljs-title">object</span> </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(obj)<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(getObj(&#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;张宝文&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-string">&#x27;男&#x27;</span>&#125;)) <span class="hljs-comment">// 必须参函数，且是对象类型</span><br><span class="hljs-comment">// console.log(getObj(&#x27;123&#x27;)) // 错误</span><br><span class="hljs-built_in">console</span>.log(getObj(<span class="hljs-built_in">String</span>)) <span class="hljs-comment">// 可以通过</span><br></code></pre></div></td></tr></table></figure><h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型（Union Types）表示取值可以为多种类型中的一种</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">str:number|string</span>):<span class="hljs-title">string</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> str.toString()<br>&#125;<br><span class="hljs-built_in">console</span>.log(getString(<span class="hljs-number">123</span>))   <span class="hljs-comment">// &#x27;123&#x27;</span><br><span class="hljs-built_in">console</span>.log(getString(<span class="hljs-string">&#x27;123&#x27;</span>)) <span class="hljs-comment">// &#x27;123&#x27;</span><br></code></pre></div></td></tr></table></figure><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是 <code>&lt;&gt;</code> 语法, 另一个为 <code>as</code> 语法</p><p><code>(&lt;string&gt;str)</code> &amp; <code>(str as string)</code> </p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getString</span>(<span class="hljs-params">str:number|string</span>):<span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-comment">// return str.toString().length</span><br>    <span class="hljs-comment">// 如果说str本身就是string类型的,就没有必要toString()方法</span><br>    <span class="hljs-keyword">if</span> ((&lt;string&gt;str).length) &#123;<br>        <span class="hljs-comment">// str.length存在</span><br>        <span class="hljs-keyword">return</span> (str <span class="hljs-keyword">as</span> string).length<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 此时说明str是number类型</span><br>        <span class="hljs-keyword">return</span> str.toString().length<br>        <span class="hljs-keyword">return</span> <br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.log(getString(<span class="hljs-number">12345</span>)) <span class="hljs-comment">// 5</span><br><span class="hljs-built_in">console</span>.log(getString(<span class="hljs-string">&#x27;0123456&#x27;</span>)) <span class="hljs-comment">// 7</span><br></code></pre></div></td></tr></table></figure><h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>TS会在没有明确的指定类型的时候推测出一个类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> txt = <span class="hljs-number">100</span>  <span class="hljs-comment">// number类型</span><br>txt = <span class="hljs-string">&#x27;张艺兴&#x27;</span>  <span class="hljs-comment">// 报错</span><br><span class="hljs-built_in">console</span>.log(txt)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/image-20210625151306764.png" alt="image-20210625151306764"></p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> txt2   <span class="hljs-comment">// any类型</span><br>txt2 = <span class="hljs-number">100</span><br>txt2 = <span class="hljs-string">&#x27;张艺兴&#x27;</span><br><span class="hljs-built_in">console</span>.log(txt2); <span class="hljs-comment">// undefined -&gt; 100 -&gt; 张艺兴</span><br></code></pre></div></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。</p><p>接口是对象的状态(属性)和行为(方法)的抽象(描述)</p><h5 id="接口试探"><a href="#接口试探" class="headerlink" title="接口试探"></a>接口试探</h5><ul><li>只读：前面添加 readonly</li><li>可有可无：后面跟上 ?</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-comment">// 需求: 创建人的对象, 需要对人的属性进行一定的约束</span><br><br>    <span class="hljs-comment">// id是number类型, 必须有, 只读的</span><br>    <span class="hljs-comment">// name是string类型, 必须有</span><br>    <span class="hljs-comment">// age是number类型, 必须有</span><br>    <span class="hljs-comment">// sex是string类型, 可以没有</span><br><br>    <span class="hljs-comment">// 定义一个接口类型,该接口作为person的类型使用,限定或者是约束该对象中的属性数据</span><br>    interface IPerson &#123;<br>        <span class="hljs-comment">// id 是只读的  ------&gt; readonly 而不是 const</span><br>        readonly id:number,<br>        <span class="hljs-attr">name</span>:string,<br>        <span class="hljs-attr">age</span>:number,<br>        <span class="hljs-comment">// sex 可有可无 ------&gt; ?</span><br>        sex?:string<br>    &#125;<br><br>    <span class="hljs-comment">// 定义一个对象,该对象的类型就是我定义的接口 IPerson</span><br>    <span class="hljs-keyword">const</span> person:IPerson = &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">1</span>,<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">18</span><br>        <span class="hljs-comment">// sex: &#x27;男&#x27;</span><br>    &#125;<br><br>    <span class="hljs-built_in">console</span>.log(person)<br>    <span class="hljs-comment">// id属性现在是可读可写 要加 readonly属性</span><br>    <span class="hljs-comment">// person.id = 100</span><br>    person.sex = <span class="hljs-string">&#x27;男&#x27;</span><br>    <span class="hljs-built_in">console</span>.log(person)<br>&#125;)()<br></code></pre></div></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 函数类型：通过接口的方式作为函数的类型来使用</span><br><br><span class="hljs-comment">// 定义一个接口，用来作为某个函数的类型使用</span><br>interface ISearchFunc &#123;<br>    <span class="hljs-comment">// 定义一个调用签名</span><br>    (source:string, <span class="hljs-attr">subString</span>:string):boolean<br>&#125;<br><br><span class="hljs-comment">// 定义一个函数，该类型就是上面定义的接口</span><br><span class="hljs-keyword">const</span> seachString: ISearchFunc = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">source:string, subString:string</span>):<span class="hljs-title">boolean</span> </span>&#123;<br>    <span class="hljs-comment">// 在 source 字符串中查找 substring 这个字符串</span><br>    <span class="hljs-keyword">return</span> source.search(subString) &gt; -<span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 调用函数</span><br><span class="hljs-built_in">console</span>.log(seachString(<span class="hljs-string">&#x27;哈哈，我又变帅了&#x27;</span>, <span class="hljs-string">&#x27;帅&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h5 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个接口</span><br>interface IFly &#123;<br>    <span class="hljs-comment">// 该方法没有任何的实现（方法中什么都没有）</span><br>    fly()<br>&#125;<br><br><span class="hljs-comment">// 定义一个类，这个类的类型就是上面的接口（实际上也可以理解为，IFly接口约束了当前这个Person类）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> <span class="hljs-title">implements</span> <span class="hljs-title">IFly</span> </span>&#123;<br>    <span class="hljs-comment">// 实现接口中的方法</span><br>    <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会飞了，我是超人&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化对象</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person()<br>person.fly()<br></code></pre></div></td></tr></table></figure><h6 id="一个类可以实现多个接口"><a href="#一个类可以实现多个接口" class="headerlink" title="一个类可以实现多个接口"></a>一个类可以实现多个接口</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 再定义一个接口</span><br>interface ISwim &#123;<br>    swim()<br>&#125;<br><br><span class="hljs-comment">// 定义一个类，这个类的类型就是Ifly和Iswim（当前这个类可以实现多个接口,一个类也可以同时被多个接口进行约束）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person2</span> <span class="hljs-title">implements</span> <span class="hljs-title">IFly</span>,<span class="hljs-title">ISwim</span> </span>&#123;<br>    <span class="hljs-comment">// 实现接口中的方法</span><br>    <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我飞了2&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">swim</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会游泳2&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化对象</span><br><span class="hljs-keyword">const</span> person2 = <span class="hljs-keyword">new</span> Person2()<br>person2.fly()<br>person2.swim()<br></code></pre></div></td></tr></table></figure><h6 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义了一个接口，继承其他的多个接口</span><br>interface IMyFlyAndSwim <span class="hljs-keyword">extends</span> IFly,ISwim &#123; &#125;<br><br><span class="hljs-comment">// 定义一个类，直接实现这个接口</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person3</span> <span class="hljs-title">implements</span> <span class="hljs-title">IMyFlyAndSwim</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">fly</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我飞了3&#x27;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">swim</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我会游泳3&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">const</span> person3 = <span class="hljs-keyword">new</span> Person3()<br>person3.fly()<br>person3.swim()<br></code></pre></div></td></tr></table></figure><p> 总结</p><ul><li>定义接口（使用的是 interface 关键字）</li><li>接口和接口之间叫继承（使用的是 extends 关键字）</li><li>类和接口之间叫实现（使用的是 implements 关键字）</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ts 中类的定义及使用</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-comment">// 定义属性</span><br>    <span class="hljs-attr">name</span>:string<br>    <span class="hljs-attr">age</span>:number<br>    <span class="hljs-attr">gender</span>:string<br>    <span class="hljs-comment">// 定义构造函数：未来将来实例化对象的时候，可以直接对属性的值进行初始化</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:string=<span class="hljs-string">&#x27;张艺兴&#x27;</span>,age:number=<span class="hljs-number">18</span>,gender:string=<span class="hljs-string">&#x27;男&#x27;</span></span>)</span> &#123;<br>        <span class="hljs-comment">// 更新对象中的属性数据</span><br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>        <span class="hljs-built_in">this</span>.gender = gender<br>    &#125;<br>    <span class="hljs-comment">// 定义实例方法</span><br>    sayHi (str:string) &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`大家好，我是<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>，今年已经<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.age&#125;</span>岁了，是个<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.gender&#125;</span>生，`</span> + str)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// ts 中使用类，实例化对象，可以直接进行初始化操作</span><br><span class="hljs-keyword">const</span> person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;张宝文&#x27;</span>, <span class="hljs-number">19</span>)<br>person.sayHi(<span class="hljs-string">&#x27;你叫什么？&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个类，继承自上方Person</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">name:string,age:number,gender:string</span>) &#123;<br>        <span class="hljs-comment">// 调用的是父类中的构造函数，使用的super</span><br>        <span class="hljs-built_in">super</span>(name,age,gender)<br>    &#125;<br><br>    <span class="hljs-comment">// 可以调用父类中的方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;我是学生类中的sayHi方法&#x27;</span>);<br>        <span class="hljs-comment">// 带哦用父类中的sayHi方法</span><br>        <span class="hljs-built_in">super</span>.sayHi(<span class="hljs-string">&#x27;你呢&#x27;</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化 Student</span><br><span class="hljs-keyword">const</span> student = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&#x27;郑佳丽&#x27;</span>,<span class="hljs-number">19</span>,<span class="hljs-string">&#x27;女&#x27;</span>)<br>student.sayHi()<br></code></pre></div></td></tr></table></figure><p>总结：</p><ul><li>类和类之间如果要有继承关系，需要使用 extends 关键字</li><li>子类中可以调用父类中的构造函数，调用的是 super 关键字（包括调用父类中的实例方法，也可以使用super）</li><li>子类中可以重写父类中的方法</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>父类型的引用指向子类型的对象，不同类型的对象针对相同的方法，产生不同的行为</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个父类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">// 定义一个属性</span><br>    <span class="hljs-attr">name</span>:string<br>    <span class="hljs-comment">// 定义一个构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:string</span>)</span> &#123;<br>        <span class="hljs-comment">// 初始化（更新属性值）</span><br>        <span class="hljs-built_in">this</span>.name = name<br>    &#125;<br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params">distance:number = <span class="hljs-number">0</span></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>跑了<span class="hljs-subst">$&#123;distance&#125;</span>米这么远的距离`</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 定义一个子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:string</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的构造函数，实现子类属性的初始化操作</span><br>        <span class="hljs-built_in">super</span>(name)<br>    &#125;<br>    <span class="hljs-comment">// 实例方法，重写父类中的实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params">distance:number = <span class="hljs-number">5</span></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>跑了<span class="hljs-subst">$&#123;distance&#125;</span>米这么远的距离`</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 定义一个子类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Pig</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name:string</span>)</span> &#123;<br>        <span class="hljs-comment">// 调用父类的构造函数，实现子类属性的初始化操作</span><br>        <span class="hljs-built_in">super</span>(name)<br>    &#125;<br>    <span class="hljs-comment">// 实例方法，重写父类中的实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params">distance:number = <span class="hljs-number">10</span></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;<span class="hljs-built_in">this</span>.name&#125;</span>跑了<span class="hljs-subst">$&#123;distance&#125;</span>米这么远的距离`</span>)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化父类对象</span><br><span class="hljs-keyword">const</span> animal: Animal = <span class="hljs-keyword">new</span> Animal(<span class="hljs-string">&#x27;动物&#x27;</span>)<br>animal.run()<br><span class="hljs-comment">// 实例化子类对象</span><br><span class="hljs-keyword">const</span> dog: Dog = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;大黄&#x27;</span>)<br>dog.run()<br><span class="hljs-comment">// 实例化子类对象</span><br><span class="hljs-keyword">const</span> pig: Pig = <span class="hljs-keyword">new</span> Pig(<span class="hljs-string">&#x27;乔治&#x27;</span>)<br>pig.run()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;====================&#x27;</span>)  <br><span class="hljs-comment">// 父类和子类的关系：父子关系，此时，父类类型创建子类的对象</span><br><br><span class="hljs-keyword">const</span> dog1: Animal = <span class="hljs-keyword">new</span> Dog(<span class="hljs-string">&#x27;小黄&#x27;</span>)<br>dog1.run()<br><span class="hljs-keyword">const</span> pig1: Animal = <span class="hljs-keyword">new</span> Pig(<span class="hljs-string">&#x27;佩奇&#x27;</span>)<br>pig1.run()<br><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;====================&#x27;</span>)  <br><span class="hljs-comment">// 该函数需要的参数是 Animal 类型的</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showRun</span>(<span class="hljs-params">animal:Animal</span>) </span>&#123;<br>    animal.run()<br>&#125;<br><br>showRun(dog1)<br>showRun(pig1)<br></code></pre></div></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符(类中的成员的修饰符)：主要是描述类中的成员(属性，构造函数，方法)的可访问性</p><h5 id="public"><a href="#public" class="headerlink" title="public"></a>public</h5><p>公共的</p><p>类中的成员都有自己默认的访问修饰符 public</p><p>类中的成员默认的修饰符，代表的是公共的，任何位置都可以访问类中的成员</p><h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>私有的</p><p>外部无法访问这个成员数据，子类中也无法访问</p><h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p>受保护的</p><p>外部无法访问这个成员数据，子类可访问</p><h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h5><p>只读的</p><p>可以对类中的属性成员进行修饰，该属性成员，就不能再外部被随意的修改了</p><ul><li>构造函数中可以对只读的属性成员的数据进行修改</li><li>如果构造函数中没有任何的参数，类中的属性成员此时使用 readonly 进行修饰了，那么外部也是不能对这个属性值进行更改的</li><li>构造函数中的参数可以使用readonly 进行修饰,一旦修饰,那么该类中就有了这个只读的成员属性了,外部可以访问,但是不能修改</li><li>构造函数中的参数可以使用 public及private及protected 进行修饰,无论是哪个进行修饰,那么该类中都会自动的添加这么一个属性成员</li></ul><h4 id="存储器-get-set"><a href="#存储器-get-set" class="headerlink" title="存储器(get set)"></a>存储器(get set)</h4><p>TypeScript 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。 </p><p>让我们可以有效的控制对对象成员的访问,通过getters和setters来进行操作</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 外部可以传入姓氏和名字数据,同时使用set和get控制姓名的数据,外部也可以修改操作</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-attr">firstName</span>:string <span class="hljs-comment">// 姓氏</span><br>    <span class="hljs-attr">lastName</span>:string  <span class="hljs-comment">// 名字</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">firstName:string,lastName:string</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.firstName = firstName<br>        <span class="hljs-built_in">this</span>.lastName = lastName<br>    &#125;<br><span class="hljs-comment">// 姓名的成员属性(外部可以访问,也可以修改)</span><br><br><span class="hljs-comment">// 读取器 ------&gt; 负责读取数据</span><br><span class="hljs-keyword">get</span> <span class="hljs-title">fullName</span>() &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;get中...&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.firstName + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-built_in">this</span>.lastName<br>&#125;<br><span class="hljs-comment">// 设置器 ------&gt; 负责修改数据</span><br><span class="hljs-keyword">set</span> <span class="hljs-title">fullName</span>(<span class="hljs-params">val</span>) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;set中...&#x27;</span>)<br>    <span class="hljs-keyword">let</span> names = val.split(<span class="hljs-string">&#x27;_&#x27;</span>)<br>    <span class="hljs-built_in">this</span>.firstName = names[<span class="hljs-number">0</span>]<br>    <span class="hljs-built_in">this</span>.lastName = names[<span class="hljs-number">1</span>]<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化对象</span><br><span class="hljs-keyword">const</span> person:Person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&#x27;东方&#x27;</span>, <span class="hljs-string">&#x27;不败&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(person)<br><span class="hljs-comment">// 获取该属性成员数据</span><br><span class="hljs-built_in">console</span>.log(person.fullName)<br><span class="hljs-comment">// 设置该属性的数据</span><br>person.fullName = <span class="hljs-string">&#x27;诸葛_孔明&#x27;</span><br><span class="hljs-built_in">console</span>.log(person)<br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/image-20210625193104527.png" alt="image-20210625193104527"></p><h4 id="静态属性-static"><a href="#静态属性-static" class="headerlink" title="静态属性(static)"></a>静态属性(static)</h4><p>静态成员:在类中通过 static 修饰的属性或方法,就是静态的属性及方法</p><p>静态成员在使用时是通过 类名. 的这种做法来调用的</p><h4 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h4><p>含抽象方法（抽象方法一般没有任何的具体内容的实现），也可以包含实例方法，抽象类是不能被实例化的,为了让子类进行实例化及实现内部的抽象方法</p><p>抽象类的目的或者是作用都是为子类服务的</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个类</span><br>abstract <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">// 抽象属性 一般不这么实现</span><br>    <span class="hljs-comment">// abstract name:string</span><br>    <span class="hljs-comment">// 抽象方法</span><br>    abstract eat()<br>    <span class="hljs-comment">// 实例方法</span><br>    <span class="hljs-function"><span class="hljs-title">sayHi</span>(<span class="hljs-params"></span>)</span> &#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;您好啊&#x27;</span>)<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 定义一个子类（派生类）Dog</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-comment">// name:string = &#x27;Lay&#x27;</span><br>    <span class="hljs-comment">// 重新的实现抽象类中的方法，此时这个方法就是当前抽象类的实例方法了</span><br>    <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;舔着吃，真好吃&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化 Dog 的对象</span><br><span class="hljs-keyword">const</span> dog:Dog = <span class="hljs-keyword">new</span> Dog()<br>dog.eat()<br><span class="hljs-comment">// 调用的是抽象类中的实例方法</span><br>dog.sayHi()<br><span class="hljs-comment">// console.log(dog.name);</span><br><br><span class="hljs-comment">// 不能实例化抽象类的对象</span><br><span class="hljs-comment">// const ani:Animal = new Animal()</span><br></code></pre></div></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 函数声明，命名函数</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x:string, y:string</span>):<span class="hljs-title">string</span> </span>&#123; <span class="hljs-comment">// 求和的函数</span><br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">const</span> result1:string = add(<span class="hljs-string">&#x27;111&#x27;</span>,<span class="hljs-string">&#x27;222&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(result1) <span class="hljs-comment">// &#x27;111222&#x27;</span><br><br><span class="hljs-comment">// 函数表达式，匿名函数</span><br><span class="hljs-keyword">const</span> add2 = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x:number, y:number</span>):<span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">const</span> result2:number = add2(<span class="hljs-number">111</span>,<span class="hljs-number">222</span>)<br><span class="hljs-built_in">console</span>.log(result2) <span class="hljs-comment">// 333</span><br><br><span class="hljs-comment">// 函数的完整写法</span><br><span class="hljs-comment">// add3 ----&gt; 变量名 ----&gt; 函数add3</span><br><span class="hljs-comment">// (x:number, y:number) =&gt; number 当前这个函数的类型</span><br><span class="hljs-comment">// function (x:number, y:number):number &#123; return x + y &#125; 相当于上面的这个函数类型的值</span><br><span class="hljs-keyword">const</span> add3:<span class="hljs-function">(<span class="hljs-params">x:number, y:number</span>) =&gt;</span> number = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x:number, y:number</span>):<span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-keyword">const</span> result3:number = add3(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>)<br><span class="hljs-built_in">console</span>.log(result3) <span class="hljs-comment">// 11</span><br></code></pre></div></td></tr></table></figure><h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><ul><li>可选参数:函数在声明时,内部的函数使用了 <code>?</code> 进行修饰,就表示该参数可以传入也可以不传入</li><li>默认参数:函数在声明的时候,内部的参数有自己的默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个函数:传入姓氏和名字,可以得到姓名</span><br><span class="hljs-comment">// 需求:如果不传入任何内容,那么就返回默认的姓氏</span><br><span class="hljs-comment">// 如果只传入姓氏,那么就返回姓氏</span><br><span class="hljs-comment">// 如果传入姓氏和名字,那么返回来的就是姓名</span><br><span class="hljs-keyword">const</span> getFullName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">firstName:string=<span class="hljs-string">&#x27;东方&#x27;</span>,lastName?:string</span>) </span>&#123;<br>    <span class="hljs-comment">// 判断名字是否传入</span><br>    <span class="hljs-keyword">if</span> (lastName) &#123;<br>        <span class="hljs-keyword">return</span> firstName + <span class="hljs-string">&#x27;_&#x27;</span> + lastName<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> firstName<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数调用</span><br><span class="hljs-built_in">console</span>.log(getFullName(<span class="hljs-string">&#x27;张&#x27;</span>, <span class="hljs-string">&#x27;艺兴&#x27;</span>));<br></code></pre></div></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数(rest参数)是放在函数声明的时候所有的参数最后</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ...args:string[] ----&gt; 剩余的参数是放在了一个字符串的数组当中</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">showMsg</span>(<span class="hljs-params">str:string, ...args:string[]</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(str);<br>    <span class="hljs-built_in">console</span>.log(args);<br>&#125;<br>showMsg(<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-string">&#x27;b&#x27;</span>,<span class="hljs-string">&#x27;c&#x27;</span>,<span class="hljs-string">&#x27;d&#x27;</span>,<span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数名字相同,函数的参数及个数不同</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个函数</span><br><span class="hljs-comment">// 需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加</span><br><br><span class="hljs-comment">// 函数重载声明</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: string, y: string</span>): <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: number, y: number</span>): <span class="hljs-title">number</span></span></span><br><span class="hljs-function"><span class="hljs-function"></span></span><br><span class="hljs-function"><span class="hljs-function">// 函数声明</span></span><br><span class="hljs-function"><span class="hljs-function"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">x: string | number, y: string | number</span>): <span class="hljs-title">string</span> | <span class="hljs-title">number</span> </span>&#123;</span></span><br><span class="hljs-function"><span class="hljs-function">    <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;string&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> y === <span class="hljs-string">&#x27;string&#x27;</span></span>) </span>&#123;</span><br><span class="hljs-function">        <span class="hljs-title">return</span> <span class="hljs-title">x</span> + <span class="hljs-title">y</span> // 字符串拼接</span><br><span class="hljs-function">    &#125; <span class="hljs-title">else</span> <span class="hljs-title">if</span> (<span class="hljs-params"><span class="hljs-keyword">typeof</span> x === <span class="hljs-string">&#x27;number&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> y === <span class="hljs-string">&#x27;number&#x27;</span></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> x + y <span class="hljs-comment">// 数组相加</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 函数调用</span><br><span class="hljs-comment">// 两个参数都是字符串</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-string">&#x27;张&#x27;</span>, <span class="hljs-string">&#x27;艺兴&#x27;</span>))<br><span class="hljs-comment">// 两个参数都是数字</span><br><span class="hljs-built_in">console</span>.log(add(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>))<br><span class="hljs-comment">// 如果传入的是非法的数据, ts 应该给我提示出错误的信息内容</span><br><span class="hljs-comment">// console.log(add(&#x27;张&#x27;, 13))</span><br><span class="hljs-comment">// console.log(add(14, &#x27;13&#x27;))</span><br></code></pre></div></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在定义函数、接口、类的时候不能预先确定要使用的数据的类型，而是在使用函数、接口、类的时候才能确定数据的类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 需求：定义一个函数，传入两个参数，第一参数是数据。第二参数是数量，函数的作用是根据数量产生对应个数的数据，存放在以一个数组中</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getArr4</span>&lt;<span class="hljs-title">T</span>&gt;(<span class="hljs-params">value:T,count:number</span>):<span class="hljs-title">T</span>[] </span>&#123;<br>    <span class="hljs-comment">// 根据数据和数量产生一个数组</span><br>    <span class="hljs-comment">// const arr : T[] = []</span><br>    <span class="hljs-keyword">const</span> arr:<span class="hljs-built_in">Array</span>&lt;T&gt; = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>        arr.push(value)<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr<br>&#125;<br><span class="hljs-keyword">const</span> arr3 = getArr4&lt;number&gt;(<span class="hljs-number">200.12345</span>,<span class="hljs-number">5</span>)<br><span class="hljs-keyword">const</span> arr4 = getArr4&lt;string&gt;(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>,<span class="hljs-number">5</span>)<br><span class="hljs-built_in">console</span>.log(arr3)<br><span class="hljs-built_in">console</span>.log(arr4)<br><span class="hljs-comment">// // arr3中存储的是数字类型的数据</span><br><span class="hljs-comment">// // arr4中存储的是字符串类型的数据</span><br><span class="hljs-built_in">console</span>.log(arr3[<span class="hljs-number">0</span>].toFixed(<span class="hljs-number">3</span>))<br><span class="hljs-built_in">console</span>.log(arr4[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h4 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a>多个泛型参数的函数</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getMsg</span>&lt;<span class="hljs-title">K</span>, <span class="hljs-title">V</span>&gt;(<span class="hljs-params">value1: K, value2: V</span>): [<span class="hljs-title">K</span>, <span class="hljs-title">V</span>] </span>&#123;<br>    <span class="hljs-keyword">return</span> [value1, value2]<br>&#125;<br><br><span class="hljs-keyword">const</span> arr1 = getMsg&lt;string,number&gt;(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">100</span>)<br><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;&#x27;</span>))<br><span class="hljs-built_in">console</span>.log(arr1[<span class="hljs-number">1</span>].toFixed(<span class="hljs-number">2</span>))<br></code></pre></div></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>在定义接口时, 为接口中的属性或方法定义泛型类型，在使用接口时, 再指定具体的泛型类型</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 需求：定义一个类，用来存储用户的相关信息（id，名字，年龄）</span><br><span class="hljs-comment">// 通过一个类的实例对象调用 add 方法可以添加多个用户信息对象，调用 getUserId 可以根据id 获取某个指定的用户信息对象</span><br><br><span class="hljs-comment">// 定义一个泛型接口</span><br>interface IBaseCRUD&lt;T&gt; &#123;<br>    <span class="hljs-attr">data</span>: <span class="hljs-built_in">Array</span>&lt;T&gt;<br>    add: <span class="hljs-function">(<span class="hljs-params">t: T</span>) =&gt;</span> T<br>    <span class="hljs-attr">getUserId</span>: <span class="hljs-function">(<span class="hljs-params">id: number</span>) =&gt;</span> T<br>&#125;<br><br><span class="hljs-comment">// 定义一个用户信息的类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    id?: number  <span class="hljs-comment">// 用户的id</span><br>    <span class="hljs-attr">name</span>: string  <span class="hljs-comment">// 用户的姓名</span><br>    <span class="hljs-attr">age</span>: number  <span class="hljs-comment">// 用户的年龄</span><br>    <span class="hljs-comment">// 构造函数</span><br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">name: string, age: number</span>)</span> &#123;<br>        <span class="hljs-built_in">this</span>.name = name<br>        <span class="hljs-built_in">this</span>.age = age<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 定义一个类，可以针对用户的信息对象进行增加及查询的操作</span><br><span class="hljs-comment">// CRUD ----&gt; Create Read Update Delete</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserCRUD</span> <span class="hljs-title">implements</span> <span class="hljs-title">IBaseCRUD</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 用来保存多个 User 类型的用户信息对象</span><br>    <span class="hljs-attr">data</span>: <span class="hljs-built_in">Array</span>&lt;User&gt; = []<br>    <span class="hljs-comment">// 方法用来存储用户信息对象的</span><br>    add(user: User): User &#123;<br>        <span class="hljs-comment">// 产生 id</span><br>        user.id = <span class="hljs-built_in">Date</span>.now() + <span class="hljs-built_in">Math</span>.random()<br>        <span class="hljs-comment">// 把用户信息对象添加到data数组中</span><br>        <span class="hljs-built_in">this</span>.data.push(user)<br>        <span class="hljs-keyword">return</span> user<br>    &#125;<br>    <span class="hljs-comment">// 根据id查询指定的用户信息对象</span><br>    getUserId(id: number): User &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.data.find(<span class="hljs-function"><span class="hljs-params">user</span> =&gt;</span> user.id === id)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 实例化添加用户信息对象的类 UserCRUD</span><br><span class="hljs-keyword">const</span> userCRUD: UserCRUD = <span class="hljs-keyword">new</span> UserCRUD()<br>userCRUD.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">20</span>))<br>userCRUD.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;lay&#x27;</span>, <span class="hljs-number">18</span>))<br><span class="hljs-keyword">const</span> &#123;id&#125; = userCRUD.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;Lay&#x27;</span>, <span class="hljs-number">18</span>))<br>userCRUD.add(<span class="hljs-keyword">new</span> User(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">19</span>))<br><br><span class="hljs-built_in">console</span>.log(userCRUD.data)<br><span class="hljs-comment">// 根据 id 查询用户信息对象数据</span><br><span class="hljs-keyword">const</span> user = userCRUD.getUserId(id)<br><span class="hljs-built_in">console</span>.log(user)<br></code></pre></div></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义一个类，类中的属性值是不确定的，方法中的参数及返回值的类型也是不确定的</span><br><span class="hljs-comment">// 定义一个泛型类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GenericNumber</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 默认的属性的值的类型是泛型类型</span><br>    <span class="hljs-attr">defaultValue</span>: T<br>    <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params">x: T, y: T</span>) =&gt;</span> T<br>&#125;<br><br><span class="hljs-comment">// 在实例化类的对象的时候，再确定泛型的类型</span><br><span class="hljs-keyword">const</span> g1: GenericNumber&lt;number&gt; = <span class="hljs-keyword">new</span> GenericNumber&lt;number&gt;()<br><span class="hljs-comment">// 设置属性值</span><br>g1.defaultValue = <span class="hljs-number">100</span><br><span class="hljs-comment">// 相加的方法</span><br>g1.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-built_in">console</span>.log(g1.add(g1.defaultValue, <span class="hljs-number">1</span>))<br><br><span class="hljs-comment">// 在实例化类的对象的时候，再确定泛型的类型</span><br><span class="hljs-keyword">const</span> g2: GenericNumber&lt;string&gt; = <span class="hljs-keyword">new</span> GenericNumber&lt;string&gt;()<br><span class="hljs-comment">// 设置属性值</span><br>g2.defaultValue = <span class="hljs-string">&#x27;哈哈&#x27;</span><br><span class="hljs-comment">// 相加的方法</span><br>g2.add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">x, y</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> x + y<br>&#125;<br><span class="hljs-built_in">console</span>.log(g2.add(<span class="hljs-string">&#x27;Agoni&#x27;</span>, <span class="hljs-string">&#x27;Lay&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性</span><br><span class="hljs-comment">// 定义一个接口,用来约束将来的某个类型中必须要有 length 这个属性</span><br>interface ILength &#123;<br>    <span class="hljs-comment">// 接口中有一个属性 length</span><br>    <span class="hljs-attr">length</span>: number<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getLength</span>&lt;<span class="hljs-title">T</span> <span class="hljs-title">extends</span> <span class="hljs-title">ILength</span>&gt;(<span class="hljs-params">x: T</span>): <span class="hljs-title">number</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> x.length<br>&#125;<br><br><span class="hljs-built_in">console</span>.log(getLength&lt;string&gt;(<span class="hljs-string">&#x27;How are you&#x27;</span>))<br><span class="hljs-comment">// console.log(getLength&lt;number&gt;(123))</span><br></code></pre></div></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><h5 id="例：jQuery"><a href="#例：jQuery" class="headerlink" title="例：jQuery"></a>例：jQuery</h5><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><h6 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句:"></a>声明语句:</h6><p>如果需要ts对新的语法进行检查, 需要要加载了对应的类型说明代码</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">declare <span class="hljs-keyword">var</span> jQuery: <span class="hljs-function">(<span class="hljs-params">selector: string</span>) =&gt;</span> any;<br></code></pre></div></td></tr></table></figure><h6 id="声明文件-1"><a href="#声明文件-1" class="headerlink" title="声明文件:"></a>声明文件:</h6><p>把声明语句放到一个单独的文件（jQuery.d.ts）中, ts会自动解析到项目中所有声明文件</p><p>下载自动识别的：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 安装 jquery</span><br>npm i jquery<br><span class="hljs-comment">// 安装声明文件</span><br>npm i @types/jquery --save-dev<br></code></pre></div></td></tr></table></figure><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p><h5 id="ECMAScript-的内置对象"><a href="#ECMAScript-的内置对象" class="headerlink" title="ECMAScript 的内置对象"></a>ECMAScript 的内置对象</h5><ul><li>Boolean</li><li>Number</li><li>String</li><li>Date</li><li>RegExp</li><li>Error</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">/* 1. ECMAScript 的内置对象 */</span><br><span class="hljs-keyword">let</span> b: <span class="hljs-built_in">Boolean</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">let</span> n: <span class="hljs-built_in">Number</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Number</span>(<span class="hljs-literal">true</span>)<br><span class="hljs-keyword">let</span> s: <span class="hljs-built_in">String</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">&#x27;abc&#x27;</span>)<br><span class="hljs-keyword">let</span> d: <span class="hljs-built_in">Date</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()<br><span class="hljs-keyword">let</span> r: <span class="hljs-built_in">RegExp</span> = <span class="hljs-regexp">/^1/</span><br><span class="hljs-keyword">let</span> e: <span class="hljs-built_in">Error</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error message&#x27;</span>)<br>b = <span class="hljs-literal">true</span><br><span class="hljs-comment">// let bb: boolean = new Boolean(2)  // error</span><br></code></pre></div></td></tr></table></figure><h5 id="BOM-和-DOM-的内置对象"><a href="#BOM-和-DOM-的内置对象" class="headerlink" title="BOM 和 DOM 的内置对象"></a>BOM 和 DOM 的内置对象</h5><ul><li>Window</li><li>Document</li><li>HTMLElement</li><li>DocumentFragment</li><li>Event</li><li>NodeList</li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> div: HTMLElement = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;test&#x27;</span>)<br><span class="hljs-keyword">const</span> divs: NodeList = <span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">&#x27;div&#x27;</span>)<br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">event: MouseEvent</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.dir(event.target)<br>&#125;)<br><span class="hljs-keyword">const</span> fragment: DocumentFragment = <span class="hljs-built_in">document</span>.createDocumentFragment()<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>TypeScript</tag>
      
      <tag>webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>php笔记</title>
    <link href="/2021/07/29/php%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/29/php%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h4 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h4><p>开头添加：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">header(<span class="hljs-string">&quot;Content-Type: text/html; charset=utf-8&quot;</span>);<br></code></pre></div></td></tr></table></figure><h2 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h2><h4 id="什么是-PHP"><a href="#什么是-PHP" class="headerlink" title="什么是 PHP"></a>什么是 PHP</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一种服务器端的 HTML 脚本/编程语言,是一种简单的、面向对象的、解释型的、健壮的、安全的、性能非常之高的、独立于架构的、可移植的、动态的脚本语言。是一种广泛用于 Open Source（开放源代码）的尤其适合 Web 开发并可以嵌入 HTML 的多用途脚本语言。它的语法接近 C，Java 和 Perl，而且容易学习。</p><p>该语言让 Web 开发人员快速的书写动态生成的网页</p><h5 id="前身"><a href="#前身" class="headerlink" title="前身"></a>前身</h5><p>Personal HomePage：个人主页，使用Perl语言开发的一种写个人主页的语言</p><p>PHP：PHP Hypertext Preprosessor， php 超文本预处理器，底层使用C语言</p><h4 id="PHP发展史"><a href="#PHP发展史" class="headerlink" title="PHP发展史"></a>PHP发展史</h4><p>…</p><p>平台支持（window，Linux，UNIX）</p><p>数据库支持（Sqlserver，mysql，Oracle，Access）</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><h5 id="静态网站特点"><a href="#静态网站特点" class="headerlink" title="静态网站特点"></a>静态网站特点</h5><ol><li>网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；</li><li>静态网页的内容相对稳定，因此<strong>容易被搜索引擎检索</strong>；</li><li>静态网页<strong>没有数据库的支持</strong>，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；</li><li>静态网页的<strong>交互性较差</strong>，在功能方面有较大的限制。</li></ol><h5 id="动态网站特点"><a href="#动态网站特点" class="headerlink" title="动态网站特点"></a>动态网站特点</h5><ol><li><p>交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后Web发展的潮流。</p></li><li><p>自动更新：即无须手动更新HTML文档，便会自动生成新页面，可以大大节省工作量。</p></li><li><p>因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。</p><p>此外动态网页是与静态网页相对应的，也就是说，网页 URL 的后缀不是 .htm、.html、.shtml、.xml 等静态网页的常见形式，而是以 .asp、.jsp、.php、.perl、.cgi 等形式为后缀。在动态网页网址中有一个标志性的符号——“?”</p></li></ol><h2 id="网站基本概念"><a href="#网站基本概念" class="headerlink" title="网站基本概念"></a>网站基本概念</h2><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器：能够提供服务的机器，取决于机器上所安装的软件（服务软件）</p><p>Web服务器：提供web服务（网站访问），就需要安装web服务软件 Apache，tomcat，iis 等</p><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>Internet Protocol，网络之间互联协议。网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议</p><p>IP地址具有<strong>唯一性</strong>（每台电脑都有一个唯一的IP地址）</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>Domain Name，是由一串用点分隔的名字组成（<a href="http://www.itcast.cn)的/">www.itcast.cn）的</a> Internet 上某一台计算机或计算机组的名称</p><p>一个域名的目的是便于记忆和沟通的一组服务器的地址（网站，电子邮件，FTP等）。域名作为力所能及难忘的互联网参与者的名称</p><p>特殊IP：127.0.0.1，代表本机</p><p>特殊域名：localhost</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>Domain Name System，域名系统</p><p>通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）</p><p>用户输入域名 localhost  –&gt;  DNS（localhost 127.0.0.1）–&gt;  服务器电脑</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>Port，可以认为是设备与外界通讯交流的出口。端口可分为<strong>虚拟端口</strong>和<strong>物理端口</strong>，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。</p><p>用户输入域名 localhost:端口  –&gt;  DNS（localhost 127.0.0.1）–&gt;  服务器电脑 –&gt; 软件（服务）</p><h2 id="Web-程序的访问流程"><a href="#Web-程序的访问流程" class="headerlink" title="Web 程序的访问流程"></a>Web 程序的访问流程</h2><p>Web分为两类：静态网站和动态网站</p><p>浏览器发起访问  –&gt;  DNS解析域名  –&gt;  服务器电脑  –&gt;  服务软件</p><h4 id="静态网站的访问"><a href="#静态网站的访问" class="headerlink" title="静态网站的访问"></a>静态网站的访问</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627153514946.png"></p><h4 id="动态网站的访问"><a href="#动态网站的访问" class="headerlink" title="动态网站的访问"></a>动态网站的访问</h4><p>动态网站访问流程与静态差不多，但是会多出几个内容：服务器端解析、数据库</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627154927756.png"></p><h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2><h4 id="安装-Apache-软件"><a href="#安装-Apache-软件" class="headerlink" title="安装 Apache 软件"></a>安装 Apache 软件</h4><ol><li><p>获取 Apache 软件</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160153744.png"></p></li><li><p>双击安装即可：指定对应路径</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160215862.png"></p></li><li><p>选择安装模式：使用自定义</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160314247.png"></p></li><li><p>选择安装位置</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160438991.png"></p></li></ol><h4 id="Apache-的目录结构说明"><a href="#Apache-的目录结构说明" class="headerlink" title="Apache 的目录结构说明"></a>Apache 的目录结构说明</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160730828.png"></p><h4 id="Httpd-exe-的详细应用"><a href="#Httpd-exe-的详细应用" class="headerlink" title="Httpd.exe 的详细应用"></a>Httpd.exe 的详细应用</h4><ol><li><p>服务器进程：运行之后才能够工作</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161153791.png"></p></li><li><p>用来查看Apache具有哪些功能以及配置文件是否有错：httpd 或者 httpd.exe（文件所在目录）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161416719.png"></p><ol><li><p>查看使用的模块：httpd.exe -M</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161553233.png"></p></li><li><p>验证配置文件是否有效：httpd -t</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161837622.png"></p></li></ol></li></ol><h2 id="配置默认站点"><a href="#配置默认站点" class="headerlink" title="配置默认站点"></a>配置默认站点</h2><ol><li><p>让 Apache 确定服务器上访问的位置：网站文件夹所在位置</p><p>Httpd.conf： DocumentRoot</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627170307785.png"></p></li><li><p>方便用户使用名字访问对应网站：给文件夹对应的起一个别名</p><p>Httpd.conf： ServerName</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627162507164.png"></p><p>端口可以单独实现：httpd.conf： listen</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627162551195.png"></p></li><li><p><strong>凡是涉及到 Apache 配置问价的修改，那么需要重启 Apache 才能生效</strong> </p></li><li><p>实现 DNS 域名解析：通常默认站点都是本地 DNS：hosts 文件</p><p>C:\Windows\System32\drivers\etc 下 hosts 文件</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627163009596.png"></p></li></ol><h2 id="安装与配置-PHP"><a href="#安装与配置-PHP" class="headerlink" title="安装与配置 PHP"></a>安装与配置 PHP</h2><h4 id="安装-PHP-语言"><a href="#安装-PHP-语言" class="headerlink" title="安装 PHP 语言"></a>安装 PHP 语言</h4><ol><li><p>获取PHP安装文件：建议去官网</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627163637004.png"></p></li><li><p>解压缩</p></li><li><p>安装：将压缩包放到 D:/server/ ，重命名 php5</p></li></ol><h4 id="PHP-目录结构说明"><a href="#PHP-目录结构说明" class="headerlink" title="PHP 目录结构说明"></a>PHP 目录结构说明</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164042157.png"></p><h4 id="php-exe-的应用"><a href="#php-exe-的应用" class="headerlink" title="php.exe 的应用"></a>php.exe 的应用</h4><p>php.exe 就是可以解析PHP代码转变成HTML代码从而让浏览器可以解析的。</p><ol><li><p>通过CMD控制器进入到php.exe所在目录</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164214834.png"></p></li><li><p>通过 php.exe 运行命令来指定要解析的 PHP脚本 就可以：<code>php.exe  -f</code>  PHP文件所在路径</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164948370.png"></p></li></ol><h2 id="配置-Apache-加载-PHP-模块"><a href="#配置-Apache-加载-PHP-模块" class="headerlink" title="配置 Apache 加载 PHP 模块"></a>配置 Apache 加载 PHP 模块</h2><ol><li><p>Apache 加载 PHP 模块：在 Apache 的主配置文件（httpd.conf）中加载对应的 PHP 提供的模块</p><p><code>LoadModule php5_module &#39;D:/server/php5/php5apache2_2.dll&#39;</code> </p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627170739713.png"></p></li><li><p>Apache 分配工作给 PHP 模块：如果是 PHP 代码就交给 PHP 处理：文件后缀判断 .php 结尾肯定是 PHP 代码</p><p><code>AddType application/x-httpd-php .php</code> </p></li><li><p>将 PHP 的配置文件加载到 Apache 配置文件中：共同生效</p><ol><li><p>在 Apache 中指定 PHP 配置文件所在路径</p><p>PHPIniDir php.ini所在路径</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627172103347.png"></p></li><li><p>php.ini 文件默认是不存在的，是以 development 和 production 格式存在，需要格式化</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627172829719.png"></p></li></ol><p>说明：PHP 的配置文件已经加入到 Apache 的配置项中，意味着 php.ini 的修改需要 Apache 重启才会生效。</p></li></ol><h2 id="安装与配置-MySQL"><a href="#安装与配置-MySQL" class="headerlink" title="安装与配置 MySQL"></a>安装与配置 MySQL</h2><h4 id="安装-MySQL-软件"><a href="#安装-MySQL-软件" class="headerlink" title="安装 MySQL 软件"></a>安装 MySQL 软件</h4><h4 id="MySQL-目录结构说明"><a href="#MySQL-目录结构说明" class="headerlink" title="MySQL 目录结构说明"></a>MySQL 目录结构说明</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627231602204.png"></p><h4 id="Bin-目录的常用命令"><a href="#Bin-目录的常用命令" class="headerlink" title="Bin 目录的常用命令"></a>Bin 目录的常用命令</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627231701378.png"></p><p>软件设计结构：C/S 和 B/S</p><p>C/S：Client客户端/Server服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）</p><p>B/S：Browser浏览器/Server服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S架构服务）</p><h2 id="MySQL-访问流程"><a href="#MySQL-访问流程" class="headerlink" title="MySQL 访问流程"></a>MySQL 访问流程</h2><p>Mysql 是一款 C/S 架构的软件，需要通过客户端来访问服务端（MySQL 提示也提供了其他模式的访问：通过一些插件扩展来充当客户端）</p><ol><li><p>启用 MySQL 客户端： mysql.exe，该软件本身可以通过 CMD 控制台运行</p></li><li><p>MySQL客户端访问服务端需要进行寻找匹配：连接认证</p><p>连接：IP和端口确认，如果是本地都可以省略</p><p>-h 主机地址 –&gt; -hlocalhost（可以是 IP）</p><p>-P 端口 –&gt; -P3306</p><p>认证：通过用户名和密码进入服务器</p><p>-u 用户名 –&gt; -uroot，不可以省略（匿名用户除外）</p><p>-p 密码 –&gt; -proot</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234054183.png"></p></li><li><p>退出命令</p><p><code>\q</code> </p></li></ol><p>注意：通常连接认证的时候密码不建议明文，可以再输入 -p 之后回车，系统会再次让输入密码，这个时候就是密文</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234340617.png"></p><h2 id="PHP-连接-MySQL-数据库"><a href="#PHP-连接-MySQL-数据库" class="headerlink" title="PHP 连接 MySQL 数据库"></a>PHP 连接 MySQL 数据库</h2><p>PHP 本身不具备操作 MySQL 数据库的能力，需要借助 PHP 操作 MySQL 的扩展来实现</p><ol><li><p>PHP 加载 MySQL 扩展：php.ini 文件</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234726830.png"></p></li><li><p>PHP 所有的扩展都是在 ext 文件夹中，需要制定扩展所在路径： extension_dir</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627235322277.png"></p></li><li><p>php.ini 已经被 Apache 加载，所以需要重启</p></li></ol><p>如果出错，尝试设置：</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628002453049.png"></p><h2 id="设定-PHP-的系统时区"><a href="#设定-PHP-的系统时区" class="headerlink" title="设定 PHP 的系统时区"></a>设定 PHP 的系统时区</h2><p>通过 php.ini 中的 timezone 配置项来实现</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">; 增加时区<br>date.timezone = PRC<br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628002923832.png"></p><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>一台服务器很贵，如果只能部署一个网站，那么非常浪费。所以需要通过其他渠道来实现一台主机上部署多个网站。</p><h4 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h4><p>虚拟主机：Virtual machine，并不存在真实的主机，但是可以提供真实主机所实现的功能。</p><p>通俗的讲，虚拟主机就是将计算机中不同的文件夹进行不同的命名，然后可以实现让服务器（Apache）根据用户的需求从不同的文件夹（网站）中读取不同的内容。</p><h4 id="虚拟主机的分类"><a href="#虚拟主机的分类" class="headerlink" title="虚拟主机的分类"></a>虚拟主机的分类</h4><p>在Apache中，可以将虚拟主机划分成两类：</p><ol><li><p>基于IP的虚拟主机：一台电脑上有多个IP，每个IP对应一个网站</p><p>原理：电脑默认只有一个IP，因为通常只配有一个网卡；但是有的电脑（服务器居多）可以配置多个网卡，每个网卡可以绑定一个IP地址。</p></li><li><p>基于域名的虚拟主机：一台电脑上只有一个IP，但是IP下可以制作多个网站，但是需要给每个网站不同的名字（虚拟主机名）</p></li></ol><h2 id="搭建基于域名的虚拟主机"><a href="#搭建基于域名的虚拟主机" class="headerlink" title="搭建基于域名的虚拟主机"></a>搭建基于域名的虚拟主机</h2><p>在Apache中，虚拟主机的搭建有两种方式：</p><ol><li><p>在主配置文件中搭建：需要手动开启虚拟主机（基于域名）</p><p>NameVirtualHost *:80</p></li><li><p>在专门的虚拟主机配置文件中配置</p><ol><li><p>在主配置文件中加载虚拟主机配置文件(httpd.conf)：虚拟主机配置文件已经开启了虚拟主机 NameVirtualHost</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004217698.png"></p></li><li><p>虚拟主机从配置文件（extra/httpd-vhosts.conf）中配置虚拟主机</p><ol><li><p>增加一个对应的站点文件夹位置：</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004550155.png"></p></li><li><p>增加主机名字：文件夹的别名：ServerName</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004830659.png"></p></li><li><p>增加域名解析 DNS：(hosts 文件)</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628005736269.png"></p></li><li><p>需要给当前设定的站点（目录）访问权限</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">&lt;<span class="hljs-built_in">Directory</span> <span class="hljs-string">&#x27;站点目录&#x27;</span>&gt;<br>    Order Deny,Allow<span class="hljs-comment">// 没有顺序关系：实际顺序有关系</span><br>    Deny <span class="hljs-keyword">from</span> 指定的范围<br>    Allow <span class="hljs-keyword">from</span> 指定范围<br>&lt;/<span class="hljs-built_in">Directory</span>&gt;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628010552694.png"></p></li><li><p>配置访问列表：当访问是一个目录时（没有指定具体要访问的文件）</p><p>Options Indexes [FollowSymLinks]，如果访问目录，那么列表显示所有文件</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628011114358.png"></p></li><li><p>当用户访问指定目录不指定文件的时候，通常需要系统指定一个默认文件</p><p>DirectoryIndex 默认的文件列表，使用空格分离</p><p>注意：如果网站中整个网站根目录允许访问，但是其中还有其他文件夹不允许访问：可以增加多个 Directory 标签，针对不同文件夹</p></li></ol></li><li><p>一旦启用虚拟主机配置文件，那么默认的主机地址 localhost 就不再生效，如果想要生效：为 localhost 增加单独的虚拟主机</p></li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628011958112.png"></p></li></ol><h2 id="PHP-基础"><a href="#PHP-基础" class="headerlink" title="PHP 基础"></a>PHP 基础</h2><h3 id="PHP-语法初步"><a href="#PHP-语法初步" class="headerlink" title="PHP 语法初步"></a>PHP 语法初步</h3><p>PHP 是一种运行在服务器端的脚本语言，可以嵌入到HTML中。</p><h4 id="PHP-代码标记"><a href="#PHP-代码标记" class="headerlink" title="PHP 代码标记"></a>PHP 代码标记</h4><p>在PHP历史发展中，可以使用多种标记来区分PHP脚本</p><ul><li>ASP标记： <code>&lt;% php代码 %&gt;</code> </li><li>短标记： <code>&lt;? php代码 ?&gt;</code> </li></ul><p>以上两种基本弃用，如果要使用那么需要在配置文件中开启</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628093541586.png"></p><ul><li>脚本标记： <code>&lt;script lang=&quot;php&quot;&gt; php代码 &lt;/script&gt;</code> </li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628094015744.png" alt="image-20210628094015744"></p><ul><li>标准标记（常用）： <code>&lt;?php php代码 ?&gt;</code> </li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628094749928.png"></p><h4 id="PHP-注释"><a href="#PHP-注释" class="headerlink" title="PHP 注释"></a>PHP 注释</h4><p>习惯：所有的代码在写的过程中都必须进行注释</p><p>PHP 中注释分为两种</p><ul><li><p>行注释：一次注释一行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// ：后面跟的所有内容都是注释</span><br><br><span class="hljs-comment"># ：与 // 一样</span><br></code></pre></div></td></tr></table></figure></li><li><p>块注释：一次注释多行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">/* : 直到下面出现之前中间全部都是注释</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628100126110.png"></p></li></ul><h4 id="PHP-语句分隔符"><a href="#PHP-语句分隔符" class="headerlink" title="PHP 语句分隔符"></a>PHP 语句分隔符</h4><p>语句分隔符：在 PHP 中，代码是以行尾单位，系统需要通过判断行的解说，该结束通常都是一个符号：英文分号 <code>;</code> </p><p>特殊说明：</p><ol><li>PHP中标记结束符?&gt;有自带语句结束符的效果，最后一行PHP代码可以没有语句结束符 <code>;</code> （不建议）</li><li>PHP中其实很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中就不建议使用标记结束符?&gt;，PHP会自动从开始到最后全部认为是PHP代码，从而解析</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>变量是用来存储数据的；</li><li>变量是存在名字的；</li><li>变量是通过名字来访问的：数据；</li><li>变量是可以改变的：数据。</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>PHP中的所有变量都必须使用 <code>$</code> 符号</p><ol><li>定义：在系统中增加对应的变量名字（内存）</li><li>赋值：可以将数据赋值给变量名（可以在定义的同时完成）</li><li>可以通过变量名访问存储的数据</li><li>可以将变量从内存中删除</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628102030737.png"></p><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ol><li>在PHP中变量名字必须以“$”符号开始；</li><li>名字由字母、数字和下划线“_”构成，但是不能以数字开头；</li><li>在PHP中本身还允许中文变量（不建议）。</li></ol><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）</p><ul><li><p><strong>$_GET</strong>：获取所有表单以get方式提交的数据</p></li><li><p><strong>$_POST</strong>：POST提交的数据都会保存在此</p></li><li><p><strong>$_REQUEST</strong>：GET和POST提交的都会保存</p></li><li><p>$GLOBALS：PHP中所有的全局变量</p></li><li><p><strong>$_SERVER</strong>：服务器信息</p></li><li><p><strong>$_SESSION</strong>：session会话数据</p></li><li><p><strong>$_COOKIE</strong>：cookie会话数据</p></li><li><p>$_ENV：环境信息（用的较少）</p></li><li><p>$_FILES：用户上传的文件信息</p></li></ul><h4 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h4><p>如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面再多加一个$符号。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628104114494.png"></p><h4 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h4><p>将一个变量赋值给另外一个变量：变量传值</p><p>变量传值一共有两种方式：值传递，引用传递</p><ul><li><p>值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628105219725.png"></p></li><li><p>引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间（两个变量是同一个值）</p><p><code>$新变量 = &amp;$老变量;</code> </p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628105345581.png"></p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628110156014.png"></p><p>在内存中，通常有以下几个分区</p><ul><li>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</li><li>代码段：存储程序的内存部分（不执行）</li><li>数据段：存储普通数据（全局区和静态区）</li><li>堆区：存储复杂数据，大但是效率低</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量与变量一样，都是用来保存数据的。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>常量：const / constant，是一种在程序运行当中，不可改变的量（数据）</p><p>常量一旦定义，通常数据不可改变（用户级别）</p><h4 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h4><p>在PHP中常量有两种定义方式（5.3之后才有两种）</p><ol><li>使用定义常量的函数：define(‘常量名’,常量值);</li><li> php5.3 之后才有的：const 常量名 = 值;</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628110809490.png"></p><h4 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h4><ol><li><p>常量不需要使用“$”符号，一旦使用系统就会认为是变量；</p></li><li><p>常量的名字组成由字母、数字和下划线组成，不能以数字开头；</p></li><li><p>常量的名字通常是以 <strong>大写字母</strong> 为主（与变量以示区别）；</p></li><li><p>常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用define定义；</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628111008222.png"></p></li></ol><p>注意细节：</p><ol><li>Define和const定义的常量是有区别：在于访问权限区别</li><li>定义常量通常不区分大小写，但是可以区分，可以参照define函数的第三个参数</li></ol><h4 id="使用形式"><a href="#使用形式" class="headerlink" title="使用形式"></a>使用形式</h4><p>常量的使用与变量一样：但是不可改变值（在定义的时候必须赋值）</p><p>有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：constant(‘常量名’)</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628111559972.png"></p><p>说明：常量和变量的使用</p><ol><li>凡是数据会可能变化的，那么肯定是用变量</li><li>数据不一定会变的，可以使用常量或者变量（变量居多）</li><li>数据不允许被修改的，一定用常量</li></ol><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>系统常量：系统帮助用户定义的常量，用户可以直接使用</p><p>常用的几个系统常量：</p><ul><li><p>PHP_VERSION： PHP版本号</p></li><li><p>PHP_INT_SIZE： 整形大小</p></li><li><p>PHP_INT_MAX： 整形能表示的最大值（PHP中整形是允许出现负数：带符号）</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628112021974.png"></p><p>在PHP中还有一些特殊的常量，他们有双下划线开始+长两名+双下划线结束，这种常量称之为系统 魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了</p><ul><li><code>__DIR__</code>：当前被执行的脚本所在电脑的绝对路径</li><li><code>__FILE__</code>：当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）</li><li><code>__LINE__</code>：当前所属的行数</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628112651317.png"></p><ul><li><code>__NAMESPACE__</code>：当前所属的命名空间</li><li><code>__CLASS__</code>：当前所属的类</li><li><code>__METHOD__</code>：当前所属的方法</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型：data type，在PHP中指的是存储的数据本身的类型，而不是变量的类型。PHP是一种弱类型语言，变量本身没有数据类型。</p><h4 id="PHP-的八种数据类型"><a href="#PHP-的八种数据类型" class="headerlink" title="PHP 的八种数据类型"></a>PHP 的八种数据类型</h4><p>在PHP中将数据分为三大类八小类：</p><ul><li><p>简单（基本）数据类型：4个小类</p><ul><li>整型：int/integer，系统分配4个字节存储，表示整数类型（有前提：存的下）</li><li>浮点型：float/double，系统分配8个字节存储，表示小数或者整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串（引号 ‘’ 或 “” ）</li><li>布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false</li></ul></li><li><p>复合数据类型：2个小类</p><ul><li>对象类型：object，存放对象（面向对象）</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li><p>特殊数据类型：2个小类</p><ul><li>资源类型：resource，存放资源数据（PHP外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是NULL（不能运算）</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前PHP取得的数据），转换成目标数据类型</p><p>在PHP中有两种类型转换方式：</p><ol><li><p>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</p></li><li><p>强制（手动）转换：人为根据需要的目标类型转换</p><p>强制转换规则：在变量之前增加一个括号()，然后在里面写上对应类型：int/integer….其中NULL类型用到unset()</p></li></ol><p>在转换过程中用到比较多的就是转布尔类型（判断）和转数值类型（算数运算）</p><p>其他类型转布尔类型：true或者false，在 PHP 中比较少类型换变成false</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628113541600.png"></p><p>其他类型转数值的说明：</p><ol><li><p>布尔true为1，false为0；</p></li><li><p>字符串转数值有自己的规则</p><ol><li><p>以字母开头的字符串，永远为0；</p></li><li><p>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628114334753.png"></p></li></ol></li></ol><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为true，失败为false）：是一组以is_开头后面跟类型名字的函数：</p><div class="hljs code-wrapper"><pre><code>`is_xxx(变量名)` </code></pre></div><p>Bool 类型不能用 echo 来查看，可以使用 var_dump 结构查看：</p><div class="hljs code-wrapper"><pre><code>`var_dump(变量1,变量2…)` </code></pre></div><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628124820018.png"></p><p>还有一组函数可以用来获取以及设定数据（变量）的类型</p><div class="hljs code-wrapper"><pre><code>gettype(变量名)：获取类型，得到的是该类型对应的字符串</code></pre></div><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628131733521.png"></p><div class="hljs code-wrapper"><pre><code>settype(变量名,类型)：设定数据类型：与强制转换不同</code></pre></div><ol><li>强制转换(类型)变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype会直接改变数据本身</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628132058386.png"></p><h4 id="整数类型（int）"><a href="#整数类型（int）" class="headerlink" title="整数类型（int）"></a>整数类型（int）</h4><p>整数类型：保存整数数值（范围限制），4个字节存储数据，最大就是32位：4,294,967,295。</p><p>但是在PHP中默认是有符号类型（区分正负数）</p><h5 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h5><p>十进制定义，二进制定义，八进制定义和十六进制定义</p><ul><li><p>$a = 120;        //10进制</p></li><li><p>$a=0b110;    //2进制</p></li><li><p>$a=0120;        //8进制</p></li><li><p>$a=0x120;    //16进制</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628134037488.png"></p><h5 id="PHP-进制转换"><a href="#PHP-进制转换" class="headerlink" title="PHP 进制转换"></a>PHP 进制转换</h5><ul><li><p>decbin()：十进制转二进制</p></li><li><p>decoct()：十进制转八进制</p></li><li><p>dechex()：十进制转十六进制</p></li><li><p>bindec()：二进制转十进制</p></li><li><p>bin2hex()：二进制转十六进制</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628140009412.png"></p><h4 id="浮点类型（float）"><a href="#浮点类型（float）" class="headerlink" title="浮点类型（float）"></a>浮点类型（float）</h4><p>浮点型：小数类型以及超过整型所能存储范围的整数（不保证精度），精度范围大概在15个有效数字左右</p><h5 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h5><p>$f = 1.23;</p><p>$f = 1.23e10;    //科学计数法，其中e表示底10</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628140744653.png" alt="image-20210628140744653"></p><p>简单说明浮点数为什么同样的字节数存储数据，但是却能表示更大的数据呢？</p><p>00000000 00000000 00000000 00000000 -&gt; 11111111 11111111 11111111 1111111 （整形最大值：所有位都是有效数据）</p><p>浮点数：加深7位算的结果是10的指数，后面三个字节存储表示具体数值</p><p>00000000 00000000 00000000 00000000 -&gt; 1<strong>1111111</strong> 11111111 11111111 1111111</p><p>注意：尽量不用用浮点数做精确判断：浮点数保存的数据不够精确，而且在计算机中凡是小数基本上存的都不准确</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141213736.png"></p><h4 id="字符串类型（string）"><a href="#字符串类型（string）" class="headerlink" title="字符串类型（string）"></a>字符串类型（string）</h4><h5 id="字符串定义语法"><a href="#字符串定义语法" class="headerlink" title="字符串定义语法"></a>字符串定义语法</h5><ol><li>单引号字符串：使用单引号包裹</li><li>双引号字符串：使用双引号包裹</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629200559846.png"></p><p>引号方式：比较适合定义那些比较短（不超过一行）或者没有结构(缩进等)要求的字符串</p><p>如果有结构要求，或者内容超过一行，可以使用以下两种结构定义</p><ol><li><p>nowdoc 字符串：没有单引号的单引号字符串</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-variable">$str</span> = &lt;&lt;&lt; <span class="hljs-string">&#x27;边界符&#x27;</span><br>    字符串内容<br>边界符;<br></code></pre></div></td></tr></table></figure></li><li><p>heredoc 字符串：没有双引号的双引号字符串</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-variable">$str</span> = &lt;&lt;&lt; 边界符<br>    字符串内容<br>边界符;<br><br></code></pre></div></td></tr></table></figure></li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629203034405.png"></p><p>heredoc和nowdoc比引号方式要区别多一点，(查看源码可知保留了结构)</p><h5 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h5><p>转义的含义：在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理：通常这种方式都是使用反斜杠+字母(单词)的特性</p><p>\r\n：回车换行</p><p>PHP在识别转义字符的时候也是使用同样的模式：反斜杠+字母</p><p>在PHP中系统常用的转义符号：</p><ul><li><p>\‘：在单引号字符串中显示单引号</p></li><li><p>\“：在双引号字符串中显示双引号</p></li><li><p>\r：代表回车（理论上是回到当前行的首位置）</p></li><li><p>\n：代表新一行</p></li><li><p>\t：类似tab键，输出4个空格</p></li><li><p>\$：在PHP中使用$符号作为变量符号，因此需要特定识别</p></li></ul><p>单引号和双引号的区别：</p><ol><li><p>其中单引号中能够识别 \‘，而双引号中就不能识别 \‘（下图浏览器查看的是页面源代码）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210630232631329.png"></p></li><li><p>双引号中因为能够识别 $ 符号，所以双引号中可以解析变量，而单引号不可以</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210630232709366.png"></p></li></ol><p>双引号中变量识别的规则：</p><ol><li><p>变量本身系统能够与后面的内容区分：应该保证变量的独立性，不要让系统难以区分</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210630232908494.png"></p></li><li><p>使用变量专业标识符（区分），给变量加上一组大括号 {}</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210630232927534.png"></p></li></ol><p>结构化定义字符串变量的规则：</p><ol><li><div class="hljs code-wrapper"><pre><code>结构化定义字符串对应的边界符有条件：</code></pre></div></li><li>上边界符后面不能跟任何内容(包括空格)；</li><li>下边界符必须顶格：最左边；</li><li>下边界符同样后面只能跟分号，不能跟任何内容；</li><li>结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身</li></ol><h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h5><ol><li><p>基本函数 strlen()：得到字符串的长度（字节为单位）</p></li><li><p>多字节字符串的长度问题：包含中文的长度。</p><p>让一个中文的长度为1而不是3</p></li><li><p>多字节字符串扩展模块：mbstring扩展（mb ：Multi Bytes）</p><p>首先需要加载PHP的mbstring扩展</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708143000403.png"></p><p>可以使用mb扩展带来很多函数</p><p>mbstring扩展针对的是一些关于字符统计：</p><div class="hljs code-wrapper"><pre><code>strlen只是针对标准交换码ASCIImbstring会针对不同的字符集 (php7默认字符集为utf-8)</code></pre></div><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708143343185.png"></p></li></ol><h5 id="字符集相关函数"><a href="#字符集相关函数" class="headerlink" title="字符集相关函数"></a>字符集相关函数</h5><ol><li><p>转换函数：implode(), explode(), str_split()</p><ul><li><p>implode(连接方式,数组)：将数组中的元素按照某个规则连接成一个字符串</p></li><li><p>explode(分割字符,目标字符串)：将字符串按照某个格式进行分割，变成数组</p><div class="hljs code-wrapper"><pre><code>中国|北京|顺义 == array(‘中国’,‘北京’,’顺义’);</code></pre></div></li><li><p>str_split(字符串,字符长度)：按照指定长度拆分字符串得到数组</p></li></ul></li><li><p>截取函数：trim(), ltrim(), rtrim()</p><ul><li>trim(字符串[,指定字符])：本身默认是用来去除字符串两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止</li><li>ltrim()：去除左边的</li><li>rtrim()：去除右边的</li></ul></li><li><p>截取函数：substr(), strstr()</p><ul><li>substr(字符串,起始位置从0开始[,长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后）</li><li>strstr(字符串,匹配字符)：从指定位置开始，截取到最后（可以用来取文件后缀名）</li></ul></li><li><p>大小转换函数：strtolower(), strtoupper(), ucfirst()</p><ul><li>strtolower：全部小写</li><li>strtoupper：全部大写</li><li>ucfirst：首字母大写</li></ul></li><li><p>查找函数：strpos(), strrpos()</p><ul><li>strpos(字符串，匹配字符)：判断字符在目标字符串中出现的位置（首次）</li><li>strrpos(字符串，匹配字符)：判断字符在目标字符串中最后出现的位置</li></ul></li><li><p>替换函数：str_replace()</p><ul><li>str_replace(匹配目标,替换的内容,字符串本身)：将目标字符串中部分字符串进行替换</li></ul></li><li><p>格式化函数：printf(), sprintf()</p><ul><li>sprintf/sprintf(输出字符串有占位符,顺序占位内容…)：格式化输出数据</li></ul></li><li><p>其他：str_repeat(), str_shuffle()</p><ul><li>str_repeat()：重复某个字符串N次</li><li>str_shuffle()：随机打乱字符串</li></ul></li></ol><h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>数组：array，数据的组合，指将一组数据（多个）存储到一个指定的容器中，用变量指向该容器，然后可以通过变量一次性得到该容器中的所有数据。</p><h5 id="数组定义语法"><a href="#数组定义语法" class="headerlink" title="数组定义语法"></a>数组定义语法</h5><ol><li><p>使用array关键字：最常用的</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">$变量 = <span class="hljs-keyword">array</span>(元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>,元素<span class="hljs-number">3</span>..);<br></code></pre></div></td></tr></table></figure></li><li><p>可以使用中括号来包裹数据：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">$变量 = [元素<span class="hljs-number">1</span>,元素<span class="hljs-number">2</span>…];<br></code></pre></div></td></tr></table></figure></li><li><p>隐形定义数组：给变量增加一个中括号，系统自动变成数组</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">$变量[] = 值<span class="hljs-number">1</span>;<span class="hljs-comment">//如果不提供下标也可以，系统自动生成（数字：从0开始）</span><br>$变量[下标] = 值; <span class="hljs-comment">//中括号里面的内容称之为下标key，该下标可以是字母</span><br></code></pre></div></td></tr></table></figure></li></ol><h5 id="PHP数组特点"><a href="#PHP数组特点" class="headerlink" title="PHP数组特点"></a>PHP数组特点</h5><ol><li><p>可以整数下标或者字符串下标 </p><ul><li><p>如果数组下标都为整数：索引数组</p></li><li><p>如果数组下标都为字符串：关联数组</p></li></ul></li><li><p>不同下标可以混合存在：混合数组</p></li><li><p>数组元素的顺序以放入顺序为准，跟下标无关</p></li><li><p>数字下标的自增长特性：从0开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1开始</p></li><li><p>特殊值下标的自动转换</p><div class="hljs code-wrapper"><pre><code>布尔值：true和false 空：NULL</code></pre></div></li><li><p>PHP中数组元素没有类型限制</p></li><li><p>PHP中数组元素没有长度限制</p></li></ol><p>补充：PHP中的数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>多维数组：数组里面的元素又是数组</p><h6 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h6><p>数组中所有的元素都是一维数组</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708162353057.png"></p><h6 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h6><p>在第二维的数组元素中可以继续是数组，在PHP中没有维度限制（PHP本质并没有二维数组）</p><p>但是：不建议使用超过三维以上的数组，会增加访问的复杂度，降低访问效率。</p><h6 id="异性数组（不规则数组）"><a href="#异性数组（不规则数组）" class="headerlink" title="异性数组（不规则数组）"></a>异性数组（不规则数组）</h6><p>异形数组：数组中的元素不规则，有普通基本变量也有数组。</p><p>在实际开发中，并不常用，尽量让数组元素规则化（便于进行访问）</p><h5 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h5><h6 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h6><p>数组遍历：普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要依次输出出来，就需要我们使用到一些简化的规则来实现自动获取下标以及输出数组元素。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-variable">$arr</span> = <span class="hljs-keyword">array</span>(<span class="hljs-number">0</span>=&gt;<span class="hljs-keyword">array</span>(‘name’ =&gt; ‘Tom’),<span class="hljs-number">1</span>=&gt;<span class="hljs-keyword">array</span>(‘name’ =&gt; ‘Jim’));<span class="hljs-comment">//二维数组</span><br><span class="hljs-comment">//访问一维元素：$arr[一维下标]</span><br><span class="hljs-variable">$arr</span>[<span class="hljs-number">0</span>];<span class="hljs-comment">//结果：array(‘name’ =&gt; ‘Tom’);</span><br><br><span class="hljs-comment">//访问二维元素：$arr[一维下标][二维下标]</span><br><span class="hljs-variable">$arr</span>[<span class="hljs-number">1</span>][‘name’];<span class="hljs-comment">//Jim</span><br></code></pre></div></td></tr></table></figure><h6 id="foreach遍历语法"><a href="#foreach遍历语法" class="headerlink" title="foreach遍历语法"></a>foreach遍历语法</h6><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">foreach</span>($数组变量 <span class="hljs-keyword">as</span> [$下标 =&gt;] $值)&#123;<span class="hljs-comment">//下标可有可无</span><br><span class="hljs-comment">//通过$下标访问元素的下标；通过$值访问元素的值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>通常：如果是关联数组（字母下标），就需要下标，如果是数字下标就直接访问值</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708162617986.png"></p><p>获取下标</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708162626190.png"></p><p>在进行数据存储定义的时候，通常二维数组不会两个维度的key下标都为数字，一般是一维为数字（无意义），二维为字符串（数据库表字段），所以在进行遍历的时候，通常是只需要针对一维进行遍历，取得二维数组元素，然后二维数组元素通过下标去访问。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708162638184.png"></p><h6 id="foreach遍历原理"><a href="#foreach遍历原理" class="headerlink" title="foreach遍历原理"></a>foreach遍历原理</h6><p>foreach遍历的原理：本质是数组的内部有一颗指针，默认是指向数组元素的第一个元素，foreach就是利用指针去获取数据，同时移动指针。</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">foreach</span>(<span class="hljs-variable">$arr</span> <span class="hljs-keyword">as</span> <span class="hljs-variable">$k</span> =&gt; <span class="hljs-variable">$v</span>)&#123;<br><span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>foreach会重置指针：让指针指向第一个元素；</li><li>进入foreach循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量$k中（如果存在），将值取出来放到对应的值变量$v中；（指针下移）</li><li>进入到循环内部（循环体），开始执行；</li><li>重复2和3，直到在2的时候遇到指针取不到内容（指针指向数组最后</li></ol><h6 id="for循环遍历数组"><a href="#for循环遍历数组" class="headerlink" title="for循环遍历数组"></a>for循环遍历数组</h6><p>for循环：基于已知边界条件（起始和结束）然后有条件的变化(规律,索引数组)</p><p>因此：for循环遍历数组有对应条件</p><ol><li>获取数组长度：count(数组)得到数组元素的长度</li><li>要求数组元素的下标是规律的数字</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210708162816017.png"></p><h6 id="while配合each和list遍历数组"><a href="#while配合each和list遍历数组" class="headerlink" title="while配合each和list遍历数组"></a>while配合each和list遍历数组</h6><p>while是在外部定义边界条件，如果要实现可以和for循环一样。</p><p>list与each配合特别好：</p><ol><li> each一定有两个元素就是0和1元素，得到的数组结构正好可以给list使用，然后通过list的(变量1,变量2)得到0和1元素的值，对应的就是原数组的下标和值。</li><li>list(变量1,变量2) = each(数组);        //是一种赋值运算，但是可以得到false结果（each取不到正确的结果），整个表达式为false，起到结束循环的效果</li></ol><h5 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h5><h6 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h6><ol><li>sort()：顺序排序（下标重排，下标和值的关系改变）</li><li>rsort()：逆序排序 （同上）</li><li>asort()：顺序排序（下标保留，下标和值的对应关系不变）</li><li>arsort()：逆序排序 (同上)</li><li>ksort()：顺序排序：按照键名（下标）</li><li>krsort()：逆序排序：按照键名（下标）</li><li>shuffle()：随机打乱数组元素，数组下标会重排</li></ol><h6 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h6><ol><li>reset()：重置指针，将数组指针指向首位</li><li>end()：重置指针，将数组指针指向最后一个元素</li><li>next()：指针下移，取得下一个元素的值</li><li>prev()：指针上移，取得上一个元素的值</li><li>current()：获取当前指针对应的元素值</li><li>key()：获取当前指针对应的下标值</li></ol><p>注意事项：next和prev会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过next和prev不能回到正确的指针位置。只能通过end或者reset进行指针重置</p><h6 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h6><ol><li>count()：统计数组中元素的数量</li><li>array_push()：往数组中加入一个元素（数组最后）</li><li>array_pop()：从数组中弹出一个元素并返回（数组最后）</li><li>array_shift()：从数组中弹出一个元素并返回（数组开头）</li><li>array_unshift()：从数组中加入一个元素（数组开头）</li><li>array_reverse()：返回单元顺序相反的数组</li><li>in_array()：判断一个元素在数组中是否存在</li><li>array_keys()：获取一个数组的所有下标，返回一个索引数组</li><li>array_values()：获取一个数组的所有值，返回一个索引数组</li></ol><h4 id="布尔类型（boolean）"><a href="#布尔类型（boolean）" class="headerlink" title="布尔类型（boolean）"></a>布尔类型（boolean）</h4><p>布尔类型：两个值true和false，通常是用于判断比较</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141333016.png" alt="image-20210628141333016"></p><p>在进行某些数据判断的时候，需要特别注意类型转换</p><div class="hljs code-wrapper"><pre><code>empty()：判断数据的值是否为“空”，不是NULL，如果为空返回true，不为空返回falseisset()：判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false</code></pre></div><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141717452.png"></p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符：operator，是一种将数据进行运算的特殊符号，在PHP中一共有十种运算符之多</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>符号是“=”，表示将右边的结果（可以是变量、数据、常量和其它运算出来的结果），保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算术运算：基本算术操作</p><ul><li><p>+：执行数据累加</p></li><li><p>-：数据相减</p></li><li><p>*：键盘上没有乘法符号，使用*代替，两个数相乘</p></li><li><p>/：正斜杠代替，表示两个数相除</p></li><li><p>%：取余(模)运算，两个数（整数）相除，保留余数</p></li></ul><p>注意：在进行除法运算或者取余运算的时候，对应的除数（第二个数）不能为0</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算：比较两个数据的大小，或者两个内容是否相同，返回的结果都是布尔类型：满足返回true，不满足返回false</p><ul><li><p>&gt;：左边大于右边，返回结果true</p></li><li><p>&gt;=：左边大于等于右边</p></li><li><p>&lt;：左边小于右边</p></li><li><p>&lt;=：左边小于或者等于右边</p></li><li><p>==：左边的与右边的相同（大小相同）</p></li><li><p>!=：左边的与右边的不同（大小不同）</p></li><li><p>===：全等于，左边与右边相同：大小以及数据的类型都要相同</p></li><li><p>!==：不全等于，只要大小或者类型不同就为true</p></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算：针对不同的结果进行匹配。满足条件返回true，不满足返回false</p><ul><li><p><code>&amp;&amp;</code> 和 <code>and</code> ：逻辑与，左边的条件与右边的条件同时成立（两边结果都为true）</p></li><li><p><code>||</code> 和 <code>or</code> ：逻辑或，左边的条件或者右边的条件只要有一个满足即可</p></li><li><p><code>!</code> ：逻辑非，对已有条件进行取反，本身为true，取反结果就是false</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628142659903.png"></p><p>逻辑与和逻辑或又称之为****短路运算*<em><strong>：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后面的表达式：</strong>在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位，提高运算效率</em>*</p><h4 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h4><p>是 PHP 中将多个字符串拼接的一种符号</p><ul><li><code>.</code> ：将两个字符串连接到一起</li><li><code>.=</code> ： 复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量</li></ul><p>A .= b  ⇔  A = A . b</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628143257603.png"></p><h4 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h4><p>在PHP中有一些错误可以提前预知，但是这些错误可能无法避免，但是又不希望报错给用户看，可以使用错误抑制符处理。</p><div class="hljs code-wrapper"><pre><code>`@` ：在可能出错的表达式前面使用@符号即可</code></pre></div><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628143553218.png"></p><p>错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用：系统本身最好没有任何错误。</p><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目运算：有三个表达式参与的运算（简单的的分支结构缩写）</p><p>语法格式：</p><p><code>表达式1 ? 表达式2 : 表达式3;</code> </p><p>运算：如果表达式1成立，那么执行表达式2，否则执行表达式3；</p><p>注意：如果表达式本身比较复杂，建议使用括号包起来。</p><p>三目运算可以进行复合三目运算：三目运算中的表达式2和3都是可以是另外一个三目运算。</p><p><code>表达式1 ? (表达式2 ? 表达式4 : 表达式5) : (表达式3 ? 表达式6 : 表达式7);</code> </p><h4 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h4><p>自操作：自己操作自己的运算符</p><ul><li><p><code>++</code> ：在原来的值上+1</p></li><li><p><code>--</code> ：在原来的值上-1</p></li></ul><p>在PHP中自操作符是可以放到变量前或者后：前置自操作和后置自操作</p><ul><li><p>后置自操作：先把自己所保存的值留下来，然后改变自己，自己给别人的值是原来的值；</p></li><li><p>前置自操作：先把自己改变，然后把改变后的值给别人。</p></li></ul><p>衍生符号：类似自操作</p><ul><li><p><code>+=</code> ：左边的结果与右边结果相加，然后赋值给左边</p></li><li><p><code>-=</code> ：左边的减去右边的结果，然后复制给左边</p></li><li><p><code>*=</code> ：乘法操作</p></li><li><p><code>/=</code> ：除法操作</p></li><li><p><code>%=</code> ：模操作</p></li></ul><p>注意：右边是一个整体     $a += $b;  ⇔  $a = $a + ($b);</p><p>如果进行除法或者取余运算，那么要考虑右边表达式的结果是否为0（为0出错）</p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><h5 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h5><p>计算机在实际存储数据的时候，采用的编码规则（二进制规则）</p><p>计算机码：原码、反码和补码。数值本身最左边一位是用来充当符号位：正0负1</p><ul><li><p>原码：数据本身从十进制转换成二进制得到的结果</p><p>正数：左边符号位为0（正数的原码、反码和补码就是原码本身）<br>负数：左边符号位为1</p></li><li><p>反码：针对负数，符号位不变，其他位取反</p></li><li><p>补码：针对负数，反码+1</p></li></ul><p>系统中存在两个0：+0和-0 (0的原码跟反码都有两个，因为这里0被分为+0和-0)</p><div class="hljs code-wrapper"><pre><code>+0： 00000000-0 ： 10000000    原码</code></pre></div><ul><li>取反 11111111</li><li>补码 00000000</li></ul><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>位运算：取出计算机中最小的单位（位bit）进行运算</p><ul><li>&amp;：按位与，两个位都为1，结果为1，否则为0</li></ul><ol><li><p>|：按位或，两个有一个为1，结果为1</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628151029489.png"></p><p>注意：</p><ol><li><p>系统进行任何位运算的时候都是使用的补码。</p><p>–计算机存储的是补码(为了实现化减为加–用加法处理减法)。用-5作为位运算时，-5在计算机内的二进制表示是二进制补码。</p></li><li><p>运算结束之后都必须转换成原码才是最终要显示的数据</p><p>–补码的计算结果依然是补码，但是显示时需要转为原码：符号位为0(正数)的补码=原码 不用转换；符号位为1(负数)的需要把补码转换为原码。</p></li></ol></li></ol><ul><li><p>~：按位非，一个位如果为1则变成0，否则反之</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628151449325.png"></p></li><li><p>^：按位异或，两个相同则为0，不同则为1</p></li><li><p>&lt;&lt;：按位左移，整个位（32位），向左移动一位，右边补0</p></li><li><p>&gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628152113926.png"></p></li></ul><p>按位左移：乘以2的操作</p><p>按位右移：除以2的操作（不完全正确）：整数除2会出现小数</p><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628152259662.png"></p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h4><ul><li>顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构）</li><li>分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码</li><li>循环结构：在某个条件控制范围内，指定的代码（块）可以重复执行</li></ul><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>最基本结构，所有代码默认都是从上往下依次执行</p><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>在PHP中，分支结构主要有两种：if分支 和 switch分支</p><h5 id="if-分支"><a href="#if-分支" class="headerlink" title="if 分支"></a>if 分支</h5><ol><li><p>最简if：只有一段代码，但是可以选择是否执行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(条件表达式)&#123;<br>    <span class="hljs-comment">//满足条件所要执行的内容 //顺序结构</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>基础if：有两面性，满足条件或者不满足条件都有对应的执行代码</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(条件表达式)&#123;<br>    <span class="hljs-comment">//满足条件后执行的代码段;</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//不满足条件执行的代码段;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>复杂if结构：在判断条件之后，通常就有两种结果：满足或者不满足，在不满足之后还可以再次进行条件判断</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">if</span>(条件表达式<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-comment">//满足条件表达式1的代码段;</span><br>&#125;<span class="hljs-keyword">elseif</span>(条件表达式<span class="hljs-number">2</span>)&#123;<span class="hljs-comment">//`else if 分开也可以</span><br>    <span class="hljs-comment">//不满足表达式1条件，但是满足表达式2的代码;</span><br>&#125;…&#123;<span class="hljs-comment">//可以使用多个elseif来进行再次条件筛选</span><br>&#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-comment">//全部不满足要执行的代码;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h5 id="switch-分支"><a href="#switch-分支" class="headerlink" title="switch 分支"></a>switch 分支</h5><p>switch分支：有一组情形存在，同过一条件，通常有多个值，但是每一个值都会有对应不同的代码要执行。</p><p>switch判断方式：是将条件放到分支结构内部判断。</p><p>switch基本语法：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">switch</span>(条件表达式)&#123;<br><span class="hljs-comment">//所有条件判断：逐个进行</span><br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">1</span>:<span class="hljs-comment">//当前条件表达式的结果与值1相等（==）</span><br>        要执行的代码段;<br>        <span class="hljs-keyword">break</span>;<span class="hljs-comment">//在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束）。</span><br>    <span class="hljs-keyword">case</span> 值<span class="hljs-number">2</span>:<br>        要执行的代码段;<br>        <span class="hljs-keyword">break</span>;<br>    <span class="hljs-comment">//可以使用类似else的语法：都不匹配</span><br><span class="hljs-keyword">default</span>:<br>        <span class="hljs-comment">//匹配失败的代码;</span><br>        <span class="hljs-keyword">break</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>if 和 switch 的选择</p><ol><li>if能做所有的分支结构事情</li><li>switch处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构</li></ol><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>代码段在一定的控制下，可以多次执行。</p><p>在PHP中循环结构有以下几种：</p><h5 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h5><p>通过条件、起始和终止判断执行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">for</span>(条件表达式<span class="hljs-number">1</span>;条件表达式<span class="hljs-number">2</span>;条件表达式<span class="hljs-number">3</span>)&#123;<br>    <span class="hljs-comment">//条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可</span><br>    <span class="hljs-comment">//条件表达式2：边界判定，限定循环执行的次数</span><br>    <span class="hljs-comment">//条件表达式3：用来执行条件变化（自操作）</span><br>    <span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>for循环执行原理：</p><ol><li>执行条件表达式1：定义初始化条件（执行一次）</li><li>执行条件表达式2：判断条件（N次）<ol><li>满足条件：执行循环体</li><li>不满足条件：循环结束</li></ol></li><li>执行循环体：（N次）</li><li>执行条件表达式3：循环变量变化（N次）</li><li>执行条件表达式2：判断条件（N次）</li><li>重复执行3-4-2步骤：直到第2步不满足条件结束循环</li></ol><p>for循环特殊使用：for循环中对应的括号（条件）可以一个都没有（死循环）但一定要避免出现；</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">for</span>(;;)&#123;<br>    <span class="hljs-comment">//循环体</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h5><p>通过判断条件终止</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">条件初始化;<br><span class="hljs-keyword">while</span>(条件表达式)&#123;<br>    <span class="hljs-comment">//条件表达式就是判断边界条件</span><br>    循环体;<span class="hljs-comment">//循环条件的变化</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>For与while的选择</p><ol><li>如果是基于固定已知条件（数值而且是有规律的变化），使用for循环</li><li>while可以做灵活的条件判定（while使用的比较多）</li></ol><h5 id="do-while循环"><a href="#do-while循环" class="headerlink" title="do-while循环"></a>do-while循环</h5><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">do</span>&#123;<br>    <span class="hljs-comment">//循环体</span><br>&#125;<span class="hljs-keyword">while</span>(条件表达式);<br></code></pre></div></td></tr></table></figure><h5 id="foreach循环"><a href="#foreach循环" class="headerlink" title="foreach循环"></a>foreach循环</h5><p>专门针对数组</p><h5 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h5><p>循环控制：在循环内部对循环本身进行控制</p><ul><li><p>中断控制：重新开始循环，循环体中还有其他内容，也不执行，重新执行</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">continue</span> 层级;<span class="hljs-comment">//层级默认是1（循环可以多层嵌套）</span><br></code></pre></div></td></tr></table></figure></li><li><p>终止控制：循环直接结束</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">break</span> 层级;<span class="hljs-comment">//层级默认是1</span><br></code></pre></div></td></tr></table></figure></li></ul><h4 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h4><p>流程控制替代语法：分支和循环结构的替代语法</p><p>PHP本身是嵌入到HTML中的脚本语言，需要在HTML中书写一些关于判断或者循环的结构语法，必须符合PHP标签规范，需要HTML与PHP进行混搭，如果使用原始的PHP代码那么会非常不美观。</p><p>例子： 九九乘法表</p><figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php+HTML">&lt;table border=&quot;1&quot;&gt;<br>    &lt;?php for ($i = 1; $i &lt; 10; $i++) &#123; ?&gt;<br>    &lt;tr&gt;<br>        &lt;?php for ($j = 1; $j &lt;= $i; $j++) &#123; ?&gt;<br>        &lt;td&gt;<br>            &lt;?php echo $i . &#x27; * &#x27; . $j . &#x27; = &#x27; . $i * $j ?&gt;<br>        &lt;/td&gt;<br>        &lt;?php &#125; ?&gt;<br>    &lt;/tr&gt;<br>    &lt;?php &#125; ?&gt;<br>&lt;/table&gt;<br></code></pre></div></td></tr></table></figure><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628160755681.png"></p><p>在PHP书写到HTML中的这些大括号{}非常不美观，所以PHP提供了一种替代机制，让其可以不用书写大括号：</p><ul><li>For(;;){  –&gt;  for(;;):</li><li>}            –&gt;  endfor;</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628161032944.png"></p><p>PHP中具体有哪些替代语法呢？</p><p>PHP应该在HTML中只做数据输出，输出通常伴有条件判断和循环操作，因此PHP提供了对应分支结构和循环结构的替代语法：全部都是对应的一个模式：</p><ul><li>左大括号 <code>&#123;</code> 使用 <code>:</code> 替代：</li><li>右大括号 <code>&#125;</code> 使用 <code>end+对应的起始标记</code> 替代</li></ul><table><thead><tr><th>标记</th><th>起始</th><th>结束</th></tr></thead><tbody><tr><td>if</td><td>if() :</td><td>endif;</td></tr><tr><td>switch</td><td>switch() :</td><td>endswitch;</td></tr><tr><td>for</td><td>for(;;) :</td><td>endfor;</td></tr><tr><td>while</td><td>while() :</td><td>endwhile;</td></tr><tr><td>foreach</td><td></td><td></td></tr></tbody></table><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>在一个PHP脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>文件包含的意义：</p><ol><li><p>要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）</p><p>向上包含：在当前脚本要用某个代码之前包含别的文件</p></li><li><p>要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）</p><p>向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）</p></li></ol><p>最大的作用：<strong>分工协作</strong>，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情。</p><h4 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h4><p>在PHP中文件的包含有四种形式（两种大形式）：</p><ul><li><p>Include：包含文件</p></li><li><p>Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）</p></li><li><p>Require：与include相同</p></li><li><p>Require_once：与include_once相同</p></li></ul><p>包含基本语法</p><ul><li><p>Include ‘文件名字’;</p></li><li><p>Include(‘文件名字’);    //文件名字：路径问题</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628163927572.png" alt="image-20210628163927572"></p><p>以上方式：是先包含文件，后使用文件中的内容（向上包含）</p><p>向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628164455678.png"></p><h4 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h4><p>PHP代码的执行流程：</p><ol><li>读取代码文件（PHP 程序）</li><li>编译：将PHP代码转换成字节码（生成 opcode）</li><li>zendengine 引擎来解析 opcode，按照字节码去进行逻辑运算</li><li>转换成对应的 HTML 代码</li></ol><p>文件加载原理：</p><ol><li><p>在文件加载（include或者require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</p></li><li><p>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的include位置</p></li><li><p>在PHP中被包含的文件是单独进行编译的</p><p>PHP文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含include这条语句的时候才会报错。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628165803659.png"></p></li></ol><h4 id="include-和-requist-的区别"><a href="#include-和-requist-的区别" class="headerlink" title="include 和 requist 的区别"></a>include 和 requist 的区别</h4><p>Include和include_once的区别：</p><ul><li><p>Include系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次；</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170242685.png"></p></li><li><p>Include_once：系统碰到多次，也只会执行一次。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170333116.png"></p></li></ul><p>Require和include的区别：本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样</p><ul><li><p>include的错误级别比较轻：不会阻止代码执行</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170614796.png"></p></li><li><p>require要求较高：如果包含出错代码不再执行（require后面的代码）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170729389.png"></p></li></ul><h4 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h4><p>文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。</p><p>文件的加载路径包含两大类：</p><ol><li><p>绝对路径</p><ol><li><p>从磁盘的根目录开始（本地绝对路径）</p><ul><li>Windows：盘符C:/路径/PHP文件</li><li>Linux：/路径/PHP文件</li></ul></li><li><p>从网站根目录开始（网络绝对路径）</p><ul><li><p>/ ：相对于网站主机名字对应的路径</p><p>Localhost/index.php -&gt; E:/server/apache/htdocs/index.php</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628172146092.png"></p></li></ol></li><li><p>相对路径：从当前文件所在目录开始的路径</p><ul><li><code>.</code> 或 <code>./</code> ：表示当前文件夹</li><li><code>../</code> ：上级目录（当前文件夹的上一层文件夹）</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628172039596.png"></p></li></ol><p>绝对路径和相对路径的加载区别：</p><ol><li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li><li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li></ol><h4 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h4><p>文件嵌套包含：一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件。</p><p>嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../），原因：windows下面，每一个文件夹下都有.和..的文件夹。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>function，是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）。</p><h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>函数有几个对应的关键点：function关键字、函数名、参数（形参和实参）、函数体和返回值</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">[参数]</span>)</span>&#123;<br>    <span class="hljs-comment">//函数体</span><br>    <span class="hljs-comment">//返回值：return 结果;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）</p><p>函数的使用：<code>函数名();</code>    //如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数：函数是一种结构不会自动运行，必须通过调用才会执行</p><p>函数的调用特点：只要系统在内存中能够找到对应的函数，就可以执行（函数的调用可以在函数定义之前）</p><p>函数执行的内存分析：</p><ol><li>读取代码进入到代码段（编译：将代码变成字节码存储到内存）。此时function已经在内存里</li><li>根据代码逐行执行</li></ol><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>命名规范：由字母、数字和下划线组成，但是不能以数字开头</p><ol><li>驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写：showParentInfo()</li><li>下划线法：单词之间通过下划线连接，单词都是小写：show_parent_info()</li></ol><p>函数名字：在一个脚本周期中，不允许出现同名函数（通常在一个系统开发中都不会使用同名函数）</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>函数的参数分为两种：形参和实参</p><p><strong>形参</strong>：形式参数，不具有实际意义的参数，是在函数定义时使用的参数</p><p><strong>实参</strong>：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数</p><p>形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：需要实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628173503789.png"></p><p>注意：</p><ol><li><p>在PHP中允许实参多余形参（个数）：函数内部不用而已</p></li><li><p>在PHP中理论上形参个数没有限制（实际开发不会太多）</p></li><li><p>实参不能少于形参个数</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628173519627.png"></p></li></ol><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>default value，指的是形参的默认值</p><p>在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。</p><p>通常默认值是用在一些，一定会有某个数据参与，但是可能通常是某个我们知道的值。</p><p>注意事项：</p><ol><li>默认值的定义是放在最右边的，不能左边形参有默认值，但是右边没有</li><li>函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的；如果多个函数使用同样的形参名字也不冲突</li></ol><h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><p>引用传值注意事项：在传入实参的时候，必须传入变量</p><h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><p>函数内部（大括号{}里面）的所有代码都称之为函数体</p><p>基本上所有的代码都可以实现</p><ol><li>定义变量</li><li>定义常量</li><li>使用流程控制（分支、循环）</li><li>可以调用函数</li></ol><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>return，指的是将函数实现的结果，通过 return 关键字，返回给函数外部（函数调用处）：在 PHP 中所有的函数都有返回值。（如果没有明确 return 使用，那么系统默认返回 NULL）</p><p>返回值作用：将计算结果返回给调用处</p><p>注意：函数的返回值可以是任意数据类型</p><p>return 关键字：</p><ol><li><p>return在函数内部存在的价值：返回当前函数的结果、结束当前函数运行</p></li><li><p>return还可以在文件中直接使用（不在函数里面）：代表文件将结果return后面跟的内容，转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表中终止文件后面的代码：return之后的内容不会执行。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628174307294.png"></p></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量（常量）能够被访问的区域</p><ol><li>变量可以在普通代码中定义</li><li>变量也可以在函数内部定义</li></ol><p>在PHP中作用域严格来说分为两种，但是PHP内部还定义一些在严格意义之外的一种，所以总共算三种：</p><ol><li><p>全局变量：就是用户普通定义的变量（函数外部定义）</p><p>所属全局空间：在PHP中只允许在全局空间使用：<strong>理论上函数内部不可访问</strong>（与 js 不同）</p><p>脚本周期：直到脚本运行结束（最后一行代码执行完）</p></li><li><p>局部变量：就是在函数内部定义的变量</p><p>所属当前函数空间：在PHP中只允许在当前函数自己内部使用</p><p>函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行）</p></li><li><p>超全局变量：系统定义的变量（预定义变量：$_SERVER、$_POST等）</p><p>所属超全局空间：没有访问限制（函数内外都可以访问）</p></li></ol><p>超全局变量会将全局变量自动纳入到 $GLOBALS 里面，而 $GLOBALS 没有作用域限制，所以能够帮助局部去访问全局变量：但是必须使用数组方式</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628174933758.png"></p><p>除了$GLOBALS之外，通过参数传值（如果要同步变化还可以使用引用传值）</p><p>在PHP中，其实还有一种方式，能够实现全局访问局部，同时局部也可以访问全局：<strong>global关键字</strong> </p><p>global关键字：是一种在函数里面定义变量的一种方式</p><ol><li>如果使用global定义的变量名在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（等同于一个变量）；</li><li>如果使用global定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量</li></ol><p>本质的形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-keyword">global</span> 变量名; <span class="hljs-comment">// 不能赋值</span><br>变量名 = 值;<span class="hljs-comment">//修改</span><br></code></pre></div></td></tr></table></figure><p>虽然以上方式可以实现局部与全局的互访，但是通常不会这么用。一般如果会存在特殊使用，也会使用参数的形式来访问（还可以使用常量：define定义的）。</p><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>static，是在函数内部定义的变量，使用static关键字修饰，用来实现跨函数共享数据的变量：函数运行结束所有局部变量都会清空，如果重新运行一下函数，所有的局部变量又会重新初始化。</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-comment">//定义变量</span><br>    <span class="hljs-built_in">static</span> $变量名 = 值;<span class="hljs-comment">//通常会在定义的时候就直接赋值</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>静态变量的作用是为了跨函数共享数据（同一个函数被多次调用）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628180343510.png"></p><p>函数在调用的时候，会自动跳过static关键字这一行：(即不再执行重新赋值为1)</p><p>静态变量的使用：</p><ol><li>为了统计：当前函数被调用的次数</li><li>为了统筹函数多次调用得到的不同结果（递归思想）</li></ol><h4 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h4><p>当前有一个变量所保存到值，刚好是一个函数的名字，那么就可以使用<code>变量()</code> 来充当函数名使用</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">$变量 = ‘display’;<br><span class="hljs-function"><span class="hljs-keyword">Function</span> <span class="hljs-title">display</span>(<span class="hljs-params"></span>)</span>&#123;<br>&#125;<br><span class="hljs-comment">//可变函数</span><br>$变量(); <span class="hljs-comment">// 等价于 display();</span><br></code></pre></div></td></tr></table></figure><p>可变函数在系统使用的过程中还是比较多的，尤其是使用很多系统函数的时候：需要用户在外部定义一个自定义函数，但是是需要传入到系统函数内部使用。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628181551870.png"></p><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>匿名函数：没有名字的函数</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">变量名 = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    函数体<br>&#125;;<br></code></pre></div></td></tr></table></figure><p>变量保存匿名函数，本质得到的是一个对象（Closure）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628224942148.png"></p><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>closure，一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）</p><p>简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用（就是函数的内部函数：匿名函数）</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628225513934.png"></p><p>证明：函数的局部变量在函数使用完之后没有被释放？</p><ol><li>使用内部匿名函数；</li><li>匿名函数使用局部变量：use；</li><li>匿名函数被返回给外部使用；</li></ol><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628225901656.png"></p><h4 id="伪类型"><a href="#伪类型" class="headerlink" title="伪类型"></a>伪类型</h4><p>假类型，实际上在PHP中不存在的类型。但是通过伪类型可以帮助程序员去更好的查看操作手册从而更方便学习。</p><p>伪类型主要有两种：在三大类八小类之外</p><ol><li>Mixed：混合的，可以是多种PHP中的数据类型</li><li>Number：数值的，可以是任意数值类型（整形和浮点型）</li></ol><h4 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h4><h5 id="有关输出的函数"><a href="#有关输出的函数" class="headerlink" title="有关输出的函数"></a>有关输出的函数</h5><ul><li><p>print()：类似于 echo 输出提供的内容，本质是一种结构（不是函数），返回1，可以不需要使用括号(因为是结构不是函数)</p></li><li><p>print_r()：类似于var_dump，但是比var_dump简单，不会输出数据的类型，只会输出值（数组打印使用比较多）</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628231543632.png"></p><h5 id="有关时间的函数"><a href="#有关时间的函数" class="headerlink" title="有关时间的函数"></a>有关时间的函数</h5><ul><li>date()：按照指定格式对对应的时间戳（从1970年格林威治时间开始计算的秒数）转换成对应的格式，如果没有指定特定的时间戳，那么就是默认解释当前时间戳</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628231813625.png"></p><ul><li><p>time()：获取当前时间对应的时间戳</p></li><li><p>microtime()：获取微秒级别的时间</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628234013522.png"></p><ul><li>strtotime()：按照规定格式的字符串转换成时间戳 (中文不行)</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628234426704.png"></p><h5 id="关于数学的函数"><a href="#关于数学的函数" class="headerlink" title="关于数学的函数"></a>关于数学的函数</h5><ul><li><p>max()：指定参数中最大的值</p></li><li><p>min()：比较两个数中较小的值</p></li><li><p>rand()：得到一个随机数，指定区间的随机整数</p></li><li><p>mt_rand()：与rand一样，只是底层结构不一样，效率比rand高（建议使用）</p></li><li><p>round()：四舍五入</p></li><li><p>ceil()：向上取整</p></li><li><p>floor()：向下取整</p></li><li><p>pow()：求指定数字的指定指数次结果：pow(2,8) == 2^8 == 256</p></li><li><p>abs()：绝对值</p></li><li><p>sqrt()：求平方根</p></li></ul><h5 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h5><ul><li><p>function_exists()：判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）</p></li><li><p>func_get_arg()：在自定义函数中去获取指定数值对应的参数 – 实参位置</p></li><li><p>func_get_args()：在自定义函数中获取所有的参数（数组）– 所有实参</p></li><li><p>func_num_args()：获取当前自定义函数的参数数量 – 实参数量</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629000146909.png"></p><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>指的是系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员。</p><h5 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h5><ol><li><p>语法错误：语法错误会导致代码在编译过程中不通过，所以代码不会执行（<strong>Parse error</strong>）</p></li><li><p>运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（<strong>runtime error</strong>）</p></li><li><p>逻辑错误：程序员在写代码时不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-variable">$a</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">if</span> (<span class="hljs-variable">$a</span> = <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">// 最常见问题：把 == 写成 =</span><br>    <span class="hljs-comment">// 执行代码</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li></ol><h5 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h5><p>所有看到的错误代号在PHP中都被定义成了系统常量（可以直接使用）</p><ol><li><p>系统错误：</p><ul><li>E_PARSE ：<strong>Parse error</strong>，编译错误，代码不会执行</li><li>E_ERROR ：<strong>Fatal error</strong>，致命错误，会导致代码不能正确继续执行（出错的位置断掉）</li><li>E_WARNING ：<strong>Warning</strong>，警告错误，不会影响代码执行，但是可能得到意想不到的结果</li><li>E_NOTICE ：<strong>Notice</strong>，通知错误，不会影响代码执行</li></ul></li><li><p>用户错误：</p><p>E_USER_ERROR , E_USER_WARNING , E_USER_NOTICE</p><p>用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到）</p></li><li><p>其他：</p><p>E_ALL，代表着所有的错误（通常在进行错误控制的时候使用比较多），建议在开发过程中（开发环境）使用</p></li></ol><p>所有以E开头的错误常量（代号）其实都是由一个字节存储，<strong>每一种错误占据一个对应的位</strong>(比如0000 0001 表示E_ERROR，0000 0010表示E_WARNING)，如果想进行一些错误的控制，可以使用位运算进行操作</p><ul><li>排除通知级别 notice ：<code>E_ALL &amp; ~E_NOTICE</code> </li><li>只要警告和通知：<code>E_WARNING | E_NOTICE</code> </li></ul><h5 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h5><p>程序运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户：主要针对代码的语法错误和运行时错误。</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629185803983.png"></p><p>人为触发：知道某些逻辑可能会出错，从而使用对应的判断代码来触发响应的错误提示</p><p><code>Trigger_error(错误提示)</code>：产生一个用户级别的 error/warning/notice 信息</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629190645937.png"></p><p>可以通过第二个参数进行严格性控制</p><ul><li>E_USER_ERROR</li><li>E_USER_WARNING</li><li>E_USER_NOTICE</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629190943882.png"></p><h5 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h5><p>错误显示设置：哪些错误该显示，以及该如何显示</p><p>在PHP中，其实有两种方式来设置当前脚本的错误处理：</p><ol><li><p>PHP 的配置文件：全局配置：php.ini 文件</p><ul><li>display_errors：是否显示错误</li><li>error_reporting：显示什么级别的错误</li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629192249764.png"></p></li><li><p>可以在运行的PHP脚本中去设置：在脚本中定义的配置项级别比配置文件高（通常在开发当中都会在代码中去进行控制和配置）</p><p>error_reporting()：设置对应的错误显示级别,没有参数表示获取当前系统错误处理对应的级别</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">error_reporting(E_ERROR | E_WARNING | E_PARSE);<br></code></pre></div></td></tr></table></figure><p>ini_set(‘配置文件中的配置项’,配置值)</p><p>ini_set(‘error_reporting’,E_ALL);</p><p>ini_set(‘display_errors’,1);</p></li></ol><h5 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h5><p>在实际生产环境中，不会直接让错误赤裸裸的展示给用户：</p><ol><li>不友好</li><li>不安全：错误会暴露网站很多信息（路径、文件名）</li></ol><p>所以在生产环境中，一般不显示错误（错误也比较少），但是不可能避免会出现错误（测试的时候不会发现所有的问题），这个时候不希望看到，但是又希望捕捉到可以让后台程序员去修改：需要保存到日志文件中，需要在 PHP 配置文件中或者代码中（ini_set）设置对应 error_log 配置项:</p><ol><li><p>开启日志功能</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193034111.png"></p></li><li><p>指定路径 (指定文件不会自动生成，必须手动创建)</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629192910558.png"></p></li></ol><h5 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h5><p>最简单的错误处理：<code>trigger_errors()</code> 函数，但是该函数不会阻止系统报错</p><p>PHP系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加操系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。</p><ol><li><p>如何将用户自定义的函数放到系统中？</p><p><code>set_error_handler()</code> </p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193323858.png"></p></li><li><p>自定义错误处理函数，系统有要求</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193429192.png"></p></li></ol><p>代码实现：</p><ol><li><p>自定义错误处理函数：注意参数</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629194719236.png"></p></li><li><p>注册自定义函数：修改错误处理机制</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629195100688.png"></p><p>当前属于简单自定义模式，如果要复杂，可以在某些影响代码功能的错误发生后，让用户跳转到某个指定界面。</p></li></ol><p>笔记CSDN博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118691660?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_58163927/article/details/118691660?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    <categories>
      
      <category>后端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>php</tag>
      
      <tag>Apache</tag>
      
      <tag>mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>npm笔记</title>
    <link href="/2021/07/29/npm%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/29/npm%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、NPM-简介"><a href="#一、NPM-简介" class="headerlink" title="一、NPM 简介"></a>一、NPM 简介</h2><h3 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h3><p>npm（node package manager）：是一个命令行工具</p><h3 id="1-2-能干嘛"><a href="#1-2-能干嘛" class="headerlink" title="1.2 能干嘛"></a>1.2 能干嘛</h3><p>下载 node 所需第三方模块，npm 是NodeJS项目模块管理工具</p><h3 id="1-3-去哪儿下"><a href="#1-3-去哪儿下" class="headerlink" title="1.3 去哪儿下"></a>1.3 去哪儿下</h3><p>安装 Node.JS 自带 npm 所以不用重新安装，直接使用。</p><p>检查版本，是否安装：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm -v<br></code></pre></div></td></tr></table></figure><h2 id="二、NPM-语法"><a href="#二、NPM-语法" class="headerlink" title="二、NPM 语法"></a>二、NPM 语法</h2><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>查看：npm list     list 可以简写为 ls</li><li>安装：npm install 模块 或 模块@版本号 [安装可选参数]     install 可以简写为 i</li><li>卸载：npm uninstall 模块</li></ul><h4 id="安装参数"><a href="#安装参数" class="headerlink" title="安装参数"></a>安装参数</h4><ul><li>–save                记录生产环境所需模块（默认） 简写为 -S</li><li>–save-dev        记录开发环境所需模块 简写为 -D</li><li>-g                       该模块可在命令行运行（global）</li></ul><p>多学一招：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 都安装</span><br>npm install<br><span class="hljs-comment">// 只安装生产环境</span><br>npm install --production<br><span class="hljs-comment">// 看全局目录所在位置</span><br>npm config <span class="hljs-keyword">list</span><br></code></pre></div></td></tr></table></figure><h2 id="三、NPM-使用"><a href="#三、NPM-使用" class="headerlink" title="三、NPM 使用"></a>三、NPM 使用</h2><h3 id="3-1-初体验"><a href="#3-1-初体验" class="headerlink" title="3.1 初体验"></a>3.1 初体验</h3><p>初始化 npm</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm init -y<br></code></pre></div></td></tr></table></figure><p>安装 MIME 模块</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install mime<br></code></pre></div></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入第三方模块 mime （判断文件 MIME 类型）</span><br><span class="hljs-keyword">var</span> mime = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mime&#x27;</span>)<br><span class="hljs-comment">// 2. 使用</span><br><span class="hljs-keyword">var</span> img = <span class="hljs-string">&#x27;xxx.png&#x27;</span><br><span class="hljs-comment">// 获取MIME类型</span><br><span class="hljs-built_in">console</span>.log(mime.getType(img));                    <span class="hljs-comment">// ⇨ &#x27;image/png&#x27;</span><br><span class="hljs-comment">// 获取文件扩展名</span><br><span class="hljs-built_in">console</span>.log(mime.getExtension(mime.getType(img))); <span class="hljs-comment">// ⇨ &#x27;null&#x27;</span><br></code></pre></div></td></tr></table></figure><h4 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h4><p>查看全局目录，命令行输入：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm config <span class="hljs-keyword">list</span><br></code></pre></div></td></tr></table></figure><p>找到全局路径：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">prefix = <span class="hljs-string">&quot;C:\\Users\\AgoniLay\\AppData\\Roaming\\npm&quot;</span><br></code></pre></div></td></tr></table></figure><p>安装全局：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install mime -g<br></code></pre></div></td></tr></table></figure><p>安装在生产环境中：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install mime --save<br></code></pre></div></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;mime&quot;</span>: <span class="hljs-string">&quot;^2.5.2&quot;</span><br>    &#125;,<br>&#125;<br></code></pre></div></td></tr></table></figure><p>安装在开发环境中：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install jquery --save-dev<br></code></pre></div></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;jquery&quot;</span>: <span class="hljs-string">&quot;^3.6.0&quot;</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>仅安装生产环境中的依赖：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install --production<br></code></pre></div></td></tr></table></figure><h2 id="四、NPM-模块版本控制（了解）"><a href="#四、NPM-模块版本控制（了解）" class="headerlink" title="四、NPM 模块版本控制（了解）"></a>四、NPM 模块版本控制（了解）</h2><h3 id="科普软件版本含义："><a href="#科普软件版本含义：" class="headerlink" title="科普软件版本含义："></a>科普软件版本含义：</h3><ul><li>aplha版    - 内测版（功能不全，bug多）</li><li>beta版      - 公测版（功能不全，发骚友准备，依旧存在bug）</li><li>rc版           - 预览版（功能不再增减）</li><li>stable版    - 用户可用</li></ul><p>主版本号.次版本号.修改版本号</p><ul><li>^   ：用户使用该版本后，最多升级到【修改版】最新</li><li>～ ：用户使用该版本后，最多升级到【次版本】最新</li><li> *  ：用户使用该版本后，最多升级到最新版本</li></ul><h2 id="五、NPM-源管理"><a href="#五、NPM-源管理" class="headerlink" title="五、NPM 源管理"></a>五、NPM 源管理</h2><p>通过 npm 命令下载会到国外服务器获取</p><p>缺点：下载速度慢</p><p>解决：切换到国内服务器</p><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 安装</span><br>npm install nrm -g <br><span class="hljs-comment">// 查看  ls 为 list 缩写</span><br>nrm ls<br><span class="hljs-comment">// 切换服务器名</span><br>nrm <span class="hljs-keyword">use</span> 服务器名<br>// 测速<br><span class="hljs-title">nrm</span> <span class="hljs-title">test</span><br></code></pre></div></td></tr></table></figure><h2 id="六、NPM-自定义脚本命令（重点，难点）"><a href="#六、NPM-自定义脚本命令（重点，难点）" class="headerlink" title="六、NPM 自定义脚本命令（重点，难点）"></a>六、NPM 自定义脚本命令（重点，难点）</h2><p>通过修改 package.json 文件的 scripts 自定义脚本命令</p><p>必须严格遵循格式</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json"><span class="hljs-string">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,<br>    <span class="hljs-attr">&quot;a&quot;</span>: <span class="hljs-string">&quot;echo 666&quot;</span>,<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;node ./mime_text.js&quot;</span><br>&#125;,<br></code></pre></div></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm run a<br>    <span class="hljs-comment">// 666</span><br>npm start<br>    <span class="hljs-comment">// 运行</span><br></code></pre></div></td></tr></table></figure><h2 id="七、NPM-包自定义发布（能跟着笔记敲）"><a href="#七、NPM-包自定义发布（能跟着笔记敲）" class="headerlink" title="七、NPM 包自定义发布（能跟着笔记敲）"></a>七、NPM 包自定义发布（能跟着笔记敲）</h2><ol><li><p>自定义模块，创建文件夹，打开终端 cd 到该文件夹下 初始化</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm init -y<br></code></pre></div></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> fn = &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;phpopenfather&#x27;</span>,<br>    <span class="hljs-attr">school</span>: <span class="hljs-string">&#x27;php@itcast&#x27;</span>,<br>    <span class="hljs-attr">say</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;悟空&#x27;</span>);<br>        <span class="hljs-keyword">return</span> un;<br>    &#125;<br>&#125;<br><br><span class="hljs-built_in">module</span>.exports = fn<br></code></pre></div></td></tr></table></figure></li><li><p>设置package</p><ul><li>name - 模块名</li><li>description - 描述</li><li>keywords - 关键词</li></ul><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;itcast-php-agonilay&quot;</span>,<br>    <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;description&quot;</span>: <span class="hljs-string">&quot;this is demo2&quot;</span>,<br>    <span class="hljs-attr">&quot;main&quot;</span>: <span class="hljs-string">&quot;index.js&quot;</span>,<br>    <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br>    &#125;,<br>    <span class="hljs-attr">&quot;keywords&quot;</span>: [<span class="hljs-string">&quot;itcast&quot;</span>, <span class="hljs-string">&quot;phpdemo&quot;</span>],<br>    <span class="hljs-attr">&quot;author&quot;</span>: <span class="hljs-string">&quot;AgoniLay&quot;</span>,<br>    <span class="hljs-attr">&quot;license&quot;</span>: <span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>打开 <a href="http://npmjs.com/">http://npmjs.com</a> 注册/登录 账号</p><p>本地登录提交（切记提交自己的包必须切换到国外服务器，下载再切换过来）</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 切换到国外服务器</span><br>nrm <span class="hljs-keyword">use</span> <span class="hljs-title">npm</span><br>// 登录<br><span class="hljs-title">npm</span> <span class="hljs-title">login</span><br>&gt;<span class="hljs-title">Username</span>: <span class="hljs-title">agonilay</span><br>&gt;<span class="hljs-title">Password</span>:<br>&gt;<span class="hljs-title">Email</span>: (<span class="hljs-title">this</span> <span class="hljs-title">IS</span> <span class="hljs-title">public</span>) 1394310259@<span class="hljs-title">qq</span>.<span class="hljs-title">com</span><br>&gt;<span class="hljs-title">Logged</span> <span class="hljs-title">in</span> <span class="hljs-title">as</span> <span class="hljs-title">agonilay</span> <span class="hljs-title">on</span> <span class="hljs-title">https</span>://<span class="hljs-title">registry</span>.<span class="hljs-title">npmjs</span>.<span class="hljs-title">org</span>/.<br>// 提交<br><span class="hljs-title">npm</span> <span class="hljs-title">publish</span><br>    // 版本号不能是 1.0.0<br></code></pre></div></td></tr></table></figure></li><li><p>使用</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm i itcast-php-agonilay<br></code></pre></div></td></tr></table></figure><p>test.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> test = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;itcast-php-agonilay&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(test);<br><span class="hljs-built_in">console</span>.log(test.name);<br>test.say();<br></code></pre></div></td></tr></table></figure><p>测试运行：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm text.js<br>    <br><span class="hljs-comment">// 结果</span><br>&#123; name: <span class="hljs-string">&#x27;phpopenfather&#x27;</span>, school: <span class="hljs-string">&#x27;php@itcast&#x27;</span>, say: [<span class="hljs-function"><span class="hljs-keyword">Function</span>: <span class="hljs-title">say</span>] &#125;</span><br><span class="hljs-function"><span class="hljs-title">phpopenfather</span></span><br><span class="hljs-function">悟空</span><br></code></pre></div></td></tr></table></figure></li></ol><h2 id="nodemon-自动重启服务（第三方模块）"><a href="#nodemon-自动重启服务（第三方模块）" class="headerlink" title="nodemon 自动重启服务（第三方模块）"></a>nodemon 自动重启服务（第三方模块）</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>通过 nodemon 检测文件修改自动重启</p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 安装</span><br>npm install nodemon --save-dev<br></code></pre></div></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 运行</span><br>nodemon index.js<br></code></pre></div></td></tr></table></figure><h2 id="moment-日期处理模块（第三方模块）"><a href="#moment-日期处理模块（第三方模块）" class="headerlink" title="moment 日期处理模块（第三方模块）"></a>moment 日期处理模块（第三方模块）</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><p>自己封装模块或使用第三方模块（<a href="http://momentjs.cn/%EF%BC%89">http://momentjs.cn/）</a></p><h3 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h3><ol><li><p>初始化项目</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm init -y<br></code></pre></div></td></tr></table></figure></li><li><p>安装 moment</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install moment<br></code></pre></div></td></tr></table></figure></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> moment = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;moment&#x27;</span>);<br>moment().format();<br></code></pre></div></td></tr></table></figure><p>需要使用哪种格式去 <a href="http://momentjs.cn/">http://momentjs.cn/</a> 查看</p></li></ol><p>笔记CSDN博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118678133?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_58163927/article/details/118678133?spm=1001.2014.3001.5502</a></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>npm</tag>
      
      <tag>nodemon</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NodeJS笔记</title>
    <link href="/2021/07/29/NodeJS%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/29/NodeJS%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="一、NodeJS-简介"><a href="#一、NodeJS-简介" class="headerlink" title="一、NodeJS 简介"></a>一、NodeJS 简介</h3><h4 id="1-1-Node-js-是什么"><a href="#1-1-Node-js-是什么" class="headerlink" title="1.1 Node.js 是什么"></a>1.1 Node.js 是什么</h4><p>Node.js 是 JavaScript 运行环境</p><p>可以直接通过浏览器访问 JavaScript 代码</p><h4 id="1-2-能干什么"><a href="#1-2-能干什么" class="headerlink" title="1.2 能干什么"></a>1.2 能干什么</h4><p>作用：让 JavaScript 成为与 PHP、Python 等平起平坐的语言</p><p>概括：前端脱离后端，直接通过 JS 写项目</p><h4 id="1-3-下载"><a href="#1-3-下载" class="headerlink" title="1.3 下载"></a>1.3 下载</h4><p>官网：<a href="http://nodejs.org/">http://nodejs.org</a></p><p>中文网址：<a href="http://nodejs.cn/">http://nodejs.cn</a></p><p>学习社区：condjs.org</p><ul><li>nvm 工具：实现 nodejs 任意版本的切换</li><li>npm 工具：下载 nodejs 所需模块（工具库）</li><li>nrm 工具：切换 npm 下载源</li></ul><h3 id="二、安装-NodeJS"><a href="#二、安装-NodeJS" class="headerlink" title="二、安装 NodeJS"></a>二、安装 NodeJS</h3><h3 id="三、初体验-REPL-（了解）"><a href="#三、初体验-REPL-（了解）" class="headerlink" title="三、初体验 REPL （了解）"></a>三、初体验 REPL （了解）</h3><ul><li>R  read  读取（读取用户输入的 JS 代码）</li><li>E  exec  执行（执行用户输入的 JS 代码）</li><li>P  print  打印（打印用户输入的 JS 代码）</li><li>L  loop  循环（后续所有的 JS 代码执行都会循环以上命令）</li><li><div class="hljs code-wrapper"><pre><code>          退出（按两下 ctrl + c）</code></pre></div></li></ul><h4 id="仿谷歌控制台"><a href="#仿谷歌控制台" class="headerlink" title="仿谷歌控制台"></a>仿谷歌控制台</h4><p>cmd窗口输入 node 回车开启仿谷歌控制台</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">cls <span class="hljs-comment">// 清屏</span><br></code></pre></div></td></tr></table></figure><h4 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h4><p>cmd窗口中 cd 到该目录下输入：</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">node hello.js<br></code></pre></div></td></tr></table></figure><h3 id="四、模块系统"><a href="#四、模块系统" class="headerlink" title="四、模块系统"></a>四、模块系统</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><h5 id="使用-NodeJS-编写应用程序主要使用："><a href="#使用-NodeJS-编写应用程序主要使用：" class="headerlink" title="使用 NodeJS 编写应用程序主要使用："></a>使用 NodeJS 编写应用程序主要使用：</h5><ul><li>ECMAScript语法：变量、判断、循环等语法（JS三大组成部分：ECMA/DOM/BOM）</li><li>内置/核心模块：http 服务、fs 文件操作、url 路径、 path 路径处理、os 操作系统</li><li>第三方模块：</li><li>自定义模块：自己创建的 js 文件</li></ul><h5 id="CommonJS-模块规范"><a href="#CommonJS-模块规范" class="headerlink" title="CommonJS 模块规范"></a>CommonJS 模块规范</h5><ul><li>一个文件就是一个模块</li><li>通过 exports 和 module.exports 来导出模块中的成员（声明模块中那些功能可以使用）</li><li>通过 require 来加载模块</li></ul><h4 id="4-2-自定义-Node-js-模块"><a href="#4-2-自定义-Node-js-模块" class="headerlink" title="4.2 自定义 Node.js 模块"></a>4.2 自定义 Node.js 模块</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 步骤1：导出成员（声明模块/文件中那些方法可以被外部使用）</span><br><span class="hljs-comment">// 写法1</span><br><span class="hljs-built_in">exports</span>.属性/方法名 = 功能<br><span class="hljs-comment">// 写法2</span><br><span class="hljs-built_in">module</span>.exports.属性/方法名 = 变量名<br><br><span class="hljs-comment">// 步骤2：导出成员（声明模块/文件中那些方法可以被外部使用）</span><br><span class="hljs-keyword">var</span> 对象 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;路径及文件名&#x27;</span>);<br>对象.属性或方法名;<br></code></pre></div></td></tr></table></figure><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>b.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 步骤1：定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is add&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">del</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is del&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">edit</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is edit&#x27;</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">select</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;this is select&#x27;</span>);<br>&#125;<br><span class="hljs-comment">// 步骤二：导出（语法：exports/module.exports.成员名 = 值）</span><br><span class="hljs-built_in">exports</span>.add = add;<br><span class="hljs-built_in">exports</span>.del = del;<br><span class="hljs-built_in">exports</span>.edit = edit;<br><span class="hljs-built_in">exports</span>.select = select;<br></code></pre></div></td></tr></table></figure><p>a.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 引入自定义模块</span><br><span class="hljs-keyword">var</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./b&#x27;</span>); <span class="hljs-comment">// 注：.js不用写</span><br><br><span class="hljs-built_in">console</span>.log(b);<br><br>b.add();<br>b.del();<br></code></pre></div></td></tr></table></figure><p>exports 就是 module.exports 的简写</p><h4 id="4-3-第三方-Node-js-模块"><a href="#4-3-第三方-Node-js-模块" class="headerlink" title="4.3 第三方 Node.js 模块"></a>4.3 第三方 Node.js 模块</h4><h4 id="4-4-内置-Node-js-模块"><a href="#4-4-内置-Node-js-模块" class="headerlink" title="4.4 内置 Node.js 模块"></a>4.4 内置 Node.js 模块</h4><h5 id="os-模块：操作系统-（了解）"><a href="#os-模块：操作系统-（了解）" class="headerlink" title="os 模块：操作系统 （了解）"></a>os 模块：操作系统 （了解）</h5><p>提供了一些操作系统相关的实用方法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 引入</span><br><span class="hljs-keyword">const</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 创建os对象（引入ondejs内置os对象）</span><br><span class="hljs-keyword">var</span> os = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>);<br><span class="hljs-comment">// 2. 调用os对象方法获取系统数据</span><br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello，&#x27;</span>        + os.EOL         + <span class="hljs-string">&#x27;itcast&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;主机名：&#x27;</span>        + os.hostname()); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;操作系统名：&#x27;</span>     + os.type()); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;操作系统平台：&#x27;</span>+ os.platform()); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;内存总量：&#x27;</span>       + os.totalmem()   + <span class="hljs-string">&#x27; 字节.&#x27;</span>); <br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;空闲内存：&#x27;</span>       + os.freemem()    + <span class="hljs-string">&#x27; 字节.&#x27;</span>); <br></code></pre></div></td></tr></table></figure><h6 id="字节概念："><a href="#字节概念：" class="headerlink" title="字节概念："></a>字节概念：</h6><p>1字节（Byte）= 8位（bit）</p><p>1KB = 1024Byte（字节）</p><p>1M = 1024KB</p><p>1G = 1024M</p><h5 id="path-模块：路径处理"><a href="#path-模块：路径处理" class="headerlink" title="path 模块：路径处理"></a>path 模块：路径处理</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// dirname后去一层</span><br><span class="hljs-comment">// basename 取最后一层</span><br><br><span class="hljs-comment">// 1. 引入内置模块</span><br><span class="hljs-keyword">var</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-comment">// 2. 练习</span><br><span class="hljs-keyword">var</span> testData = <span class="hljs-string">&#x27;c:/Users/AgoniLay/Desktop/zbw/work/index.html&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(path.basename(testData)); <span class="hljs-comment">// index.html</span><br>testData = path.dirname(testData)<br><span class="hljs-built_in">console</span>.log(testData); <span class="hljs-comment">// c:/Users/AgoniLay/Desktop/zbw/work</span><br><span class="hljs-built_in">console</span>.log(path.basename(testData)); <span class="hljs-comment">// work</span><br></code></pre></div></td></tr></table></figure><h5 id="url-模块：网址处理"><a href="#url-模块：网址处理" class="headerlink" title="url 模块：网址处理"></a>url 模块：网址处理</h5><p>需求：获取网址 <a href="http://itcast.cn/?name=AgoniLay&amp;age=19">http://itcast.cn?name=AgoniLay&amp;age=19</a> 中的参数</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入url内置模块</span><br><span class="hljs-keyword">var</span> url = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;url&#x27;</span>)<br><span class="hljs-comment">// 2. 使用</span><br><span class="hljs-keyword">var</span> data = <span class="hljs-string">&#x27;http://itcast.cn?name=AgoniLay&amp;age=19&#x27;</span>;<br><br><span class="hljs-built_in">console</span>.log(data);<br><span class="hljs-built_in">console</span>.log(url.parse(data));<br><span class="hljs-built_in">console</span>.log(url.parse(data, <span class="hljs-literal">true</span>)); <span class="hljs-comment">// query值转换为对象</span><br><br><span class="hljs-keyword">var</span> urlQueryObj = url.parse(data, <span class="hljs-literal">true</span>)<br><span class="hljs-built_in">console</span>.log(urlQueryObj.query); <span class="hljs-comment">// &#123; name: &#x27;AgoniLay&#x27;, age: &#x27;19&#x27; &#125;</span><br><span class="hljs-built_in">console</span>.log(urlQueryObj.query.name); <span class="hljs-comment">// AgoniLay</span><br><span class="hljs-built_in">console</span>.log(urlQueryObj.query.age); <span class="hljs-comment">// 19</span><br></code></pre></div></td></tr></table></figure><h5 id="fs-模块：文件系统"><a href="#fs-模块：文件系统" class="headerlink" title="fs 模块：文件系统"></a>fs 模块：文件系统</h5><h6 id="1-写入文件"><a href="#1-写入文件" class="headerlink" title="1. 写入文件"></a>1. 写入文件</h6><p>语法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入 fs 内置对象</span><br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br><span class="hljs-comment">// 2. 调用函数写数据进文件</span><br>fs.writeFile(<span class="hljs-string">&#x27;路径及文件名&#x27;</span>, <span class="hljs-string">&#x27;数据&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// err   为 null -则写入成功</span><br>    <span class="hljs-comment">// err 不为 null -则写入失败</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>练习：通过 write.js 创建 a.txt 写入 你好，AgoniLay</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fs.writeFile(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-string">&#x27;你好，AgoniLay&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// err 为null     成功</span><br>    <span class="hljs-comment">// err 不为null   有瑕疵</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;success&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h6 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2. 读取文件"></a>2. 读取文件</h6><p>语法</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 调用函数从文件读数据</span><br>fs.writeFile(<span class="hljs-string">&#x27;路径及文件名&#x27;</span>, <span class="hljs-string">&#x27;数据&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-comment">// err   为 null -则读取成功</span><br>    <span class="hljs-comment">// err  不为 null -则读取失败</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><p>练习：通过 read.js 文件读取 a.txt 内容</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fs.readFile(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// err 为null     成功</span><br>    <span class="hljs-comment">// err 不为null   有瑕疵</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(data);  <span class="hljs-comment">// 默认不是我们可识别的内容</span><br>    <span class="hljs-comment">// 而是 Buffer对象</span><br>    <span class="hljs-comment">// 通过 Buffer对象.toString() 转化为字符显示</span><br>    <span class="hljs-built_in">console</span>.log(data.toString());<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>省去转换，提前声明：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 多学一招：前期读的时候就声明</span><br>fs.readFile(<span class="hljs-string">&#x27;./a.txt&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-comment">// err 为null     成功</span><br>    <span class="hljs-comment">// err 不为null   有瑕疵</span><br>    <span class="hljs-keyword">if</span> (err) &#123;<br>        <span class="hljs-built_in">console</span>.log(err);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">console</span>.log(data);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="http-模块（构建-http-服务器）"><a href="#http-模块（构建-http-服务器）" class="headerlink" title="http 模块（构建 http 服务器）"></a>http 模块（构建 http 服务器）</h5><h6 id="1-创建-http-服务器"><a href="#1-创建-http-服务器" class="headerlink" title="1. 创建 http 服务器"></a>1. 创建 http 服务器</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//  1. 引入 http 模块</span><br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>)<br><br><span class="hljs-comment">// 2. 创建web服务器</span><br><span class="hljs-keyword">var</span> server = http.createServer();<br><span class="hljs-comment">// 3. 监听请求</span><br>server.on(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123; <span class="hljs-comment">// req - request 请求  res - response 响应</span><br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;收到客户端请求，请求地址：&#x27;</span> + req.url);<br>    <br>    <span class="hljs-comment">// 响应数据</span><br>    res.write(<span class="hljs-string">&#x27;hello AgoniLay&#x27;</span>);<br>res.end();<br>&#125;)<br><span class="hljs-comment">// 4. 启动服务</span><br>server.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;服务启动成功，访问：http://localhost:8080&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h6 id="2-响应不同数据"><a href="#2-响应不同数据" class="headerlink" title="2. 响应不同数据"></a>2. 响应不同数据</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 解决乱码</span><br>res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>)<br></code></pre></div></td></tr></table></figure><p>判断用户访问的是首页还是登录页</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 判断请求的地址</span><br><span class="hljs-keyword">if</span> (req.url == <span class="hljs-string">&#x27;/&#x27;</span> || req.url == <span class="hljs-string">&#x27;/index&#x27;</span>) &#123;<br>    $msg = <span class="hljs-string">&#x27;this is index&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (req.url == <span class="hljs-string">&#x27;/login&#x27;</span>) &#123;<br>    $msg = <span class="hljs-string">&#x27;this is login&#x27;</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    $msg = <span class="hljs-string">&#x27;404&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="五、请求和响应对象"><a href="#五、请求和响应对象" class="headerlink" title="五、请求和响应对象"></a>五、请求和响应对象</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><h5 id="请求对象（request）"><a href="#请求对象（request）" class="headerlink" title="请求对象（request）"></a>请求对象（request）</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">req.headers获取请求头信息（对象）<br>req.rawHeaders获取请求头信息（数组）<br>req.httpVersion获取 HTTP 版本<br>req.method获取请求方法<br>req.url获取请求路径（注：不含网址）<br></code></pre></div></td></tr></table></figure><h5 id="响应对象（response）"><a href="#响应对象（response）" class="headerlink" title="响应对象（response）"></a>响应对象（response）</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">res.statusCode = <span class="hljs-number">404</span>;<br>res.statusMessage = <span class="hljs-string">&#x27;Not Found&#x27;</span>;<br>res.setHeader(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span>);<br><br><span class="hljs-comment">// 简化版</span><br>res.writeHeader(<span class="hljs-string">&#x27;404&#x27;</span>, <span class="hljs-string">&#x27;Not Found&#x27;</span>, &#123;<br>    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html;charset=utf-8&#x27;</span><br>&#125;)<br><br>res.write(<span class="hljs-string">&#x27;数据&#x27;</span>);<br>res.end();<br></code></pre></div></td></tr></table></figure><h4 id="检测静态资源并响应"><a href="#检测静态资源并响应" class="headerlink" title="检测静态资源并响应"></a>检测静态资源并响应</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (currentUrl.indexOf(<span class="hljs-string">&#x27;/public&#x27;</span>) === <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-comment">// 检测静态资源并响应（略难）</span><br>    fs.readFile(<span class="hljs-string">&#x27;./&#x27;</span> + currentUrl, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (err) res.end(<span class="hljs-string">&#x27;404 Not Found&#x27;</span>);<br>        res.write(data);<br>        res.end();<br>    &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="六、表单提交数据处理（留言板案例）"><a href="#六、表单提交数据处理（留言板案例）" class="headerlink" title="六、表单提交数据处理（留言板案例）"></a>六、表单提交数据处理（留言板案例）</h3><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 表单提交数据处理</span><br><span class="hljs-keyword">if</span> (req.method == <span class="hljs-string">&#x27;POST&#x27;</span>) &#123;<br>    <span class="hljs-comment">//明确：表单post提交的数据可能会非常大，所以分片获取</span><br>    <span class="hljs-comment">//说明：data事件-数据传输中，end事件-数据传输完毕</span><br>    <span class="hljs-keyword">var</span> postData = <span class="hljs-string">&#x27;&#x27;</span>;<br>    req.on(<span class="hljs-string">&#x27;data&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">chunk</span>) </span>&#123;<br>        postData += chunk; <br>    &#125;); <br>    req.on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-comment">//通过querystring模块将字符串数据转化为对象</span><br>        paramObj = querystring.parse(postData); <br>        <span class="hljs-comment">// 2. 入库（压入到数组中 push pop）</span><br>        <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>        <span class="hljs-keyword">var</span> date = d.getFullYear() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getMonth() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getDate() + <span class="hljs-string">&#x27; &#x27;</span> + d.getHours() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getMinutes() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getSeconds();<br>        <span class="hljs-keyword">var</span> msg = &#123;<span class="hljs-attr">name</span>: paramObj.name, <span class="hljs-attr">content</span>: paramObj.content, <span class="hljs-attr">create_at</span>: date&#125;<br>        msgs.push(msg)<br>        <span class="hljs-comment">// 3. 跳转</span><br>        res.statusCode = <span class="hljs-number">302</span>;<br>        res.setHeader(<span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>        res.end()<br>    &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 1. 接收数据</span><br>    <span class="hljs-keyword">var</span> paramObj = url.parse(req.url, <span class="hljs-literal">true</span>).query<br>    <span class="hljs-comment">// 2. 入库（压入到数组中 push pop）</span><br>    <span class="hljs-keyword">var</span> d = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br>    <span class="hljs-keyword">var</span> date = d.getFullYear() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getMonth() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getDate() + <span class="hljs-string">&#x27; &#x27;</span> + d.getHours() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getMinutes() + <span class="hljs-string">&#x27;-&#x27;</span> + d.getSeconds();<br>    <span class="hljs-keyword">var</span> msg = &#123;<span class="hljs-attr">name</span>: paramObj.name, <span class="hljs-attr">content</span>: paramObj.content, <span class="hljs-attr">create_at</span>: date&#125;<br>    msgs.push(msg)<br>    <span class="hljs-comment">// 3. 跳转</span><br>    res.statusCode = <span class="hljs-number">302</span>;<br>    res.setHeader(<span class="hljs-string">&#x27;Location&#x27;</span>, <span class="hljs-string">&#x27;/&#x27;</span>);<br>    res.end()<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="⭐扩展"><a href="#⭐扩展" class="headerlink" title="⭐扩展"></a>⭐扩展</h3><h4 id="1-自定义网站图标"><a href="#1-自定义网站图标" class="headerlink" title="1. 自定义网站图标"></a>1. 自定义网站图标</h4><h4 id="2-MIME"><a href="#2-MIME" class="headerlink" title="2. MIME"></a>2. MIME</h4><p>MIME(Multipurpose Internet Mail Extensions) 是描述消息内容类型的英特网标准。</p><p>text/html - html文件    text/javascript - javascript文件   image/png - png文件</p><h4 id="3-状态码-301-amp-302"><a href="#3-状态码-301-amp-302" class="headerlink" title="3. 状态码 301 &amp; 302"></a>3. 状态码 301 &amp; 302</h4>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>nodejs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Express笔记</title>
    <link href="/2021/07/29/Express%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/29/Express%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一、Express-简介"><a href="#一、Express-简介" class="headerlink" title="一、Express 简介"></a>一、Express 简介</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>基于 nodejs 开发的一个框架</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>加快项目开发，便于团队协作</p><h2 id="二、使用（初体验）"><a href="#二、使用（初体验）" class="headerlink" title="二、使用（初体验）"></a>二、使用（初体验）</h2><ol><li><p>创建开发目录，初始化</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm init -y<br></code></pre></div></td></tr></table></figure></li><li><p>安装 express</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install express<br></code></pre></div></td></tr></table></figure></li><li><p>使用</p><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入模块</span><br><span class="hljs-keyword">var</span> experss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web服务器</span><br><span class="hljs-keyword">var</span> app = experss()<br><span class="hljs-comment">// 3. 路由</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-comment">// end()    响应字符串（乱码）</span><br>    <span class="hljs-comment">// send()   响应字符串（自动识别）</span><br>    <span class="hljs-comment">// render() 响应字符串（自动识别，只能获取指定文件字符串并响应，注：必须配合模板引擎使用）</span><br><br>    <span class="hljs-comment">// res.end(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;)</span><br>    res.send(<span class="hljs-string">&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;</span>)<br>&#125;)<br><span class="hljs-comment">// 4. 启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;启动成功，访问：http://localhost:8080&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure></li></ol><h2 id="三、配置模板引擎（art）"><a href="#三、配置模板引擎（art）" class="headerlink" title="三、配置模板引擎（art）"></a>三、配置模板引擎（art）</h2><ul><li>默认通过公 end 或 send 渲染，无法加载视图，所以得自己配置默认模板引擎官方以前推荐用 jade 现在升级为 pug 也有用 ejs 个人推荐 art 模板引擎</li><li>文档：<a href="http://aui.github.io/art-template/zh-cn/express/">http://aui.github.io/art-template/zh-cn/express/</a></li></ul><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.engine(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<br></code></pre></div></td></tr></table></figure><h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><p>安装</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install art-template<br>npm install express-art-template<br></code></pre></div></td></tr></table></figure><p>创建 views 目录</p><p>test1.html</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Document<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            &#123;&#123;if age &gt; 18&#125;&#125;<br>            妹妹哥哥来了<br>            &#123;&#123;else&#125;&#125;<br>            你走吧<br>            &#123;&#123;/if&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>            &#123;&#123;each orders as order index&#125;&#125;<br>            &#123;&#123;index&#125;&#125; &#123;&#123;order.title&#125;&#125;<br>            &#123;&#123;/each&#125;&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>app2.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入模块</span><br><span class="hljs-keyword">var</span> experss = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 web服务器</span><br><span class="hljs-keyword">var</span> app = experss()<br><span class="hljs-comment">// 3. 配置</span><br><span class="hljs-comment">// 声明所使用的模板引擎（ps. 使用render方法必须）</span><br>app.engine(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>))<br><span class="hljs-comment">// 4. 路由</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-comment">// end()    响应字符串（乱码）</span><br>    <span class="hljs-comment">// send()   响应字符串（自动识别）</span><br>    <span class="hljs-comment">// render() 响应字符串（自动识别，只能获取指定文件字符串并响应，注：必须配合模板引擎使用）</span><br><br>    <span class="hljs-comment">// res.end(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;)</span><br>    <span class="hljs-comment">// res.send(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;);</span><br>    res.render(<span class="hljs-string">&#x27;test1.html&#x27;</span>, &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">5</span>,<br>        <span class="hljs-attr">orders</span>: [<br>            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题1&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">30</span>&#125;,<br>            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">2</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题2&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">33</span>&#125;,<br>            &#123;<span class="hljs-attr">id</span>:<span class="hljs-number">3</span>, <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;标题3&#x27;</span>, <span class="hljs-attr">price</span>: <span class="hljs-number">12</span>&#125;,<br>        ], <br>    &#125;)<br>&#125;)<br><span class="hljs-comment">// 5. 启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;启动成功，访问：http://localhost:8080&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h5 id="扩展：HTTP请求类型"><a href="#扩展：HTTP请求类型" class="headerlink" title="扩展：HTTP请求类型"></a>扩展：HTTP请求类型</h5><div class="hljs code-wrapper"><pre><code>OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACEa</code></pre></div><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>什么是路由：就是网址</li><li>什么是路由参数：就是网址参数</li><li>在 PHP 中作用：声明交给哪个控制器的哪个方法处理</li><li>在 NodeJS 中作用：交给指定匿名函数处理</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p><em><strong>普通语法</strong></em>：app.HTTP请求类型（请求路径，回调函数）</p><p>发送<em><strong>GET</strong></em>请求：app.<em><strong>get</strong></em>（请求路径，回调函数）</p><p>发送<em><strong>POST</strong></em>请求：app.<em><strong>post</strong></em>（请求路径，回调函数）</p><p>发送<em><strong>任意</strong></em>请求：app.<em><strong>all</strong></em>（请求路径，回调函数）</p><p><em><strong>特殊语法：</strong></em>app.<em><strong>use</strong></em>（请求路径，回调函数）</p><p>区别1：use匹配任意类型请求</p><p>区别2：<em><strong>use非完全匹配</strong></em>（ps. 只需要<em><strong>url前面匹配</strong></em>请求路径即可匹配）</p><p><em><strong>路由参数：</strong></em>app.<em><strong>HTTP请求类型</strong></em>（请求路径/:参数1/…/:参数n，回调函数）</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>app3.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//1.引入express框架模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">//2.创建框架核心app对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">//3.路由</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br><br><span class="hljs-comment">//注：修改method=get 或者 method=post查看结果</span><br><span class="hljs-keyword">var</span> formHtml = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;form action=&quot;/test&quot; method=&quot;post&quot;&gt;</span><br><span class="hljs-string">&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;</span><br><span class="hljs-string">&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;</span><br><span class="hljs-string">&lt;input type=&quot;submit&quot;  /&gt;</span><br><span class="hljs-string">&lt;/form&gt;</span><br><span class="hljs-string">`</span><br>res.send(formHtml)<br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>res.send(<span class="hljs-string">&#x27;this is get submit&#x27;</span>)<br>&#125;)<br><br>app.post(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>res.send(<span class="hljs-string">&#x27;this is post submit&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">//4.启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="特殊语法练习"><a href="#特殊语法练习" class="headerlink" title="特殊语法练习"></a>特殊语法练习</h4><p>app4.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//1.引入express框架模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">//2.创建框架核心app对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">//3.路由</span><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>,  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) </span>&#123;<br><br><span class="hljs-keyword">var</span> formHtml = <span class="hljs-string">`</span><br><span class="hljs-string">&lt;form action=&quot;/test/a/b/c&quot; method=&quot;post&quot;&gt;</span><br><span class="hljs-string">&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;</span><br><span class="hljs-string">&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;</span><br><span class="hljs-string">&lt;input type=&quot;submit&quot;  /&gt;</span><br><span class="hljs-string">&lt;/form&gt;</span><br><span class="hljs-string">`</span><br>res.send(formHtml)<br>&#125;)<br><br>app.use(<span class="hljs-string">&#x27;/test&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>res.send(<span class="hljs-string">&#x27;this is /test&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">//4.启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h4 id="路由参数练习"><a href="#路由参数练习" class="headerlink" title="路由参数练习"></a>路由参数练习</h4><p>app5.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//1.引入express框架模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">//2.创建框架核心app对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">//3.路由</span><br>app.get(<span class="hljs-string">&#x27;/stu/:name/:age&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(req.params);<br>res.send(<span class="hljs-string">&#x27;匹配成功，快去看控制台有没有获取数据..&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//4.启动服务 </span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="五、利用-Express-托管静态文件"><a href="#五、利用-Express-托管静态文件" class="headerlink" title="五、利用 Express 托管静态文件"></a>五、利用 Express 托管静态文件</h2><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.use(<span class="hljs-string">&#x27;/public&#x27;</span>, express.static(<span class="hljs-string">&#x27;public&#x27;</span>))<br></code></pre></div></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">//1.引入express框架模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-comment">//2.创建框架核心app对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">//3.路由</span><br><span class="hljs-comment">// 响应指定静态资源</span><br>app.get(<span class="hljs-string">&#x27;/public/css/a.css&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    fs.readFile(<span class="hljs-string">&#x27;./public/css/a.css&#x27;</span>, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (err) res.send(err);<br>        res.send(data)<br>    &#125;)<br>&#125;)<br><span class="hljs-comment">// 响应多个静态资源</span><br><span class="hljs-comment">// app.use(&#x27;/public&#x27;, function(req, res)&#123;</span><br><span class="hljs-comment">// fs.readFile(&#x27;./public/&#x27; + req.url , &#x27;utf8&#x27;, function (err, data) &#123;</span><br><span class="hljs-comment">// if (err) res.send(err);</span><br><span class="hljs-comment">// res.send(data)</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// 在express中</span><br><span class="hljs-comment">// 作用：允许指定目录下的文件被外访问</span><br><span class="hljs-comment">// 语法：express.static(&#x27;目录名&#x27;)   </span><br><span class="hljs-comment">// 返回：一个函数，可理解为读取URL需要读取的文件</span><br>app.use(<span class="hljs-string">&#x27;/public&#x27;</span>, express.static(<span class="hljs-string">&#x27;public&#x27;</span>))<br><span class="hljs-comment">//4.启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h2 id="六、案例"><a href="#六、案例" class="headerlink" title="六、案例"></a>六、案例</h2><h3 id="NodeJS-each循环"><a href="#NodeJS-each循环" class="headerlink" title="NodeJS each循环"></a>NodeJS each循环</h3><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- node.js each循环 --&gt;</span><br>&#123;&#123;each msgs as msg index&#125;&#125;<br><span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;list-group-item&quot;</span>&gt;</span><br>    &#123;&#123;msg.name&#125;&#125;说:&#123;&#123;msg.content&#125;&#125;<br>    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;pull-right&quot;</span>&gt;</span>&#123;&#123;msg.create_at&#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>&#123;&#123;/each&#125;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="切换-NodeJS-版本"><a href="#切换-NodeJS-版本" class="headerlink" title="切换 NodeJS 版本"></a>切换 NodeJS 版本</h3><h4 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h4><p>通过 nvm 工具可以实现 node.js 任意版本切换</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a href="http://github.com/coreybutler/nvm-windows/releases">http://github.com/coreybutler/nvm-windows/releases</a></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">nvm version<br>nvm install   latest<br>nvm install   版本号<br>nvm uninstall 版本号<br>nvm <span class="hljs-keyword">list</span><br>nvm <span class="hljs-keyword">use</span>      版本号<br></code></pre></div></td></tr></table></figure><h2 id="七、优化"><a href="#七、优化" class="headerlink" title="七、优化"></a>七、优化</h2><p>通过应用生成器工具 <code>express-generator</code> 可以快速创建一个应用的骨架。</p><p>网站：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn</a></p><h3 id="7-1-路由优化（理解）"><a href="#7-1-路由优化（理解）" class="headerlink" title="7.1 路由优化（理解）"></a>7.1 路由优化（理解）</h3><h4 id="方法1：（不推荐）"><a href="#方法1：（不推荐）" class="headerlink" title="方法1：（不推荐）"></a>方法1：（不推荐）</h4><p>创建 routes 目录，在中创建 stu.js 文件，专门负责路由管理</p><p>stu.js：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">app, fs</span>) </span>&#123;<br>    <span class="hljs-comment">// 路由部分</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>app.js：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 4. 路由</span><br><span class="hljs-comment">// var indexRouter = require(&#x27;./routes/index&#x27;);</span><br><span class="hljs-comment">// var orderRouter = require(&#x27;./routes/order&#x27;);</span><br><span class="hljs-keyword">var</span> stuRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/stu&#x27;</span>);<br><span class="hljs-comment">// indexRouter(app, fs)</span><br><span class="hljs-comment">// orderRouter(app, fs)</span><br>stuRouter(app, fs)<br></code></pre></div></td></tr></table></figure><h4 id="方法2："><a href="#方法2：" class="headerlink" title="方法2："></a>方法2：</h4><ol><li><p>修改 app.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// var indexRouter = require(&#x27;./routes/index&#x27;);</span><br><span class="hljs-comment">// var orderRouter = require(&#x27;./routes/order&#x27;);</span><br>   <span class="hljs-keyword">var</span> stuRouter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes/stu&#x27;</span>);<br><span class="hljs-comment">// app.use(&#x27;/&#x27;,     indexRouter);</span><br><span class="hljs-comment">// app.use(&#x27;/order&#x27;, orderRouter);</span><br>   app.use(<span class="hljs-string">&#x27;/stu&#x27;</span>, stuRouter);<br></code></pre></div></td></tr></table></figure></li><li><p>stu.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">var</span> router = express.Router()<br><br><span class="hljs-comment">// 路由部分</span><br><br><span class="hljs-built_in">module</span>.exports = router<br></code></pre></div></td></tr></table></figure></li></ol><h3 id="7-2-数据操作优化（理解）"><a href="#7-2-数据操作优化（理解）" class="headerlink" title="7.2 数据操作优化（理解）"></a>7.2 数据操作优化（理解）</h3><p>创建 models 文件夹，新建 stu.js </p><p>在其中创建模型</p><p>然后再路由当中调用，避免冗余，便于后期扩展开发</p><h2 id="八、Express-框架"><a href="#八、Express-框架" class="headerlink" title="八、Express 框架"></a>八、Express 框架</h2><h3 id="8-1-中间件"><a href="#8-1-中间件" class="headerlink" title="8.1 中间件"></a>8.1 中间件</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>HTTP请求中的过滤层（HTTP请求交给方法处理前，先交给另一个方法过滤）</p><ul><li>PHP 中：BaseController</li><li>NodeJS 中：app.use()</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>判断登录状态、检测RBAC权限、错误捕捉等</p><h3 id="8-3-路由中间件"><a href="#8-3-路由中间件" class="headerlink" title="8.3 路由中间件"></a>8.3 路由中间件</h3><ol><li><p>创建 day3 目录</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php"><span class="hljs-comment">// 初始化</span><br>npm init -y<br><span class="hljs-comment">// 安装 express 以及 art</span><br>npm install express art-template express-art-template<br></code></pre></div></td></tr></table></figure></li><li><p>app.js 中：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入 express 模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 app 对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">// 3. 配置</span><br><span class="hljs-comment">// 4. 路由</span><br><br><span class="hljs-comment">// 中间件</span><br>app.use(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);<br>    next(); <span class="hljs-comment">// 继续向后访问</span><br>&#125;)<br><br>app.get(<span class="hljs-string">&#x27;/stu&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stu list&#x27;</span>);<br>    res.send(<span class="hljs-string">&#x27;stu list&#x27;</span>) <span class="hljs-comment">// end send render</span><br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/stu/create&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;stu add&#x27;</span>);<br>    res.send(<span class="hljs-string">&#x27;stu add&#x27;</span>) <span class="hljs-comment">// end send render</span><br>&#125;)<br><span class="hljs-comment">// 5. 启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;启动成功...&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>中间件匹配成功后，不会继续往下寻找，需要使用 <code>next()</code>继续访问</p><p>使用<code>next()</code>函数需要添加 next 形参</p><p><code>function (req, res, next) &#123;&#125;</code></p></li></ol><h3 id="8-4-错误处理"><a href="#8-4-错误处理" class="headerlink" title="8.4 错误处理"></a>8.4 错误处理</h3><h5 id="中间件灵活使用"><a href="#中间件灵活使用" class="headerlink" title="中间件灵活使用"></a>中间件灵活使用</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.get(<span class="hljs-string">&#x27;/stu&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>    fs.readFile(<span class="hljs-string">&#x27;./aaaa.txt&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, data</span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (err) next(err) <span class="hljs-comment">// next如果不传递参数 只匹配下一个URL</span><br>           <span class="hljs-comment">// next传递err 则匹配第一个含有err的中间件</span><br>        res.send(data) <span class="hljs-comment">// end send render</span><br>    &#125;)<br>&#125;)<br><br><span class="hljs-comment">// 中间件灵活使用（404）</span><br>app.use(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>    res.send(<span class="hljs-string">&#x27;404 Page&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 错误统一处理</span><br><span class="hljs-comment">// 脚下留心：（形参可以不写，但顺序不能改变）</span><br><span class="hljs-comment">// &#x27;/&#x27; 可以省略不写，等价</span><br><span class="hljs-comment">// app.use(function (err, req, res, next) &#123;</span><br>app.use(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">err, req, res, next</span>) </span>&#123;<br>    res.send(<span class="hljs-string">&#x27;网络异常... 请稍后重试&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><ul><li>形参可以不写，但顺序不能改变</li><li>‘/‘ 可以省略不写，与写上等价</li><li>next 如果不传递参数 只匹配下一个 URL；next 传递 err  则匹配第一个含有 err 的中间件</li></ul><h2 id="九、会话技术"><a href="#九、会话技术" class="headerlink" title="九、会话技术"></a>九、会话技术</h2><h3 id="9-1-cookie"><a href="#9-1-cookie" class="headerlink" title="9.1 cookie"></a>9.1 cookie</h3><h5 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h5><p><a href="https://www.npmjs.com/package/cookie-parser">https://www.npmjs.com/package/cookie-parser</a></p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><ol><li><p>安装cookie模块，语法：<code>npm install cookie-parser</code></p></li><li><p>引入cookie模块，语法：<code>var cookieParser = require(&#39;cookie-parser&#39;)</code></p></li><li><p>初始化cookie，语法：<code>app.use(cookieParser())</code></p><div class="hljs code-wrapper"><pre><code>                   相当于：`app.user(&#39;/&#39;, cookieParser())`</code></pre></div><p><strong>作用</strong>：http传入的cookie进行解析后赋值给req.cookies</p><p><strong>其次</strong>：cookieParser加参数，并且设置是signed=true则加密存储（推荐）</p></li></ol><h6 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h6><p><code>res.cookie(键, 值, &#123;signed: 是否加密true-是,false-否默认,maxAge: 时间/毫秒&#125;)</code></p><p>获取（未加密）：<code>req.cookies</code></p><p>获取（  加密）：<code>req.signedCookies</code></p><p>清除：<code>res.clearCookie(键)</code></p><h5 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 需求：设置cookie数据a=1永久，b=2（1分钟）c=3（加密）d=4（删除）</span><br><span class="hljs-comment">//1.引入express框架模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> cookieParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cookie-parser&#x27;</span>)<br><span class="hljs-comment">//2.创建框架核心app对象</span><br><span class="hljs-keyword">var</span> app = express() <br><span class="hljs-comment">//3.配置</span><br><span class="hljs-comment">//http传入的cookie进行解析后赋值给req.cookies</span><br>app.use(cookieParser(<span class="hljs-string">&#x27;itcast&#x27;</span>))<br><span class="hljs-comment">//4.路由</span><br>app.get(<span class="hljs-string">&#x27;/set&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    <span class="hljs-comment">//res.cookie(键, 值, &#123;signed: 是否加密true-是,false-否默认,maxAge: 时间/毫秒&#125;)</span><br>    res.cookie(<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-number">1</span>)<br>    res.cookie(<span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-number">2</span>, &#123;<span class="hljs-attr">maxAge</span>: <span class="hljs-number">60</span>*<span class="hljs-number">1000</span>&#125;)<br>    res.cookie(<span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-number">3</span>, &#123;<span class="hljs-attr">signed</span>: <span class="hljs-literal">true</span>&#125;)<br>    res.cookie(<span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-number">4</span>)<br>    res.send(<span class="hljs-string">&#x27;设置成功&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;未加密&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(req.cookies)<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;加密&#x27;</span>)<br>    <span class="hljs-built_in">console</span>.log(req.signedCookies)<br>    res.send(<span class="hljs-string">&#x27;打开控制台查看&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/del&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    <span class="hljs-comment">//res.clearCookie(键)</span><br>    res.clearCookie(<span class="hljs-string">&#x27;d&#x27;</span>)<br>    res.send(<span class="hljs-string">&#x27;删除成功，重新访问/get验证&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">//5.启动服务 </span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running...&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><h3 id="9-2-session"><a href="#9-2-session" class="headerlink" title="9.2 session"></a>9.2 session</h3><h5 id="手册-1"><a href="#手册-1" class="headerlink" title="手册"></a>手册</h5><p><a href="https://www.npmjs.com/package/express-session">https://www.npmjs.com/package/express-session</a></p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><ol><li>安装 session 模块，语法：<code>npm install express-session</code></li><li>引入 session 模块，语法：<code>var session = require(&#39;express-session&#39;)</code></li><li>初始化 session，语法：</li></ol><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.use(session (&#123;<br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;itcast&#x27;</span>,    <span class="hljs-comment">// 加密存储</span><br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,    <span class="hljs-comment">// 客户端并行请求是否覆盖:true-是,false-否</span><br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>    <span class="hljs-comment">// 初始化session存储</span><br>&#125;))<br></code></pre></div></td></tr></table></figure><p>设置：<code>req.session.键 = 值</code></p><p>获取：<code>req.session.键</code></p><p>清除：<code>req.session.键 = null</code></p><h5 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入 express 模块</span><br><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">var</span> session = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-session&#x27;</span>)<br><span class="hljs-comment">// 2. 创建 app 对象</span><br><span class="hljs-keyword">var</span> app = express()<br><span class="hljs-comment">// 3. 配置</span><br>app.use(session(&#123;<br>    <span class="hljs-attr">secret</span>: <span class="hljs-string">&#x27;itcast&#x27;</span>,    <span class="hljs-comment">//加密存储</span><br>    <span class="hljs-attr">resave</span>: <span class="hljs-literal">false</span>,      <span class="hljs-comment">//客户端并行请求是否覆盖:true-是,false-否</span><br>    <span class="hljs-attr">saveUninitialized</span>: <span class="hljs-literal">true</span>   <span class="hljs-comment">//初始化session存储</span><br>&#125;))<br><span class="hljs-comment">// 4. 路由（需  求：设置session数据a=1，b=2，c=3 最后删除c）</span><br>app.get(<span class="hljs-string">&#x27;/set&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>    req.session.a = <span class="hljs-number">1</span><br>    req.session.b = <span class="hljs-number">2</span><br>    req.session.c = <span class="hljs-number">3</span><br>    res.send(<span class="hljs-string">&#x27;设置成功，通过/get获取&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/get&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res, next</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(req.session.a);<br>    <span class="hljs-built_in">console</span>.log(req.session.b);<br>    <span class="hljs-built_in">console</span>.log(req.session.c);<br>    res.send(<span class="hljs-string">&#x27;获取成功，请通过控制台查看&#x27;</span>)<br>&#125;)<br>app.get(<span class="hljs-string">&#x27;/del&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">req, res</span>) </span>&#123;<br>    req.session.c = <span class="hljs-literal">null</span><br>    res.send(<span class="hljs-string">&#x27;删除成功，请通过/get重新查看&#x27;</span>)<br>&#125;)<br><span class="hljs-comment">// 5. 启动服务</span><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;启动成功...&#x27;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>cookie 在客户端；session 在服务端</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><h4 id="如何展示静态页面"><a href="#如何展示静态页面" class="headerlink" title="如何展示静态页面"></a>如何展示静态页面</h4><h6 id="在-PHP-中"><a href="#在-PHP-中" class="headerlink" title="在 PHP 中"></a>在 PHP 中</h6><ol><li>确定路由</li><li>根据路由创建控制器方法 -&gt; 加载视图 display 或 view 函数</li><li>创建视图 -&gt; 修改静态资源路径</li></ol><h6 id="在-NodeJS-中"><a href="#在-NodeJS-中" class="headerlink" title="在 NodeJS 中"></a>在 NodeJS 中</h6><ol><li>定义路由 -&gt; 通过render加载视图传递数据</li><li>创建视图 -&gt; 修改静态资源路径</li></ol><h4 id="如何数据处理"><a href="#如何数据处理" class="headerlink" title="如何数据处理"></a>如何数据处理</h4><ol><li>修改表单属性值</li><li>接受数据</li><li>逻辑数据</li><li>数据库操作</li><li>判断跳转</li></ol><h4 id="如何显示列表"><a href="#如何显示列表" class="headerlink" title="如何显示列表"></a>如何显示列表</h4><ol><li>控制器方法获取数据 -&gt; 传递给视图</li><li>调用模板标签循环显示</li></ol><h4 id="如何实现-增删改"><a href="#如何实现-增删改" class="headerlink" title="如何实现 增删改"></a>如何实现 增删改</h4><ol><li>修改静态页面（前：修改表单 action name    后：修改 a 标签 id）</li><li>数据处理（1-接受数据，2-数据过滤，3-入库，4-判断跳转）</li></ol><h3 id="express-模板框架生成器"><a href="#express-模板框架生成器" class="headerlink" title="express 模板框架生成器"></a>express 模板框架生成器</h3><p>全局安装</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">npm install -g express-<span class="hljs-built_in">generator</span><br></code></pre></div></td></tr></table></figure><p>在想要生成项目的目录下终端输入</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">express 项目名<br></code></pre></div></td></tr></table></figure><p>即可自动生成</p><p>然后</p><figure class="highlight php"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs php">cd 项目名<br>npm install<br>npm install art-template express-art-template<br></code></pre></div></td></tr></table></figure><p>激活默认模板引擎</p><p>替换</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span><br><span class="hljs-comment">// app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);</span><br></code></pre></div></td></tr></table></figure><p>为</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.use(<span class="hljs-string">&#x27;/public&#x27;</span>, express.static(<span class="hljs-string">&#x27;public&#x27;</span>))<br>app.set(<span class="hljs-string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>));<br>app.engine(<span class="hljs-string">&#x27;html&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-art-template&#x27;</span>));<br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;html&#x27;</span>);<br></code></pre></div></td></tr></table></figure><p>即可进行后续开发</p><h1 id="ES6-扩展"><a href="#ES6-扩展" class="headerlink" title="ES6 扩展"></a>ES6 扩展</h1><h2 id="数组扩展新语法"><a href="#数组扩展新语法" class="headerlink" title="数组扩展新语法"></a>数组扩展新语法</h2><h4 id="find-搜索"><a href="#find-搜索" class="headerlink" title="find() 搜索"></a><code>find()</code> 搜索</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// var arr = [</span><br><span class="hljs-comment">// &#123;name:&#x27;test1&#x27;, age: 1&#125;,</span><br><span class="hljs-comment">// &#123;name:&#x27;test2&#x27;, age: 2&#125;,</span><br><span class="hljs-comment">// &#123;name:&#x27;test3&#x27;, age: 3&#125;</span><br><span class="hljs-comment">// ];</span><br><br><span class="hljs-comment">// //需求：获取name=test3的元素下标</span><br><span class="hljs-comment">// var index = arr.findIndex(function(item)&#123;</span><br><span class="hljs-comment">// return item.name == &#x27;test3&#x27;</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// console.log(index)</span><br><span class="hljs-comment">// //需求：获取name=test3的元素</span><br><span class="hljs-comment">// var obj = arr.find(function(item)&#123;</span><br><span class="hljs-comment">// return item.name == &#x27;test3&#x27;</span><br><span class="hljs-comment">// &#125;)</span><br><span class="hljs-comment">// console.log(obj)</span><br><span class="hljs-comment">// console.log(&#x27;------------&#x27;)</span><br><br><span class="hljs-comment">//原理</span><br><span class="hljs-comment">//JS面向对象：封装 、 继承、 多态</span><br><span class="hljs-comment">//JS封装：this 私有的  var 公开的 （类控制成员只保留部分的成员和方法供外部使用 通过修饰符 public private protected）</span><br><span class="hljs-comment">//JS继承：prototype        （extend）</span><br><br><span class="hljs-comment">//var xx = [1,2] 相当于 var xx  = new Array(1,2)   </span><br><span class="hljs-comment">//var xx = &#x27;aaa&#x27; 相当于 var xx  = new String(&#x27;aaa&#x27;)</span><br><span class="hljs-comment">//Array是系统类</span><br><span class="hljs-comment">//现在通过原先继承，给他增加一个myFind方法</span><br><span class="hljs-built_in">Array</span>.prototype.myFind = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">conditionFunc</span>) </span>&#123;<br>    <span class="hljs-comment">//conditionFunc == function(item) &#123; return item.name == &#x27;test3&#x27; &#125;</span><br>    <span class="hljs-comment">//this指调用当前方法的对象（注：下述代码 arr调用myFind）</span><br>    <span class="hljs-comment">//所以this指arr</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.length; i++) &#123;<br>        <span class="hljs-comment">//判断条件是否成立，成立就返回（注：this指数组，this[i] 数组中的元素）</span><br>        <span class="hljs-keyword">if</span> (conditionFunc(<span class="hljs-built_in">this</span>[i])) &#123;<br>            <span class="hljs-comment">//return this[i]  //相当于 es6中的find</span><br>            <span class="hljs-keyword">return</span> i  <span class="hljs-comment">//相当于 es6中的findIndex</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> arr = [<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;test1&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">1</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;test2&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">2</span>&#125;,<br>    &#123;<span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;test3&#x27;</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">3</span>&#125;<br>];<br><span class="hljs-keyword">var</span> result = arr.myFind(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">item</span>)</span>&#123;<br>    <span class="hljs-keyword">return</span> item.name == <span class="hljs-string">&#x27;test2&#x27;</span><br>&#125;)<br><span class="hljs-built_in">console</span>.log(result)<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>nodejs</tag>
      
      <tag>express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ajax笔记</title>
    <link href="/2021/07/28/ajax%E7%AC%94%E8%AE%B0/"/>
    <url>/2021/07/28/ajax%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="零、基本概述"><a href="#零、基本概述" class="headerlink" title="零、基本概述"></a>零、基本概述</h3><h4 id="0-1-服务器"><a href="#0-1-服务器" class="headerlink" title="0.1 服务器"></a>0.1 服务器</h4><p>提供了某种服务的电脑，一般没有显示器，没有输入设备</p><p>服务器主要提供的服务：</p><ul><li>文件服务器（提供文件下载任务）</li><li>邮件服务器（提供邮件服务）</li><li>游戏服务器</li><li>web服务器</li></ul><h4 id="0-2-web服务器"><a href="#0-2-web服务器" class="headerlink" title="0.2 web服务器"></a>0.2 web服务器</h4><h5 id="如何成为web服务器："><a href="#如何成为web服务器：" class="headerlink" title="如何成为web服务器："></a>如何成为web服务器：</h5><p>装一个软件：</p><ul><li>apache – 阿帕奇：开源的web服务器软件，目前使用人数最多的 web服务器软件</li><li>IIS – 微软的web服务器软件，不开源 –&gt; 开源</li><li>tomcat – web服务器软件</li><li>Nqinx – web服务器软件</li></ul><h3 id="一、原生Ajax"><a href="#一、原生Ajax" class="headerlink" title="一、原生Ajax"></a>一、原生Ajax</h3><h4 id="1-1-AJAX简介"><a href="#1-1-AJAX简介" class="headerlink" title="1.1 AJAX简介"></a>1.1 AJAX简介</h4><p>页面内加载数据，不进行刷新界面</p><h4 id="1-2-XML简介"><a href="#1-2-XML简介" class="headerlink" title="1.2 XML简介"></a>1.2 XML简介</h4><p>XML 可扩展标记语言，被设计用来传输和存储数据</p><p>比如说我有一个学生数据：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">name = <span class="hljs-string">&quot;孙悟空&quot;</span>; age = <span class="hljs-number">18</span>; gender=<span class="hljs-string">&quot;男&quot;</span>;<br></code></pre></div></td></tr></table></figure><p>用XML表示：</p><figure class="highlight xml"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">student</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>孙悟空<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">age</span>&gt;</span>18<span class="hljs-tag">&lt;/<span class="hljs-name">age</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">gender</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">gender</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">student</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>现在已经被 JSON 取代了</p><p>用JOSN表示：</p><figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;name&quot;</span>:<span class="hljs-string">&quot;孙悟空&quot;</span>,<span class="hljs-attr">&quot;age&quot;</span>:<span class="hljs-number">18</span>,<span class="hljs-attr">&quot;gender&quot;</span>:<span class="hljs-string">&quot;男&quot;</span>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-3-AJAX的特点"><a href="#1-3-AJAX的特点" class="headerlink" title="1.3 AJAX的特点"></a>1.3 AJAX的特点</h4><h5 id="1-3-1-优点"><a href="#1-3-1-优点" class="headerlink" title="1.3.1 优点"></a>1.3.1 优点</h5><ol><li>可以无需刷新页面而与服务器端进行通信</li><li>允许你根据用户事件来更新部分页面内容</li></ol><h5 id="1-3-2-缺点"><a href="#1-3-2-缺点" class="headerlink" title="1.3.2 缺点"></a>1.3.2 缺点</h5><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好</li></ol><h4 id="1-4-http协议"><a href="#1-4-http协议" class="headerlink" title="1.4 http协议"></a>1.4 http协议</h4><p>HTTP (hypertext transport protocol) 协议【超文本传输协议】</p><p>详细规定了浏览器和万维网服务器之间互相通信的规则。</p><p>以下报文可以在</p><h5 id="1-4-1-请求报文"><a href="#1-4-1-请求报文" class="headerlink" title="1.4.1 请求报文"></a>1.4.1 请求报文</h5><p>格式与参数：</p><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">行POST /s?ie=utf-8  HTTP/1.1<br>头Host: atguigu.com<br> Cookie: name=guigu<br> Content-type: application/x-www-form-urlencoded<br> User-Agent: chrome 83<br>空行<br>体GET(为空) POST(可以不为空) username=admin&amp;admin&amp;password=admin<br></code></pre></div></td></tr></table></figure><h5 id="1-4-2-响应报文"><a href="#1-4-2-响应报文" class="headerlink" title="1.4.2 响应报文"></a>1.4.2 响应报文</h5><figure class="highlight http"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs http">行HTTP/1.1  200 (404,403,401,500,200)  OK<br>头Content-Type: texy/html;charset=utf-8<br> Content-length: 2048<br> Content-encoding: gzip<br>空行<br>体&lt;html&gt;<br>&lt;head&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>&lt;h1&gt;张艺兴&lt;/h1&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></div></td></tr></table></figure><p>安装 node.js</p><p>安装 Express：基于 Node.js 的 web开发框架</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">// 初始化npm<br>npm init --yes<br>// 安装 express 框架<br>npm install express<br></code></pre></div></td></tr></table></figure><p>设置服务端  server.js</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 1. 引入express</span><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><br><span class="hljs-comment">// 2. 创建应用对象</span><br><span class="hljs-keyword">const</span> app = express();<br><br><span class="hljs-comment">// 3. 创建路由规则</span><br><span class="hljs-comment">// request  对请求报文的封装</span><br><span class="hljs-comment">// response 对相应报文的封装</span><br>app.get(<span class="hljs-string">&#x27;/server&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 设置相应头 设置允许跨域</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    <span class="hljs-comment">// 响应头 设置允许接受自定义相应头</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-comment">// 设置响应</span><br>    <span class="hljs-comment">// response.send(&#x27;HELLO EXPRESS&#x27;);</span><br>    <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>&#125;<br>  response.send(<span class="hljs-built_in">JSON</span>.stringify(data));<br>&#125;);<br><br><span class="hljs-comment">// 4. 监听端口启动服务</span><br>app.listen(<span class="hljs-number">8000</span>, <span class="hljs-function">()=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;服务已经启动， 8000 端口接听中....&quot;</span>);<br>&#125;)<br></code></pre></div></td></tr></table></figure><p>启动 web服务端 cd到对应文件夹打开终端</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">node server<span class="hljs-selector-class">.js</span><br></code></pre></div></td></tr></table></figure><p>nodemon 工具：帮助我们重启服务</p><p><a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a> 官网</p><p>终端输入 安装</p><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">npm install -g nodemon<br></code></pre></div></td></tr></table></figure><h3 id="二、jQuery-AJAX"><a href="#二、jQuery-AJAX" class="headerlink" title="二、jQuery AJAX"></a>二、jQuery AJAX</h3><h4 id="2-1-导入jQuery"><a href="#2-1-导入jQuery" class="headerlink" title="2.1 导入jQuery"></a>2.1 导入jQuery</h4><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h4 id="2-2-jQuery发送AJAX"><a href="#2-2-jQuery发送AJAX" class="headerlink" title="2.2 jQuery发送AJAX"></a>2.2 jQuery发送AJAX</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$.get(<span class="hljs-string">&#x27;http://127.0.0.1:8000/jquery-serve&#x27;</span>, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">100</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">200</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>&#125;, <span class="hljs-string">&#x27;json&#x27;</span>)<br></code></pre></div></td></tr></table></figure><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$.post(<span class="hljs-string">&#x27;http://127.0.0.1:8000/jquery-serve&#x27;</span>, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">100</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">200</span>&#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(data);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$.ajax(&#123;<br>    <span class="hljs-comment">// url</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;http://127.0.0.1:8000/jquery-serve&#x27;</span>,<br>    <span class="hljs-comment">// 参数</span><br>    <span class="hljs-attr">data</span>: &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">100</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">200</span>&#125;,<br>    <span class="hljs-comment">// 请求类型</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">&#x27;GET&#x27;</span>,<br>    <span class="hljs-comment">// 响应体结果</span><br>    <span class="hljs-attr">dataType</span>: <span class="hljs-string">&#x27;json&#x27;</span>,<br>    <span class="hljs-comment">// 成功的回调</span><br>    <span class="hljs-attr">success</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(data);<br>    &#125;,<br>    <span class="hljs-comment">// 超时时间</span><br>    <span class="hljs-attr">timeout</span>: <span class="hljs-number">2000</span>,<br>    <span class="hljs-comment">// 失败的回调</span><br>    <span class="hljs-attr">error</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;出错了！&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">c</span>:<span class="hljs-number">300</span>,<br>        <span class="hljs-attr">d</span>:<span class="hljs-number">400</span><br>    &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// jQuery 服务</span><br>app.all(<span class="hljs-string">&#x27;/jquery-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 设置相应头 设置允许跨域</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span><br>    <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>&#125;<br>    response.send(<span class="hljs-built_in">JSON</span>.stringify(data));<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="三、Axios"><a href="#三、Axios" class="headerlink" title="三、Axios"></a>三、Axios</h3><h4 id="3-1-引入Axios"><a href="#3-1-引入Axios" class="headerlink" title="3.1 引入Axios"></a>3.1 引入Axios</h4><h5 id="script标签引入Axios"><a href="#script标签引入Axios" class="headerlink" title="script标签引入Axios"></a>script标签引入Axios</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html">// crossorigin=&quot;anonymous&quot; 页面报错可以加<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">crossorigin</span>=<span class="hljs-string">&quot;anonymous&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><h5 id="npm-下载"><a href="#npm-下载" class="headerlink" title="npm 下载"></a>npm 下载</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">npm install axios<br></code></pre></div></td></tr></table></figure><h4 id="3-2-发送AJAX请求"><a href="#3-2-发送AJAX请求" class="headerlink" title="3.2 发送AJAX请求"></a>3.2 发送AJAX请求</h4><h5 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios.get(<span class="hljs-string">&#x27;http://127.0.0.1:8000/axios-serve&#x27;</span>, &#123;<br>    <span class="hljs-comment">// url参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">id</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">7</span><br>    &#125;,<br>    <span class="hljs-comment">// 请求头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-number">20</span><br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(value);<br>&#125;)<br></code></pre></div></td></tr></table></figure><h5 id="post-1"><a href="#post-1" class="headerlink" title="post"></a>post</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">btns[<span class="hljs-number">1</span>].onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    axios.post(<span class="hljs-string">&#x27;/axios-serve&#x27;</span>, &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>    &#125;, &#123;<br>        <span class="hljs-comment">// url参数</span><br>        <span class="hljs-attr">params</span>: &#123;<br>            <span class="hljs-attr">id</span>: <span class="hljs-number">200</span>,<br>            <span class="hljs-attr">vip</span>: <span class="hljs-number">9</span><br>        &#125;,<br>        <span class="hljs-comment">// 请求头信息</span><br>        <span class="hljs-attr">headers</span>: &#123;<br>            <span class="hljs-attr">height</span>: <span class="hljs-number">180</span>,<br>            <span class="hljs-attr">weight</span>: <span class="hljs-number">180</span><br>        &#125;<br>    &#125;);<br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="ajax-1"><a href="#ajax-1" class="headerlink" title="ajax"></a>ajax</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">axios(&#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-comment">// url</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">&#x27;/axios-serve&#x27;</span>,<br>    <span class="hljs-comment">// url参数</span><br>    <span class="hljs-attr">params</span>: &#123;<br>        <span class="hljs-attr">vip</span>: <span class="hljs-number">10</span>,<br>        <span class="hljs-attr">leave</span>: <span class="hljs-number">30</span><br>    &#125;,<br>    <span class="hljs-comment">// 头信息</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">a</span>: <span class="hljs-number">100</span>,<br>        <span class="hljs-attr">b</span>: <span class="hljs-number">200</span><br>    &#125;,<br>    <span class="hljs-comment">// 请求体参数</span><br>    <span class="hljs-attr">data</span>: &#123;<br>        <span class="hljs-attr">username</span>: <span class="hljs-string">&#x27;admin&#x27;</span>,<br>        <span class="hljs-attr">password</span>: <span class="hljs-string">&#x27;admin&#x27;</span><br>    &#125;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>    <span class="hljs-comment">// 响应状态码</span><br>    <span class="hljs-built_in">console</span>.log(response.status);<br>    <span class="hljs-comment">// 响应状态字符串</span><br>    <span class="hljs-built_in">console</span>.log(response.statusText);<br>    <span class="hljs-comment">// 响应头信息</span><br>    <span class="hljs-built_in">console</span>.log(response.headers);<br>    <span class="hljs-comment">// 响应体</span><br>    <span class="hljs-built_in">console</span>.log(response.data);<br>&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// Axios 服务</span><br>app.all(<span class="hljs-string">&#x27;/axios-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>  <span class="hljs-comment">// 设置相应头 设置允许跨域</span><br>  response.setHeader(<span class="hljs-string">&#x27;Access-control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>  response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>  response.send(<span class="hljs-string">&#x27;Hello Axios AJAX&#x27;</span>);<br>  <span class="hljs-comment">// const data = &#123;name: &#x27;张艺兴&#x27;&#125;</span><br>  <span class="hljs-comment">// response.send(JSON.stringify(data));</span><br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="四、使用fetch函数"><a href="#四、使用fetch函数" class="headerlink" title="四、使用fetch函数"></a>四、使用fetch函数</h3><h4 id="使用-fetch-请求"><a href="#使用-fetch-请求" class="headerlink" title="使用 fetch 请求"></a>使用 fetch 请求</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fetch(<span class="hljs-string">&#x27;http://127.0.0.1:8000/fetch-serve?vip=10&#x27;</span>, &#123;<br>    <span class="hljs-comment">// 请求方法</span><br>    <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>    <span class="hljs-comment">// 请求头</span><br>    <span class="hljs-attr">headers</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>    &#125;,<br>    <span class="hljs-comment">// 请求体</span><br>    <span class="hljs-attr">body</span>: <span class="hljs-string">&#x27;username=admin&amp;password=admin&#x27;</span><br>&#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// return response.text();</span><br>    <span class="hljs-keyword">return</span> response.json();<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(response);<br>&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// fetch 服务</span><br>app.all(<span class="hljs-string">&#x27;/fetch-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 设置相应头 设置允许跨域</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-control-Allow-Origin&#x27;</span>,<span class="hljs-string">&#x27;*&#x27;</span>);<br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-comment">// response.send(&#x27;Hello Fetch AJAX&#x27;);</span><br>    <span class="hljs-keyword">const</span> data = &#123;<span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>&#125;<br>    response.send(<span class="hljs-built_in">JSON</span>.stringify(data));<br>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="五、跨域"><a href="#五、跨域" class="headerlink" title="五、跨域"></a>五、跨域</h3><h4 id="5-1-同源策略-Same-Origin-Policy"><a href="#5-1-同源策略-Same-Origin-Policy" class="headerlink" title="5.1 同源策略 (Same-Origin Policy)"></a>5.1 同源策略 (Same-Origin Policy)</h4><p>最早由 Netscape 公司提出，是浏览器的一种安全策略。</p><p>同源：协议、域名、端口号 必须完全相同。</p><p>违背同源策略就是跨域。</p><h4 id="5-2-如何解决跨域"><a href="#5-2-如何解决跨域" class="headerlink" title="5.2 如何解决跨域"></a>5.2 如何解决跨域</h4><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><ol><li><p>JSONP 是什么</p><p>JSONP(JSONP with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。</p></li><li><p>JSONP 怎么工作的？</p><p>在网页有一些标签天生具有跨域能力，比如：img link iframe script</p><p>利用 script 标签的跨域能力来发送请求的。</p></li></ol><h6 id="使用-jsonp-跨域"><a href="#使用-jsonp-跨域" class="headerlink" title="使用 jsonp 跨域"></a>使用 jsonp 跨域</h6><p>index.html：</p><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">    <span class="hljs-comment">// 处理数据</span></span><br><span class="javascript">    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span>(<span class="hljs-params">data</span>) </span>&#123;</span><br><span class="javascript">        <span class="hljs-comment">// 获取 result 元素</span></span><br><span class="javascript">        <span class="hljs-keyword">const</span> result = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;result&#x27;</span>);</span><br><span class="javascript">        result.innerHTML = data.name;</span><br><span class="javascript">    &#125;</span><br><span class="javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment">&lt;!-- &lt;script src=&quot;./js/app.js&quot;&gt;&lt;/script&gt; --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://127.0.0.1:8000/jsonp-serve&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure><p>app.js：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> data = &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴帅&#x27;</span><br>&#125;;<br><br>handle(data);<br></code></pre></div></td></tr></table></figure><p>server.js：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// jsonp 服务</span><br>app.all(<span class="hljs-string">&#x27;/jsonp-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span><br>    <span class="hljs-keyword">const</span> data = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴帅&#x27;</span><br>    &#125;;<br>    <span class="hljs-comment">// 见这个字符串转化为字符串</span><br>    <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(data);<br>    <span class="hljs-comment">// 返回结果</span><br>    response.end(<span class="hljs-string">`handle(<span class="hljs-subst">$&#123;str&#125;</span>)`</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h6 id="jQuery-发送-JSONP-请求"><a href="#jQuery-发送-JSONP-请求" class="headerlink" title="jQuery 发送 JSONP 请求"></a>jQuery 发送 JSONP 请求</h6><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$.getJSON(<span class="hljs-string">&#x27;http://127.0.0.1:8000/jquery-jsonp-serve?callback=?&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">data</span>) </span>&#123;<br>    $(<span class="hljs-string">&#x27;#result&#x27;</span>).html(<span class="hljs-string">`</span><br><span class="hljs-string">        名称：<span class="hljs-subst">$&#123;data.name&#125;</span>&lt;br&gt;</span><br><span class="hljs-string">        校区：<span class="hljs-subst">$&#123;data.city&#125;</span></span><br><span class="hljs-string">    `</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.all(<span class="hljs-string">&#x27;/jquery-jsonp-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span><br>    <span class="hljs-keyword">const</span> data = &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;张艺兴&#x27;</span>,<br>        <span class="hljs-attr">city</span>: [<span class="hljs-string">&#x27;LAY&#x27;</span>, <span class="hljs-string">&#x27;AGONI&#x27;</span>, <span class="hljs-string">&quot;AGONILAY&quot;</span>]<br>    &#125;;<br>    <span class="hljs-comment">// 见这个字符串转化为字符串</span><br>    <span class="hljs-keyword">let</span> str = <span class="hljs-built_in">JSON</span>.stringify(data);<br>    <span class="hljs-comment">// 接收 callback 参数</span><br>    <span class="hljs-keyword">let</span> cb = request.query.callback;<br>    <span class="hljs-comment">// 返回结果</span><br>    response.end(<span class="hljs-string">`<span class="hljs-subst">$&#123;cb&#125;</span>(<span class="hljs-subst">$&#123;str&#125;</span>)`</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><ol><li><p>CORS 是什么</p><p>CORS (Cross-Origin Resource Sharing)，跨域资源共享。是官方的跨域解决方案。</p><p>特点：不需要再客户端做任何特殊的操作，完全在服务器中进行处理，支持 get  和 post 请求。</p></li><li><p>CORS 是怎么工作的</p><p>通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p></li><li><p>CORS 的使用</p><p>主要是服务器端的设置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">app.all(<span class="hljs-string">&#x27;/cors-serve&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">request, response</span>)=&gt;</span>&#123;<br>    <span class="hljs-comment">// 设置响应头</span><br>    response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br>    <span class="hljs-comment">// response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://127.0.0.1:5500&#x27;)</span><br><br>    response.send(<span class="hljs-string">&#x27;hello cors&#x27;</span>);<br>&#125;);<br></code></pre></div></td></tr></table></figure><p>一般还会设置：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 设置响应头部</span><br>response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br><span class="hljs-comment">// 设置响应方法</span><br>response.setHeader(<span class="hljs-string">&#x27;Access-Control-Allow-Method&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>)<br></code></pre></div></td></tr></table></figure></li></ol><p>笔记CSDN博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118693841">https://blog.csdn.net/qq_58163927/article/details/118693841</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>Ajax</tag>
      
      <tag>axios</tag>
      
      <tag>跨域</tag>
      
    </tags>
    
  </entry>
  
  
  
  
  
  
  <entry>
    <title>about</title>
    <link href="/"/>
    <url>/</url>
    
    <content type="html"><![CDATA[<p style="text-align: center; color: #8EC0E4; font-size: 1.5rem; font-weight: bold;">AgoniLay 的 小空间</p><h3 style="text-align: center; color: #efb9b9;">    热爱轮滑</h3><div style="text-align: center;">    <img src="/about/lh3.jpg?aboutimg" class="normal" title="山西职业建筑学院新生赛" width="100%" style="margin-bottom: 1.2rem;">    <img src="/about/lh2.jpg?aboutimg" class="normal small" title="很多年前中北科学楼大合照">    <img src="/about/lh4.jpg?aboutimg" class="normal small" title="森林公园团日活动"></div><style>    * {        padding: 0;        margin: 0;    }    img.small {        height: 12rem;    }    img.normal {        border-radius: 20px;        box-shadow: 2px 2px 5px #999, -2px -2px 10px #999;    }    img.normal:hover {        box-shadow: 4px 4px 10px #efb9b9, -4px -4px 10px #efb9b9;        transform: scale(1.02, 1.02);        transition: all .5s;    }</style><h3 style="text-align: center; color: #efb9b9;">热爱饥荒</h3><div class="banner_dontstarve">    <img class="dontstarve" src="/about/dontstarve1.png">    <img class="dontstarve" src="/about/dontstarve2.png">    <img class="dontstarve" src="/about/dontstarve3.png">    <img class="dontstarve" src="/about/dontstarve4.png">    <img class="dontstarve" src="/about/dontstarve5.png">    <img class="dontstarve" src="/about/dontstarve6.png"></div><style>    .banner_dontstarve {        width: 100%;        overflow-x: auto;        overflow-y: none;        display: flex;        margin-top: 2rem;        padding: 0.5rem;    }    .dontstarve {        width: 20rem;        margin-right: 1rem;        border-radius: 5px;    }</style><h3 style="text-align: center; color: #efb9b9;">喜欢海贼王</h3><h4 style="text-align: center; color: #e58a8a;">背后の伤痕是剑士の耻辱</h4><h3 style="text-align: center; color: #efb9b9;">喜欢张艺兴<h4 style="text-align: center; color: #e58a8a;">无需多言</h4><h3 style="text-align: center; color: #efb9b9;">爱😘郑佳丽</h3><div id="lover_wrap">    <!-- 包裹所有元素的容器 -->    <div class="cube">        <!--前面图片 -->        <div class="out_front">            <img src="/about/lover1.jpg" class="pic">        </div>        <!--后面图片 -->        <div class="out_back">            <img src="/about/lover2.jpg" class="pic">        </div>        <!--左图片 -->        <div class="out_left">            <img src="/about/lover3.jpg" class="pic">        </div>        <div class="out_right">            <img src="/about/lover4.jpg" class="pic">        </div>        <div class="out_top">            <img src="/about/lover5.jpg" class="pic">        </div>        <div class="out_bottom">            <img src="/about/lover6.jpg" class="pic">        </div>        <!--小正方体 -->         <span class="in_front">            <img src="/about/lover1.jpg" class="in_pic">        </span>        <span class="in_back">            <img src="/about/lover1.jpg" class="in_pic">        </span>        <span class="in_left">            <img src="/about/lover1.jpg" class="in_pic">        </span>        <span class="in_right">            <img src="/about/lover1.jpg" class="in_pic">        </span>        <span class="in_top">            <img src="/about/lover1.jpg" class="in_pic">        </span>        <span class="in_bottom">            <img src="/about/lover1.jpg" class="in_pic">        </span>    </div></div><style>    /*最外层容器样式*/    #lover_wrap {        position: relative;        width: 300px;        height: 300px;        margin: 6rem auto 12rem;        /*改变左右上下,图片方块移动*/        z-index: 99;    }    /*包裹所有容器样式*/    .cube {        min-width: 300px;        min-height: 300px;        margin: 0 auto;        transform-style: preserve-3d;        transform: rotateX(-30deg) rotateY(-80deg);        -webkit-animation: rotate 20s infinite;        /*匀速*/        animation-timing-function: linear;    }    @-webkit-keyframes rotate {        from{transform: rotateX(0deg) rotateY(0deg);}        to{transform: rotateX(360deg) rotateY(360deg);}    }    .cube div {        position: absolute;        width: 100%;        height: 100%;        opacity: 0.8;        transition: all .4s;    }    /*定义所有图片样式*/    .pic{        width: 300px;        height: 300px;    }    .cube .out_front{        transform: rotateY(0deg) translateZ(150px);    }    .cube .out_back{        transform: translateZ(-150px) rotateY(180deg);    }    .cube .out_left{        transform: rotateY(90deg) translateZ(150px);    }    .cube .out_right{        transform: rotateY(-90deg) translateZ(150px);    }    .cube .out_top{        transform: rotateX(90deg) translateZ(150px);    }    .cube .out_bottom{        transform: rotateX(-90deg) translateZ(150px);    }    /*定义小正方体样式*/    .cube span{        display: bloack;        width: 150px;        height: 150px;        position: absolute;        top: 75px;        left: 75px;    }    .cube .in_pic{        width: 150px;        height: 150px;    }    .cube .in_front{        transform: rotateY(0deg) translateZ(75px);    }    .cube .in_back{        transform: translateZ(-75px) rotateY(180deg);    }    .cube .in_left{        transform: rotateY(90deg) translateZ(75px);    }    .cube .in_right{        transform: rotateY(-90deg) translateZ(75px);    }    .cube .in_top{        transform: rotateX(90deg) translateZ(75px);    }    .cube .in_bottom{        transform: rotateX(-90deg) translateZ(75px);    }    /*鼠标移入后样式*/    .cube:hover .pic {        max-width: none;        width: 500px;        height: 500px;    }    .cube:hover span {        box-shadow: 2px 2px 5px 0 gold;    }    .cube:hover .out_front{        transform: rotateY(0deg) translateZ(400px) translateX(-100px) translateY(-100px);    }    .cube:hover .out_back{        transform: translateZ(-400px) rotateY(180deg) translateX(-100px) translateY(-100px);    }    .cube:hover .out_left{        transform: rotateY(90deg) translateZ(400px) translateX(-100px) translateY(-100px);    }    .cube:hover .out_right{        transform: rotateY(-90deg) translateZ(400px) translateX(-100px) translateY(-100px);    }    .cube:hover .out_top{        transform: rotateX(90deg) translateZ(400px) translateX(-100px) translateY(-100px);    }    .cube:hover .out_bottom{        transform: rotateX(-90deg) translateZ(400px) translateX(-100px) translateY(-100px);    }</style><img src="/about/onepiece-loading2.gif" class="onepiece_footer"><style>    .py-5, #board {        padding-bottom: 0!important;    }    .onepiece_footer {        position: absolute;        bottom: 0;        right: 0;        width: 100%;        border-radius: 0 0 2rem 2rem;    }</style></h3>]]></content>
    
  </entry>
  
  
  
</search>
