<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试知识总结 | AgoniLay的博客</title><meta name="keywords" content="前端,面试"><meta name="author" content="AgoniLay"><meta name="copyright" content="AgoniLay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP 和 HTTPS基本概念 HTTP（HyperText Transfer Protocol）：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS（HyperText Transfer Protocol Secure）：超文本传输安全协议，是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL（Security">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试知识总结">
<meta property="og:url" content="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="AgoniLay的博客">
<meta property="og:description" content="HTTP 和 HTTPS基本概念 HTTP（HyperText Transfer Protocol）：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS（HyperText Transfer Protocol Secure）：超文本传输安全协议，是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL（Security">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe">
<meta property="article:published_time" content="2022-04-11T07:34:22.000Z">
<meta property="article:modified_time" content="2022-05-06T17:49:26.651Z">
<meta property="article:author" content="AgoniLay">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe"><link rel="shortcut icon" href="/img/zoro3.jpg"><link rel="canonical" href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?050530911bbf514fb098003dafd2a51e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试知识总结',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-05-07 01:49:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/zoro3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AgoniLay的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试知识总结</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T07:34:22.000Z" title="发表于 2022-04-11 15:34:22">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-05-06T17:49:26.651Z" title="更新于 2022-05-07 01:49:26">2022-05-07</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>113分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试知识总结"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>HTTP（HyperText Transfer Protocol）：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的<strong>超文本传输协议</strong>；</li>
<li>HTTPS（HyperText Transfer Protocol Secure）：超文本传输安全协议，是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL（Security Socket Later）层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>
</ul>
<h3 id="区别以及优缺点"><a href="#区别以及优缺点" class="headerlink" title="区别以及优缺点"></a>区别以及优缺点</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTTP 协议安全，https 是具有安全性的 ssl 的加密传输协议，可以防止数据在传输过程中被窃取、改变，确保数据的完整性；</li>
<li>http 协议的默认端口是 80，https 是 443；</li>
<li>http 的连接比较简单，是无状态的；https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10% ~ 20% 的耗电；</li>
<li>https 缓存没有 http 高效，会增加数据开销；</li>
<li>https 协议需要 CA 证书，费用较高，功能越强大的证书费用越高；</li>
<li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPv4 资源支持不了这种消耗。</li>
</ul>
<h3 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求服务器<strong>建立 SSL 链接</strong>；</li>
<li>服务器接收到客户端的请求后，会<strong>将网站的证书（包含公钥）传输给客户端</strong>；</li>
<li>客户端和服务端开始<strong>协商 SSL 链接的安全等级</strong>，也就是加密等级；</li>
<li>客户端浏览器通过双方协商一致的安全等级，<strong>建立会话密钥</strong>，然后通过网站的公钥来加密会话密钥，并传送给服务器；</li>
<li>服务器<strong>通过自己的私钥解密出会话密钥</strong>；</li>
<li>服务器<strong>通过会话密钥加密与客户端之间的通信</strong>。</li>
</ol>
<h3 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h3><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>简单快速：统一资源符，资源地址是固定的，请求资源只需要传送对应的路径和方法；</li>
<li>灵活：HTTP 允许传输任意类型的数据对象，同一个 HTTP 协议可以完成不同数据类型的传输；</li>
<li>无连接：每次处理请求之后，链接就会断开，不会一直处于链接状态；</li>
<li>无状态：无状态是指协议对于事务处理没有记忆能力，每次请求处理处理完断开后，没有记录信息，客户端再次请求，服务端也不能识别是否是同一个客户端。</li>
</ul>
<h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><ul>
<li><strong>GET</strong>：请求资源</li>
<li><strong>POST</strong>：传输资源</li>
<li>HEAD：获取报文首部数据</li>
<li>PUT：更新资源</li>
<li>DELETE：删除资源</li>
</ul>
<p><strong>POST 和 GET 的区别</strong>：</p>
<ol>
<li>GET 在浏览器回退时无害，而 POST 会再次提交请求；</li>
<li>GET 请求会被浏览器主动缓存，POST 若未手动设置则不会保存；</li>
<li>GET 请求参数会被完整保留在浏览器历史记录中，POST 不会保存；</li>
<li>GET 请求在 URL 中传递的参数是有长度限制的，POST 没有；</li>
<li>GET 参数通过 URL 传递，POST 放在 Request Body 中；</li>
<li>GET 产生的 URL 地址可以收藏，POST 不可以；</li>
<li>对参数的数据类型，GET 只接受 ASCII 字符，POST 没有限制；</li>
<li>GET 比 POST 更不安全，GET 参数都暴露在 URL 上，不能用来传递敏感信息</li>
</ol>
<h4 id="状态码"><a href="#状态码" class="headerlink" title="状态码"></a>状态码</h4><p>1xx（临时响应）：</p>
<ul>
<li>100（Continue）：继续提出请求，表示服务器已收到请求的一部分，正在等待其余部分</li>
<li>101（Switching Protocols）：切换协议，请求者已要求服务器切换协议，服务器已确认并准备切换</li>
<li>102（Processing）：继续执行，代表处理将被继续执行</li>
</ul>
<p>2xx（成功）：</p>
<ul>
<li><strong>200</strong>（OK）：成功，服务器已成功处理了请求</li>
<li>201（Created）：已创建，请求成功并且服务器创建了新的资源</li>
<li>202（Accepted）：已接受，服务器已接收请求，但尚未处理</li>
<li>203（Non-Authoritative Information）：非授权信息，服务器已成功处理，但返回的信息可能来自其他来源</li>
<li><strong>204</strong>（No Content）：无内容，服务器已成功处理，但没有返回任何内容</li>
<li>205（Reset Content）：重置内容，服务器已成功处理，但没有返回任何内容</li>
<li><strong>206</strong>（Partical Content）：部分内容，客户端发送了一个带有 Range 的 GET 请求，服务器成功处理了部分 GET 请求</li>
<li>207：多种状态，代表之后的消息体是一个 XML 消息</li>
</ul>
<p>3xx（重定向）：</p>
<ul>
<li>300（Multiple Choices）：多种选择，针对请求，服务器可执行多种操作；</li>
<li><strong>301</strong>（Moved Permanently）：<strong>永久重定向</strong> </li>
<li><strong>302</strong>（Found，Moved Temporatily）：<strong>临时重定向</strong>，需假定当原先请求是 GET 时才会自动进行重定向</li>
<li><strong>303</strong>（See Other）：查看其他位置，<u>类似于 301/302</u>，不同之处在于，<u>若原先的请求是 POST，Location 头指定的重定向目标文档应通过 GET 提取</u> </li>
<li><strong>304</strong>（Not Modified）：<strong>未修改</strong>，自上次请求后，请求的网页未修改过</li>
<li>305（Use Proxy）：使用代理，请求者只能使用代理访问请求的网页</li>
<li>306（Switch Proxy）：已废弃</li>
<li><strong>307</strong>（Temporary Redirtct）：临时重定向，和 302 相同，<u>排除了是 POST 请求却错误使用 302，而不使用 303 的情况</u> </li>
</ul>
<p>4xx（请求错误）：</p>
<ul>
<li><strong>400</strong>（Bad Request）：错误请求，服务器不了解请求的语法</li>
<li><strong>401</strong>（Unauthorized）：未授权，请求要求身份认证</li>
<li><strong>403</strong>（Forbidden）：<strong>资源不可用</strong>，服务器理解客户端的请求，但拒绝处理</li>
<li><strong>404</strong>（Not Found）：<strong>未找到</strong>，服务器找不到请求的网页</li>
<li>405（Method Not Allowed）：方法禁用</li>
<li>406（Not Acceptable）：不接受，指定的资源已找到，但 MIME 类型和 Accept 中所指定的不兼容</li>
<li>407（Proxy Authentication Required）：需要代理授权，类似于 401，需经过代理服务器的授权</li>
<li>408（Request Timeout）：<strong>请求超时</strong>，可以在之后重复同一请求</li>
<li>409（Conflict）：冲突，通常和 PUT 请求有关，请求和资源的当前状态冲突 导致请求不能成功</li>
<li>410（Gone）：请求的文档已不可再用，且不知应重定向至哪个地址。与 404 的区别在于：410 表示文档已永久离开指定位置，而 404 指文档因未知的原因不可用</li>
<li>411（Length Required）：服务器不能处理请求，除非客户端发送一个 Content-Length 头</li>
<li>412（Precondition Failed）：请求头中指定的一些前提条件失败</li>
<li><strong>413</strong>（Request Entity Too Large）：目标文档的大小超过服务器当前可处理的大小，若服务器认为可以稍后处理则应该提供一个 Retry-After 头</li>
<li><strong>414</strong>（Request URI Too Long）：URI 太长</li>
<li>415（Unsupported Media Type）：对于当前请求的方法和所请求的资源，请求中提交的实体并不是服务器中所支持的格式</li>
<li>416（Requested Range Not Satisfiable）：服务器不能满足客户在请求中指定的 Range 头</li>
</ul>
<p>5xx（服务器错误）：</p>
<ul>
<li><strong>500</strong>（Internal Server Error）：服务器内部错误</li>
<li>501（Not Implemented）：服务器不支持实现请求所需要的功能</li>
<li>502（Bad Gateway）：错误网关</li>
<li><strong>503</strong>（Service Unavailable）：服务器由于维护或者负载过重未能应答</li>
<li>504（Gateway Timeout）：网关超时</li>
<li>505（HTTP Version Not Supported）：HTTP 版本不受控制</li>
</ul>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ol>
<li>第一次握手：建立连接时，客户端发送 <code>SYN</code> 包（SYN = j）到服务器，并进入 <code>SYN_SENT</code> 状态，等待服务器确认（SYN：同步序列编号，Synchronize Sequence Numbers）；</li>
<li>第二次握手：服务器收到 <code>SYN</code> 包并确认客户端的 <code>SYN</code>（ACK = j + 1），同时也发送一个自己的 <code>SYN</code> 包（SYN = k），即 SYN + ACK 包，此时服务器进入 <code>SYN_RECV</code>，（ACK：确认应答报文）；</li>
<li>第三次握手：客户端收到服务器的 <code>SYN + ACK</code> 包，向服务器发送确认包 <code>ACK</code>（ACK = k + 1），此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（TCP 连接成功）状态，完成三次握手。</li>
</ol>
<blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
</blockquote>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol>
<li><strong>客户端进程发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN = 1，其序列号为 seq = u（的等于之前已经传送过来的数据的最后一个字节的序号加 1），此时，<strong>客户端进入 FIN-WAIT-1(终止等待 1)状态</strong>；</li>
<li><strong>服务器收到连接释放报文，发出确认报文</strong>，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，<strong>服务端就进入了 CLOSE-WAIT(关闭等待)状态</strong>；</li>
<li>客户端收到服务器的确认请求后，此时，<strong>客户端就进入 FIN-WAIT-2(终止等待 2)状态</strong>，等待服务器发送连接释放报文；</li>
<li><strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</strong>，FIN = 1，ack = u + 1，由于在半关闭状态，服务器可能又发送了一部分数据，此时的序列号是 seq = w，此时，<strong>服务器就进入了 LAST-ACK(最后确认)状态</strong>，等待客户端的确认；</li>
<li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong>，ACK = 1，ack = w + 1，自己的序列号是 seq = u + 1，此时，<strong>客户端就进入了 TIME-WAIT(时间等待)状态</strong>，此时 TCP 连接还没有释放，必须经过 2**MSL(最长报文段寿命)的时间后，<strong>当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>；</li>
<li>服务器只要收到了客户端发出的确认，<strong>立即进入 CLOSED 状态</strong>。同样，撤销 TCB 后，就结束了这次的 TCP 连接，服务器结束 TCP 连接要比客户端稍早一些。</li>
</ol>
<h3 id="保证数据包传输的有序可靠"><a href="#保证数据包传输的有序可靠" class="headerlink" title="保证数据包传输的有序可靠"></a>保证数据包传输的有序可靠</h3><p>对字节流分段并进行编号然后 <code>通过 ACK 回复</code> 和 <code>超时重发</code> 两个机制来保证：</p>
<ul>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包留在缓存区；</li>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
<li>如在定时器超时之前收到了对方的应答信息，则释放改数据包占用的缓冲区；</li>
<li>否则，重传改数据包，直到收到应答或重传次数超过规定的最大次数为止；</li>
<li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已接收到，如果接收方正好也有数据要发，则应答包可以放在数据包中稍带过去。</li>
</ul>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol>
<li>TCP 是面向<strong>链接</strong>的，而 UDP 是面向无连接的；</li>
<li>TCP 仅支持 <strong>单播传输</strong>，UDP 提供了单播，多播，广播的功能；</li>
<li>TCP 的三次握手保证了连接的<strong>可靠性</strong>；UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收；</li>
<li>UDP 的<strong>头部开销</strong>比 TCP 的更小，数据<strong>传输速率更高，实时性更好</strong>。</li>
</ol>
<h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><h4 id="跨域的原理"><a href="#跨域的原理" class="headerlink" title="跨域的原理"></a>跨域的原理</h4><p>跨域，是指浏览器不能执行其他网址的脚本，是由浏览器的同源策略造成的；</p>
<p>同源策略是一种约定，由 NetSpace 公司 1995 年引入浏览器，是浏览器最核心也是最基本的安全功能，是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，就被当作是非同源；</p>
<p>同源策略限制以下几种行为：</p>
<ul>
<li>Cookie、LocalStorage 和 IndexDB 无法读取</li>
<li>DOM 和 JS 对象无法获得</li>
<li>AJAX 请求不能发送</li>
</ul>
<p>跨域原理，即通过各种方式，避开浏览器的安全限制。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p><strong>JSONP</strong>：</p>
<p>原理：利用 <code>&lt;script&gt;</code> 标签没有跨域限制，通过 <code>src</code> 属性发送带有 callback 参数的 GET 请求，服务器将接口返回数据拼凑到 callback 函数中返回给浏览器，浏览器解析执行，从而前端拿到 callback 函数返回的数据：</p>
<ol>
<li>去创建一个 script 标签</li>
<li>script 的 src 属性设置接口地址</li>
<li>接口参数必须要携带一个自定义函数名，否则后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">script.type = <span class="string">&#x27;text/javascript&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.src = <span class="string">&#x27;http://localhost:3000/?callback=getData&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 srcipt 生效</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script)</span><br></pre></td></tr></table></figure>

<p>服务端返回如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getData(&#123; <span class="string">&quot;success&quot;</span>: <span class="literal">true</span>, <span class="string">&quot;user&quot;</span>: <span class="string">&quot;AgoniLay&quot;</span> &#125;)</span><br></pre></td></tr></table></figure>

<p>缺点：JSON 只支持 GET，因为 script 标签只能使用 get 请求；JSONP 需要后端配合返回指定格式的数据。</p>
<p><strong>CORS</strong>：</p>
<p>CORS（Cross-origin resourse sharing）跨域资源共享，是一个 W3C 标准。</p>
<p>原理：服务器设置 Accesss-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许向跨源服务器发出 XMLHttpRequest 请求。</p>
<blockquote>
<p>需要浏览器和服务器同时支持，IE 10 以上以及主流浏览器均支持。</p>
</blockquote>
<p>浏览器将 CORS 跨域请求分为简单请求和非简单请求：</p>
<p>满足简单请求的条件：</p>
<ul>
<li>使用 head、get、post 之一；</li>
<li>请求的 Header 是以下之一：<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type：application/x-www-form-urlencoded、multipart/form-data、text/plain</li>
</ul>
</li>
</ul>
<p>不同时满足以上两个条件，就属于非简单请求。</p>
<ol>
<li>简单请求：</li>
</ol>
<p>浏览器直接发出 CORS 请求，在头信息中增加一个 Origin 字段，用来说明本次请求来自哪个源（协议+域名+端口），服务器根据这个值来决定是否同意此次请求；</p>
<p>CORS 请求设置的响应头字段均以 Access-Control 开头：</p>
<ol>
<li><strong>Access-Control-Allow-Origin</strong>：必选，值为请求时 Origin 字段的值，或者 <code>*</code> </li>
<li>Access-Control-Allow-Credentials：可选，值为一个布尔值，表示是否允许发送 Cookie</li>
<li>Access-Control-Expose-Headers：可选，CORS 请求时 XMLHttpRequest 对象的 getResponseHeader() 方法只能拿到固定 6 个基本字段（Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma）如果想拿到规定之外的其他字段，则需要在此字段中指定。</li>
</ol>
<p>非简单请求：</p>
<p>指对服务器有特殊要求的请求，如请求方法是 PUt 或 DELETE，或 Content-Type 字段的类型是 application/json；非简单请求的 CORS 请求会在正式通信前增加一次 HTTP 请求查询，称为 “预检”请求（preflight）。</p>
<p>预检请求用的请求方法是 OPTIONS，表示次请求是用来询问的，请求头中关键字段是 Origin，表示请求来自哪个源，还包含：</p>
<ul>
<li>Access-Control-Request-Method：必选，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法；</li>
<li>Access-Control-Request-Headers：可选，值是逗号分隔的一个字符串，指定浏览器 CORS 请求会额外发送的头信息字段；</li>
</ul>
<p>服务器收到预检请求后，检查字段后，确认允许跨域请求，并作出回应，回应中除了关键的 <code>Access-Control-Allow-Origin</code> 字段外，其他相关字段有：</p>
<ul>
<li>Access-Control-Request-Method：必选，逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法；</li>
<li>Access-Control-Request-Headers：若浏览器请求包括 Access-Control-Request-Headers 字段，则此字段必需；值是逗号分隔的一个字符串，表明服务器支持的所有头信息字段，不限于浏览器在预检中请求的字段；</li>
<li>Access-Control-Allow-Credentials：可选，与简单请求相同；</li>
<li>Access-Control-Max-Age：可选，用来指定本次预检请求的有效期，单位为秒。</li>
</ul>
<blockquote>
<p>Nginx 代理跨域原理与 CORS 跨域原理相同，通过配置文件设置请求头响应头 <strong>Access-Control-Allow-Origin</strong> 等字段。</p>
</blockquote>
<p><strong>document.domain + iframe</strong>：</p>
<p>此方案仅限主域名相同，子域名不同的跨域应用场景。原理：两个页面都通过 JS 强制设置 document.domain 为基础子域，就实现了同源。</p>
<p><strong>window.name + iframe</strong>：</p>
<p>利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name，并且可以支持非常长的 name 值（2MB）</p>
<p><strong>location.hash + iframe</strong>：</p>
<p>原理：两页面通过中间页来进行跨域通信，利用 iframe 的 location.hash 传值</p>
<p><strong>postMessage</strong>：</p>
<p>利用 H5 新特性 <code>window.postMessage()</code>，可以解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口数据传递；</li>
<li>多窗口间的消息传递；</li>
<li>页面与嵌套的 iframe 消息传递；</li>
<li>以上三场景的跨域数据传递；</li>
</ul>
<p>接收两个参数：</p>
<ul>
<li>data：支持任意基本类型或可复制的对象，部分浏览器只支持字符串，所以通常使用 JSON.stringify() 进行序列化操作</li>
<li>origin：协议+主机+端口号，也可以设置为 <code>*</code>，表示可以传递给任意窗口；和当前窗口同源设置为 <code>/</code> </li>
</ul>
<p><strong>WebSocket 协议</strong>：</p>
<p>WebSocket protocol 是 HTML5 一种新的协议，实现了浏览器与服务器双工通信，同时允许跨域通讯，是 server push 技术的一种很好的实现；原生 WebSocket API 使用不方便，一般使用 Socket.io（对原生的进行了封装，提供了更简单、灵活的接口，对不支持 WebSocket 的浏览器提供了向下兼容）</p>
<p>proxy 代理：</p>
<p>目前常用的方式，通过服务器设置代理</p>
<h3 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h3><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接受缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<h4 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h4><p>在流传输中出现，UDP 不会出现粘包，因为它有消息边界。</p>
<p>粘包情况有两种，一种是 <strong>粘在一起的包都是完整的数据包</strong>，另一种是 <strong>粘在一起的包有不完整的包</strong>。</p>
<h4 id="避免措施"><a href="#避免措施" class="headerlink" title="避免措施"></a>避免措施</h4><ol>
<li>对于发送方引起的粘包现象，用户可以通过编程设置来避免，<strong>TCP 提供了强制数据立即传送的操作指令 push</strong>，TCP 软件收到改操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<ul>
<li>虽然可以避免发送方引起的粘包，但关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用</li>
</ul>
</li>
<li>对于接收方引起的粘包现象，则可通过优化程序设计、精简接收进程工作量、<strong>提高接收进程优先级</strong>等措施，使其即使接收数据，从而尽量避免出现粘包现象；<ul>
<li>只能减少出现粘包的可能性，并不能完全避免粘包</li>
</ul>
</li>
<li>由接收方控制，将一包数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>分包多发</strong>。<ul>
<li>虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li>
</ul>
</li>
</ol>
<blockquote>
<p>周全的对策：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开，高效可行。</p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="输入-URL-到页面加载"><a href="#输入-URL-到页面加载" class="headerlink" title="输入 URL 到页面加载"></a>输入 URL 到页面加载</h3><ol>
<li>在浏览器地址栏输入 URL；</li>
<li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则直接显示页面内容，如果没有则进行下一步；<ul>
<li>浏览器缓存：浏览器会记录 DNS 一段时间；</li>
<li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的 DNS 查询缓存）；</li>
<li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续 搜索路由器缓存；</li>
<li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li>
</ul>
</li>
<li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址，<strong>DNS 服务器是基于 UDP 的，因此会用到 UDP 协议</strong>；</li>
<li>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接；</li>
<li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该请求作为 TCP 三次握手的第三次数据发送给服务器；</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给服务器</li>
<li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li>
<li>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后进行解析：<ul>
<li>构建 DOM 树：词法分析然后解析成 DOM 树，是由 DOM 元素及属性节点组成，树的根是 document 对象；</li>
<li>构建 CSS 规则树：生成 CSS 规则树（CSSOM）；</li>
<li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，病候检出渲染树（render tree）；</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置；</li>
<li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li>
</ul>
</li>
<li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码：<ul>
<li>创建 window 对象：window 对象也叫全局变量环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，DOM 树也会映射在 window 的 document 对象上；当关闭网页或者浏览器时，全局执行环境会被销毁；</li>
<li>加载文件：JS 引擎分析它的语法和词法是否合法，合法则进入预编译；</li>
<li>预编译：浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并赋值为 <code>undefined</code>；寻找全局函数声明，作为 window 的方法加入到 window 对象中，将函数体赋值给它（匿名函数是不参与预编译的，它是变量）；</li>
<li>解释执行：执行到变量就赋值，若变量未定义，在 ES5 严格模式下此变量会变成 window 的一个属性，也就是成为全局变量；函数执行，就将函数的环境推入一个环境的栈中，执行完成后弹出，交回控制权；</li>
</ul>
</li>
</ol>
<h3 id="重绘与重排"><a href="#重绘与重排" class="headerlink" title="重绘与重排"></a>重绘与重排</h3><ul>
<li>重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，即重排；表现为重新生成布局，重新排列元素；</li>
<li>重绘（Repaint）：当一个元素的外观发生改变，但没有影响布局，重新把元素外观绘制出来的过程，叫重绘；表现为元素的外观被改变。</li>
</ul>
<blockquote>
<p>重绘不一定会出现重排，但重排一定会重绘！</p>
</blockquote>
<p>重排和重绘的代价是高昂的，会破坏用户体验，让 UI 展示非常迟缓，相比之下重排的性能影响更大，两者无法避免的情况下一般选择代价更小的重绘。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>添加、删除、更新 DOM 节点；</li>
<li>通过 <code>display: none</code> 隐藏一个 DOM 节点，触发重排和重绘；</li>
<li>通过 <code>visibility: hidden</code> 隐藏一个 DOM 节点，只触发重绘；</li>
<li>移动或者给页面中的 DOM 节点添加动画；</li>
<li>添加一个样式表，调整样式属性；</li>
<li>用户行为：调整窗口大小、改变字号、滚动等。</li>
</ul>
<h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ol>
<li><p><strong>集中改变样式</strong>，不要一条一条多次修改 DOM 中的样式；</p>
</li>
<li><p>不要把 DOM 节点的属性放在循环里当成循环里的变量；</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会触发整个页面的 reflow 的；</p>
</li>
<li><p>不要使用 table 布局，很小的改动会造成整个 table 的重新布局；</p>
</li>
<li><p>尽量只修改 <code>position: absolute</code> 或 <code>fixed</code> 的元素，影响较小；</p>
</li>
<li><p>动画开启 GPU 加速，translate 使用 3D 变化；</p>
</li>
<li><p>提升为合成层：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他层；</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>提升合成层的最好方式是使用 CSS 的 <code>will-change</code> 属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="304"><a href="#304" class="headerlink" title="304"></a>304</h3><ul>
<li>浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍返回 200，但不会请求数据；</li>
<li>强缓存失效，进入协商缓存阶段，首先验证 ETag，ETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化，服务器根据客户端上送的该资源的最后  If-None-Match 值来判断是否命中缓存；</li>
<li>协商缓存 LastModified/If-Modified-Since 阶段，客户端第一次请求资源时，服务器返回的 header 中会加上 Last-Modified，Last-Modified 标识该资源的最后修改时间，再次请求该资源时，request 的请求头中会包含 If-Modified-Since，为缓存之前返回的 Last-Modified，服务器收到 If-Modified-Since 后，根据资源的最后修改时间判断是否命中缓存。</li>
</ul>
<h3 id="强制缓存-协商缓存"><a href="#强制缓存-协商缓存" class="headerlink" title="强制缓存 协商缓存"></a>强制缓存 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 - 服务器响应该请求。</p>
<p>浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220412153039501.png" class title="第一次发起 HTTP 请求">

<ul>
<li>浏览器每次发起请求，都会<strong>先在浏览器缓存中查找该请求的结果以及缓存标识</strong>；</li>
<li>浏览器每次拿到返回的请求结果都会<strong>将该结果和缓存标识存入浏览器缓存中</strong>。</li>
</ul>
<p>强制缓存：</p>
<p>就是<strong>向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 Cache-Control 优先级更高。</p>
<p>强制缓存的情况主要有三种：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（与首次发请求一致）；</li>
<li>存在该缓存结果和缓存标识，但已失效，强制缓存失效，则使用协商缓存；</li>
<li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li>
</ol>
<p>协商缓存：</p>
<p>就是<strong>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，字段包括：<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>，其中 Etag/If-None-Match 的优先级更高。</p>
<p>情况有两种：</p>
<ol>
<li>协商缓存生效，返回 304；</li>
<li>协商缓存失效，重新发起请求，返回 200 和请求结果。</li>
</ol>
<h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h3><p>进程：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p>
<p>线程：是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。</p>
<ul>
<li>一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成；</li>
<li>进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</li>
</ul>
<p>协程（Coroutines）：是一种基于线程之上，但又比线程更加轻量级的存在。</p>
<p>进程和线程的区别：</p>
<ol>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>并发性：进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行；</li>
<li>拥有资源：进程拥有资源，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>系统开销：创建或撤销进程比线程的开销大，因为系统都要为之分配和回收资源；多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差；</li>
</ol>
<p>联系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有一个或多个线程；</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>处理机分给线程，即真正在处理机上运行的是线程；</li>
<li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<h3 id="Cookie-Session-Token"><a href="#Cookie-Session-Token" class="headerlink" title="Cookie Session Token"></a>Cookie Session Token</h3><h4 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h4><p>Cookie 指浏览器里面能存储的一种数据，仅仅是浏览器实现的一种数据存储功能。</p>
<ul>
<li>cookie 由服务器生成发送给浏览器，浏览器将 cookie 以 key-value 形式保存在某个文本文件内，下次请求同网站时会将该 cookie 发送给服务器；</li>
<li>每个域的 cookie 数量是有限的，均保存在客户端浏览器中；</li>
<li>Cookie 时客户端保存用户信息的一种机制，用来记录用户的一些信息（如登录状态），也是实现 Session 的一种方式；</li>
<li>不同的浏览器由不同的存储大小，但一般不超过 4KB，故只能存储一小段的文本信息。</li>
</ul>
<h4 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h4><p>Session（会话），是另一种记录客户状态的机制，保存在服务端的一种数据结构。</p>
<ul>
<li>主要存储 SessionID 和 Session 内容，可以保存在集群、数据库、文件中，用于跟踪用户的状态；</li>
<li>当客户端浏览器再次访问时，只需要从该 Session 中查找该客户的状态即可；</li>
</ul>
<h4 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h4><p>在大多数使用 Web API 的互联网公司中，token 是多用户下处理认证的最佳方式；</p>
<p>最简单的 Token 组成：</p>
<ul>
<li><strong>uid</strong>（用户唯一的身份标识）</li>
<li><strong>time</strong>（当前时间的时间戳）</li>
<li><strong>sign</strong>（签名，由 Token 的前几位 + 哈希算法压缩成一定长的十六进制字符串，防止恶意第三方拼接 Token 请求服务器）</li>
</ul>
<p>验证原理：基于 Token 的身份验证是<strong>无状态</strong>的，</p>
<ol>
<li>客户端使用用户名跟密码请求登录；</li>
<li>服务器收到请求，验证用户名和密码成功后签发一个 Token 并发送给客户端；</li>
<li>客户端收到后将 Token 存储起来，每次向服务器请求资源时需要带着该 Token；</li>
<li>服务器收到请求后验证请求中带着的 Token，验证成功则返回数据。</li>
</ol>
<p>优势：</p>
<ol>
<li>无状态</li>
<li>安全性：不再发送 cookie，能够防止 CSRF（跨站请求伪造）</li>
<li>可扩展性</li>
<li>多平台跨域</li>
</ol>
<p><strong>Cookie SessionStorage LocalStorage 的异同</strong>：</p>
<p>相同点：</p>
<ul>
<li>均存储在客户端</li>
</ul>
<p>不同点：</p>
<ul>
<li>cookie 数据大小不能超过 4K；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+；</li>
<li>cookie 的设置的过期时间之前一直有效；localStorage 永久储存，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；</li>
<li>cookie 的数据会自动传递到服务器；sessionStorage 和 localStorage 数据保存在本地。</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML5-语义化"><a href="#HTML5-语义化" class="headerlink" title="HTML5 语义化"></a>HTML5 语义化</h3><p>HTML5 的语义化指的是<strong>合理正确的使用语义化的标签来创建页面结构</strong>。</p>
<p>语义化标签包括：</p>
<ul>
<li>header、nav、main、article、section、aside、footer</li>
</ul>
<p>优点：</p>
<ul>
<li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果；</li>
<li>代码结构清晰，易于阅读；</li>
<li>利于开发和维护，方便其他设备解析（如屏幕阅读器），根据语义渲染网页；</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>id 选择器 <code>#</code>、类选择器 <code>.</code>、属性选择器 <code>[a=&quot;b&quot;]</code>、伪类选择器 <code>:</code>、标签选择器 <code>div h1...</code>、相邻选择器 <code>+</code>、子选择器 <code>&gt;</code>、后代选择器 <code>(空格)</code>、通配符选择器 <code>*</code>。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li><code>!important</code></li>
<li>内联样式（1000）</li>
<li>ID 选择器（0100）</li>
<li>类选择器/属性选择器/伪类选择器（0010）</li>
<li>元素选择器/伪元素选择器（0001）</li>
<li>关系选择器/通配符选择器（0000）</li>
</ul>
<p>带 important 标记的样式属性优先级最高；样式表的来源相同时：</p>
<p><code>!important</code> &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p><strong>固定定位 fixed</strong>：元素的位置相对于浏览器窗口是固定位置，即使窗口滚动也不会移动；fixed 定位使元素的位置与文档流无关，因此不占据空间，fixed 定位的元素和其他元素重叠；</p>
<p><strong>相对定位 relative</strong>：如果一个元素相对定位，它将依旧出现在所在的位置上，可以通过设置垂直水平距离让此元素相对于原先的位置进行移动，但元素仍占据原先的空间，会覆盖其他元素；</p>
<p><strong>绝对定位 absolute</strong>：绝对定位的元素的位置相对于最近的已定位父元素，若无已定位的父元素，则位置相对于 body，absolute 定位使元素的位置与文档流无关，因此不占据空间，absolute 定位的元素和其他元素重叠；</p>
<p><strong>粘性定位 sticky</strong>：元素先按照普通文档流定位，相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位，在跨越特定阈值前为相对定位，之后为固定定位；</p>
<p><strong>默认定位 static</strong>：默认值。没有定位，元素出现在正常的流中，忽略 top、bottom、left、right 以及 z-index 声明。</p>
<p>也可以设置为 <code>inherit</code>：来从父元素继承 position 属性的值。</p>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>box-sizing 规定两个并排的带边框的框：</p>
<ul>
<li><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框【标准盒模型】；</li>
<li><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒【IE 盒模型/怪异盒模型】；</li>
<li>inherit：继承父元素的 box-sizing 值</li>
</ul>
<h3 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h3><p>CSS 盒模型本质上是一个盒子，包括：边距、边框、填充盒实际内容；CSS 中的盒模型包括 IE 盒模型和标准 W3C 盒模型。</p>
<ul>
<li>在标准的盒模型中，width 指 <code>content</code> 部分的宽度；</li>
<li>在 IE 盒模型中，width 表示 <code>content + padding + border</code> 三个部分的宽度。</li>
</ul>
<p>总宽度都是 <code>width + margin(左右)</code>，高度同理。</p>
<p>可通过 <code>box-sizing</code> 进行设置，根据计算宽高的区域可以分为：</p>
<ul>
<li><code>content-box</code>：W3C 标准盒模型</li>
<li><code>border-box</code>：IE 盒模型</li>
<li><code>padding-box</code>：FireFox 曾支持</li>
<li><code>margin-box</code>：浏览器未实现</li>
</ul>
<blockquote>
<p>理论上是有四种盒模型，但目前 W3C 和 MDN 规范中均只支持 <code>content-box</code> 与 <code>border-box</code>。</p>
</blockquote>
<h3 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>BFC（Block Formatting Context），块级格式上下文，是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有：</p>
<ul>
<li>内部 box 垂直放置；</li>
<li>计算 BFC 的高度的时候，浮动元素也参与计算。</li>
</ul>
<h4 id="原理布局规则"><a href="#原理布局规则" class="headerlink" title="原理布局规则"></a>原理布局规则</h4><ul>
<li>内部的 Box 会在垂直方向，一个一个的放置；</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；</li>
<li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于默认的从左往右排列的格式）；</li>
<li>BFC 的区域不会与 float box 重叠；</li>
<li>BFC 是一个独立容器，容器里的子元素不会影响到外面的元素；</li>
<li>计算 BFC 高度时，浮动元素也参与计算；</li>
<li>元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box 会参与不同的 <code>Formatting Context</code>。</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>overflow 的值不为 visible</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>去除边距重叠现象；</li>
<li>清除浮动（让父元素的高度包含子浮动元素）；</li>
<li>避免某元素被浮动元素覆盖；</li>
<li>避免多列布局由于宽度计算四舍五入而自动换行。</li>
</ul>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul>
<li>对于行内元素：<code>text-align: center;</code> </li>
<li>对于确定宽度的块级元素：<ul>
<li><code>margin: 0 auto;</code> </li>
<li><code>position: absolute; margin-left: (父width - 子width) / 2;</code>，需要父元素 <code>position: relative;</code> </li>
</ul>
</li>
<li>对于宽度未知的块级元素：<ul>
<li><code>display: table; margin: 0 auto;</code> </li>
<li><code>display: inline-block; text-align: center;</code> </li>
<li><code>position: absolute; left: 50%; transform: translateX(-50%);</code> </li>
<li><code>display: flex; justify-content: center;</code> </li>
</ul>
</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol>
<li><code>inline-height: height;</code> 适合纯文字类；</li>
<li>通过设置父容器相对定位，子元素设置绝对定位，标签通过 margin 实现自适应居中；</li>
<li>弹性布局 flex：父级设置 <code>display: flex;</code>，子级设置 margin 为 auto 实现自适应居中；</li>
<li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现；</li>
<li>利用 table 布局，子级设置 <code>vertical-align: middle;</code>，使用的前提条件：内联元素以及 display 值为 table-cell 的元素</li>
</ol>
<h3 id="隐藏页面中元素"><a href="#隐藏页面中元素" class="headerlink" title="隐藏页面中元素"></a>隐藏页面中元素</h3><ol>
<li><code>opacity: 0</code>，元素变透明，即隐藏，不会改变页面布局，且绑定的一些事件仍然可以触发（如点击事件）；</li>
<li><code>visibility: hidden</code>，同样不会改变页面布局，但无法触发已绑定的事件，隐藏对应元素，在文档布局中仍保留原来的空间；</li>
<li><code>display: none</code>，会改变页面布局，在文档布局中不再分配空间（重排重绘）</li>
</ol>
<h3 id="用-CSS-画三角"><a href="#用-CSS-画三角" class="headerlink" title="用 CSS 画三角"></a>用 CSS 画三角</h3><p><strong>盒子宽高均为零，三面边框均透明</strong>。</p>
<p>利用伪元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid pink;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#css</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">16px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">16px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-5px-边框"><a href="#0-5px-边框" class="headerlink" title="0.5px 边框"></a>0.5px 边框</h3><p>方案一：缩小</p>
<p>利用缩小使得视觉上变为 0.5px：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：兼容性较好，可以设置圆角，<strong>推荐使用</strong>。</p>
<p>方案二：线性渐变</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, transparent);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：适合设置一条边框，无法展示圆角。</p>
<p>方案三：阴影</p>
<p>用阴影代替边框，直接设置阴影为：<code>box-shadow: 0 0 0 0.5px #000</code> </p>
<p>特点：使用方便，能够正常显示圆角，兼容性一般</p>
<p>方案四：直接设置 <code>border-width: 0.5px</code>，兼容性差</p>
<h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒模型提供最大的灵活性，指定 <code>display: flex</code> 即可。</p>
<p>容器属性：</p>
<ul>
<li>flex-direction：决定主轴的方向(即子 item 的排列方法)，取值：<ul>
<li>row | row-reverse | column | column-reverse</li>
</ul>
</li>
<li>flex-wrap：决定换行规则，取值：<ul>
<li>nowrap | wrap | wrap-reverse</li>
</ul>
</li>
<li>flex-flow：flex-direction 和 flex-wrap 的简写形式；</li>
<li>justify-content：水平主轴对齐方式；</li>
<li>align-items：竖直轴线方向对齐方式；</li>
<li>align-content：元素排列大于一行时 align-items 需换成 align-content；</li>
</ul>
<p>元素属性：</p>
<ul>
<li>order：定义项目的排列顺序，默认为 0，越小越靠前；</li>
<li>flex-grow：定义项目的放大比例，即使存在空间，也不会放大；</li>
<li>flex-shrink：定义项目的缩小比例，当空间不足的情况下会等比例的缩小，0 为不缩小；</li>
<li>flex-basis：定义了在分配多余的空间项目所占的空间；</li>
<li>flex：flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 <code>0 1 auto</code>；</li>
<li>align-self：允许单个项目于其他项目不同的对齐方式，可覆盖；</li>
<li>align-items：默认值为 auto，表示继承父元素的 align-items 值。</li>
</ul>
<h4 id="Rem-布局"><a href="#Rem-布局" class="headerlink" title="Rem 布局"></a>Rem 布局</h4><p>Rem 相对于根（html）的 font-size 大小来计算，就是一个相对比例（如：<code>font-size: 10px</code>，那么），rem 布局的本质是等比缩放，一般是基于宽度。</p>
<p>优点：可以快速使用移动端布局，字体，图片高度；</p>
<p>缺点：</p>
<ol>
<li>目前 IE 不支持，对 pc 页面来讲使用次数不多；</li>
<li>数据量大：所有的图片、盒子都需要给一个准确的值，才能保证不同机型的适配；</li>
<li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小，且必须将改变 font-size 的代码放在 css 样式之前。</li>
</ol>
<h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>通过百分比单位 <code>%</code> 来实现响应式的效果，可以使得浏览器中的组件的宽高随着浏览器的变化而变化。</p>
<ul>
<li>height 相对于 height；</li>
<li>width 相对于 width；</li>
<li>padding、bording、margin 等不论是垂直还是水平方向都相对于直接父元素的 width；</li>
<li>除了 border-radius 外，translate、background-szie 等都相对于自身。</li>
</ul>
<p>缺点：计算困难，可能使布局问题复杂</p>
<h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当元素浮动以后可以向左或向右移动，直到它的边缘碰到包含它的框或者另外一个浮动元素的边框为止；元素浮动后会脱离正常的文档流，所以文档的普通流中的框就会变得好像浮动元素不存在一样。</p>
<p>优点：</p>
<ul>
<li>在图文混排的时候可以很好的实现文字环绕图片；</li>
<li>当元素浮动起来后，它有着块级元素的一些性质，如设置宽高；</li>
</ul>
<p>缺点：会造成父级元素高度塌陷，需要进行清除浮动。</p>
<h3 id="圣杯布局-双飞翼布局"><a href="#圣杯布局-双飞翼布局" class="headerlink" title="圣杯布局 双飞翼布局"></a>圣杯布局 双飞翼布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>我是头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>我是尾部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hiddle;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220416103735470.png" class title="圣杯布局">

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle_child&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle_child</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="CSS-单位"><a href="#CSS-单位" class="headerlink" title="CSS 单位"></a>CSS 单位</h3><p>CSS 中单位有 15 种，可以分为：</p>
<ul>
<li>绝对长度<ul>
<li>cm：厘米</li>
<li>mm：毫米</li>
<li>in：寸</li>
<li><strong>px</strong>：像素，网页内常用的单位，也是基本单位；</li>
<li>pt：point 点，大约 1/72 寸</li>
<li>pc：pica 派卡，大约 6pt</li>
</ul>
</li>
<li>相对长度：<ul>
<li>ex：取当前作用效果的字体的高度，无法确定的情况下以 0.5 em 计算</li>
<li>ch：以节点所使用字体的 ‘0’ 字符为基准，找不到时以 0.5em 计算</li>
<li>em：基准点为父节点字体的大小，自身定义了 font-size 则按自身来计算（浏览器默认字体大小是 16px）</li>
<li>rpx：是微信小程序解决自适应屏幕尺寸的单位</li>
<li><strong>rem</strong>：基准点为根元素 html 的字体大小，CSS3 新增</li>
<li><strong>vw</strong>：view width，1vw 代表浏览器视口宽度的 1%</li>
<li><strong>vh</strong>：view height，1vh 代表浏览器视口高度的 1%</li>
<li>vmin：当前 vm 和 vh 中较小的一个值</li>
<li>vmax：当前 vm 和 vh 中较大的一个值</li>
<li>**%**：相对于父元素尺寸的百分比</li>
</ul>
</li>
</ul>
<h3 id="使用-rem-或-viewport-进行移动端适配"><a href="#使用-rem-或-viewport-进行移动端适配" class="headerlink" title="使用 rem 或 viewport 进行移动端适配"></a>使用 rem 或 viewport 进行移动端适配</h3><h4 id="rem-适配原理"><a href="#rem-适配原理" class="headerlink" title="rem 适配原理"></a>rem 适配原理</h4><p>改变了一个元素在不同设备上占据的 css 像素的个数。</p>
<p>优点：没有破坏完美视口</p>
<p>缺点：px 转换 rem 较为复杂</p>
<h4 id="viewport-适配原理"><a href="#viewport-适配原理" class="headerlink" title="viewport 适配原理"></a>viewport 适配原理</h4><p>每一个元素在不同设备上占据的 css 像素的个数是一样的，但 css 像素和物理像素的比例是不一样的。</p>
<p>优点：在设计图上所取量的大小即为可以设置的像素大小（所量及所设）</p>
<p>缺点：破坏完美视口</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol>
<li><p>添加额外标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加额外标签并添加 clear 属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以添加一个 br 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>父级添加 overflow 属性，或者设置高度；</p>
</li>
<li><p>建立伪类选择器清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 css 中添加 :after 伪元素 */</span></span><br><span class="line"><span class="selector-class">.parent</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CSS-中可以继承的属性"><a href="#CSS-中可以继承的属性" class="headerlink" title="CSS 中可以继承的属性"></a>CSS 中可以继承的属性</h3><ol>
<li>字体系列属性：<ul>
<li>font-family、font-weight、font-size、font-style</li>
</ul>
</li>
<li>文本系列：<ul>
<li>text-indent、text-align、line-height</li>
<li>word-spacing、letter-spacing</li>
<li>text-transform、color</li>
</ul>
</li>
<li>元素可见性：visibility</li>
<li>列表布局属性：<ul>
<li>list-style、list-style-image、list-style-type 等</li>
</ul>
</li>
<li>光标属性：cursor</li>
</ol>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是 CSS3 开始加入的功能，可以进行响应式适配展示，由两部分组成：</p>
<ul>
<li>一个可选的媒体类型（如 screen、print）等；</li>
<li>零个或多个媒体功能限定表达式（如 <code>max-width: 500px</code>、<code>orientation: landscape</code>）等</li>
</ul>
<p>最终这两部分会被解析为 true 或 false，进而确定该媒体查询关联的样式是否生效。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span>|<span class="keyword">only</span> mediatype <span class="keyword">and</span> (mediafeature <span class="keyword">and</span>|<span class="keyword">or</span>|<span class="keyword">not</span> mediafeature) &#123;</span><br><span class="line">  CSS-<span class="selector-tag">Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词定义：</p>
<ul>
<li><code>not</code>：用于否定媒体查询，将解析后的媒体查询结反转；若出现在逗号分隔的查询列表中，将仅否定应用了该查询的特定查询；使用 not 必需指定媒体类型；</li>
<li><code>only</code>：仅在整个查询匹配时才用于应用样式，对于防止版本低的浏览器应用所选样式很有用；</li>
<li><code>,</code>：用于将多个媒体查询合并为一个规则，各自分开处理，类似于逻辑或 or；</li>
<li><code>and</code>：用于将多个媒体查询规则组合成单条媒体查询，类似于逻辑与；</li>
</ul>
<p>媒体类型（Media Types）：描述设备的一般类型</p>
<ul>
<li><code>all</code>：用于所有设备</li>
<li><code>print</code>：用于打印机和打印预览</li>
<li><code>screen</code>：用于电脑屏幕、平板电脑、智能手机等</li>
<li><code>speech</code>：用于屏幕阅读器等发声设备</li>
<li>其他已废弃（aural、braille、embossed、handheld、projection、tty、tv）</li>
</ul>
<p>媒体功能：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>每一组彩色原件的个数，非彩色设备则值为 0</td>
</tr>
<tr>
<td>min-color</td>
<td>每一组彩色原件的最小个数</td>
</tr>
<tr>
<td>max-color</td>
<td>每一组彩色原件的最大个数</td>
</tr>
<tr>
<td>color-index</td>
<td>彩色查询表中的条目数，没有使用则为 0</td>
</tr>
<tr>
<td>min-color-index</td>
<td>彩色查询表中的最大条目数</td>
</tr>
<tr>
<td>max-color-index</td>
<td>彩色查询表中的最大条目数</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>屏幕可见区域宽高比</td>
</tr>
<tr>
<td>device-height</td>
<td>屏幕可见区域高度</td>
</tr>
<tr>
<td>device-width</td>
<td>屏幕可见区域最大宽度</td>
</tr>
<tr>
<td>min-device-aspect-ratio</td>
<td>屏幕可见区域最小宽高比</td>
</tr>
<tr>
<td>min-device-height</td>
<td>屏幕可见区域最小高度</td>
</tr>
<tr>
<td>min-device-width</td>
<td>屏幕可见区域最小宽度</td>
</tr>
<tr>
<td>max-device-aspect-ratio</td>
<td>屏幕可见区域最大宽高比</td>
</tr>
<tr>
<td>max-device-height</td>
<td>屏幕可见区域最大高度</td>
</tr>
<tr>
<td>max-device-width</td>
<td>屏幕可见区域最大宽度</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>页面可见区域宽高比</td>
</tr>
<tr>
<td>height</td>
<td>页面可见区域高度</td>
</tr>
<tr>
<td>width</td>
<td>页面可见区域宽度</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>页面可见区域最大宽高比</td>
</tr>
<tr>
<td>max-height</td>
<td>页面可见区域最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>页面可见区域最大宽度</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>页面可见区域最小宽高比</td>
</tr>
<tr>
<td>min-height</td>
<td>页面可见区域最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>页面可见区域最小宽度</td>
</tr>
<tr>
<td>max-resolution</td>
<td>设备的最大分辨率</td>
</tr>
<tr>
<td>min-resolution</td>
<td>设备的最小分辨率</td>
</tr>
<tr>
<td>resolution</td>
<td>设备的分辨率，单位为 dpi、dpcm</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的最大单色元件个数</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的最小单色元件个数</td>
</tr>
<tr>
<td>monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的单色元件个数，若非单色设备则值为 0</td>
</tr>
<tr>
<td>orientation</td>
<td>页面可见区域高度是否大于或者等于宽度</td>
</tr>
<tr>
<td>grid</td>
<td>查询输出设备是否使用栅格或点阵</td>
</tr>
<tr>
<td>scan</td>
<td>电视类设备的扫描工序</td>
</tr>
</tbody></table>
<h2 id="JS-TS-ES6"><a href="#JS-TS-ES6" class="headerlink" title="JS TS ES6"></a>JS TS ES6</h2><h3 id="JS-的数据类型"><a href="#JS-的数据类型" class="headerlink" title="JS 的数据类型"></a>JS 的数据类型</h3><p>包含值类型(基本对象类型)和引用类型(复杂对象类型)</p>
<p>基本类型：在内存中占据固定大小，保存在栈内存中</p>
<ul>
<li>Number（数字类型）</li>
<li>String（字符串类型）</li>
<li>Boolean（布尔类型）</li>
<li>null（空）</li>
<li>undefined（未定义）</li>
<li>Symbol（符号类型，ES6）</li>
<li>bigInt（ES10）</li>
</ul>
<p>引用类型：引用类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址</p>
<ul>
<li>Object（对象）</li>
<li>Function（函数）</li>
<li>Array（数组）</li>
<li>Date（日期）</li>
<li>RegExp（正则表达式）</li>
<li>特殊的包装类型：String、Number、Boolean</li>
<li>单体内置对象：Global、Math 等</li>
<li>Map（字典，ES6）</li>
<li>Set（集合，ES6）</li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>判断空对象方法：</p>
<ul>
<li><p><code>JSON.stringify(obj) === &#39;&#123;&#125;&#39;</code> </p>
</li>
<li><p><code>Object.keys(obj).length == 0</code> </p>
</li>
<li><p><code>Object.getWonPropertyNames(obj).length == 0</code> </p>
</li>
<li><p>jQuery 中的 <code>$.isEmptyObject(obj)</code> 方法</p>
</li>
<li><p>```js<br>var result = function (obj) {<br>  for (let key in obj) {</p>
<pre><code>return false
</code></pre>
<p>  }<br>  return true<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Symbol</span><br><span class="line"></span><br><span class="line">Symbol 指的是独一无二的值，每个通过 `Symbol()` 生成的值都是唯一的。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let var_symbol = Symbol()</span><br><span class="line">let other_symbol = Symbol()</span><br><span class="line">console.log(var_symbol === other_symbol) // false</span><br><span class="line">console.log(typeof var_symbol) // symbol</span><br><span class="line">console.log(var_symbol.constructor === Symbol) // true</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以用 <code>Symbol.for(key)</code> 创建相等的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;symbol&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> other_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&#x27;symbol&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(var_symbol === other_symbol) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(key)</code> 会根据给定的建 key(字符串)，来从运行时的 symbol 注册表中找到对应的 symbol，如找到则返回，未找到则新建一个与该键相关联的 symbol 返回，并放入全局 symbol 注册表中。</p>
<p>应用场景：</p>
<ol>
<li>使用 Symbol 来作为对象属性名（key）</li>
<li>使用 Symbol 来替代常量</li>
<li>使用 Symbol 定义类的私有属性/方法</li>
</ol>
<p><strong>Object.getOwnPropertySymbols()</strong> 方法返回一个数组，包含给定对象所有自有的 Symbol 值的属性（包括不可枚举的 Symbol 值属性）。</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种数字类型的数据，可以表示任意精度格式的整数。</p>
<p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 <code>Infinity/-Infinity</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>ES10 引入了一种新的数据类型 BigInt 来解决这个问题，只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，为了与 Number 进行区分，BigInt 类型的数据必须添加后缀 <code>n</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span> <span class="comment">// 普通 Number</span></span><br><span class="line"><span class="number">12n</span> <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span> <span class="comment">// 3n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Number 类型进行运算</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span> <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<p>BigInt 与普通整数时两种值，它们之间并不相等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12n</span> === <span class="number">12</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于 BigInt 与 Number 完全属于两种类型，并且不会进行隐式转换，所以没有办法进行混合运算。想要运算的话，必须将两种数据类型转换为同一种后，方可进行计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(number)</span><br><span class="line"><span class="built_in">Number</span>(bigint)</span><br></pre></td></tr></table></figure>

<p>typeof 运算符对于 BigInt 类型的数据返回 <code>bigint</code> 字符串；BigInt 并不是一个构造函数，不能使用 new 来创建实例；创建一个 BigInt 时，参数必须为整数，否则会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12n</span> <span class="comment">// &#x27;bigint&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">BigInt</span>() <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="number">1.2</span>) <span class="comment">// Uncaught RangeError</span></span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是 ES6 引入的一种叫做集合（是由一堆无序的、相关联的，且不重复的内存结构）的数据结构。</p>
<p>Set 就像一个数组，但是仅包含唯一项，Set 对象是值的集合，可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setTest = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">0</span>, -<span class="number">0</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>])</span><br><span class="line"><span class="built_in">console</span>.log(setTest) <span class="comment">// Set &#123; 0, Infinity, null, undefined, NaN &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>虽然 NaN !== NaN，但是在 Set 集合内只会存在一个；</li>
<li>undefine、null、Infinity 也只能各自存在一个。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line">set.size <span class="comment">// 返回集合中所包含元素的数量</span></span><br><span class="line"><span class="comment">// 操作方法</span></span><br><span class="line">set.add(value) <span class="comment">// 向 set 中添加元素</span></span><br><span class="line">set.delete(value) <span class="comment">// 删除 set 中对应元素</span></span><br><span class="line">set.has(value) <span class="comment">// 判断值在集合中是否存在，返回 true 或 false</span></span><br><span class="line">set.clear() <span class="comment">// 移除集合中所有的向</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 遍历进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Set]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 是一组键值对的结构，具有极快的查找速度。</p>
<p>初始化 Map 需要一个二维数组，或者直接初始化一个空 Map：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">map.size <span class="comment">// 返回映射中的元素数</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>) <span class="comment">// 添加新的 key-value</span></span><br><span class="line">map.has(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 判断是否存在 key，返回 true 或 false</span></span><br><span class="line">map.get(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 返回 key 对应的 value 值</span></span><br><span class="line">map.delete(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 删除 key</span></span><br><span class="line">map.clear() <span class="comment">// 移除 map 中所有的键值对</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 对映射中每个元素进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Map]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一个 key 只能对应一个 value，多次对一个 key 放入 value，后面的将会覆盖前面的值。</p>
<p><strong>Object 和 Map 的区别</strong>：</p>
<p>相同点：都是以 key-value 的形式对数据进行存储</p>
<p>不同点：</p>
<table>
<thead>
<tr>
<th>不同点</th>
<th>Object</th>
<th>Map</th>
</tr>
</thead>
<tbody><tr>
<td>key 的数据类型范围</td>
<td>number、string、symbol</td>
<td>所有已有的数据类型均可以</td>
</tr>
<tr>
<td>key 的顺序</td>
<td>Object.keys() 获取到的顺序是：数字(升序)-&gt;string(symbol)(创建的顺序)</td>
<td>声明的顺序</td>
</tr>
<tr>
<td>创建方式</td>
<td><code>new Object()</code>、<code>&#123;&#125;</code>、<code>Object.create(&#123;&#125;)</code></td>
<td><code>new Map()</code></td>
</tr>
<tr>
<td>取值</td>
<td>通过 <code>.</code> 或 <code>[]</code></td>
<td><code>map.get()</code></td>
</tr>
<tr>
<td>判断是否存在属性</td>
<td><code>&#39;key&#39; in obj</code></td>
<td><code>map.has(key)</code></td>
</tr>
<tr>
<td>设置属性的方式</td>
<td><code>obj[&#39;key&#39;] = value</code>、<code>obj.key = value</code></td>
<td><code>map.set(&#39;key&#39;, value)</code></td>
</tr>
<tr>
<td>删除 key 的方式</td>
<td><code>delete obj.key</code></td>
<td><code>map.delete(&#39;key&#39;)</code><br><code>map.clear()</code></td>
</tr>
<tr>
<td>获取长度</td>
<td>通过 <code>Object.keys(obj)</code> 返回一个数组，通过获取数组的长度来获取 size</td>
<td><code>map.size</code></td>
</tr>
<tr>
<td>JSON 操作</td>
<td>支持 JSON.stringify 和 JSON.parse 的操作</td>
<td>不支持</td>
</tr>
<tr>
<td>this 指向不同</td>
<td>指向访问的 obj</td>
<td>取决于操作函数的调用者</td>
</tr>
<tr>
<td>Iterating(迭代)</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<blockquote>
<p>判断是否可以迭代的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [][<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Set</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Map</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>性能对比</strong>：</p>
<p>插入性能：</p>
<p>向 Object 和 Map 中插入新键值对的消耗大致相当，<strong>涉及到大量的插入操作时，Map 的性能更佳</strong>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initObj</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    obj[<span class="string">&#x27;name&#x27;</span> + i] = i</span><br><span class="line">    <span class="comment">// obj[i] = i</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMap</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    map.set(<span class="string">&#x27;name&#x27;</span> + i, i)</span><br><span class="line">    <span class="comment">// map.set(i, i)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`object set spend <span class="subst">$&#123;initObj()&#125;</span>,map set spend <span class="subst">$&#123;initMap()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151220692.png" class title="map&amp;obj插入大量字符串键">

<blockquote>
<p>但当设置的键为整数值时，object 的性能要比 map 好一些。</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151330371.png" class title="map&amp;obj插入大量整数键">
</blockquote>
<p>查找性能：</p>
<p>从大型 Object 和 Map 中查找键值对的性能差异很小；若<strong>只有少量键值对，则 Object 有时速度更快</strong>；在把 Object 当数组使用时，浏览器引擎进行了优化，在内存中使用了更高效的布局。</p>
<p>当<strong>键不为整数时，Map 的性能要略优于 Object</strong>.</p>
<p>删除性能：</p>
<p>对于大多数浏览器引擎来说，Map 的 delete 操作都比插入和查找更快，<strong>代码中涉及大量删除操作时，应选择 Map 使用</strong>；同样，若键为整数则 Object 略优。</p>
<p>内存占用：</p>
<p>存储单个键值对所占用的内存数量都会随着键的数量线性增加，给定固定大小的内存，<strong>Map 大约可以比 Object 多存储 50% 的键值对</strong>。</p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>为了便于操作基本类型的值，JavaScript 引入了三个特殊的引用类型 boolean、number、string 的包装类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">234</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +b) <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>基本类型可以添加属性，访问不报错但返回 undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="comment">// 这一步，系统知道 a 是个常量，所以包装类创建了一个 Number 类型的实例，同时为此实例添加了 name 属性</span></span><br><span class="line"><span class="comment">// 之后又迅速销毁了这个实例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line">  a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line">  <span class="keyword">delete</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.name)</span><br><span class="line"><span class="comment">// 系统看到又错了，包装类自动又创建了一个 Number 类型的实例</span></span><br><span class="line"><span class="comment">// 但此实例并没有 name 属性，所以返回 undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型检测方案"><a href="#数据类型检测方案" class="headerlink" title="数据类型检测方案"></a>数据类型检测方案</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>              <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>           <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>           <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>         <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log()  <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> []             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>优点：可以快速区分基本数据类型</p>
<p>缺点：无法区分 Object、Array 和 null，均返回 object</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>                <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>            <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            <span class="comment">// false</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>                <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>               <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：能够区分 Array、Object 和 Function，适用于判断自定义的类实例对象</p>
<p>缺点：不能判断基本数据类型</p>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString</span><br><span class="line">toString.call(<span class="number">1</span>)              <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="literal">true</span>)           <span class="comment">// [object Boolean]</span></span><br><span class="line">toString.call(<span class="string">&quot;mc&quot;</span>)           <span class="comment">// [object String]</span></span><br><span class="line">toString.call([])             <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;)             <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>)      <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>)           <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>优点：精准判断数据类型</p>
<p>缺点：较前两种方法写法较为繁琐不易于记忆，可以进行封装后使用</p>
<h4 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h4><p>ES6 之前创建变量使用 var，之后创建变量用的是 let/const</p>
<p>区别：</p>
<ol>
<li><p>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问；<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；<br>const 用来定义常量，使用时必须初始化（即创建时必须赋值），只能在块作用域里访问，且不能修改；</p>
</li>
<li><p>var 可以先使用，后声明，因为存在变量提升，let/const 必须先声明后使用；</p>
</li>
<li><p>var 允许在相同作用域内重复声明同一个变量，但 let/const 不允许；</p>
</li>
<li><p>在全局上下文中，基于 let 声明的全局变量与全局对象（window）没有任何关系，var 声明的会有映射关系；</p>
</li>
<li><p>会产生暂时性死区：</p>
<p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，而会返回 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">let</span> b</span><br></pre></td></tr></table></figure></li>
<li><p>let/const/function 会把当前所在的大括号（除函数之外）作为一个全新的块级上下文。</p>
</li>
</ol>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul>
<li><p>join()：以指定的字符串连接起来，变成字符串，通常和 String 中的 split 连用；</p>
<ul>
<li>参数为指定的字符串，默认为 <code>,</code>；</li>
</ul>
</li>
<li><p>slice()：按传入的下标截取数组；</p>
<ul>
<li>参数1：开始截取的位置即下标，默认从开始截；</li>
<li>参数2：可选，若不传则默认截取到末尾，若传入则截取到该下标的前一位；</li>
<li>传入负数则从数组的末尾往前数；</li>
<li>返回值：返回按指定下标截取后的数组，不会影响前数组；</li>
</ul>
</li>
<li><p>splice()：删除或添加数组元素；</p>
<ul>
<li>参数1：开始删除的位置即下标；</li>
<li>参数2：可选，删除元素个数，不传则默认删到最后；</li>
<li>参数3,4,5…：添加的元素；</li>
<li>返回值：返回删除后的数据，<strong>会改变原数组</strong>；</li>
</ul>
</li>
<li><p>pop()：移除数组的最后一项，返回删除的项，<strong>会改变原数组</strong>；</p>
</li>
<li><p>push()：在数组末尾添加项数，返回添加后的数组长度，<strong>会改变原数组</strong>；</p>
</li>
<li><p>shift()：删除数组中的第一项，返回删除的项，<strong>会改变原数组</strong>；</p>
</li>
<li><p>unshift()：像数组的最前面添加项，返回新的数组长度，<strong>会改变原数组</strong>；</p>
</li>
<li><p>sort()：按一定规则排序，返回新数组，<strong>会改变原数组</strong>；</p>
<ul>
<li>参数接受一个函数；</li>
</ul>
</li>
<li><p>reverse()：数组反转，返回新数组，<strong>会改变原数组</strong>；</p>
</li>
<li><p>concat()：将两个数组连接，返回新数组，不会改变原数组；</p>
</li>
<li><p>indexOf()：查找一个数组中是否存在某个值，存在返回下标，不存在返回 -1；</p>
<ul>
<li>默认从首位开始查询；</li>
<li>只能匹配第一次出现的位置；</li>
<li>参数1：要查找的值；</li>
<li>参数2：可选，传入指定的下标，指定从哪个位置开始查询；</li>
</ul>
</li>
<li><p>lastIndexOf()：从末尾开始倒着查询；</p>
</li>
<li><p>every()：检测数组的每一项是否都符合条件，符合返回 true，若有一项不符合则停止检测返回 false；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>some()：检测数组中是否存在符合指定条件的项，若有则停止检测返回 true，否则返回 false；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>filter()：过滤，检测数组，返回符合条件的内容，没有则返回空数组；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>map()：映射，返回一个新的数组，新数组中的元素是原数组调用函数后处理过的值；</p>
</li>
<li><p>reduce()：对数组的每一个元素指定一个函数（正序执行），将其结果汇总为单个返回值；</p>
<ul>
<li><p>接收一个函数参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr, index, arr</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;, init)</span><br></pre></td></tr></table></figure>

<ul>
<li>prev：必需，累计器累计回调的返回值；表示上一次调用回调时的返回值，或者是初始值；</li>
<li>curr：必需，表示当前正在处理的数组元素；</li>
<li>index：可选，表示当前正在处理的元素的索引，提供 init 初始值则起始索引为 0，否则起始索引为 1；</li>
<li>arr：可选，表示原数组；</li>
<li>init：可选，表示初始值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以下为 ES6 新增：</p>
<ul>
<li>includes()：检测数组是否存在某个值，存在为 true，否则为 false；<ul>
<li>参数1：传入的指定值；</li>
<li>参数2：可选，表示搜索的起始位置，默认为 0，若为负数则倒着数；</li>
<li>若传入的值为整数，且大于数组的长度则返回 false；</li>
<li>若闯入的值为负数，且超过数组长度则从 0 开始查询；</li>
</ul>
</li>
<li>Array.of()：将一组值转为数组；<ul>
<li>如果没有传入参数则返回一个空数组 <code>[]</code>；</li>
<li>可以代替 Array() 和 new Array() 去创建和声明一个新数组；</li>
</ul>
</li>
<li>fill()：使用定值去填充一个数组，数组中的元素会被全部抹除；<ul>
<li>参数1：要替换为的值；</li>
<li>还可以接收参数2 和参数3，指定填充的起始位置和结束位置（前包后不包）；</li>
</ul>
</li>
<li>copyWithin()：将数组中指定的成员项，复制到其他位置（会覆盖原来的成员），返回新数组，<strong>会改变原数组</strong>；<ul>
<li>参数1：指定从哪个位置开始替换数据；</li>
<li>参数2：可选，默认从 0 开始复制，传入则从指定位置开始复制，为负则从尾部数；</li>
<li>参数3：可选，默认复制到最后，若传入则为复制的结束位置，为负则从尾部数；</li>
</ul>
</li>
<li>find()：用来找出第一个符合条件的成员；<ul>
<li>参数是一个回调函数，依次查询每一项，直到查询到第一个符合条件的成员，并返回该项的值，若不存在则返回 undefined；</li>
</ul>
</li>
<li>findIndex()：类似于 find()，但返回的是符合条件的项的位置即下标，均不满足则返回 -1；</li>
<li>entries()：键值对的遍历；</li>
<li>keys()：键名遍历；</li>
<li>values()：键值遍历。</li>
</ul>
<h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><p>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢；当某些代码操作不能被合理释放，就会造成内存泄漏。</p>
<p>浏览器垃圾回收机制/内存回收机制：</p>
<ol>
<li>标记清除</li>
<li>谷歌浏览器：查找引用</li>
<li>IE 浏览器：引用计数法</li>
</ol>
<p>优化手段：</p>
<ol>
<li>堆内存：fn = null【null：空指针对象】</li>
<li>栈内存：将上下文中被外部占用的堆取消掉即可</li>
</ol>
<p>内存泄漏：</p>
<ul>
<li>全局变量</li>
<li>闭包</li>
<li>DOM 元素的引用</li>
<li>定时器</li>
</ul>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域 -&gt; 当前创建函数所处的上下文。如果是在全局下创建的函数就是 <code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文 <code>EC(FN)</code>，供字符串代码执行（进栈执行）。</p>
<p>定义：作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成</p>
<ol>
<li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域；</li>
<li>函数作用域：在固定的代码片段才能被访问</li>
</ol>
<p>作用：作用域的最大用处就是 <strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p>一般情况下，变量到创建该变量的函数的作用域中取值。但如果没有查询到，就会向上级作用域去查，直到查到全局作用域，这一个查找过程所构成的链条就叫做作用域链。</p>
<h3 id="闭包：保存-保护"><a href="#闭包：保存-保护" class="headerlink" title="闭包：保存/保护"></a>闭包：保存/保护</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数执行时形成的私有上下文 <code>EC(FN)</code>，正常情况下，代码执行完会出栈然后释放；但是特殊情况下，如果当前私有上下文中的数据被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不会被销毁的上下文。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰；</li>
<li>保存：如果当前上下文不被释放，则存储的私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</li>
</ol>
<p>把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部函数可以访问定义它们外部函数的参数和变量，设计私有的方法和变量，避免全局变量的污染；</li>
<li>函数嵌套函数；</li>
<li>本质是将函数内部和外部连接起来，优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除。</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li>模仿块级作用域</li>
<li>保护外部函数的变量，能够访问函数定义时所在的词法作用域（阻止其被回收）</li>
<li>封装私有化变量</li>
<li>创建模块</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>会导致函数的变量一致保存在内存中，过多的闭包会导致内存泄漏。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol>
<li>作为普通函数执行时，<code>this</code> 指向 <code>window</code>；</li>
<li>当函数作为对象的方法被调用时，<code>this</code> 就会指向该对象；</li>
<li>构造器调用，this 指向返回的这个对象；</li>
<li>箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象，如果有嵌套的情况，则 this 绑定到最近的一层对象上；</li>
<li>基于 Function.prototype 上的 apply、call 和 bind 调用模式，可以显示指定调用函数的 this 指向。</li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的特点：</p>
<ol>
<li>箭头函数均为匿名函数；</li>
<li>箭头函数不能用于构造函数，不能使用 new；</li>
<li>箭头函数中的 this 指向不同：<ul>
<li>在普通函数中，this 总是指向调用它的对象，用作构造函数则指向创建的对象实例；</li>
<li>但箭头函数本身不会创建 this，但会<strong>在声明时捕获其所在上下文的 this 供自己使用，且一旦捕获无法改变</strong>。</li>
</ul>
</li>
<li>箭头函数不能 generator 函数，不能使用 yeild 关键字；</li>
<li>箭头函数不具有 prototype 原型对象；</li>
<li>不具有 new.target 和 super。</li>
</ol>
<h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h3><p>原型关系：</p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 __proto__</li>
<li>实例的 __proto__ 指向对应 class 的 prototype</li>
</ul>
<p>原型：在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code> 属性，这个属性指向函数的原型对象。</p>
<p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 __proto**，该指针是指向上一层的原型对象，而上一层的原型对象的结构以此类推。因此可以利用 <code>__proto__</code>一直指向 Object 的原型对象上，而 Object 的原型对象用<code>Object.prototype.__proto__ = null</code> 表示原型链顶端，如此形成了 js 的原型链继承；</p>
<p>特点：JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol>
<li>创建一个空的新对象；</li>
<li>设置原型，将对象的原型 <code>__proto__</code> 设置为函数的 <code>prototype</code> 对象；</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（添加属性）；</li>
<li>判断函数的返回类型，若是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo =  <span class="keyword">new</span> Foo(<span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> fn () &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Foo.prototype</span><br><span class="line">  Foo.call(obj, <span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>JS 是单线程的，为了防止一个函数执行时间过长而阻塞后面的代码，所以会先将同步代码压入执行栈中，一次执行，将异步代码突入异步队列，异步队列又分为宏任务队列和微任务队列，微任务队列优先于宏任务队列。</p>
<p>JS 运行的环境一般为浏览器或者 Node，在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<h4 id="浏览器中"><a href="#浏览器中" class="headerlink" title="浏览器中"></a>浏览器中</h4><p>先执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后取宏任务清微任务不停循环。</p>
<p>EventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p>
<ol>
<li>函数入栈，当 Stack 中执行到异步任务时，就将它丢给 WebAPIs，接着执行同步任务，直到 Stack 为空；</li>
<li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行；</li>
<li>执行栈为空时，Event Loop 把微任务队列执行清空；</li>
<li>微任务队列清空后，进入宏任务队列，取对列的第一项任务放入 Stack（栈）中执行，执行完成后，查看微任务队列是否有任务，有则执行清空，然后重复此步骤，直至清空所有的任务。</li>
</ol>
<p>浏览器中的任务源（task）：</p>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><p>页面中大部分任务都是在主线程上执行的，包括：</p>
<ul>
<li>渲染事件（DOM、计算布局、绘制）</li>
<li>用户交互事件（鼠标点击、滚动页面、放大缩小等）</li>
<li>JavaScript 脚本执行事件</li>
<li>网络请求完成、文件读写完成事件</li>
</ul>
<p>ajax、setTimeout、setInterval、setTmmediate(只兼容 IE)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器 API</p>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；</li>
<li>微任务的执行时长会影响到当前宏任务的时长；</li>
<li>在一个宏任务中分别创建一个用于回调的宏任务和微任务，无论如何微任务都早于宏任务执行。</li>
</ul>
<p>then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObserve</p>
<h4 id="Node-中"><a href="#Node-中" class="headerlink" title="Node 中"></a>Node 中</h4><p>Node 是基于 V8 引擎的运行在服务端的 <code>JavaScript</code> 运行环境，在处理高并发、I/O 密集（文件操作、网络操作、数据库操作等）场景有明显的优势。</p>
<p>由于服务目的和环境不同，其事件循环还要处理一些 I/O，所以 Node 的 Event Loop 与浏览器的是不太一样：</p>
<ol>
<li>timers：计时器，执行 setTimeout 和 setInterval 的回调；</li>
<li>pending callbacks：执行延迟到下一个循环迭代的 I/O 回调；</li>
<li>idle，prepare：队列的移动，仅系统内部使用；</li>
<li>poll 轮询：检索新的 I/O 事件，执行与 I/O 相关的回调；</li>
<li>check：执行 Immediate 的回调；</li>
<li>close callbacks：执行 close 事件的 callback ，一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code> </li>
</ol>
<h3 id="setTimeout-Promise-Async-Await"><a href="#setTimeout-Promise-Async-Await" class="headerlink" title="setTimeout Promise Async/Await"></a>setTimeout Promise Async/Await</h3><p>setTimeout：</p>
<p>setTimeout 的回调函数放入宏任务队列中，等到执行栈清空后执行；</p>
<p>Promise：</p>
<p>Promise 本身是同步的立即执行函数，当在 executor 中执行 resolve 或者 reject 是，此时是异步操作，会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 的 中存放的方法执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出顺序：</span></span><br><span class="line"><span class="comment">		script start</span></span><br><span class="line"><span class="comment">		promise1</span></span><br><span class="line"><span class="comment">		promise1 end</span></span><br><span class="line"><span class="comment">		script end</span></span><br><span class="line"><span class="comment">		promise2</span></span><br><span class="line"><span class="comment">		settimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>async/awiat：</p>
<p>async 函数返回一个 Promise 对象，当函数执行时，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	输出顺序：</span></span><br><span class="line"><span class="comment">		script start</span></span><br><span class="line"><span class="comment">		async1 start</span></span><br><span class="line"><span class="comment">		async2</span></span><br><span class="line"><span class="comment">		script end</span></span><br><span class="line"><span class="comment">		async1 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>async/await 通过同步的方式实现异步的原理：</p>
<p>async/awiat 就是一个自执行的 generate 函数，利用 generate 函数的特性把异步的代码写成同步的形式，第一个请求的返回值作为后一个请求的参数，其中每一个参数都是一个 promise 对象。</p>
<h3 id="节流-防抖"><a href="#节流-防抖" class="headerlink" title="节流/防抖"></a>节流/防抖</h3><p>节流：<strong>事件触发后，规定时间内，事件处理函数不能再次被调用</strong>；也就是在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次；</p>
<p>防抖：<strong>多次触发事件，事件触发函数只能执行一次，并且是在触发结束时执行</strong>；即当一个事件被触发准备执行事件函数前，会等待一定的时间，如果没有再次被触发，那么就执行，如果被触发，则本次作废，重新从新触发的时间开始计算，并再次等待，直到能最终执行。</p>
<p>使用场景：</p>
<ol>
<li>节流：滚动加载更多、搜索框的搜索联想功能、高频点击、表单重复提交…</li>
<li>搜索框搜索输入，并在输入完成后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后再重新渲染。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次之后，只有大于设定的执行周期才会执行第二次.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次函数触发的时间</span></span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.call(<span class="built_in">this</span>, ...args)</span><br><span class="line">      <span class="comment">// 同步执行结束时间</span></span><br><span class="line">      lastTime = nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;scroll 事件被触发了&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数 一个需要频繁触发的函数，再规定时间内，只让最后一次生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被防抖的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除上一次的延时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">// 重新设置新的延时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h3><p>对于基本数据类型而言，== 和 === 是有区别的：</p>
<ul>
<li>不同类型间比较，== 只比较转化成同一类型后的值是否相等；</li>
<li>=== 如果类型和数值有一项不同，就是不等</li>
</ul>
<p>对于引用数据类型来说，== 和 === 是没有区别的；</p>
<p>对于引用类型和基本数据类型比较：</p>
<ul>
<li>== 会将引用数据类型转化为基本数据类型，进行值比较；</li>
<li>=== 结果为 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> 				<span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span>   				 	<span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="number">42</span> 				 	<span class="comment">// true -- 字符串转数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="number">42</span> 				<span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="literal">true</span> 				<span class="comment">// false -- 字符串与布尔值分别转化成数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="literal">true</span> 			<span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> 	<span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">false</span>      <span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == [<span class="number">42</span>]					<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === [<span class="number">42</span>]					<span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == <span class="built_in">Object</span>(a)			<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === <span class="built_in">Object</span>(a)		<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡捕获"><a href="#事件冒泡捕获" class="headerlink" title="事件冒泡捕获"></a>事件冒泡捕获</h3><p>不支持冒泡的事件：</p>
<ul>
<li>UI 事件：load、unload、resize、abort、error</li>
<li>焦点事件：blur、focus</li>
<li>鼠标事件：mouseleave、mouseenter</li>
</ul>
<h3 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h3><h4 id="新命令"><a href="#新命令" class="headerlink" title="新命令"></a>新命令</h4><p>ES5 只有两种声明变量的方法 var 和 function；ES6 添加了 let 和 const 以及 import 和 class。</p>
<p><strong>let</strong> 特性：</p>
<ul>
<li><p>不存在变量提升；</p>
</li>
<li><p>同一作用域下不能重复定义同一个变量；</p>
</li>
<li><p>有着严格的作用域，属于块级作用域；</p>
</li>
<li><p>会出现暂时性死区：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>const</strong> 特性：</p>
<ul>
<li>const 声明一个只读的常量，一旦声明，常量的值就不能改变；</li>
<li>必须在声明时初始化，不能只声明不赋值；</li>
<li>当声明的常量是数组，对象等引用类型时，对象所包含的值可以被修改，但指向的地址不能被修改；</li>
<li>一般推荐使用大写字母来命名变量</li>
</ul>
<h4 id="新数据类型"><a href="#新数据类型" class="headerlink" title="新数据类型"></a>新数据类型</h4><p><strong>Symbol</strong>：</p>
<p>ES6 新增的基本数据类型</p>
<p><strong>Set/WeakSet</strong>：</p>
<p>Set 类似于数组，区别在于成员是唯一的，无论是原始值或者是对象引用；</p>
<p>WeakSet 结构与 Set 类似，但区别有以下两点：</p>
<ol>
<li><code>WeakSet</code> 对象只能存放对象引用，不能存放值；</li>
<li><code>WeakSet</code> 对象中存储的对象都是被弱引用的，若没有其他的变量或属性引用这个对象值，则这个对象值会被垃圾回收，故 WeakSet 对象是无法被枚举的。</li>
</ol>
<p><strong>Map/WeakMap</strong>：</p>
<p>Map 类似于对象，保存键值对，任何值（对象或者原始值）都可以作为一个键或值；</p>
<p>WeakMap 是一组键值对的集合，其中的键是弱引用的，键必须是对象，值任意类型。</p>
<h4 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h4><p>Promise 是 ES6 提供的一种异步解决方案，比回调函数更加清晰明了，很好地解决了回调地狱的问题。</p>
<ul>
<li>一旦状态改变则永远无法更改。</li>
</ul>
<h4 id="Proxy-Reflect"><a href="#Proxy-Reflect" class="headerlink" title="Proxy/Reflect"></a>Proxy/Reflect</h4><p>Proxy 对象用于定义基本操作的自定义行为（属性查找、赋值、枚举、函数调用等）；</p>
<p>Reflect 是一个内置对象，提供拦截 JS 操作的方法，与 Proxy 方法相同，不可构造；</p>
<blockquote>
<p>并不是任何值都可以被代理，如果对象带有 <code>configurable: false</code> 和 <code>writable: false</code> 属性，则代理失效</p>
</blockquote>
<h4 id="箭头函数-1"><a href="#箭头函数-1" class="headerlink" title="箭头函数"></a>箭头函数</h4><p>箭头函数（Arrow function）表达式的语法比函数表达式更简洁，没有自己的 this、arguments、super、new.target，并且不能用作构造函数。</p>
<p>特性：</p>
<ol>
<li>不需要用关键字 function 来定义函数；</li>
<li>在箭头函数内部，this 并不会更其他函数一样指向调用它的对象，而是<strong>继承上下文的 this 指向</strong>；</li>
<li>只有一个参数时可以省略括号，当只有一句返回语句时可以省略 return；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function">(<span class="params">v</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> v</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 可以简写为</span></span><br><span class="line"><span class="keyword">let</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v</span><br></pre></td></tr></table></figure>

<h4 id="数组对象解构"><a href="#数组对象解构" class="headerlink" title="数组对象解构"></a>数组对象解构</h4><p>可以将对象中的属性，数组值进行进行解构，以便快速获取数组和对象的值。</p>
<p>数组解构就是能快速提取数组中的指定成员：</p>
<ol>
<li><p>解构赋值都是按照顺序一一对应的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">const</span> [a, b, c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(a, b, c) <span class="comment">// 100, 200, 300</span></span><br></pre></td></tr></table></figure></li>
<li><p>也可以取数组的某一项值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">const</span> [,,c] = arr</span><br><span class="line"><span class="built_in">console</span>.log(c) <span class="comment">// 300</span></span><br></pre></td></tr></table></figure></li>
<li><p>还可以用 <code>...</code> 的方式提取所有的成员（只能在解构成员的最后一个成员使用）：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]</span><br><span class="line"><span class="keyword">const</span> [a, ...all] = arr</span><br><span class="line"><span class="built_in">console</span>.log(all) <span class="comment">// [200, 300]</span></span><br></pre></td></tr></table></figure></li>
<li><p>超出数组长度则之后提取的是 undefined。</p>
</li>
</ol>
<p>对象解构和数组解构基本类似，区别在于对象是根据对象的属性名来取值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;agoni&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">const</span> &#123; name &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(name) <span class="comment">// &#x27;agoni&#x27;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;agoni&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span> &#125;</span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&#x27;Agoni&#x27;</span></span><br><span class="line"><span class="comment">// const &#123; name &#125; = obj // 会报错</span></span><br><span class="line"><span class="comment">// 可以重命名</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">name</span>: myName &#125; = obj</span><br><span class="line"><span class="built_in">console</span>.log(myName) <span class="comment">// &#x27;agoni&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="遍历"><a href="#遍历" class="headerlink" title="遍历"></a>遍历</h4><p><strong>Iterator</strong>：</p>
<p>Iterator 是 ES6 中的一种新的遍历机制，是一种接口，为不同的数据结构提供统一的访问机制。</p>
<p>作用：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口；</li>
<li>使数据接口的成员能够按照某种次序排列；</li>
<li>主要供 ES6 新的遍历命令 for…of 消费</li>
</ol>
<p>遍历过程：</p>
<ol>
<li>创建一个指针对象，指向当前数据结构的起始位置，Iterator 的本质就是一个指针对象；</li>
<li>当第一次调用指针对象的 next() 方法时，指针指向数据对象的第一个元素；</li>
<li>依次向后不断调用 next() 方法，直至它指向当前数据结构的结束位置；</li>
</ol>
<p>每一次调用 next() 方法时，均会返回包含两个属性的对象，value 和 done（boolean 值，表示是否遍历完成）；</p>
<p>可以遍历：Array、Map、Set、String、TypedArray、arguments、NodeList</p>
<p><strong>for…of</strong>：</p>
<p>可用于替换 for…in 和 forEach()，循环内部调用的是数据结构的 Symbol.iterator 方法，常用于 Map、Set、Array、String 等；</p>
<p><u>for…in 遍历的是键名，for…of 遍历的是键值</u>。</p>
<h4 id="class-类"><a href="#class-类" class="headerlink" title="class 类"></a>class 类</h4><p>通过 class 关键字，可以定义类，可以看作是一个语法糖，绝大部分功能 ES5 都可以做到，只是让对象原型的写法更加清晰，更像面向对象编程的语法而已：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6 之前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.information = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;, I am &#x27;</span> + <span class="built_in">this</span>.age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 之后</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  information () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;My name is &#x27;</span> + <span class="built_in">this</span>.name + <span class="string">&#x27;, I am &#x27;</span> + <span class="built_in">this</span>.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Math-对象的扩展"><a href="#Math-对象的扩展" class="headerlink" title="Math 对象的扩展"></a>Math 对象的扩展</h4><ul>
<li>二进制表示法：<code>0B</code> 或 <code>0b</code> 开头表示二进制</li>
<li>八进制表示法：<code>0O</code> 或 <code>0o</code> 开头表示八进制</li>
<li>Number.EPSILON：数值最小精度</li>
<li>Number.MIN_SAFE_INTEGER：最小安全数值（<code>-2^53</code>）</li>
<li>Number.MAX_SAFE_INTEGER：最大安全数值（<code>2^53</code>）</li>
<li>Number.parseInt()：返回转换值的整数部分</li>
<li>Number.parseInt()：返回转换值的浮点数部分</li>
<li>Number.isFinite()：是否为有限数值</li>
<li>Number.isNaN()：是否为 NaN</li>
<li>Number.isInteger()：是否为整数</li>
<li>Number.isSafeInteger()：是否在数值安全范围内</li>
<li>Math.trunc()：返回数值整数的部分</li>
<li>Math.sign()：返回数值类型（<code>正数1</code>、<code>负数-1</code>、<code>零0</code>）</li>
<li>Math.cbrt()：返回数值立方根</li>
<li>Math.clz32()：返回数值的 32 位无符号整数形式</li>
<li>Math.imul()：返回两个数值相乘</li>
<li>Math.fround()：返回数值的 32 位单精度浮点数形式</li>
<li>Math.hypot()：返回所有数值平方和的平方根</li>
<li>Math.expm1()：返回 <code>e^n - 1</code> </li>
<li>Math.log1p()：返回 <code>1 + n</code> 的自然对数（<code>Math.log(1 + n)</code>）</li>
<li>Math.log10()：返回以 10 为底的 n 的对数</li>
<li>Math.log2()：返回以 2 为底的 n 的对数</li>
<li>Math.sinh()：返回 n 的双曲正弦</li>
<li>Math.cosh()：返回 n 的双曲余弦</li>
<li>Math.tanh()：返回 n 的双曲正切</li>
<li>Math.asinh()：返回 n 的反双曲正弦</li>
<li>Math.acosh()：返回 n 的反双曲余弦</li>
<li>Math.atanh()：返回 n 的反双曲正切</li>
</ul>
<h4 id="Array-对象的扩展"><a href="#Array-对象的扩展" class="headerlink" title="Array 对象的扩展"></a>Array 对象的扩展</h4><p>Array.prototype.from()：转换具有 Iterator 接口的数据结构为真正数组，返回新数组；</p>
<p>Array.prototype.of()：转换一组值为真正数组，返回新数组；</p>
<p>Array.prototype.copyWithin()：把指定位置的成员复制到其他位置，返回原数组；</p>
<p>Array.prototype.find()：返回第一个符合条件的成员；</p>
<p>Array.prototype.findIndex()：返回第一个符合条件的成员索引值；</p>
<p>Array.prototype.fill()：根据指定值填充整个数组，返回原数组；</p>
<p>Array.prototype.keys()：返回以索引值为遍历器的对象；</p>
<p>Array.prototype.values()：返回以属性值为遍历器的对象；</p>
<p>Array.prototype.entries()：返回以索引值和属性值为遍历器的对象；</p>
<p>数组空位：明确将数组空位转为 undefined 或 empty：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from([<span class="string">&#x27;a&#x27;</span>,, <span class="string">&#x27;b&#x27;</span>]) <span class="comment">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span></span><br><span class="line">[...[<span class="string">&#x27;a&#x27;</span>,, <span class="string">&#x27;b&#x27;</span>]] 				<span class="comment">// [&#x27;a&#x27;, undefined, &#x27;b&#x27;]</span></span><br><span class="line"><span class="built_in">Array</span>(<span class="number">3</span>) 	<span class="comment">// [empty × 3]</span></span><br><span class="line">[, <span class="string">&#x27;a&#x27;</span>] 	<span class="comment">// [empty, &#x27;a&#x27;]</span></span><br></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p><strong>函数参数设置默认值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f_1</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> text = text || <span class="string">&#x27;AgoniLay&#x27;</span> <span class="comment">// 缺点在于 text 传 falsy 值则一直会是后值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f_2</span> (<span class="params">text = <span class="string">&#x27;AgoniLay&#x27;</span></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>对象的简化赋值</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&#x27;AgoniLay&#x27;</span>, age = <span class="number">20</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; <span class="attr">name</span>: name, <span class="attr">age</span>: age &#125;</span><br><span class="line"><span class="comment">// 简化为</span></span><br><span class="line"><span class="keyword">const</span> person = &#123; name, age &#125;</span><br></pre></td></tr></table></figure>

<p><strong>Spread/Rest 操作符</strong>：</p>
<p>Rest 操作符用于获取函数调用时传入的参数；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fun = <span class="function"><span class="keyword">function</span>(<span class="params">...args</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>扩展运算符（Spread）用于数组的构造、析构，以及在函数调用时使用数组填充参数列表；</p>
<p>只能用于可迭代对象，否则会报错；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"><span class="keyword">const</span> arr = [...arr1, ...arr2]</span><br><span class="line"><span class="keyword">const</span> [num, ...nums] = arr2</span><br><span class="line"><span class="built_in">console</span>.log(num) 	<span class="comment">// 3</span></span><br><span class="line"><span class="built_in">console</span>.log(nums)	<span class="comment">// [4, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>super</strong>：</p>
<p>通过使用 super 可以调用某个对象的 prototype 对象的方法或获取参数。</p>
<p><strong>模板字符串</strong>（Template string）：</p>
<p>在 ES6 之前要将字符串和变量拼接起来只能通过 <code>+</code> 来实现，内容过多需要 <code>\</code> 表示换行；</p>
<p>在 ES6 中可以使用 <code>``</code> 将内容括起来，在反引号中，使用 <strong><code>$&#123;&#125;</code></strong> 来写入需要引用的变量，且<strong>回车换行也真实有效</strong>。</p>
<p><strong>模块化</strong>：</p>
<p>在 ES6 之前，JS 并没有模块化的概念，有的只是社区制定的如 CommonJS、AMD 之类的规则，ES6 之后可以使用专属的模块化语法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出</span></span><br><span class="line"><span class="keyword">const</span> &#123; PI &#125; = <span class="built_in">Math</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> area = <span class="function"><span class="params">r</span> =&gt;</span> PI * r ** <span class="number">2</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> circumference = r = <span class="number">2</span> * PI * r</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入</span></span><br><span class="line"><span class="keyword">import</span> &#123; area &#125; <span class="keyword">from</span> <span class="string">&#x27;./circle.js&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`半径为 4 的圆的面积是：<span class="subst">$&#123;area(<span class="number">4</span>)&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<p><strong>RegExp 对象的扩展</strong>：</p>
<p>新增符号：</p>
<ul>
<li><code>i</code> 修饰符：ignore，不区分大小写；</li>
<li><code>y</code> 修饰符：sticky，粘连修饰符，与 g 类似，也是全局匹配，但 y 要求匹配之后后一个匹配必须从剩余的第一个位置开始；</li>
<li><code>u</code> 修饰符：unicode，表示开启 Unicode 模式，用来正确处理大于 <code>\uFFF</code> 的 Unicode 字符</li>
</ul>
<p>String.prototype.flags 用来查看 RegExp 构造函数的修饰符；</p>
<p>RegExp.prototype.sticky 返回是否有 y 修饰符；</p>
<p>字符串方法的实现改为了调用 RegExp 方法：</p>
<ul>
<li>String.prototype.match 调用 <code>RegExp.prototype[Symbol.match]</code> </li>
<li>replace、search、split 同理</li>
</ul>
<h4 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h4><p>**Array.prototype.includes()**：用来判断一个数组是否包含一个指定的值，包含返回 true，否则返回 false</p>
<p>**幂运算符 ****：具有与 Math.pow() 一样的功能</p>
<p><strong>模板字符串</strong>：</p>
<ul>
<li>Unicode 字符以 <code>u</code> 开头，例如 <code>\u00A9</code> </li>
<li>Unicode 码位用 <code>u&#123;&#125;</code> 开头，例如 <code>\u&#123;2F804&#125;</code> </li>
<li>十六进制以 <code>x</code> 开头，例如 <code>\x49</code> </li>
<li>八进制以 <code> </code> 和数字开头，例如 <code>\251</code> </li>
</ul>
<h4 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h4><p><strong>async/await</strong>：就是 Promise 的语法糖，用来解决链式调用过多而形成的 面条地狱</p>
<p>**Object.values()**：返回一个给定对象自身的所有可枚举属性值的数组，顺序与使用 for…in 循环的顺序相同</p>
<p>**Object.entries()**：返回一个给定对象自身可枚举属性的键值对数组，顺序与使用 for…in 循环的顺序相同</p>
<p>**padStart()**：用另一个字符串填充当前字符串，以便产生的字符串达到给定的长度，填充从字符串的左侧开始；</p>
<p>**padEnd()**：与 padStart() 一样，填充从字符串的右侧开始；</p>
<p><strong>函数参数结尾逗号</strong>：参数不能仅包含逗号，使用 <code>...</code> 剩余参数时不支持使用；</p>
<p><strong>Atomics 对象</strong>：提供了一组静态方法来对 <code>SharedArrayBuffer</code> 对象进行原子操作；</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220505173659289.png" class title="ES8 Atomics 对象方法">

<p>**Object.getOwnPropertyDescriptors()**：用来获取一个对象的所有自身属性的描述符。</p>
<h4 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h4><p><strong>for await…of</strong>：会在异步或者同步可迭代对象上创建一个迭代循环，调用自定义迭代钩子，并为每个不同属性的值执行语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span>* <span class="title">asyncGenerator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = <span class="number">3</span></span><br><span class="line">  <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> i--</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> <span class="keyword">await</span> (<span class="keyword">let</span> num <span class="keyword">of</span> asyncGenerator()) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(num)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// 3 2 1</span></span><br></pre></td></tr></table></figure>

<p><strong>模板字符串</strong>：ES9 开始允许嵌套支持常见转义序列，移除对 ECMAScript 在带标签的模板字符串中转义序列的语法限制</p>
<p><strong>正则表达式反向断言</strong>：</p>
<p>断言表示当前位置附近的指定位置的字符串应该满足断言，但是并不捕获；ES9 开始支持反向断言。</p>
<p>正则表达式的断言一共有 4 种形式：</p>
<ul>
<li><code>(?=pattern)</code> 零宽正向肯定断言</li>
<li><code>(?!pattern)</code> 零宽正向否定断言</li>
<li><code>(?&lt;=pattern)</code> 零宽反向肯定断言</li>
<li><code>(?&lt;!pattern)</code> 零宽反向否定断言</li>
</ul>
<p><strong>正则表达式 s/dotAll 模式</strong>：新的修饰符 <code>s</code> 表示可以匹配任意字符；</p>
<p><strong>正则命名捕获组</strong>：允许为每一个组匹配指定一个名字，便于阅读代码，也便于引用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = <span class="regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">&#x27;1999-12-31&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.year <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.month <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> year = matchObj.groups.day <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>

<p><strong>对象扩展运算符</strong>：ES6 添加了数组的扩展操作符，ES9 开始支持对对象使用</p>
<p>**Promise.prototype.finally()**：会返回一个 Promise，当 Promise 的状态变更，都会执行 finally() 的回调</p>
<h4 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h4><p>**Array.prototype.flat()/flatMap()**：</p>
<p>flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回；</p>
<p>flatMap() 与 map() 方法和深度为 1 的 flat() 几乎相同，区别在于会首先使用映射函数映射每个元素，然后将结果压缩成一个新数组，效率会更高。    </p>
<p>**String.prototype.trimStart()/trimLeft()/trimEnd()/trimRight()**：单独去掉首部和尾部的空格</p>
<p>**Object.fromEntries()**：把键值对列表转换成一个对象，是 <code>Object.entries()</code> 的反函数</p>
<p><strong>Symbol.prototype.description</strong>：是一个只读属性，会返回 <code>Symbol</code> 对象的可选描述的字符串：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>).toString()   <span class="comment">// ‘Symbol(desc)’</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;desc&#x27;</span>).description  <span class="comment">// ’desc‘</span></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">&#x27;&#x27;</span>).description  <span class="comment">// &#x27;&#x27;</span></span><br><span class="line"><span class="built_in">Symbol</span>().description  <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>**String.prototype.matchAll()**：返回一个包含所有匹配正则表达式的结果及分组捕获组的迭代器</p>
<p>**Function.prototype.toString()**：在 ES10 之前，此方法得到的字符串是去掉空白符号的，但从 ES10 开始会保留这些空格和注释内容</p>
<p><strong>try-catch</strong>：catch 后所需要的异常参数变为非必须</p>
<p><strong>BigInt</strong>：是一种内置对象，BigInt 可以表示任意大小的整数，在一个整数字面量后加 <code>n</code> 来定义一个 BigInt，或者调用函数 <code>BigInt()</code>；</p>
<p>基本可以进行全部操作符的运算（除 <code>&gt;&gt;&gt;(无符号右移)</code> 之外），不支持单目(<code>+</code>)运算符</p>
<p><strong>globalThis</strong>：包含类似全局对象 <code>this</code> 值，所以在全局环境下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">globalThis === <span class="built_in">this</span></span><br></pre></td></tr></table></figure>

<p>**import()**：静态的 <code>import</code> 语句用于导入由另一个模块导出的绑定，导入的模块必定运行在严格模式下，在浏览器中，<code>import</code> 语句只能在声明了 <code>type=&quot;module&quot;</code> 的 script 标签内使用；</p>
<p>ES10 之后，添加了动态的 <code>import()</code>，不需要依赖 <code>type=&quot;module&quot;</code> 的 script 标签</p>
<p><strong>私有元素和方法</strong>：在 ES10 之后可以使用私有变量进行组件封装。</p>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>概念：视图模型双向绑定，是 <code>Model-View-ViewModel</code> 的缩写，也就是将 MVC 中的 Controller 演变成 ViewModel。</p>
<ul>
<li>Model 层代表数据模型</li>
<li>View 代表 UI 组件</li>
<li>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 ViewModel 层并自动将数据渲染到页面中，视图变化时会通知 ViewModel 层更新数据；</li>
</ul>
<p>以前是操作 DOM 结构更新视图，现在是<strong>数据驱动视图</strong>。</p>
<p>优点：</p>
<ol>
<li><strong>低耦合</strong>：View 可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化时 Model 可以不变化，反之也一样；</li>
<li><strong>可重用性</strong>：可以把一些视图逻辑放在一个 Model 里，让很多的 View 重用这段视图逻辑；</li>
<li><strong>独立开发</strong>：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li><strong>可测试</strong>。</li>
</ol>
<h3 id="Vue2-Vue3"><a href="#Vue2-Vue3" class="headerlink" title="Vue2 - Vue3"></a>Vue2 - Vue3</h3><h4 id="变化"><a href="#变化" class="headerlink" title="变化"></a>变化</h4><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220502223310066.png" class title="Vue3 新特性">

<ul>
<li>速度更快<ul>
<li>重写了虚拟 DOM 实现</li>
<li>编译模板的优化</li>
<li>更高效的组件初始化</li>
<li>update 性能提高了 1.3 ~ 2 倍</li>
<li>SSR 速度提高了 2 ~ 3 倍</li>
</ul>
</li>
<li>体积更小<ul>
<li>通过 Webpack 的 tree-shaking 功能将无用代码剪辑</li>
</ul>
</li>
<li>更易维护<ul>
<li>Composition API</li>
<li>更好的 Typescript 支持</li>
<li>编译器重写</li>
</ul>
</li>
<li>更接近原生<ul>
<li>可以自定义渲染 API</li>
</ul>
</li>
<li>更易使用<ul>
<li>由于响应式 API 的暴露，可以自定义响应式相关</li>
<li>轻松识别组件重新渲染的原因</li>
</ul>
</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><p><strong>双向数据绑定原理发生了改变</strong>：</p>
<ul>
<li>Vue2 的双向数据绑定时利用 ES5 的 <strong><code>Object.defineProperty()</code></strong> 对数据进行劫持，结合发布订阅模式来实现；</li>
<li>Vue3 中使用了 ES6 的 <strong>proxy</strong> API 对数据代理</li>
</ul>
<p>Vue3 使用 proxy 的优势：</p>
<ol>
<li>defineProperty 只能监听某个属性，不能对全对象监听；</li>
<li>可以省去 for in、闭包等来提升效率（直接绑定整个对象 ）；</li>
<li>可以监听数组，不用再去单独的对数组做特异性操作。</li>
</ol>
<p><strong>Vue3 支持碎片（Fragments）</strong>：</p>
<p>也就是在组件中可以拥有多个根节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Vue2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;form-element&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Vue3 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&#x27;form-element&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; title &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>Composition API</strong>：</p>
<p>Vue2 与 Vue3 最大的区别就是 Vue2 使用<strong>选项型 API（Options API）</strong>而 Vue3 使用<strong>合成型 API（Composition API）</strong>。</p>
<p>旧的选项型 API 在代码里分割了不同的属性 data、computed、methods 等；新的合成型 API 可以使用方法来分割，相比于选项型 API 使用属性来分割会<u>更加简便和整洁</u>。</p>
<p>Vue2：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">firstname</span>: <span class="string">&#x27;Agoni&#x27;</span>,</span><br><span class="line">      <span class="attr">lastname</span>: <span class="string">&#x27;Lay&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    add () &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    btnComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    fullName () &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">this</span>.firstname + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastname</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue3：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="built_in">String</span></span><br><span class="line">  &#125;,</span><br><span class="line">  setup () &#123;</span><br><span class="line">    <span class="keyword">const</span> state = reactive(&#123;</span><br><span class="line">      <span class="attr">firstname</span>: <span class="string">&#x27;Agoni&#x27;</span>,</span><br><span class="line">      <span class="attr">lastname</span>: <span class="string">&#x27;Lay&#x27;</span>,</span><br><span class="line">      <span class="attr">fullName</span>: computed(<span class="function">() =&gt;</span> state.firstname + <span class="string">&#x27; &#x27;</span> + state.lastName)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">const</span> login = <span class="function">() =&gt;</span> &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      login,</span><br><span class="line">      state</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>建立数据 data</strong>：</p>
<p>Vue2 中直接将数据放入 data 属性中；在 Vue3 中，需要使用一个新的 setup() 方法，此方法在组件初始化的时候触发：</p>
<ol>
<li>从 vue 中引入 reactive；</li>
<li>使用 reactive() 方法来声明数据为响应式数据；</li>
<li>使用 setup() 方法返回响应式数据，从而使 template 可以获取到这些数据。</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123; state.username &#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    setup () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> state = reactive(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">firstname</span>: <span class="string">&#x27;agoni&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">lastname</span>: <span class="string">&#x27;lay&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123; state &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>生命周期钩子 - Lifecycle Hooks</strong>：</p>
<table>
<thead>
<tr>
<th align="right">Vue2</th>
<th>Vue3</th>
</tr>
</thead>
<tbody><tr>
<td align="right">beforeCreate</td>
<td>setup()</td>
</tr>
<tr>
<td align="right">created</td>
<td>setup()</td>
</tr>
<tr>
<td align="right">beforeMount</td>
<td>onBeforeMount</td>
</tr>
<tr>
<td align="right">mounted</td>
<td>onMounted</td>
</tr>
<tr>
<td align="right">beforeUpdate</td>
<td>onBeforeUpdate</td>
</tr>
<tr>
<td align="right">updated</td>
<td>onUpdated</td>
</tr>
<tr>
<td align="right">beforeDestroy</td>
<td>onBeforeUnmount</td>
</tr>
<tr>
<td align="right">destroyed</td>
<td>onUnmounted</td>
</tr>
<tr>
<td align="right">activated</td>
<td>onActivated</td>
</tr>
<tr>
<td align="right">deactivated</td>
<td>onDeactivated</td>
</tr>
</tbody></table>
<p>**setup()**：</p>
<ul>
<li>可以接受两个参数（props、context(包含 attrs、slots、emit)）</li>
<li>在开始创建组件之前，在 beforeCreate 和 created 之前执行，创建的是 data 和 method</li>
<li>执行 setup 时，组件实例尚未被创建<ul>
<li>this 此时并不指向 vue 实例，Vue 为避免错误引用，直接将 setup 函数中的 this 指向了 undefined</li>
</ul>
</li>
<li>与模板一起使用需要返回一个对象，在 setup 函数中定义的变量和对象都需要 return 出去才可以使用</li>
<li>可以返回一个渲染函数，该函数可以直接使用在同一作用域中声明的响应式状态</li>
</ul>
<p>注意：</p>
<ul>
<li><p>setup 函数中不能使用 this；</p>
</li>
<li><p>setup 函数中的 props 时响应式的，传入新的 prop 时，它将被更新；不能使用 ES6 解构，因为会消除 prop 的响应性，如需解构，可以使用 setup 函数中的 <code>toRefs</code> 来完成：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; toRefs &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup (props) &#123;</span><br><span class="line">    <span class="keyword">const</span> title = toRefs(props)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在 setup 内使用响应式数据时，需要通过 <code>.value</code> 获取；</p>
</li>
<li><p>从 setup 中返回的对象上的属性在模板中使用时，将自动展开为内布置，不需要追加 <code>.value</code>；</p>
</li>
<li><p>setup 函数只能时同步的，不能是异步的。</p>
</li>
</ul>
<p><strong>父子传参</strong>：</p>
<p>父传子：使用 <strong>props</strong> </p>
<p>子传父：通过<strong>自定义事件 Emitting Events</strong> </p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vue2</span></span><br><span class="line">login () &#123;</span><br><span class="line">  <span class="built_in">this</span>.$emit(<span class="string">&#x27;login&#x27;</span>, &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="built_in">this</span>.username,</span><br><span class="line">    <span class="attr">password</span>: <span class="built_in">this</span>.password</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue3</span></span><br><span class="line">setup (props, &#123; attrs, slots, emit &#125;) &#123;</span><br><span class="line">  <span class="keyword">const</span> state = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> login = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    emit(<span class="string">&#x27;login&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">username</span>: state.username,</span><br><span class="line">      <span class="attr">password</span>: state.password</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>setup() 函数的第二个参数 context 是一个普通对象，所以可以安全地对 context 进行使用 ES6 的解构。</p>
</blockquote>
<h4 id="新增"><a href="#新增" class="headerlink" title="新增"></a>新增</h4><p><strong>framents</strong>：组件支持有多个根节点</p>
<p><strong>Teleport</strong>： 是一种可以将模板移动到 DOM 中 Vue app 外的其他位置的技术，像 modals、toast 等元素，若嵌套在某个组件内部，则组件的定位、层叠和样式就会变得复杂，通过 Teleport 可以在组件的逻辑位置写模板代码，然后在 Vue 应用范围之外渲染。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;showToast&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">class</span>=<span class="string">&quot;btn&quot;</span>&gt;</span></span><br><span class="line">  打开 Toasts</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- to 属性就是要渲染的目标位置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">teleport</span> <span class="attr">to</span>=<span class="string">&quot;#teleport-target&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;visible&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">class</span>=<span class="string">&quot;toast-wrap&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;toast-msg&quot;</span>&gt;</span>Toast 文案<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">teleport</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><strong>createRenderer</strong>：构建自定义渲染器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createRenderer &#125; <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123; render, createApp &#125; = createRenderer(&#123;</span><br><span class="line">  patchProp,</span><br><span class="line">  insert,</span><br><span class="line">  remove,</span><br><span class="line">  createElement,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; render, createApp &#125;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&#x27;@vue/runtime-core&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>composition API</strong>：组合式 API，能够更加容易维护代码，将相同功能的变量进行一个集中式的管理：</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/format,png.png" class title="composition API">

<h4 id="非兼容更改"><a href="#非兼容更改" class="headerlink" title="非兼容更改"></a>非兼容更改</h4><p><strong>模板指令</strong>：</p>
<ul>
<li>组件上 v-model 的用法更改</li>
<li><code>&lt;template v-for&gt;</code> 和非 v-for 节点上 key 用法更改</li>
<li>同一元素上 v-for 和 v-if 的优先级改变</li>
<li><code>v-bind=&quot;object&quot;</code> 现在排序敏感</li>
<li><code>v-for</code> 中的 ref 不再注册 ref 数组</li>
</ul>
<hr>
<h3 id="Vue-底层原理"><a href="#Vue-底层原理" class="headerlink" title="Vue 底层原理"></a>Vue 底层原理</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.definedProperty() 来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>Vue 是一个典型的 MVVM 框架，Model 只是普通的 JavaScript 对象，修改它则 View 会自动更新，这种设计让状态管理变得非常简单而直观。</p>
<p><code>Observer</code>（数据监听器）：Observer 的核心时通过 Object.defineProperty() 来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter，此时 Observer 通知订阅者，也就是 Watcher；</p>
<p><code>Watcher</code>（订阅者）：Watcher 订阅者作为 Observer 和 Complie 之间通信的桥梁：</p>
<ol>
<li>在自身实例化时往属性订阅器（dep）中添加自己</li>
<li>自身必须有一个 update 方法</li>
<li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调</li>
</ol>
<p><code>Compile</code>（指令解析器）：Compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听函数的订阅者，一旦数据有变动，收到通知就更新视图。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件：</p>
<ul>
<li>create 阶段：vue 实例被创建<ul>
<li><code>beforeCreate</code>：创建前，此时 data 和 methods 中的数据还没有初始化；</li>
<li><code>created</code>：创建完毕，data 中有值，但还未挂载；</li>
</ul>
</li>
<li>mount 阶段：vue 实例被挂载到真实 DOM 节点<ul>
<li><code>beforeMount</code>：可以发起服务器请求去请求数据；</li>
<li><code>mounted</code>：此时可以操作 DOM；</li>
</ul>
</li>
<li>update 阶段：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<ul>
<li><code>beforeUpdate</code>：更新前；</li>
<li><code>updated</code>：更新后；</li>
</ul>
</li>
<li>destroy 阶段：vue 实例被销毁<ul>
<li><code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法；</li>
<li><code>destroyed</code>：销毁后。</li>
</ul>
</li>
<li>activate 阶段：keep-alive 组件专属生命周期<ul>
<li><code>activated</code>：被 keep-alive 缓存的组件激活时调用</li>
<li><code>deactivated</code>：被 keep-alive 缓存的组件失活时调用</li>
</ul>
</li>
</ul>
<p>组件生命周期：</p>
<p>父组件 beforeCreate -&gt; 父组件 created -&gt; 父组件 beforeMount -&gt; 子组件 beforeCreate -&gt; 子组件 created -&gt; 子组件 beforeMount -&gt; 子组件 mounted -&gt; 父组件 mounted -&gt; 父组件 beforeDestroy -&gt; 子组件 beforeDestroy -&gt; 子组件 detroyed -&gt;  父组件 detroyed</p>
<p>父组件更新：父组件 beforeUpdate -&gt; 父组件 updated</p>
<p>子组件更新：父组件 beforeUpdate -&gt; 子组件 beforeUpdate -&gt; 子组件 updated -&gt; 父组件 updated</p>
<h3 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed watch"></a>computed watch</h3><p>既能用 computed 实现又可以用 watch 监听来实现的功能，推荐使用 computed：</p>
<ul>
<li>computed 计算属性是用来声明式的描述一个值依赖了其他的值，当所依赖的值或者变量改变时，计算属性就会跟着改变；</li>
<li>watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</li>
</ul>
<p>watch 监听属性：是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用；</p>
<p>computed 计算属性：属性的结果会被缓存，当 computed 中的函数所以来的属性没有发生变化时，调用当前函数时就会从缓存中读取结果，只有当依赖的响应式属性变化时才会重新计算，主要当做属性来使用；computed 中的函数必须用 return 返回最后的结果，computed 更高效，优先使用；</p>
<p>使用场景：</p>
<ul>
<li>computed：当一个属性受多个属性影响的时候使用；</li>
<li>watch：当一条数据影响多条数据的时候使用。</li>
</ul>
<h3 id="data-为何是函数"><a href="#data-为何是函数" class="headerlink" title="data 为何是函数"></a>data 为何是函数</h3><ol>
<li>一个组件被复用多次的的话，也就会创建多个实例。本质上这些实例都是用的同一个构造函数。</li>
<li>如果 data 是对象的话，对象是引用类型，会影响到所有的实例。</li>
</ol>
<p>所以为了<strong>保证组件不同的实例之间 data 不冲突</strong>，data 必须是一个函数。</p>
<h3 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a>v-for 和 v-if</h3><ol>
<li>当 v-for 和 v-if 处于一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中；如果要遍历的数组很大，而真正展示的数据又很少时，这将造成很大的性能浪费；</li>
<li>这种场景建议使用 computed，先对数据进行过滤；或者将 v-if 提至外层使用 template。</li>
</ol>
<blockquote>
<p>3.x 版本中 v-if 总是优先于 v-for 生效。</p>
</blockquote>
<p>由于语法上存在歧义，建议避免在同一元素上同时使用两者。</p>
<p>比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p>
<h3 id="React-Vue-中的-key"><a href="#React-Vue-中的-key" class="headerlink" title="React/Vue 中的 key"></a>React/Vue 中的 key</h3><ul>
<li><p>key 的作用是是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度，更高效的更新虚拟 DOM；</p>
<p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中，会根据节点的 key 去对比就跌点数组中的 key，从而找到相应旧节点，若没有找到则认为是一个新增节点。如果没有 key，就需要采用遍历查找的方式去找到对应的节点。一种是 map 映射，另一种是遍历查找，相比而言，map 映射的速度更快；</p>
</li>
<li><p>为了在数据变化时强制更新组件，以避免就地复用带来的副作用；</p>
<p>当 vue 用 v-for 更新已渲染的元素列表时，默认使用就地复用策略，如果数据项的顺序被改变，vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，重复的 key 将会造成渲染错误。</p>
</li>
</ul>
<h3 id="vue-组件的通信方式"><a href="#vue-组件的通信方式" class="headerlink" title="vue 组件的通信方式"></a>vue 组件的通信方式</h3><ul>
<li><code>props</code>/<code>$emit</code> 父子组件通信：<ul>
<li>父 -&gt; 子 <code>props</code>，子 -&gt; 父 <code>$on、$emit</code> 获取父子组件实例</li>
<li><code>parent、children</code> 获取实例的方式调用组件的属性或者方法</li>
<li>父 -&gt; 子孙 <code>Provide、inject</code> 官方不推荐使用，但写组件库时较为常用</li>
</ul>
</li>
<li><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信：<ul>
<li><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</li>
</ul>
</li>
<li>vuex 跨级组件通信<ul>
<li>Vuex、<code>$attrs、$listeners</code>、<code>Provide、reject</code> </li>
</ul>
</li>
</ul>
<h3 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h3><ol>
<li>nextTick 是 Vue 提供的一个全局 API，是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM；</li>
<li>Vue 在更新 DOM 时时异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 <code>watcher</code> 被多次触发，只会被推入到队列中一次。这种在缓存时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用；</li>
<li>会在 callbacks 中加入传入的函数，然后用 <code>timerFunc</code> 异步方式调用，首选的异步方式会是 Promise。</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在下次 DOM 更新循环之后执行延迟回调，在修改数据之后使用 nextTick 来获取更新后的 DOM。</p>
<p>nextTick 主要使用的宏任务和微任务，根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，若均不行则采用 setTimeout 定义一个异步方法，多次调用 nextTick 会将此方法存入队列中，通过这个异步方法清空当前队列。</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>分为默认插槽、具名插槽和作用域插槽</p>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。</p>
<p>场景：tabs 标签页、后台导航、vue 性能优化</p>
<p>原理：vue 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点而不是直接存储 DOM 结构。将满足条件（pruneCache）的组件在 cache 对象中缓存起来，在需要重新渲染时再将 VNode 节点从 cache 对象中取出并渲染。</p>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>多个组件间有重复的逻辑就会用到 mixin，但 mixin 并不是完美的解决方案，会有一些问题（Vue3 提出的 Composition API 旨在解决这些问题）。</p>
<p>场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合</p>
<p>劣势：</p>
<ol>
<li>变量来源不明确，不利于阅读；</li>
<li>多 mixin 可能导致命名冲突；</li>
<li>mixin 和组件可能出现多对多的关系，使得项目复杂度变高。</li>
</ol>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 的核心就是 store（仓库）。</p>
<ol>
<li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，则相应的组件也会得到高效更新；</li>
<li>改变 store 中的状态的唯一途径就是显式地提交（commit）mutation，这使得可以方便地跟踪每一个状态的变化。</li>
</ol>
<p>Vuex 包括以下核心模块：</p>
<ul>
<li><strong>State</strong>：定义了应用的状态数据；</li>
<li><strong>Getter</strong>：再 store 中定义 getter（相当于计算属性）；</li>
<li><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数；</li>
<li><strong>Action</strong>：用于提交 Mutation，而不是直接变更状态，可以包含任意异步操作；</li>
<li><strong>Module</strong>：允许将单一的 Store 拆分成多个 store 且同时保存在单一的状态树中。</li>
</ul>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/vuex.png" class title="vuex">

<h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>Virtual DOM，用普通 JS 对象来描述 DOM 结构</p>
<h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>当一次操作中有多次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这些更新内容保存在本地一个 JS 对象中，最终将这个 JS 对象一次性更新到 DOM 树上，避免无谓的计算量；操作内存中的 JS 对象的速度显然要更快。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以下一个真实的 DOM 节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;real-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Real DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>before update<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用 JS 来模拟 DOM 节点实现虚拟 DOM：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Real DOM&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;virtualDom&#x27;</span>).appendChild(root)</span><br></pre></td></tr></table></figure>

<p><code>Element</code> 方法实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.tagName = tagName</span><br><span class="line">  <span class="built_in">this</span>.props = props || &#123;&#125;</span><br><span class="line">  <span class="built_in">this</span>.children = children || []</span><br><span class="line">  <span class="built_in">this</span>.key = props ? props.key : <span class="literal">undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      count += child.count</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName)</span><br><span class="line">  <span class="keyword">const</span> props = <span class="built_in">this</span>.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">    el.setAttributte(propName, props[propName])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> Element) ? child.render() : <span class="built_in">document</span>.createTextNode(child)</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Diff"><a href="#Diff" class="headerlink" title="Diff"></a>Diff</h4><p>Diff 实现 O(n) 复杂度：</p>
<p>新的 DOM 树：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),								<span class="comment">// REPLACE</span></span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]),						 	<span class="comment">// TEXT</span></span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;marginLeft10&#x27;</span> &#125;, [   			<span class="comment">// PROPS</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]), // REORDER remove</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>diff 算法会从根节点开始，逐层向下比较旧虚拟 DOM 和新虚拟 DOM，如果在某一层的耨个节点发现不同，则判断变化类型，做出相应的处理，只有以下四种情况：</p>
<ol>
<li><p>节点类型变了，<code>p -&gt; h3</code>，此过程称为 <code>REPLACE</code>，<strong>直接将旧节点卸载并装载新节点</strong>，包括旧节点下的全部子节点也全部卸载；</p>
<p>当旧节点和新节点仅仅是类型变化，但下面的所有子节点都一样时，这种做法效率不高，但为了避免较高的时间复杂度，此做法值得；</p>
<p>所以开发时应避免无谓的节点类型的变化；</p>
</li>
<li><p>节点类型一样，仅仅属性或属性值变了，此过程称为 <code>PROPS</code>，此时不会触发节点卸载和装载，而是进行节点更新，查找不同属性的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span> (<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = oldNode</span><br><span class="line">  <span class="keyword">const</span> newProps = newNode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">const</span> propsPatches = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> isSame = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(oldProps.hasOwnProperty(key))) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>仅文本发生，直接修改文字内容即可，称为 <code>TEXT</code>；</p>
</li>
<li><p>移动/增加/删除 子节点，此过程称为 <code>REORDER</code>：</p>
<ul>
<li>若元素没有指定 key，或者在 for 循环中使用 index 作为 key，则会依次遍历，从改变项逐个向后做修改；</li>
<li>若有指定唯一不变的 key，则会直接找到改变项进行修改，极大提升了 diff 算法的效率。</li>
</ul>
</li>
</ol>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><p><strong>git config</strong>：</p>
<p>配置 Git 的相关参数，一共有三个配置文件：</p>
<ol>
<li>仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，只对配置文件所在的仓库有效；</li>
<li>全局配置文件：MAC 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>；</li>
<li>系统级配置文件：在 Git 的安装目录进行下的 <code>etc/gitconfig</code>（MAC 系统下安装目录在 <code>/usr/local/git</code>）</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>:：仓库级  --global：全局级  --system：系统级</span></span><br><span class="line">git config &lt; --local | --global | --system &gt; -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前生效的配置信息</span></span><br><span class="line">git config -l</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑配置文件</span></span><br><span class="line">git config &lt; --local | --global | --system &gt; -e</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加配置项</span></span><br><span class="line">git config &lt; --local | --global | --system &gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取配置项</span></span><br><span class="line">git config &lt; --local | --global | --system &gt; --get &lt;name&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除配置项</span></span><br><span class="line">git config &lt; --local | --global | --system &gt; --unset &lt;name&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置提交记录中的用户信息</span></span><br><span class="line">git config --global user.name &lt;用户名&gt;</span><br><span class="line">git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改 Git 缓存区大小，单位 B</span></span><br><span class="line">git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用 git status/diff 时以高亮或彩色显示改动状态</span></span><br><span class="line">git config --global color.ui true</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置可以缓存密码，默认缓存时间 15 分钟</span></span><br><span class="line">git config --global credential.helper &#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置长期存储密码</span></span><br><span class="line">git config --global credential.helper store</span><br></pre></td></tr></table></figure>

<p><strong>查看、添加、提交、删除、找回、重置修改文件</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">git help &lt;command&gt; # 显示 command 相关的 help</span><br><span class="line">git show # 显示某次提交的内容</span><br><span class="line">git co -- &lt;file&gt; # 抛弃工作区对应文件修改</span><br><span class="line">git co . # 抛弃工作区修改</span><br><span class="line">git add &lt;file&gt; # 将对应工作文件修改提交到本地暂存区</span><br><span class="line">git add . # 提交全部修改</span><br><span class="line">git rm &lt;file&gt; # 从版本库中删除文件</span><br><span class="line">git rm &lt;file&gt; --cached # 从版本库中删除文件，但不删除源文件</span><br><span class="line">git reset &lt;file&gt; # 从暂存区恢复到工作区</span><br><span class="line">git reset -- . # 从暂存区恢复到工作区</span><br><span class="line">git reset --hard # 恢复最近一次提交过的状态</span><br><span class="line">git ci --amend # 修改最后一次提交记录</span><br><span class="line">git revert &lt;$id&gt; # 恢复某次提交的状态，恢复动作本身也创建次提交状态</span><br><span class="line">git revert HEAD # 恢复最后一次提交的状态</span><br></pre></td></tr></table></figure>

<p>查看文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;file&gt; # 比较当前文件和暂存区文件差异</span><br><span class="line">git diff &lt;$id1&gt; &lt;$id2&gt; # 比较两次提交之间的差异</span><br><span class="line">git diff &lt;branch1&gt; &lt;branch2&gt; # 比较两个分支之间的差异</span><br><span class="line">git diff --staged # 比较暂存区和版本库差异</span><br><span class="line">git diff --cached # 比较暂存区和版本库差异</span><br><span class="line">git diff -stat # 仅仅比较统计信息</span><br></pre></td></tr></table></figure>

<p>查看提交记录</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git log &lt;file&gt; # 查看该文件每次提交记录</span><br><span class="line">git log -p &lt;file&gt; # 查看每次详细修改内容的 diff</span><br><span class="line">git log -p -2 # 查看近两次详细修改内容的 diff</span><br><span class="line">git log --stat # 查看提交统计信息</span><br><span class="line"><span class="meta">#</span><span class="bash"> Mac 上可以用 tig 代替 diff 和 <span class="built_in">log</span></span></span><br><span class="line">brew install tig</span><br></pre></td></tr></table></figure>

<p><strong>本地分支管理</strong>：</p>
<p><code>git branch</code> 可以简写为 <code>git br</code> </p>
<p><code>git checkout</code> 简写为 <code>git co</code> </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git br -r # 查看远程分支</span><br><span class="line">git br &lt;new_branch&gt; # 创建新的分支</span><br><span class="line">git br -v # 查看各个分支最后提交信息</span><br><span class="line">git br --merged # 查看已经被合并到当前分支的分支</span><br><span class="line">git br --no-merged # 查看尚未被合并到当前分支的分支</span><br><span class="line">git co &lt;branch&gt; # 切换分支</span><br><span class="line">git co -b &lt;new_branch&gt; # 创建新分支并切换至新分支</span><br><span class="line">git co -b &lt;new_branch&gt; &lt;branch&gt; # 基于 branch 创建</span><br><span class="line">git co $id # 把某次历史提交记录 checkout 出来，无分支信息，切换之后会自动删除</span><br><span class="line">git co $id -b &lt;new_branch&gt; # 把某次历史提交记录 checkout 出来并创建成一个分支</span><br><span class="line">git br -d &lt;branch&gt; # 删除分支</span><br><span class="line">git br -D &lt;branch&gt; # 强制删除分支(未被合并的分支删除时需强制删除)</span><br></pre></td></tr></table></figure>

<p>分支合并和 rebase</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt; # 将 branch 分支合并到当前分支</span><br><span class="line">git merge origin/master --no-ff # 不要 Fast-Foward 合并，还可以生成 merge 提交</span><br><span class="line">git rebase master &lt;branch&gt; # 将 master rebase 到 branch</span><br></pre></td></tr></table></figure>

<p><strong>远程分支管理</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">git pull # 抓取远程仓库所有分支更新并合并到本地，相当于 fetch merge</span><br><span class="line">git pull --no-ff # 不要快进合并</span><br><span class="line">git fetch origin # 抓取远程仓库更新</span><br><span class="line">git merge origin/master # 将远程主分支合并到本地当前分支</span><br><span class="line">git co --track origin/branch # 跟踪某个远程分支创建的本地分支</span><br><span class="line">git co -b &lt;local_branch&gt; origin/&lt;remote_branch&gt; # 基于远程分支创建本地分支</span><br><span class="line">git push # push 所有分支</span><br><span class="line">git push origin master # 将本地主分支推到远程主分支</span><br><span class="line">git push -u origin master # 将本地主分支推到远程（远程无主分支则创建，用于初始化远程仓库）</span><br><span class="line">git push origin &lt;local_branch&gt; # 创建远程分支</span><br><span class="line">git push origin &lt;local_branch&gt;:&lt;remote_branch&gt; # 创建远程分支</span><br><span class="line">git push origin :&lt;remote_branch&gt; # 先删除本地分支，再 push 删除远程分支</span><br></pre></td></tr></table></figure>

<p><strong>其他常用</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> init</span></span><br><span class="line">git init # 初始化一个 repo，在当前文件夹下创建一个 .git 文件夹</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> status</span></span><br><span class="line">git status # 查询当前 repo 的状态</span><br><span class="line">git status -s # 表示 --short，输出标记包含两列</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> commit</span></span><br><span class="line">git commit -m &quot;message&quot; # 提交已经被 add 的改动</span><br><span class="line">git commit -a # 会先将所有已经 track 的文件的改动 add 进来，然后提交，对于没有 tract 的文件还是需要 add</span><br><span class="line">git commit --amend # 增补提交，使用当前提交节点相同的父节点进行一次新的提交，旧的提交将会被取消</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> clean</span></span><br><span class="line">git clean # 从工作目录中移除没有 track 的文件 一般加参数 -df</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> remote</span></span><br><span class="line">git remote # 列出 remote aliases</span><br><span class="line">git remote -v # 可以看到每个别名对应的实际 url</span><br><span class="line">git remote add [alias] [url] # 添加一个新的 remote repo</span><br><span class="line">git remote rm [alias] [url] # 删除一个存在的 remote repo</span><br><span class="line">git remote rename [old_alias] [new_alias] # 重命名</span><br><span class="line">git remote set-url [alias] [url] # 更新 url</span><br></pre></td></tr></table></figure>

<h3 id="管理项目"><a href="#管理项目" class="headerlink" title="管理项目"></a>管理项目</h3><p>实际开发中，一个仓库主要存放两条主分支：master 与 develop 分支，生命周期为整个项目周期。</p>
<ul>
<li>master：这个分支最为稳定，这个分支表明项目处于可发布的状态；</li>
<li>develop：作为开发的分支，平行于 master 分支；</li>
<li>feature branches：功能分支，必须从 develop 分支建立，完成后合并回 develop 分支；</li>
<li>release branches：这个分支用来发布新版本。从 develop 分支建立，完成后合并回 develop 与 master 分支；</li>
<li>hotfix branches：这个分支主要为修复线上特别紧急的 bug 准备，必须从 master 分支建立，完成后合并回 develop 与 master 分支，主要是解决线上版本的紧急 bug 修复</li>
</ul>
<h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><ol>
<li>移除生产环境的控制台打印；<ul>
<li>eslint + pre-commit；</li>
<li>使用插件自动去除：如 <code>terser-webpack-plugin</code>，无需安装额外的插件，仅需在 configureWebpack 中设置 terser 插件的 drop_console 为 true 即可；</li>
<li>vscode 中的 turbo console；</li>
</ul>
</li>
<li>第三方库的按需加载；<ul>
<li>echarts：使用配置文件指定使用的模块；或使用 <code>babel-piugin-equire</code> 实现按需加载；</li>
<li>element-ui：使用 <code>babel-plugin-component</code> 实现按需引入；</li>
</ul>
</li>
<li>避免 CSS 表达式、滤镜，减少 DOM 操作，优化图片、精灵图，避免图片空链接等；</li>
</ol>
<p>优化技术方案：</p>
<ul>
<li>降低请求成本</li>
<li>减少请求数：<ul>
<li>JS、CSS打包到HTML；</li>
<li>JS 控制图片异步加载、懒加载；</li>
<li>小型图片使用 data-uri；</li>
</ul>
</li>
<li>减少传输体积：<ul>
<li>尽量使用 SVG/gradient 代替图片；</li>
<li>根据机型和网络状况控制图片清晰度；</li>
<li>对低清晰度图片使用锐化来提升体验；</li>
<li>设计上避免大型背景图；</li>
</ul>
</li>
<li>使用 CDN 加速</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 是跨站脚本攻击（Cross-Site Scripting），俗称<strong>脚本注入</strong>；典型的例子是在留言板的输入框中输入带有 html 标签的关键字进行恶意的修改页面以及盗取 Cookie。</p>
<p>解决方法：</p>
<ol>
<li>过滤：对诸如 <code>script</code>、<code>img</code>、<code>a</code> 等标签进行过滤；</li>
<li>编码：像一些常见的符号，如 <code>&lt;&gt;</code> 在输入时要对其进行转码；</li>
<li>通过限制输入长度强制截断来进行防御；</li>
<li>在服务端使用 HTTP 的 Content Security Policy 头部来指定策略，或者在前端设置 meta 标签。</li>
</ol>
<h3 id="CSRF"><a href="#CSRF" class="headerlink" title="CSRF"></a>CSRF</h3><p>CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入第三方网站，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击网站进行某项操作的目的。</p>
<p>解决办法：</p>
<ol>
<li>在关键步骤，添加验证码验证；</li>
<li>使用 Token，每次提交时需带上 Token；</li>
<li>Samesite Cookie 属性。</li>
</ol>
<h3 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h3><p>点击劫持是指在一个 Web 页面中隐藏了一个透明的 iframe，用外层假页面诱导用户点击，实际上是在隐藏的 iframe 上触发了点击事件进行一些用户不知情的操作。</p>
<p>解决办法：</p>
<ol>
<li>frame busting</li>
<li>X-Frame-Options：设置为 DENY、SAMEORIGIN、ALLOW-FROM</li>
</ol>
<h3 id="SQL-注入"><a href="#SQL-注入" class="headerlink" title="SQL 注入"></a>SQL 注入</h3><p>把 SQL 命令插入到 Web 表单提交或页面请求的字符串中，最终达到使服务器执行恶意的 SQL 命令。</p>
<p>解决办法：</p>
<ol>
<li>对用户的输入进行校验，通过正则表达式、或限制长度；</li>
<li>不要进行动态拼装 SQL，可以使用参数化的 SQL 或直接使用存储过程进行数据查询存储；</li>
<li>不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接；</li>
<li>不要把机密信息直接存放，进行加密或者 hash 掉密码和敏感的信息。</li>
</ol>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="代码报错位置"><a href="#代码报错位置" class="headerlink" title="代码报错位置"></a>代码报错位置</h3><p>使用 <code>source-map</code> 库进行错误定位。</p>
<p><code>Source Map</code> 是一个 JSON 文件，包含了代码转换前后的位置信息。也就是说，给定一个转换之后的压缩代码的位置，就可以通过 <code>Source Map</code> 获取转换之前的代码位置，有以下属性：</p>
<ul>
<li>version：Source Map 的版本号；</li>
<li>sources：转换前的文件列表；</li>
<li>names：转换前的所有变量名和属性名；</li>
<li><strong>mappings</strong>：记录位置信息的字符串，经过编码；</li>
<li>file：转换前后的文件名；</li>
<li>sourceRoot：转换前的文件所在的目录，若在同一目录，则为空；</li>
<li>sourceContent：转换前的文件内容列表，与 sources 列表依次对应；</li>
</ul>
<h2 id="其他相关"><a href="#其他相关" class="headerlink" title="其他相关"></a>其他相关</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><h4 id="图片类型"><a href="#图片类型" class="headerlink" title="图片类型"></a>图片类型</h4><p>图片的类型目前分为两种：</p>
<ul>
<li>位图：也叫点阵图，就是用像素点拼起来的图，如 png、jpg 等格式图片；</li>
<li>矢量图：也叫向量图，画面上的对象对应的算法是不变的，所以即使缩放也不会失真，常见的就是 svg 格式。</li>
</ul>
<h4 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h4><p><strong>GIF</strong>：</p>
<p>GIF（raphics Interchange Format），图形交换格式，1987 由 Compu Serve 公司为了填补跨平台图像格式的空白而发展开来；采用 Lemple-Zew-Welch（LZW）压缩算法，<u>最多只能支持 256 种颜色</u>，适用于色彩较少的图片。</p>
<p>GIF 格式图片最大的特性是<strong>帧动画</strong>，相较于 bmp <u>尺寸较小</u>，而且<u>支持透明和动画</u>。</p>
<p><strong>JPEG/JPG</strong>：</p>
<p>JPEG（Joint Photographic Experts Group，联合图像专家组），文件后缀名为 <code>.jpg</code> 或 <code>.jpeg</code>，较为常用，是一种有损压缩格式：能够将图像压缩在很小的储存空间，图像中重复或不重要的资料会被丢失，因此容易造成图像数据的损伤。</p>
<p>优点：采用有损压缩，压缩后体积更小；支持 24 位真彩色；支持渐进式加载；</p>
<p>缺点：有损压缩会损坏图片的质量；不支持透明/半透明。</p>
<blockquote>
<p>渐进式 JPEG：其文件包含多次扫描，这些扫描顺寻的存储在 JPEG 文件中，在打开文件过程中，会先显示整个图片的模糊轮廓，随着扫描次数的增加，图片变得越来越清晰，普通的 JPEG 是从上往下加载图片</p>
</blockquote>
<p><strong>PNG</strong>：</p>
<p>PNG（Portable Network Graphics），便携式网络图像，是一种无损压缩的位图片形格式；支持 8 位、24 位、32 位三种：</p>
<ul>
<li>PNG8：最多支持 256(2<sup>8</sup>) 种颜色，有一位的布尔透明通道（全透明/不透明）；</li>
<li>PNG24：支持 2<sup>24</sup> 种颜色，R G B 分别用八位，不支持透明；</li>
<li>PNG32：在 24 位的基础上增加了 8 位的透明信息，支持不同程度的半透效果；</li>
</ul>
<p>优点：无损压缩；支持透明/半透明；最高支持 24 位真彩色图像以及 8 位灰度图像；</p>
<p>缺点：与 JPG 相比，压缩量较少；不支持动画，想支持动画需使用 APNG；</p>
<blockquote>
<p>APNG（Animated Portable Network Graphics），一个基于PNG的位图动画格式，就是多张 PNG 组成的动图，浏览器兼容较差。</p>
</blockquote>
<p><strong>WEBP</strong>：</p>
<p>最初是由 Google 在 2010 年发布，目标是减少文件大小，同时支持无损压缩和有损压缩；几乎集成了以上所有格式的优点，并且能拥有更高的压缩率；</p>
<p>要比 JPG 的还要小 50% 左右，但兼容性不太好。</p>
<p><strong>SVG</strong>：</p>
<p>SVG 是一种用 XML 定义的语言，用来描述二维矢量及矢量/栅格图形。SVG 提供了三种类型的图形对象：矢量图形、图像、文本；图形对象可以进行分组、添加样式、变换、组合等操作；</p>
<p>SVG 图形是可交互和动态的，可以在 SVG 文件中嵌入动画元素或通过脚本来定义动画；</p>
<p>SVG 最大的不同是矢量图，无论如何缩放都不会失真，SVG 文件通常要比 JPEG 和 PNG 格式的文件小很多；</p>
<p>优点：</p>
<ul>
<li>可以被非常多的工具读取和修改（如记事本）；</li>
<li>与 JPEG 和 GIF 图像相比，尺寸更小、压缩性更强；</li>
<li>可以在任何分辨率下被高质量地打印；</li>
<li>可以自由伸缩且不会失真；</li>
<li>可以与 JavaScript 技术一起运行；</li>
<li>文件是纯粹的 XML；</li>
</ul>
<p>缺点：</p>
<ul>
<li>渲染成本相对于其他格式图片要较高。对于性能有影响；</li>
<li>需要学习成本（XML）</li>
</ul>
<blockquote>
<p>SVGA：动画播放引擎</p>
<p>优点：可以控制动画的暂停和播放，还可以监听动画的播放状态；体积相对与 APNG 更小；可以随意伸缩不失真；浏览器兼容性良好；</p>
<p>缺点：需要 JS 解析，同一页面不宜使用过多 SVGA 动画，会消耗过多性能。</p>
</blockquote>
<p>选择图片格式步骤：</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220503143220283.png" class title="图片格式选择">





<h4 id="压缩类型"><a href="#压缩类型" class="headerlink" title="压缩类型"></a>压缩类型</h4><p>无压缩：无压缩的图片格式不对图片数据进行压缩处理，能准确地呈现原图片，例如 BMP 格式图片；</p>
<p>有损压缩：指在压缩文件大小的过程中，损失了一部分图片的信息，即降低了图片的质量，且这种损失是不可逆的</p>
<ul>
<li>常见的有损压缩手段是按照一定的算法将<strong>临近的像素点进行合并</strong>；</li>
<li>JPG 格式的图片使用的就是有损压缩；</li>
</ul>
<p>无损压缩：在压缩图片的过程中，图片的质量没有任何损耗，任何时候都可以从无损压缩过的图片中国恢复出原先的信息；</p>
<ul>
<li>压缩算法对图片的所有的<strong>数据进行编码压缩</strong>，能在保证图片的质量的同时降低图片的体积；</li>
<li>PNG、GIF 等使用的就是无损压缩。</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AgoniLay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://agonilay.github.io" target="_blank">AgoniLay的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/15/%E6%89%8B%E5%86%99JS%E7%9B%B8%E5%85%B3/"><img class="prev-cover" src="https://img2.baidu.com/it/u=147831657,1408237617&amp;fm=26&amp;fmt=auto" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手写JS相关</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/10/Sass/"><img class="next-cover" src="https://img0.baidu.com/it/u=2134113155,1156622243&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=780&amp;h=484" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sass</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="前端面试复习笔记"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端面试复习笔记</div></div></a></div><div><a href="/2022/04/20/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/" title="面经总结"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">面经总结</div></div></a></div><div><a href="/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/" title="NodeJS 黑马笔记"><img class="cover" src="https://img2.baidu.com/it/u=2903413025,1209967719&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-11</div><div class="title">NodeJS 黑马笔记</div></div></a></div><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/" title="前端综合复习笔记"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端综合复习笔记</div></div></a></div><div><a href="/2021/07/30/ES8%E7%AC%94%E8%AE%B0/" title="ES8笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES8笔记</div></div></a></div><div><a href="/2021/07/30/ES7%E7%AC%94%E8%AE%B0/" title="ES7笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES7笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS"><span class="toc-number">1.</span> <span class="toc-text">HTTP 和 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">区别以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">HTTPS 工作原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">1.4.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.4.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">1.4.3.</span> <span class="toc-text">状态码</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.2.</span> <span class="toc-text">TCP 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0"><span class="toc-number">2.3.</span> <span class="toc-text">保证数据包传输的有序可靠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP 请求跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">跨域的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96"><span class="toc-number">2.6.</span> <span class="toc-text">粘包问题分析与对策</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="toc-number">2.6.1.</span> <span class="toc-text">出现原因</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%AA%E6%96%BD"><span class="toc-number">2.6.2.</span> <span class="toc-text">避免措施</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD"><span class="toc-number">3.1.</span> <span class="toc-text">输入 URL 到页面加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92"><span class="toc-number">3.2.</span> <span class="toc-text">重绘与重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">3.2.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D"><span class="toc-number">3.2.2.</span> <span class="toc-text">避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#304"><span class="toc-number">3.3.</span> <span class="toc-text">304</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">3.4.</span> <span class="toc-text">强制缓存 协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><span class="toc-number">3.5.</span> <span class="toc-text">进程 线程 协程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-Session-Token"><span class="toc-number">3.6.</span> <span class="toc-text">Cookie Session Token</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Cookie"><span class="toc-number">3.6.1.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Session"><span class="toc-number">3.6.2.</span> <span class="toc-text">Session</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Token"><span class="toc-number">3.6.3.</span> <span class="toc-text">Token</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">4.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">4.1.</span> <span class="toc-text">HTML5 语义化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">5.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">5.1.</span> <span class="toc-text">CSS 选择器及优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">5.1.1.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">5.1.2.</span> <span class="toc-text">优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position"><span class="toc-number">5.2.</span> <span class="toc-text">position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-sizing"><span class="toc-number">5.3.</span> <span class="toc-text">box-sizing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.4.</span> <span class="toc-text">CSS 盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">5.5.</span> <span class="toc-text">BFC(块级格式上下文)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">5.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99"><span class="toc-number">5.5.2.</span> <span class="toc-text">原理布局规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">5.5.3.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.5.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">5.6.</span> <span class="toc-text">水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">5.6.1.</span> <span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">5.6.2.</span> <span class="toc-text">垂直居中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%85%83%E7%B4%A0"><span class="toc-number">5.7.</span> <span class="toc-text">隐藏页面中元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-CSS-%E7%94%BB%E4%B8%89%E8%A7%92"><span class="toc-number">5.8.</span> <span class="toc-text">用 CSS 画三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-5px-%E8%BE%B9%E6%A1%86"><span class="toc-number">5.9.</span> <span class="toc-text">0.5px 边框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">5.10.</span> <span class="toc-text">页面布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex-%E5%B8%83%E5%B1%80"><span class="toc-number">5.10.1.</span> <span class="toc-text">Flex 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rem-%E5%B8%83%E5%B1%80"><span class="toc-number">5.10.2.</span> <span class="toc-text">Rem 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"><span class="toc-number">5.10.3.</span> <span class="toc-text">百分比布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-number">5.10.4.</span> <span class="toc-text">浮动布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80"><span class="toc-number">5.11.</span> <span class="toc-text">圣杯布局 双飞翼布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><span class="toc-number">5.11.1.</span> <span class="toc-text">圣杯布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80"><span class="toc-number">5.11.2.</span> <span class="toc-text">双飞翼布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E5%8D%95%E4%BD%8D"><span class="toc-number">5.12.</span> <span class="toc-text">CSS 单位</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rem-%E6%88%96-viewport-%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-number">5.13.</span> <span class="toc-text">使用 rem 或 viewport 进行移动端适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">5.13.1.</span> <span class="toc-text">rem 适配原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewport-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">5.13.2.</span> <span class="toc-text">viewport 适配原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">5.14.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">5.15.</span> <span class="toc-text">CSS 中可以继承的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">5.16.</span> <span class="toc-text">媒体查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-TS-ES6"><span class="toc-number">6.</span> <span class="toc-text">JS TS ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.1.</span> <span class="toc-text">JS 的数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">6.1.1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInt"><span class="toc-number">6.1.2.</span> <span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">6.1.3.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">6.1.4.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">6.1.5.</span> <span class="toc-text">包装类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="toc-number">6.2.</span> <span class="toc-text">数据类型检测方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-number">6.2.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">6.2.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">6.2.3.</span> <span class="toc-text">Object.prototype.toString.call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var-let-const"><span class="toc-number">6.2.4.</span> <span class="toc-text">var let const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">6.3.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">6.4.</span> <span class="toc-text">JS 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">6.5.</span> <span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%9A%E4%BF%9D%E5%AD%98-%E4%BF%9D%E6%8A%A4"><span class="toc-number">6.6.</span> <span class="toc-text">闭包：保存&#x2F;保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">6.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">6.6.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">6.6.3.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">6.6.4.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">6.6.5.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">6.7.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">6.8.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">6.9.</span> <span class="toc-text">原型 原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">6.10.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop"><span class="toc-number">6.11.</span> <span class="toc-text">EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD"><span class="toc-number">6.11.1.</span> <span class="toc-text">浏览器中</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.11.1.1.</span> <span class="toc-text">宏任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">6.11.1.2.</span> <span class="toc-text">微任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E4%B8%AD"><span class="toc-number">6.11.2.</span> <span class="toc-text">Node 中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-Promise-Async-Await"><span class="toc-number">6.12.</span> <span class="toc-text">setTimeout Promise Async&#x2F;Await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81-%E9%98%B2%E6%8A%96"><span class="toc-number">6.13.</span> <span class="toc-text">节流&#x2F;防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number">6.14.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%8D%95%E8%8E%B7"><span class="toc-number">6.15.</span> <span class="toc-text">事件冒泡捕获</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ES6-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">6.16.</span> <span class="toc-text">ES6 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%91%BD%E4%BB%A4"><span class="toc-number">6.16.1.</span> <span class="toc-text">新命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">6.16.2.</span> <span class="toc-text">新数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Promise"><span class="toc-number">6.16.3.</span> <span class="toc-text">Promise</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Proxy-Reflect"><span class="toc-number">6.16.4.</span> <span class="toc-text">Proxy&#x2F;Reflect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0-1"><span class="toc-number">6.16.5.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E8%A7%A3%E6%9E%84"><span class="toc-number">6.16.6.</span> <span class="toc-text">数组对象解构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%8D%E5%8E%86"><span class="toc-number">6.16.7.</span> <span class="toc-text">遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#class-%E7%B1%BB"><span class="toc-number">6.16.8.</span> <span class="toc-text">class 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Math-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.16.9.</span> <span class="toc-text">Math 对象的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Array-%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95"><span class="toc-number">6.16.10.</span> <span class="toc-text">Array 对象的扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">6.16.11.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES7"><span class="toc-number">6.16.12.</span> <span class="toc-text">ES7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES8"><span class="toc-number">6.16.13.</span> <span class="toc-text">ES8</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES9"><span class="toc-number">6.16.14.</span> <span class="toc-text">ES9</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ES10"><span class="toc-number">6.16.15.</span> <span class="toc-text">ES10</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">7.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-number">7.1.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue2-Vue3"><span class="toc-number">7.2.</span> <span class="toc-text">Vue2 - Vue3</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E5%8C%96"><span class="toc-number">7.2.1.</span> <span class="toc-text">变化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AF%B9%E6%AF%94"><span class="toc-number">7.2.2.</span> <span class="toc-text">对比</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B0%E5%A2%9E"><span class="toc-number">7.2.3.</span> <span class="toc-text">新增</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E5%85%BC%E5%AE%B9%E6%9B%B4%E6%94%B9"><span class="toc-number">7.2.4.</span> <span class="toc-text">非兼容更改</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">7.3.</span> <span class="toc-text">Vue 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.4.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-watch"><span class="toc-number">7.5.</span> <span class="toc-text">computed watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-%E4%B8%BA%E4%BD%95%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">7.6.</span> <span class="toc-text">data 为何是函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E5%92%8C-v-if"><span class="toc-number">7.7.</span> <span class="toc-text">v-for 和 v-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Vue-%E4%B8%AD%E7%9A%84-key"><span class="toc-number">7.8.</span> <span class="toc-text">React&#x2F;Vue 中的 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">7.9.</span> <span class="toc-text">vue 组件的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.10.</span> <span class="toc-text">nextTick 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">7.10.1.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">7.11.</span> <span class="toc-text">插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive"><span class="toc-number">7.12.</span> <span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin"><span class="toc-number">7.13.</span> <span class="toc-text">mixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex"><span class="toc-number">7.14.</span> <span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">7.15.</span> <span class="toc-text">虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">7.15.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">7.15.2.</span> <span class="toc-text">实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Diff"><span class="toc-number">7.15.3.</span> <span class="toc-text">Diff</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">8.</span> <span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">8.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="toc-number">8.2.</span> <span class="toc-text">管理项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-number">8.3.</span> <span class="toc-text">项目优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">9.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-number">9.1.</span> <span class="toc-text">XSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSRF"><span class="toc-number">9.2.</span> <span class="toc-text">CSRF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%82%B9%E5%87%BB%E5%8A%AB%E6%8C%81"><span class="toc-number">9.3.</span> <span class="toc-text">点击劫持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SQL-%E6%B3%A8%E5%85%A5"><span class="toc-number">9.4.</span> <span class="toc-text">SQL 注入</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">10.</span> <span class="toc-text">工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99%E4%BD%8D%E7%BD%AE"><span class="toc-number">10.1.</span> <span class="toc-text">代码报错位置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9B%B8%E5%85%B3"><span class="toc-number">11.</span> <span class="toc-text">其他相关</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%89%87"><span class="toc-number">11.1.</span> <span class="toc-text">图片</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.1.</span> <span class="toc-text">图片类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BE%E7%89%87%E6%A0%BC%E5%BC%8F"><span class="toc-number">11.1.2.</span> <span class="toc-text">图片格式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%8B%E7%BC%A9%E7%B1%BB%E5%9E%8B"><span class="toc-number">11.1.3.</span> <span class="toc-text">压缩类型</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AgoniLay</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz',
      appKey: 'k49y92c0BEE6zL2mCA2AUHKu',
      avatar: 'monsterid',
      serverURLs: 'https://fmlk1v2u.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>