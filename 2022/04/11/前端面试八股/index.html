<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试八股 | AgoniLay的博客</title><meta name="keywords" content="前端,面试"><meta name="author" content="AgoniLay"><meta name="copyright" content="AgoniLay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP 和 HTTPS基本概念 HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。  区别以及优缺点 HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTT">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试八股">
<meta property="og:url" content="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="AgoniLay的博客">
<meta property="og:description" content="HTTP 和 HTTPS基本概念 HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。  区别以及优缺点 HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe">
<meta property="article:published_time" content="2022-04-11T07:34:22.000Z">
<meta property="article:modified_time" content="2022-04-25T15:57:57.634Z">
<meta property="article:author" content="AgoniLay">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe"><link rel="shortcut icon" href="/img/zoro3.jpg"><link rel="canonical" href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?050530911bbf514fb098003dafd2a51e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试八股',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-25 23:57:57'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/zoro3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AgoniLay的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T07:34:22.000Z" title="发表于 2022-04-11 15:34:22">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-25T15:57:57.634Z" title="更新于 2022-04-25 23:57:57">2022-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>72分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议；</li>
<li>HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>
</ul>
<h3 id="区别以及优缺点"><a href="#区别以及优缺点" class="headerlink" title="区别以及优缺点"></a>区别以及优缺点</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTTP 协议安全，https 是具有安全性的 ssl 的加密传输协议，可以防止数据在传输过程中被窃取、改变，确保数据的完整性；</li>
<li>http 协议的默认端口是 80，https 是 443；</li>
<li>http 的连接比较简单，是无状态的；https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10% ~ 20% 的耗电；</li>
<li>https 缓存没有 http 高效，会增加数据开销；</li>
<li>https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高；</li>
<li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPv4 资源支持不了这种消耗；</li>
</ul>
<h3 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<strong>建立 ssl 链接</strong>；</li>
<li>web 服务器接收到客户端的请求后，会<strong>将网站的证书（包含公钥）传输给客户端</strong>；</li>
<li>客户端和 web 服务器端开始<strong>协商 SSL 链接的安全等级</strong>，也就是加密等级；</li>
<li>客户端浏览器通过双方协商一致的安全等级，<strong>建立会话密钥</strong>，然后通过网站的公钥来加密会话密钥，并传送给网站；</li>
<li>web 服务器<strong>通过自己的私钥解密出会话密钥</strong>；</li>
<li>web 服务器<strong>通过会话密钥加密与客户端之间的通信</strong>。</li>
</ol>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ol>
<li>第一次握手：建立连接时，客户端发送 <code>SYN</code> 包（SYN = j）到服务器，并进入 <code>SYN_SENT</code> 状态，等待服务器确认（SYN：同步序列编号，Synchronize Sequence Numbers）；</li>
<li>第二次握手：服务器收到 <code>SYN</code> 包并确认客户端的 <code>SYN</code>（ACK = j + 1），同时也发送一个自己的 <code>SYN</code> 包（SYN = k），即 SYN + ACK 包，此时服务器进入 <code>SYN_RECV</code>；</li>
<li>第三次握手：客户端收到服务器的 <code>SYN + ACK</code> 包，向服务器发送确认包 <code>ACK</code>（ACK = k + 1），此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（TCP 连接成功）状态，完成三次握手。</li>
</ol>
<blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
</blockquote>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol>
<li><strong>客户端进程发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN = 1，其序列号为 seq = u（的等于之前已经传送过来的数据的最后一个字节的序号加 1），此时，<strong>客户端进入 FIN-WAIT-1(终止等待 1)状态</strong>；</li>
<li><strong>服务器收到连接释放报文，发出确认报文</strong>，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，<strong>服务端就进入了 CLOSE-WAIT(关闭等待)状态</strong>；</li>
<li>客户端收到服务器的确认请求后，此时，<strong>客户端就进入 FIN-WAIT-2(终止等待 2)状态</strong>，等待服务器发送连接释放报文；</li>
<li><strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</strong>，FIN = 1，ack = u + 1，由于在半关闭状态，服务器可能又发送了一部分数据，此时的序列号是 seq = w，此时，<strong>服务器就进入了 LAST-ACK(最后确认)状态</strong>，等待客户端的确认；</li>
<li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong>，ACK = 1，ack = w + 1，自己的序列号是 seq = u + 1，此时，<strong>客户端就进入了 TIME-WAIT(时间等待)状态</strong>，此时 TCP 连接还没有释放，必须经过 2**MSL(最长报文段寿命)的时间后，<strong>当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>；</li>
<li>服务器只要收到了客户端发出的确认，<strong>立即进入 CLOSED 状态</strong>。同样，撤销 TCB 后，就结束了这次的 TCP 连接，服务器结束 TCP 连接要比客户端稍早一些。</li>
</ol>
<h3 id="保证数据包传输的有序可靠"><a href="#保证数据包传输的有序可靠" class="headerlink" title="保证数据包传输的有序可靠"></a>保证数据包传输的有序可靠</h3><p>对字节流分段并进行编号然后 <code>通过 ACK 回复</code> 和 <code>超时重发</code> 两个机制来保证：</p>
<ul>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包留在缓存区；</li>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
<li>如在定时器超时之前收到了对方的应答信息，则释放改数据包占用的缓冲区；</li>
<li>否则，重传改数据包，直到收到应答或重传次数超过规定的最大次数为止；</li>
<li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已接收到，如果接收方正好也有数据要发，则应答包可以放在数据包中稍带过去。</li>
</ul>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol>
<li>TCP 是面向<strong>链接</strong>的，而 UDP 是面向无连接的；</li>
<li>TCP 仅支持 <strong>单播传输</strong>，UDP 提供了单播，多播，广播的功能；</li>
<li>TCP 的三次握手保证了连接的<strong>可靠性</strong>；UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收；</li>
<li>UDP 的<strong>头部开销</strong>比 TCP 的更小，数据<strong>传输速率更高，实时性更好</strong>。</li>
</ol>
<h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><h4 id="跨域的原理"><a href="#跨域的原理" class="headerlink" title="跨域的原理"></a>跨域的原理</h4><p>跨域，是指浏览器不能执行其他网址的脚本，是由浏览器的同源策略造成的；</p>
<p>同源策略，是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，就被当作是不同的域；</p>
<p>跨域原理，即通过各种方式，避开浏览器的安全限制。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>JSONP：</p>
<p>ajax 受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，从而实现跨域。</p>
<ol>
<li>去创建一个 script 标签</li>
<li>script 的 src 属性设置接口地址</li>
<li>接口参数必须要携带一个自定义函数名，否则后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/?callback=getData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 srcipt 生效</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求；JSONP 需要后端配合返回指定格式的数据。</p>
<p>document.domain：</p>
<p>基本域名相同 子域名不同</p>
<p>window.name：</p>
<p>利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p>
<p>CORS：</p>
<p>CORS（Cross-origin resourse sharing）跨域资源共享服务器设置对 CORS 的支持原理：服务器设置 Accesss-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求。</p>
<p>proxy 代理：</p>
<p>目前常用的方式，通过服务器设置代理</p>
<p>window.postMessage()：</p>
<p>利用 H5 新特性 <code>window.postMessage()</code> </p>
<h2 id="Cookie-sessionStorage-localStorage"><a href="#Cookie-sessionStorage-localStorage" class="headerlink" title="Cookie sessionStorage localStorage"></a>Cookie sessionStorage localStorage</h2><p>相同点：</p>
<ul>
<li>均存储在客户端</li>
</ul>
<p>不同点：</p>
<ul>
<li>cookie 数据大小不能超过 4K；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+；</li>
<li>cookie 的设置的过期时间之前一直有效；localStorage 永久储存，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；</li>
<li>cookie 的数据会自动传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li>
</ul>
<h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接受缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>在流传输中出现，UDP 不会出现粘包，因为它有消息边界。</p>
<p>粘包情况有两种，一种是 <strong>粘在一起的包都是完整的数据包</strong>，另一种是 <strong>粘在一起的包有不完整的包</strong>。</p>
<h3 id="避免措施"><a href="#避免措施" class="headerlink" title="避免措施"></a>避免措施</h3><ol>
<li>对于发送方引起的粘包现象，用户可以通过编程设置来避免，<strong>TCP 提供了强制数据立即传送的操作指令 push</strong>，TCP 软件收到改操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<ul>
<li>虽然可以避免发送方引起的粘包，但关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用</li>
</ul>
</li>
<li>对于接收方引起的粘包现象，则可通过优化程序设计、精简接收进程工作量、<strong>提高接收进程优先级</strong>等措施，使其即使接收数据，从而尽量避免出现粘包现象；<ul>
<li>只能减少出现粘包的可能性，并不能完全避免粘包</li>
</ul>
</li>
<li>由接收方控制，将一包数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>分包多发</strong>。<ul>
<li>虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li>
</ul>
</li>
</ol>
<blockquote>
<p>周全的对策：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开，高效可行。</p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="输入-URL-到页面加载"><a href="#输入-URL-到页面加载" class="headerlink" title="输入 URL 到页面加载"></a>输入 URL 到页面加载</h3><ol>
<li>在浏览器地址栏输入 URL；</li>
<li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则直接显示页面内容，如果没有则进行下一步；<ul>
<li>浏览器缓存：浏览器会记录 DNS 一段时间；</li>
<li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的 DNS 查询缓存）；</li>
<li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续 搜索路由器缓存；</li>
<li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li>
</ul>
</li>
<li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址，<strong>DNS 服务器是基于 UDP 的，因此会用到 UDP 协议</strong>；</li>
<li>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接；</li>
<li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该 i 请求作为 TCP 三次握手的第三次数据发送给服务器；</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给服务器</li>
<li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li>
<li>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后进行解析：<ul>
<li>构建 DOM 树：词法分析然后解析成 DOM 树，是由 DOM 元素及属性节点组成，树的根是 document 对象；</li>
<li>构建 CSS 规则树：生成 CSS 规则树（CSSOM）；</li>
<li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，病候检出渲染树（render tree）；</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置；</li>
<li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li>
</ul>
</li>
<li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码：<ul>
<li>创建 window 对象：window 对象也叫全局变量环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，DOM 树也会映射在 window 的 document 对象上；当关闭网页或者浏览器时，全局执行环境会被销毁；</li>
<li>加载文件：JS 引擎分析它的语法和词法是否合法，合法则进入预编译；</li>
<li>预编译：浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并赋值为 <code>undefined</code>；寻找全局函数声明，作为 window 的方法加入到 window 对象中，将函数体赋值给它（匿名函数是不参与预编译的，它是变量）；</li>
<li>解释执行：执行到变量就赋值，若变量未定义，在 ES5 严格模式下此变量会变成 window 的一个属性，也就是成为全局变量；函数执行，就将函数的环境推入一个环境的栈中，执行完成后弹出，交回控制权；</li>
</ul>
</li>
</ol>
<h3 id="重绘与重排"><a href="#重绘与重排" class="headerlink" title="重绘与重排"></a>重绘与重排</h3><ul>
<li>重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，即重排；表现为重新生成布局，重新排列元素；</li>
<li>重绘（Repaint）：当一个元素的外观发生改变，但没有影响布局，重新把元素外观绘制出来的过程，叫重绘；表现为元素的外观被改变。</li>
</ul>
<blockquote>
<p>重绘不一定会出现重排，但重排一定会重绘！</p>
</blockquote>
<p>重排和重绘的代价是高昂的，会破坏用户体验，让 UI 展示非常迟缓，相比之下重排的性能影响更大，两者无法避免的情况下一般选择代价更小的重绘。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>添加、删除、更新 DOM 节点；</li>
<li>通过 <code>display: none</code> 隐藏一个 DOM 节点，触发重排和重绘；</li>
<li>通过 <code>visibility: hidden</code> 隐藏一个 DOM 节点，只触发重绘；</li>
<li>移动或者给页面中的 DOM 节点添加动画；</li>
<li>添加一个样式表，调整样式属性；</li>
<li>用户行为：调整窗口大小、改变字号、滚动等。</li>
</ul>
<h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ol>
<li><p><strong>集中改变样式</strong>，不要一条一条多次修改 DOM 中的样式；</p>
</li>
<li><p>不要把 DOM 节点的属性放在循环里当成循环里的变量；</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会触发整个页面的 reflow 的；</p>
</li>
<li><p>不要使用 table 布局，很小的改动会造成整个 table 的重新布局；</p>
</li>
<li><p>尽量只修改 <code>position: absolute</code> 或 <code>fixed</code> 的元素，影响较小；</p>
</li>
<li><p>动画开启 GPU 加速，translate 使用 3D 变化；</p>
</li>
<li><p>提升为合成层：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他层；</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>提升合成层的最好方式是使用 CSS 的 <code>will-change</code> 属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="304"><a href="#304" class="headerlink" title="304"></a>304</h3><ul>
<li>浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍返回 200，但不会请求数据；</li>
<li>强缓存失效，进入协商缓存阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化，服务器根据客户端上送的 If-No 该资源的最后 ne-Match 值来判断是否命中缓存；</li>
<li>协商缓存 LastModify/If-Modify-Since 阶段，客户端第一次请求资源时，服务器返回的 header 中会加上 Last-Modify，Last-Modify 标识该资源的最后修改时间，再次请求该资源时，request 的请求头中会包含 If-Modify-Since，为缓存之前返回的 Last-Modify，服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li>
</ul>
<h3 id="强制缓存-协商缓存"><a href="#强制缓存-协商缓存" class="headerlink" title="强制缓存 协商缓存"></a>强制缓存 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 - 服务器响应该请求。</p>
<p>浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220412153039501.png" class title="第一次发起 HTTP 请求">

<ul>
<li>浏览器每次发起请求，都会<strong>先在浏览器缓存中查找该请求的结果以及缓存标识</strong>；</li>
<li>浏览器每次拿到返回的请求结果都会<strong>将该结果和缓存标识存入浏览器缓存中</strong>。</li>
</ul>
<p>强制缓存：</p>
<p>就是<strong>向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 Cache-Control 优先级更高。</p>
<p>强制缓存的情况主要有三种：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（与首次发请求一致）；</li>
<li>存在该缓存结果和缓存标识，但已失效，强制缓存失效，则使用协商缓存；</li>
<li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li>
</ol>
<p>协商缓存：</p>
<p>就是<strong>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，字段包括：<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>，其中 Etag/If-None-Match 的优先级更高。</p>
<p>情况有两种：</p>
<ol>
<li>协商缓存生效，返回 304；</li>
<li>协商缓存失效，重新发起请求，返回 200 和请求结果。</li>
</ol>
<h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h3><p>进程：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p>
<p>线程：是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。</p>
<ul>
<li>一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成；</li>
<li>进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</li>
</ul>
<p>协程（Coroutines）：是一种基于线程之上，但又比线程更加轻量级的存在。</p>
<p>进程和线程的区别：</p>
<ol>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>并发性：进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行；</li>
<li>拥有资源：进程拥有资源，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>系统开销：创建或撤销进程比线程的开销大，因为系统都要为之分配和回收资源；多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差；</li>
</ol>
<p>联系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有一个或多个线程；</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>处理机分给线程，即真正在处理机上运行的是线程；</li>
<li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML5-语义化"><a href="#HTML5-语义化" class="headerlink" title="HTML5 语义化"></a>HTML5 语义化</h3><p>HTML5 的语义化指的是<strong>合理正确的使用语义化的标签来创建页面结构</strong>。</p>
<p>语义化标签包括：</p>
<ul>
<li>header、nav、main、article、section、aside、footer</li>
</ul>
<p>优点：</p>
<ul>
<li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果；</li>
<li>代码结构清晰，易于阅读；</li>
<li>利于开发和维护，方便其他设备解析（如屏幕阅读器），根据语义渲染网页；</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。</li>
</ul>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>id 选择器 <code>#</code>、类选择器 <code>.</code>、属性选择器 <code>[a=&quot;b&quot;]</code>、伪类选择器 <code>:</code>、标签选择器 <code>div h1...</code>、相邻选择器 <code>+</code>、子选择器 <code>&gt;</code>、后代选择器 <code>(空格)</code>、通配符选择器 <code>*</code>。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li><code>!important</code></li>
<li>内联样式（1000）</li>
<li>ID 选择器（0100）</li>
<li>类选择器/属性选择器/伪类选择器（0010）</li>
<li>元素选择器/伪元素选择器（0001）</li>
<li>关系选择器/通配符选择器（0000）</li>
</ul>
<p>带 important 标记的样式属性优先级最高；样式表的来源相同时：</p>
<p><code>!important</code> &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p><strong>固定定位 fixed</strong>：元素的位置相对于浏览器窗口是固定位置，即使窗口滚动也不会移动；fixed 定位使元素的位置与文档流无关，因此不占据空间，fixed 定位的元素和其他元素重叠；</p>
<p><strong>相对定位 relative</strong>：如果一个元素相对定位，它将依旧出现在所在的位置上，可以通过设置垂直水平距离让此元素相对于原先的位置进行移动，但元素仍占据原先的空间，会覆盖其他元素；</p>
<p><strong>绝对定位 absolute</strong>：绝对定位的元素的位置相对于最近的已定位父元素，若无已定位的父元素，则位置相对于 body，absolute 定位使元素的位置与文档流无关，因此不占据空间，absolute 定位的元素和其他元素重叠；</p>
<p><strong>粘性定位 sticky</strong>：元素先按照普通文档流定位，相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位，在跨越特定阈值前为相对定位，之后为固定定位；</p>
<p><strong>默认定位 static</strong>：默认值。没有定位，元素出现在正常的流中，忽略 top、bottom、left、right 以及 z-index 声明。</p>
<p>也可以设置为 <code>inherit</code>：来从父元素继承 position 属性的值。</p>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>box-sizing 规定两个并排的带边框的框：</p>
<ul>
<li><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框【标准盒模型】；</li>
<li><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒【IE 盒模型/怪异盒模型】；</li>
<li>inherit：继承父元素的 box-sizing 值</li>
</ul>
<h3 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h3><p>CSS 盒模型本质上是一个盒子，包括：边距、边框、填充盒实际内容；CSS 中的盒模型包括 IE 盒模型和标准 W3C 盒模型。</p>
<ul>
<li>在标准的盒模型中，width 指 <code>content</code> 部分的宽度；</li>
<li>在 IE 盒模型中，width 表示 <code>content + padding + border</code> 三个部分的宽度。</li>
</ul>
<p>总宽度都是 <code>width + margin(左右)</code>，高度同理。</p>
<p>可通过 <code>box-sizing</code> 进行设置，根据计算宽高的区域可以分为：</p>
<ul>
<li><code>content-box</code>：W3C 标准盒模型</li>
<li><code>border-box</code>：IE 盒模型</li>
<li><code>padding-box</code>：FireFox 曾支持</li>
<li><code>margin-box</code>：浏览器未实现</li>
</ul>
<blockquote>
<p>理论上是有四种盒模型，但目前 W3C 和 MDN 规范中均只支持 <code>content-box</code> 与 <code>border-box</code>。</p>
</blockquote>
<h3 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>BFC（Block Formatting Context），块级格式上下文，是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有：</p>
<ul>
<li>内部 box 垂直放置；</li>
<li>计算 BFC 的高度的时候，浮动元素也参与计算。</li>
</ul>
<h4 id="原理布局规则"><a href="#原理布局规则" class="headerlink" title="原理布局规则"></a>原理布局规则</h4><ul>
<li>内部的 Box 会在垂直方向，一个一个的放置；</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；</li>
<li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于默认的从左往右排列的格式）；</li>
<li>BFC 的区域不会与 float box 重叠；</li>
<li>BFC 是一个独立容器，容器里的子元素不会影响到外面的元素；</li>
<li>计算 BFC 高度时，浮动元素也参与计算；</li>
<li>元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box 会参与不同的 <code>Formatting Context</code>。</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>overflow 的值不为 visible</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>去除边距重叠现象；</li>
<li>清除浮动（让父元素的高度包含子浮动元素）；</li>
<li>避免某元素被浮动元素覆盖；</li>
<li>避免多列布局由于宽度计算四舍五入而自动换行。</li>
</ul>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul>
<li>对于行内元素：<code>text-align: center;</code> </li>
<li>对于确定宽度的块级元素：<ul>
<li><code>margin: 0 auto;</code> </li>
<li><code>position: absolute; margin-left: (父width - 子width) / 2;</code>，需要父元素 <code>position: relative;</code> </li>
</ul>
</li>
<li>对于宽度未知的块级元素：<ul>
<li><code>display: table; margin: 0 auto;</code> </li>
<li><code>display: inline-block; text-align: center;</code> </li>
<li><code>position: absolute; left: 50%; transform: translateX(-50%);</code> </li>
<li><code>display: flex; justify-content: center;</code> </li>
</ul>
</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol>
<li><code>inline-height: height;</code> 适合纯文字类；</li>
<li>通过设置父容器相对定位，子元素设置绝对定位，标签通过 margin 实现自适应居中；</li>
<li>弹性布局 flex：父级设置 <code>display: flex;</code>，子级设置 margin 为 auto 实现自适应居中；</li>
<li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现；</li>
<li>利用 table 布局，子级设置 <code>vertical-align: middle;</code>，使用的前提条件：内联元素以及 display 值为 table-cell 的元素</li>
</ol>
<h3 id="隐藏页面中元素"><a href="#隐藏页面中元素" class="headerlink" title="隐藏页面中元素"></a>隐藏页面中元素</h3><ol>
<li><code>opacity: 0</code>，元素变透明，即隐藏，不会改变页面布局，且绑定的一些事件仍然可以触发（如点击事件）；</li>
<li><code>visibility: hidden</code>，同样不会改变页面布局，但无法触发已绑定的事件，隐藏对应元素，在文档布局中仍保留原来的空间；</li>
<li><code>display: none</code>，会改变页面布局，在文档布局中不再分配空间（重排重绘）</li>
</ol>
<h3 id="用-CSS-画三角"><a href="#用-CSS-画三角" class="headerlink" title="用 CSS 画三角"></a>用 CSS 画三角</h3><p><strong>盒子宽高均为零，三面边框均透明</strong>。</p>
<p>利用伪元素：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid pink;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直接边框：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#css</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">16px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">16px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="0-5px-边框"><a href="#0-5px-边框" class="headerlink" title="0.5px 边框"></a>0.5px 边框</h3><p>方案一：缩小</p>
<p>利用缩小使得视觉上变为 0.5px：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：兼容性较好，可以设置圆角，<strong>推荐使用</strong>。</p>
<p>方案二：线性渐变</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, transparent);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>优点：适合设置一条边框，无法展示圆角。</p>
<p>方案三：阴影</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒模型提供最大的灵活性，指定 <code>display: flex</code> 即可。</p>
<p>容器属性：</p>
<ul>
<li>flex-direction：决定主轴的方向(即子 item 的排列方法)，取值：<ul>
<li>row | row-reverse | column | column-reverse</li>
</ul>
</li>
<li>flex-wrap：决定换行规则，取值：<ul>
<li>nowrap | wrap | wrap-reverse</li>
</ul>
</li>
<li>flex-flow：flex-direction 和 flex-wrap 的简写形式；</li>
<li>justify-content：水平主轴对齐方式；</li>
<li>align-items：竖直轴线方向对齐方式；</li>
<li>align-content：元素排列大于一行时 align-items 需换成 align-content；</li>
</ul>
<p>元素属性：</p>
<ul>
<li>order：定义项目的排列顺序，默认为 0，越小越靠前；</li>
<li>flex-grow：定义项目的放大比例，即使存在空间，也不会放大；</li>
<li>flex-shrink：定义项目的缩小比例，当空间不足的情况下会等比例的缩小，0 为不缩小；</li>
<li>flex-basis：定义了在分配多余的空间项目所占的空间；</li>
<li>flex：flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 <code>0 1 auto</code>；</li>
<li>align-self：允许单个项目于其他项目不同的对齐方式，可覆盖；</li>
<li>align-items：默认值为 auto，表示继承父元素的 align-items 值。</li>
</ul>
<h4 id="Rem-布局"><a href="#Rem-布局" class="headerlink" title="Rem 布局"></a>Rem 布局</h4><p>Rem 相对于根（html）的 font-size 大小来计算，就是一个相对比例（如：<code>font-size: 10px</code>，那么），rem 布局的本质是等比缩放，一般是基于宽度。</p>
<p>优点：可以快速使用移动端布局，字体，图片高度；</p>
<p>缺点：</p>
<ol>
<li>目前 IE 不支持，对 pc 页面来讲使用次数不多；</li>
<li>数据量大：所有的图片、盒子都需要给一个准确的值，才能保证不同机型的适配；</li>
<li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小，且必须将改变 font-size 的代码放在 css 样式之前。</li>
</ol>
<h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>通过百分比单位 <code>%</code> 来实现响应式的效果，可以使得浏览器中的组件的宽高随着浏览器的变化而变化。</p>
<ul>
<li>height 相对于 height；</li>
<li>width 相对于 width；</li>
<li>padding、bording、margin 等不论是垂直还是水平方向都相对于直接父元素的 width；</li>
<li>除了 border-radius 外，translate、background-szie 等都相对于自身。</li>
</ul>
<p>缺点：计算困难，可能使布局问题复杂</p>
<h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当元素浮动以后可以向左或向右移动，直到它的边缘碰到包含它的框或者另外一个浮动元素的边框为止；元素浮动后会脱离正常的文档流，所以文档的普通流中的框就会变得好像浮动元素不存在一样。</p>
<p>优点：</p>
<ul>
<li>在图文混排的时候可以很好的实现文字环绕图片；</li>
<li>当元素浮动起来后，它有着块级元素的一些性质，如设置宽高；</li>
</ul>
<p>缺点：会造成父级元素高度塌陷，需要进行清除浮动。</p>
<h3 id="圣杯布局-双飞翼布局"><a href="#圣杯布局-双飞翼布局" class="headerlink" title="圣杯布局 双飞翼布局"></a>圣杯布局 双飞翼布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>我是头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>我是尾部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hiddle;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220416103735470.png" class title="圣杯布局">

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle_child&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>CSS：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle_child</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用-rem-或-viewport-进行移动端适配"><a href="#使用-rem-或-viewport-进行移动端适配" class="headerlink" title="使用 rem 或 viewport 进行移动端适配"></a>使用 rem 或 viewport 进行移动端适配</h3><h4 id="rem-适配原理"><a href="#rem-适配原理" class="headerlink" title="rem 适配原理"></a>rem 适配原理</h4><p>改变了一个元素在不同设备上占据的 css 像素的个数。</p>
<p>优点：没有破坏完美视口</p>
<p>缺点：px 转换 rem 较为复杂</p>
<h4 id="viewport-适配原理"><a href="#viewport-适配原理" class="headerlink" title="viewport 适配原理"></a>viewport 适配原理</h4><p>每一个元素在不同设备上占据的 css 像素的个数是一样的，但 css 像素和物理像素的比例是不一样的。</p>
<p>优点：在设计图上所取量的大小即为可以设置的像素大小（所量及所设）</p>
<p>缺点：破坏完美视口</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol>
<li><p>添加额外标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加额外标签并添加 clear 属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以添加一个 br 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>父级添加 overflow 属性，或者设置高度；</p>
</li>
<li><p>建立伪类选择器清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 css 中添加 :after 伪元素 */</span></span><br><span class="line"><span class="selector-class">.parent</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="CSS-中可以继承的属性"><a href="#CSS-中可以继承的属性" class="headerlink" title="CSS 中可以继承的属性"></a>CSS 中可以继承的属性</h3><ol>
<li>字体系列属性：<ul>
<li>font-family、font-weight、font-size、font-style</li>
</ul>
</li>
<li>文本系列：<ul>
<li>text-indent、text-align、line-height</li>
<li>word-spacing、letter-spacing</li>
<li>text-transform、color</li>
</ul>
</li>
<li>元素可见性：visibility</li>
<li>列表布局属性：<ul>
<li>list-style、list-style-image、list-style-type 等</li>
</ul>
</li>
<li>光标属性：cursor</li>
</ol>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是 CSS3 开始加入的功能，可以进行响应式适配展示，由两部分组成：</p>
<ul>
<li>一个可选的媒体类型（如 screen、print）等；</li>
<li>零个或多个媒体功能限定表达式（如 <code>max-width: 500px</code>、<code>orientation: landscape</code>）等</li>
</ul>
<p>最终这两部分会被解析为 true 或 false，进而确定该媒体查询关联的样式是否生效。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span>|<span class="keyword">only</span> mediatype <span class="keyword">and</span> (mediafeature <span class="keyword">and</span>|<span class="keyword">or</span>|<span class="keyword">not</span> mediafeature) &#123;</span><br><span class="line">  CSS-<span class="selector-tag">Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键词定义：</p>
<ul>
<li><code>not</code>：用于否定媒体查询，将解析后的媒体查询结反转；若出现在逗号分隔的查询列表中，将仅否定应用了该查询的特定查询；使用 not 必需指定媒体类型；</li>
<li><code>only</code>：仅在整个查询匹配时才用于应用样式，对于防止版本低的浏览器应用所选样式很有用；</li>
<li><code>,</code>：用于将多个媒体查询合并为一个规则，各自分开处理，类似于逻辑或 or；</li>
<li><code>and</code>：用于将多个媒体查询规则组合成单条媒体查询，类似于逻辑与；</li>
</ul>
<p>媒体类型（Media Types）：描述设备的一般类型</p>
<ul>
<li><code>all</code>：用于所有设备</li>
<li><code>print</code>：用于打印机和打印预览</li>
<li><code>screen</code>：用于电脑屏幕、平板电脑、智能手机等</li>
<li><code>speech</code>：用于屏幕阅读器等发声设备</li>
<li>其他已废弃（aural、braille、embossed、handheld、projection、tty、tv）</li>
</ul>
<p>媒体功能：</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>color</td>
<td>每一组彩色原件的个数，非彩色设备则值为 0</td>
</tr>
<tr>
<td>min-color</td>
<td>每一组彩色原件的最小个数</td>
</tr>
<tr>
<td>max-color</td>
<td>每一组彩色原件的最大个数</td>
</tr>
<tr>
<td>color-index</td>
<td>彩色查询表中的条目数，没有使用则为 0</td>
</tr>
<tr>
<td>min-color-index</td>
<td>彩色查询表中的最大条目数</td>
</tr>
<tr>
<td>max-color-index</td>
<td>彩色查询表中的最大条目数</td>
</tr>
<tr>
<td>device-aspect-ratio</td>
<td>屏幕可见区域宽高比</td>
</tr>
<tr>
<td>device-height</td>
<td>屏幕可见区域高度</td>
</tr>
<tr>
<td>device-width</td>
<td>屏幕可见区域最大宽度</td>
</tr>
<tr>
<td>min-device-aspect-ratio</td>
<td>屏幕可见区域最小宽高比</td>
</tr>
<tr>
<td>min-device-height</td>
<td>屏幕可见区域最小高度</td>
</tr>
<tr>
<td>min-device-width</td>
<td>屏幕可见区域最小宽度</td>
</tr>
<tr>
<td>max-device-aspect-ratio</td>
<td>屏幕可见区域最大宽高比</td>
</tr>
<tr>
<td>max-device-height</td>
<td>屏幕可见区域最大高度</td>
</tr>
<tr>
<td>max-device-width</td>
<td>屏幕可见区域最大宽度</td>
</tr>
<tr>
<td>aspect-ratio</td>
<td>页面可见区域宽高比</td>
</tr>
<tr>
<td>height</td>
<td>页面可见区域高度</td>
</tr>
<tr>
<td>width</td>
<td>页面可见区域宽度</td>
</tr>
<tr>
<td>max-aspect-ratio</td>
<td>页面可见区域最大宽高比</td>
</tr>
<tr>
<td>max-height</td>
<td>页面可见区域最大高度</td>
</tr>
<tr>
<td>max-width</td>
<td>页面可见区域最大宽度</td>
</tr>
<tr>
<td>min-aspect-ratio</td>
<td>页面可见区域最小宽高比</td>
</tr>
<tr>
<td>min-height</td>
<td>页面可见区域最小高度</td>
</tr>
<tr>
<td>min-width</td>
<td>页面可见区域最小宽度</td>
</tr>
<tr>
<td>max-resolution</td>
<td>设备的最大分辨率</td>
</tr>
<tr>
<td>min-resolution</td>
<td>设备的最小分辨率</td>
</tr>
<tr>
<td>resolution</td>
<td>设备的分辨率，单位为 dpi、dpcm</td>
</tr>
<tr>
<td>max-monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的最大单色元件个数</td>
</tr>
<tr>
<td>min-monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的最小单色元件个数</td>
</tr>
<tr>
<td>monochrome</td>
<td>在一个单色框架缓冲区中每像素包含的单色元件个数，若非单色设备则值为 0</td>
</tr>
<tr>
<td>orientation</td>
<td>页面可见区域高度是否大于或者等于宽度</td>
</tr>
<tr>
<td>grid</td>
<td>查询输出设备是否使用栅格或点阵</td>
</tr>
<tr>
<td>scan</td>
<td>电视类设备的扫描工序</td>
</tr>
</tbody></table>
<h2 id="JS-TS-ES6"><a href="#JS-TS-ES6" class="headerlink" title="JS TS ES6"></a>JS TS ES6</h2><h3 id="JS-的-8-种数据类型"><a href="#JS-的-8-种数据类型" class="headerlink" title="JS 的 8 种数据类型"></a>JS 的 8 种数据类型</h3><p>包含值类型(基本对象类型)和引用类型(复杂对象类型)</p>
<p>基本类型：在内存中占据固定大小，保存在栈内存中</p>
<ul>
<li>Number（数字类型）</li>
<li>String（字符串类型）</li>
<li>Boolean（布尔类型）</li>
<li>null（空）</li>
<li>undefined（未定义）</li>
<li>Symbol（符号类型，ES6）</li>
<li>bigInt（ES10）</li>
</ul>
<p>引用类型：引用类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址</p>
<ul>
<li>Object（对象）</li>
<li>Function（函数）</li>
<li>Array（数组）</li>
<li>Date（日期）</li>
<li>RegExp（正则表达式）</li>
<li>特殊的包装类型：String、Number、Boolean</li>
<li>单体内置对象：Global、Math 等</li>
<li>Map（字典，ES6）</li>
<li>Set（集合，ES6）</li>
</ul>
<h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>判断空对象方法：</p>
<ul>
<li><p><code>JSON.stringify(obj) === &#39;&#123;&#125;&#39;</code> </p>
</li>
<li><p><code>Object.keys(obj).length == 0</code> </p>
</li>
<li><p><code>Object.getWonPropertyNames(obj).length == 0</code> </p>
</li>
<li><p>jQuery 中的 <code>$.isEmptyObject(obj)</code> 方法</p>
</li>
<li><p>```js<br>var result = function (obj) {<br>  for (let key in obj) {</p>
<pre><code>return false
</code></pre>
<p>  }<br>  return true<br>}</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Symbol</span><br><span class="line"></span><br><span class="line">Symbol 指的是独一无二的值，每个通过 `Symbol()` 生成的值都是唯一的。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let var_symbol = Symbol();</span><br><span class="line">let other_symbol = Symbol();</span><br><span class="line">console.log(var_symbol === other_symbol); // false</span><br><span class="line">console.log(typeof var_symbol); // symbol</span><br><span class="line">console.log(var_symbol.constructor === Symbol); // true</span><br></pre></td></tr></table></figure></li>
</ul>
<p>可以用 <code>Symbol.for(key)</code> 创建相等的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> other_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(var_symbol === other_symbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(key)</code> 会根据给定的建 key(字符串)，来存运行时的 symbol 注册表中找到对应的 symbol，如找到则返回，未找到则新建一个与该键相关联的 symbol 返回，并放入全局 symbol 注册表中。</p>
<p>应用场景：</p>
<ol>
<li>使用 Symbol 来作为对象属性名（key）</li>
<li>使用 Symbol 来替代常量</li>
<li>使用 Symbol 定义类的私有属性/方法</li>
</ol>
<p>Object.getOwnPropertySymbols() 方法返回一个数组，包含给定对象所有自有的 Symbol 值的属性（包括不可枚举的 Symbol 值属性）。</p>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种数字类型的数据，可以表示任意精度格式的整数。</p>
<p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 <code>Infinity/-Infinity</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>ES10 引入了一种新的数据类型 BigInt 来解决这个问题，只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，为了与 Number 进行区分，BigInt 类型的数据必须添加后缀 <code>n</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>; <span class="comment">// 普通 Number</span></span><br><span class="line"><span class="number">12n</span>; <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span>; <span class="comment">// 3n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Number 类型进行运算</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>; <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<p>BigInt 与普通整数时两种值，它们之间并不相等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12n</span> === <span class="number">12</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于 BigInt 与 Number 完全属于两种类型，并且不会进行隐式转换，所以没有办法进行混合运算。想要运算的话，必须将两种数据类型转换为同一种后，方可进行计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(number);</span><br><span class="line"><span class="built_in">Number</span>(bigint);</span><br></pre></td></tr></table></figure>

<p>typeof 运算符对于 BigInt 类型的数据返回 <code>bigint</code> 字符串；BigInt 并不是一个构造函数，不能使用 new 来创建实例；创建一个 BigInt 时，参数必须为整数，否则会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12n</span>; <span class="comment">// &#x27;bigint&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">BigInt</span>(); <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="number">1.2</span>); <span class="comment">// Uncaught RangeError</span></span><br></pre></td></tr></table></figure>

<h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是 ES6 引入的一种叫做集合（是由一堆无序的、相关联的，且不重复的内存结构）的数据结构。</p>
<p>Set 就像一个数组，但是仅包含唯一项，Set 对象是值的集合，可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setTest = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">0</span>, -<span class="number">0</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>])</span><br><span class="line"><span class="built_in">console</span>.log(setTest) <span class="comment">// Set &#123; 0, Infinity, null, undefined, NaN &#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>虽然 NaN !== NaN，但是在 Set 集合内只会存在一个；</li>
<li>undefine、null、Infinity 也只能各自存在一个。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line">set.size <span class="comment">// 返回集合中所包含元素的数量</span></span><br><span class="line"><span class="comment">// 操作方法</span></span><br><span class="line">set.add(value) <span class="comment">// 向 set 中添加元素</span></span><br><span class="line">set.delete(value) <span class="comment">// 删除 set 中对应元素</span></span><br><span class="line">set.has(value) <span class="comment">// 判断值在集合中是否存在，返回 true 或 false</span></span><br><span class="line">set.clear() <span class="comment">// 移除集合中所有的向</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 遍历进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Set]&#x27;</span></span><br></pre></td></tr></table></figure>

<h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 是一组键值对的结构，具有极快的查找速度。</p>
<p>初始化 Map 需要一个二维数组，或者直接初始化一个空 Map：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">map.size <span class="comment">// 返回映射中的元素数</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>) <span class="comment">// 添加新的 key-value</span></span><br><span class="line">map.has(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 判断是否存在 key，返回 true 或 false</span></span><br><span class="line">map.get(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 返回 key 对应的 value 值</span></span><br><span class="line">map.delete(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 删除 key</span></span><br><span class="line">map.clear() <span class="comment">// 移除 map 中所有的键值对</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 对映射中每个元素进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Map]&#x27;</span></span><br></pre></td></tr></table></figure>

<p>一个 key 只能对应一个 value，多次对一个 key 放入 value，后面的将会覆盖前面的值。</p>
<p><strong>Object 和 Map 的区别</strong>：</p>
<p>相同点：都是以 key-value 的形式对数据进行存储</p>
<p>不同点：</p>
<table>
<thead>
<tr>
<th>不同点</th>
<th>Object</th>
<th>Map</th>
</tr>
</thead>
<tbody><tr>
<td>key 的数据类型范围</td>
<td>number、string、symbol</td>
<td>所有已有的数据类型均可以</td>
</tr>
<tr>
<td>key 的顺序</td>
<td>Object.keys() 获取到的顺序是：数字(升序)-&gt;string(symbol)(创建的顺序)</td>
<td>声明的顺序</td>
</tr>
<tr>
<td>创建方式</td>
<td><code>new Object()</code>、<code>&#123;&#125;</code>、<code>Object.create(&#123;&#125;)</code></td>
<td><code>new Map()</code></td>
</tr>
<tr>
<td>取值</td>
<td>通过 <code>.</code> 或 <code>[]</code></td>
<td><code>map.get()</code></td>
</tr>
<tr>
<td>判断是否存在属性</td>
<td><code>&#39;key&#39; in obj</code></td>
<td><code>map.has(key)</code></td>
</tr>
<tr>
<td>设置属性的方式</td>
<td><code>obj[&#39;key&#39;] = value</code>、<code>obj.key = value</code></td>
<td><code>map.set(&#39;key&#39;, value)</code></td>
</tr>
<tr>
<td>删除 key 的方式</td>
<td><code>delete obj.key</code></td>
<td><code>map.delete(&#39;key&#39;)</code><br><code>map.clear()</code></td>
</tr>
<tr>
<td>获取长度</td>
<td>通过 <code>Object.keys(obj)</code> 返回一个数组，通过获取数组的长度来获取 size</td>
<td><code>map.size</code></td>
</tr>
<tr>
<td>JSON 操作</td>
<td>支持 JSON.stringify 和 JSON.parse 的操作</td>
<td>不支持</td>
</tr>
<tr>
<td>this 指向不同</td>
<td>指向访问的 obj</td>
<td>取决于操作函数的调用者</td>
</tr>
<tr>
<td>Iterating(迭代)</td>
<td>不可以</td>
<td>可以</td>
</tr>
</tbody></table>
<blockquote>
<p>判断是否可以迭代的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [][<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Set</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Map</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>性能对比</strong>：</p>
<p>插入性能：</p>
<p>向 Object 和 Map 中插入新键值对的消耗大致相当，<strong>涉及到大量的插入操作时，Map 的性能更佳</strong>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initObj</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    obj[<span class="string">&#x27;name&#x27;</span> + i] = i</span><br><span class="line">    <span class="comment">// obj[i] = i</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMap</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    map.set(<span class="string">&#x27;name&#x27;</span> + i, i)</span><br><span class="line">    <span class="comment">// map.set(i, i)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`object set spend <span class="subst">$&#123;initObj()&#125;</span>,map set spend <span class="subst">$&#123;initMap()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure>

<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151220692.png" class title="map&amp;obj插入大量字符串键">

<blockquote>
<p>但当设置的键为整数值时，object 的性能要比 map 好一些。</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151330371.png" class title="map&amp;obj插入大量整数键">
</blockquote>
<p>查找性能：</p>
<p>从大型 Object 和 Map 中查找键值对的性能差异很小；若<strong>只有少量键值对，则 Object 有时速度更快</strong>；在把 Object 当数组使用时，浏览器引擎进行了优化，在内存中使用了更高效的布局。</p>
<p>当<strong>键不为整数时，Map 的性能要略优于 Object</strong>.</p>
<p>删除性能：</p>
<p>对于大多数浏览器引擎来说，Map 的 delete 操作都比插入和查找更快，<strong>代码中涉及大量删除操作时，应选择 Map 使用</strong>；同样，若键为整数则 Object 略优。</p>
<p>内存占用：</p>
<p>存储单个键值对所占用的内存数量都会随着键的数量线性增加，给定固定大小的内存，<strong>Map 大约可以比 Object 多存储 50% 的键值对</strong>。</p>
<h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>为了便于操作基本类型的值，JavaScript 引入了三个特殊的引用类型 boolean、number、string 的包装类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">234</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +b) <span class="comment">// number</span></span><br></pre></td></tr></table></figure>

<p>基本类型可以添加属性，访问不报错但返回 undefined：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="comment">// 这一步，系统知道 a 是个常量，所以包装类创建了一个 Number 类型的实例，同时为此实例添加了 name 属性</span></span><br><span class="line"><span class="comment">// 之后又迅速销毁了这个实例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line">  a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line">  <span class="keyword">delete</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.name)</span><br><span class="line"><span class="comment">// 系统看到又错了，包装类自动又创建了一个 Number 类型的实例</span></span><br><span class="line"><span class="comment">// 但此实例并没有 name 属性，所以返回 undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型检测方案"><a href="#数据类型检测方案" class="headerlink" title="数据类型检测方案"></a>数据类型检测方案</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>              <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>           <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>           <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>         <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log()  <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> []             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>优点：可以快速区分基本数据类型</p>
<p>缺点：无法区分 Object、Array 和 null，均返回 object</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>                <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>            <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            <span class="comment">// false</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>                <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>               <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：能够区分 Array、Object 和 Function，适用于判断自定义的类实例对象</p>
<p>缺点：不能判断 NUmber、Boolean、String 基本数据类型</p>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">toString.call(<span class="number">1</span>)              <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="literal">true</span>)           <span class="comment">// [object Boolean]</span></span><br><span class="line">toString.call(<span class="string">&quot;mc&quot;</span>)           <span class="comment">// [object String]</span></span><br><span class="line">toString.call([])             <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;)             <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>)      <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>)           <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>优点：精准判断数据类型</p>
<p>缺点：较前两种方法写法较为繁琐不易于记忆，可以进行封装后使用</p>
<h4 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h4><p>ES6 之前创建变量使用 var，之后创建变量用的是 let/const</p>
<p>区别：</p>
<ol>
<li><p>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问；<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；<br>const 用来定义常量，使用时必须初始化（即创建时必须赋值），只能在块作用域里访问，且不能修改；</p>
</li>
<li><p>var 可以先使用，后声明，因为存在变量提升，let/const 必须先声明后使用；</p>
</li>
<li><p>var 允许在相同作用域内重复声明同一个变量，但 let/const 不允许；</p>
</li>
<li><p>在全局上下文中，基于 let 声明的全局变量与全局对象（window）没有任何关系，var 声明的会有映射关系；</p>
</li>
<li><p>会产生暂时性死区：</p>
<p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，而会返回 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">let</span> b</span><br></pre></td></tr></table></figure></li>
<li><p>let/const/function 会把当前所在的大括号（除函数之外）作为一个全新的块级上下文。</p>
</li>
</ol>
<h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul>
<li><p>join()：以指定的字符串连接起来，变成字符串，通常和 String 中的 split 连用；</p>
<ul>
<li>参数为指定的字符串，默认为 <code>,</code>；</li>
</ul>
</li>
<li><p>slice()：按传入的下标截取数组；</p>
<ul>
<li>参数1：开始截取的位置即下标；</li>
<li>参数2：可选，若不传则默认截取到末尾，若传入则截取到该下标的前一位；</li>
<li>传入负数则从数组的末尾往前数；</li>
<li>返回值：返回按指定下标截取后的数组，不会影响前数组；</li>
</ul>
</li>
<li><p>splice()：删除或添加数组元素；</p>
<ul>
<li>参数1：开始删除的位置即下标；</li>
<li>参数2：可选，删除元素个数，不传则默认删到最后；</li>
<li>参数3,4,5…：添加的元素；</li>
<li>返回值：返回删除后的数据，<strong>会改变原数组</strong>；</li>
</ul>
</li>
<li><p>pop()：移除数组的最后一项，返回删除的项，<strong>会改变原数组</strong>；</p>
</li>
<li><p>push()：在数组末尾添加项数，返回添加后的数组长度，<strong>会改变原数组</strong>；</p>
</li>
<li><p>shift()：删除数组中的第一项，返回删除的项，<strong>会改变原数组</strong>；</p>
</li>
<li><p>unshift()：像数组的最前面添加项，返回新的数组长度，<strong>会改变原数组</strong>；</p>
</li>
<li><p>sort()：按一定规则排序，返回新数组，<strong>会改变原数组</strong>；</p>
<ul>
<li>参数接受一个函数；</li>
</ul>
</li>
<li><p>reverse()：数组反转，返回新数组，<strong>会改变原数组</strong>；</p>
</li>
<li><p>concat()：将两个数组连接，返回新数组，不会改变原数组；</p>
</li>
<li><p>indexOf()：查找一个数组中是否存在某个值，存在返回下标，不存在返回 -1；</p>
<ul>
<li>默认从首位开始查询；</li>
<li>只能匹配第一次出现的位置；</li>
<li>参数1：要查找的值；</li>
<li>参数2：可选，传入指定的下标，指定从哪个位置开始查询；</li>
</ul>
</li>
<li><p>lastIndexOf()：从末尾开始倒着查询；</p>
</li>
<li><p>every()：检测数组的每一项是否都符合条件，符合返回 true，若有一项不符合则停止检测返回 false；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>some()：检测数组中是否存在符合指定条件的项，若有则停止检测返回 true，否则返回 false；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>filter()：过滤，检测数组，返回符合条件的内容，没有则返回空数组；</p>
<ul>
<li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li>
<li>不会改变原数组；</li>
</ul>
</li>
<li><p>map()：映射，返回一个新的数组，新数组中的元素是原数组调用函数后处理过的值；</p>
</li>
<li><p>reduce()：对数组的每一个元素指定一个函数（正序执行），将其结果汇总为单个返回值；</p>
<ul>
<li><p>接收一个函数参数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr, index, arr</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;, init)</span><br></pre></td></tr></table></figure>

<ul>
<li>prev：必需，累计器累计回调的返回值；表示上一次调用回调时的返回值，或者是初始值；</li>
<li>curr：必需，表示当前正在处理的数组元素；</li>
<li>index：可选，表示当前正在处理的元素的索引，提供 init 初始值则起始索引为 0，否则起始索引为 1；</li>
<li>arr：可选，表示原数组；</li>
<li>init：可选，表示初始值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>以下为 ES6 新增：</p>
<ul>
<li>includes()：检测数组是否存在某个值，存在为 true，否则为 false；<ul>
<li>参数1：传入的指定值；</li>
<li>参数2：可选，表示搜索的起始位置，默认为 0，若为负数则倒着数；</li>
<li>若传入的值为整数，且大于数组的长度则返回 false；</li>
<li>若闯入的值为负数，且超过数组长度则从 0 开始查询；</li>
</ul>
</li>
<li>Array.of()：将一组值转为数组；<ul>
<li>如果没有传入参数则返回一个空数组 <code>[]</code>；</li>
<li>可以代替 Array() 和 new Array() 去创建和声明一个新数组；</li>
</ul>
</li>
<li>fill()：使用定值去填充一个数组，数组中的元素会被全部抹除；<ul>
<li>参数1：要替换为的值；</li>
<li>还可以接收参数2 和参数3，指定填充的起始位置和结束位置（前包后不包）；</li>
</ul>
</li>
<li>copyWithin()：将数组中指定的成员项，复制到其他位置（会覆盖原来的成员），返回新数组，<strong>会改变原数组</strong>；<ul>
<li>参数1：指定从哪个位置开始替换数据；</li>
<li>参数2：可选，默认从 0 开始复制，传入则从指定位置开始复制，为负则从尾部数；</li>
<li>参数3：可选，默认复制到最后，若传入则为复制的结束位置，为负则从尾部数；</li>
</ul>
</li>
<li>find()：用来找出第一个符合条件的成员；<ul>
<li>参数是一个回调函数，依次查询每一项，直到查询到第一个符合条件的成员，并返回该项的值，若不存在则返回 undefined；</li>
</ul>
</li>
<li>findIndex()：类似于 find()，但返回的是符合条件的项的位置即下标，均不满足则返回 -1；</li>
<li>entries()：键值对的遍历；</li>
<li>keys()：键名遍历；</li>
<li>values()：键值遍历。</li>
</ul>
<h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><p>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢；当某些代码操作不能被合理释放，就会造成内存泄漏。</p>
<p>浏览器垃圾回收机制/内存回收机制：</p>
<ol>
<li>标记清除</li>
<li>谷歌浏览器：查找引用</li>
<li>IE 浏览器：引用计数法</li>
</ol>
<p>优化手段：</p>
<ol>
<li>堆内存：fn = null【null：空指针对象】</li>
<li>栈内存：将上下文中被外部占用的堆取消掉即可</li>
</ol>
<p>内存泄漏：</p>
<ul>
<li>全局变量</li>
<li>闭包</li>
<li>DOM 元素的引用</li>
<li>定时器</li>
</ul>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域 -&gt; 当前创建函数所处的上下文。如果是在全局下创建的函数就是 <code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文 <code>EC(FN)</code>，供字符串代码执行（进栈执行）。</p>
<p>定义：作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成</p>
<ol>
<li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域；</li>
<li>函数作用域：在固定的代码片段才能被访问</li>
</ol>
<p>作用：作用域的最大用处就是 <strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p>一般情况下，变量到创建该变量的函数的作用域中取值。但如果没有查询到，就会向上级作用域去查，直到查到全局作用域，这一个查找过程所构成的链条就叫做作用域链。</p>
<h3 id="闭包：保存-保护"><a href="#闭包：保存-保护" class="headerlink" title="闭包：保存/保护"></a>闭包：保存/保护</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数执行时形成的私有上下文 <code>EC(FN)</code>，正常情况下，代码执行完会出栈然后释放；但是特殊情况下，如果当前私有上下文中的数据被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不会被销毁的上下文。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰；</li>
<li>保存：如果当前上下文不被释放，则存储的私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</li>
</ol>
<p>把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部函数可以访问定义它们外部函数的参数和变量，设计私有的方法和变量，避免全局变量的污染；</li>
<li>函数嵌套函数；</li>
<li>本质是将函数内部和外部连接起来，优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除。</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li>模仿块级作用域</li>
<li>保护外部函数的变量，能够访问函数定义时所在的词法作用域（阻止其被回收）</li>
<li>封装私有化变量</li>
<li>创建模块</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>会导致函数的变量一致保存在内存中，过多的闭包会导致内存泄漏。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol>
<li>作为普通函数执行时，<code>this</code> 指向 <code>window</code>；</li>
<li>当函数作为对象的方法被调用时，<code>this</code> 就会指向该对象；</li>
<li>构造器调用，this 指向返回的这个对象；</li>
<li>箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象，如果有嵌套的情况，则 this 绑定到最近的一层对象上；</li>
<li>基于 Function.prototype 上的 apply、call 和 bind 调用模式，可以显示指定调用函数的 this 指向。</li>
</ol>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的特点：</p>
<ol>
<li>箭头函数均为匿名函数；</li>
<li>箭头函数不能用于构造函数，不能使用 new；</li>
<li>箭头函数中的 this 指向不同：<ul>
<li>在普通函数中，this 总是指向调用它的对象，用作构造函数则指向创建的对象实例；</li>
<li>但箭头函数本身不会创建 this，但会<strong>在声明时捕获其所在上下文的 this 供自己使用，且一旦捕获无法改变</strong>。</li>
</ul>
</li>
<li>箭头函数不能 generator 函数，不能使用 yeild 关键字；</li>
<li>箭头函数不具有 prototype 原型对象；</li>
<li>不具有 new.target 和 super。</li>
</ol>
<h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h3><p>原型关系：</p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 __proto__</li>
<li>实例的 __proto__ 指向对应 class 的 prototype</li>
</ul>
<p>原型：在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code> 属性，这个属性指向函数的原型对象。</p>
<p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 __proto**，该指针是指向上一层的原型对象，而上一层的原型对象的结构以此类推。因此可以利用 <code>__proto__</code>一直指向 Object 的原型对象上，而 Object 的原型对象用<code>Object.prototype.__proto__ = null</code> 表示原型链顶端，如此形成了 js 的原型链继承；</p>
<p>特点：JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol>
<li>创建一个空的新对象；</li>
<li>设置原型，将对象的原型 <code>__proto__</code> 设置为函数的 <code>prototype</code> 对象；</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（添加属性）；</li>
<li>判断函数的返回类型，若是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象；</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo =  <span class="keyword">new</span> Foo(<span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> fn () &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Foo.prototype</span><br><span class="line">  Foo.call(obj, <span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>JS 是单线程的，为了防止一个函数执行时间过长而阻塞后面的代码，所以会先将同步代码压入执行栈中，一次执行，将异步代码突入异步队列，异步队列又分为宏任务队列和微任务队列，微任务队列优先于宏任务队列。</p>
<p>JS 运行的环境一般为浏览器或者 Node，在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<h4 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h4><p>先执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后取宏任务清微任务不停循环。</p>
<p>EventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p>
<ol>
<li>函数入栈，当 Stack 中执行到异步任务时，就将它丢给 WebAPIs，接着执行同步任务，直到 Stack 为空；</li>
<li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行；</li>
<li>执行栈为空时，Event Loop 把微任务队列执行清空；</li>
<li>微任务队列清空后，进入宏任务队列，取对列的第一项任务放入 Stack（栈）中执行，执行完成后，查看微任务队列是否有任务，有则执行清空，然后重复此步骤，直至清空所有的任务。</li>
</ol>
<p>浏览器中的任务源（task）：</p>
<h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><p>页面中大部分任务都是在主线程上执行的，包括：</p>
<ul>
<li>渲染事件（DOM、计算布局、绘制）</li>
<li>用户交互事件（鼠标点击、滚动页面、放大缩小等）</li>
<li>JavaScript 脚本执行事件</li>
<li>网络请求完成、文件读写完成事件</li>
</ul>
<p>ajax、setTimeout、setInterval、setTmmediate(只兼容 IE)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器 API</p>
<h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p>
<ul>
<li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；</li>
<li>微任务的执行时长会影响到当前宏任务的时长；</li>
<li>在一个宏任务中分别创建一个用于回调的宏任务和微任务，无论如何微任务都早于宏任务执行。</li>
</ul>
<p>then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObserve</p>
<h4 id="Node-中的事件循环"><a href="#Node-中的事件循环" class="headerlink" title="Node 中的事件循环"></a>Node 中的事件循环</h4><p>Node 是基于 V8 引擎的运行在服务端的 <code>JavaScript</code> 运行环境，在处理高并发、I/O 密集（文件操作、网络操作、数据库操作等）场景有明显的优势。</p>
<p>由于服务目的和环境不同，其事件循环还要处理一些 I/O，所以 Node 的 Event Loop 与浏览器的是不太一样：</p>
<ol>
<li>timers：计时器，执行 setTimeout 和 setInterval 的回调；</li>
<li>pending callbacks：执行延迟到下一个循环迭代的 I/O 回调；</li>
<li>idle，prepare：队列的移动，仅系统内部使用；</li>
<li>poll 轮询：检索新的 I/O 事件，执行与 I/O 相关的回调；</li>
<li>check：执行 Immediate 的回调；</li>
<li>close callbacks：执行 close 事件的 callback ，一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code> </li>
</ol>
<h3 id="setTimeout-Promise-Async-Await"><a href="#setTimeout-Promise-Async-Await" class="headerlink" title="setTimeout Promise Async/Await"></a>setTimeout Promise Async/Await</h3><p>setTimeout：</p>
<p>setTimeout 的回调函数放入宏任务队列中，等到执行栈清空后执行；</p>
<p>Promise：</p>
<p>Promise 本身是同步的立即执行函数，当在 executor 中执行 resolve 或者 reject 是，此时是异步操作，会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 的 中存放的方法执行。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出顺序：</span></span><br><span class="line"><span class="comment">		script start</span></span><br><span class="line"><span class="comment">		promise1</span></span><br><span class="line"><span class="comment">		promise1 end</span></span><br><span class="line"><span class="comment">		script end</span></span><br><span class="line"><span class="comment">		promise2</span></span><br><span class="line"><span class="comment">		settimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>async/awiat：</p>
<p>async 函数返回一个 Promise 对象，当函数执行时，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	输出顺序：</span></span><br><span class="line"><span class="comment">		script start</span></span><br><span class="line"><span class="comment">		async1 start</span></span><br><span class="line"><span class="comment">		async2</span></span><br><span class="line"><span class="comment">		script end</span></span><br><span class="line"><span class="comment">		async1 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>async/await 通过同步的方式实现异步的原理：</p>
<p>async/awiat 就是一个自执行的 generate 函数，利用 generate 函数的特性把异步的代码写成同步的形式，第一个请求的返回值作为后一个请求的参数，其中每一个参数都是一个 promise 对象。</p>
<h3 id="节流-防抖"><a href="#节流-防抖" class="headerlink" title="节流/防抖"></a>节流/防抖</h3><p>节流：<strong>事件触发后，规定时间内，事件处理函数不能再次被调用</strong>；也就是在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次；</p>
<p>防抖：<strong>多次触发事件，事件触发函数只能执行一次，并且是在触发结束时执行</strong>；即当一个事件被触发准备执行事件函数前，会等待一定的时间，如果没有再次被触发，那么就执行，如果被触发，则本次作废，重新从新触发的时间开始计算，并再次等待，直到能最终执行。</p>
<p>使用场景：</p>
<ol>
<li>节流：滚动加载更多、搜索框的搜索联想功能、高频点击、表单重复提交…</li>
<li>搜索框搜索输入，并在输入完成后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后再重新渲染。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次之后，只有大于设定的执行周期才会执行第二次.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次函数触发的时间</span></span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.call(<span class="built_in">this</span>, ...args)</span><br><span class="line">      <span class="comment">// 同步执行结束时间</span></span><br><span class="line">      lastTime = nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;scroll 事件被触发了&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数 一个需要频繁触发的函数，再规定时间内，只让最后一次生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被防抖的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除上一次的延时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">// 重新设置新的延时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<h3 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h3><p>对于基本数据类型而言，== 和 === 是有区别的：</p>
<ul>
<li>不同类型间比较，== 只比较转化成同一类型后的值是否相等；</li>
<li>=== 如果类型和数值有一项不同，就是不等</li>
</ul>
<p>对于引用数据类型来说，== 和 === 是没有区别的；</p>
<p>对于引用类型和基本数据类型比较：</p>
<ul>
<li>== 会将引用数据类型转化为基本数据类型，进行值比较；</li>
<li>=== 结果为 false</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> 				<span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span>   				 	<span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="number">42</span> 				 	<span class="comment">// true -- 字符串转数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="number">42</span> 				<span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="literal">true</span> 				<span class="comment">// false -- 字符串与布尔值分别转化成数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="literal">true</span> 			<span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> 	<span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">false</span>      <span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == [<span class="number">42</span>]					<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === [<span class="number">42</span>]					<span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == <span class="built_in">Object</span>(a)			<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === <span class="built_in">Object</span>(a)		<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡捕获"><a href="#事件冒泡捕获" class="headerlink" title="事件冒泡捕获"></a>事件冒泡捕获</h3><p>不支持冒泡的事件：</p>
<ul>
<li>UI 事件：load、unload、resize、abort、error</li>
<li>焦点事件：blur、focus</li>
<li>鼠标事件：mouseleave、mouseenter</li>
</ul>
<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>概念：视图模型双向绑定，是 <code>Model-View-ViewModel</code> 的缩写，也就是将 MVC 中的 Controller 演变成 ViewModel。</p>
<ul>
<li>Model 层代表数据模型</li>
<li>View 代表 UI 组件</li>
<li>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 ViewModel 层并自动将数据渲染到页面中，视图变化时会通知 ViewModel 层更新数据；</li>
</ul>
<p>以前是操作 DOM 结构更新视图，现在是<strong>数据驱动视图</strong>。</p>
<p>优点：</p>
<ol>
<li><strong>低耦合</strong>：View 可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化时 Model 可以不变化，反之也一样；</li>
<li><strong>可重用性</strong>：可以把一些视图逻辑放在一个 Model 里，让很多的 View 重用这段视图逻辑；</li>
<li><strong>独立开发</strong>：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li>
<li><strong>可测试</strong>。</li>
</ol>
<h3 id="Vue-底层原理"><a href="#Vue-底层原理" class="headerlink" title="Vue 底层原理"></a>Vue 底层原理</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.definedProperty() 来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<p>Vue 是一个典型的 MVVM 框架，Model 只是普通的 JavaScript 对象，修改它则 View 会自动更新，这种设计让状态管理变得非常简单而直观。</p>
<p><code>Observer</code>（数据监听器）：Observer 的核心时通过 Object.defineProperty() 来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter，此时 Observer 通知订阅者，也就是 Watcher；</p>
<p><code>Watcher</code>（订阅者）：Watcher 订阅者作为 Observer 和 Complie 之间通信的桥梁：</p>
<ol>
<li>在自身实例化时往属性订阅器（dep）中添加自己</li>
<li>自身必须有一个 update 方法</li>
<li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调</li>
</ol>
<p><code>Compile</code>（指令解析器）：Compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听函数的订阅者，一旦数据有变动，收到通知就更新视图。</p>
<h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件：</p>
<ul>
<li>create 阶段：vue 实例被创建<ul>
<li><code>beforeCreate</code>：创建前，此时 data 和 methods 中的数据还没有初始化；</li>
<li><code>created</code>：创建完毕，data 中有值，但还未挂载；</li>
</ul>
</li>
<li>mount 阶段：vue 实例被挂载到真实 DOM 节点<ul>
<li><code>beforeMount</code>：可以发起服务器请求去请求数据；</li>
<li><code>mounted</code>：此时可以操作 DOM；</li>
</ul>
</li>
<li>update 阶段：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<ul>
<li><code>beforeUpdate</code>：更新前；</li>
<li><code>updated</code>：更新后；</li>
</ul>
</li>
<li>destroy 阶段：vue 实例被销毁<ul>
<li><code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法；</li>
<li><code>destroyed</code>：销毁后。</li>
</ul>
</li>
</ul>
<p>组件生命周期：</p>
<p>父组件 beforeCreate -&gt; 父组件 created -&gt; 父组件 beforeMount -&gt; 子组件 beforeCreate -&gt; 子组件 created -&gt; 子组件 beforeMount -&gt; 子组件 mounted -&gt; 父组件 mounted -&gt; 父组件 beforeDestroy -&gt; 子组件 beforeDestroy -&gt; 子组件 detroyed -&gt;  父组件 detroyed</p>
<p>父组件更新：父组件 beforeUpdate -&gt; 父组件 updated</p>
<p>子组件更新：父组件 beforeUpdate -&gt; 子组件 beforeUpdate -&gt; 子组件 updated -&gt; 父组件 updated</p>
<h3 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed watch"></a>computed watch</h3><p>既能用 computed 实现又可以用 watch 监听来实现的功能，推荐使用 computed：</p>
<ul>
<li>computed 计算属性是用来声明式的描述一个值依赖了其他的值，当所依赖的值或者变量改变时，计算属性就会跟着改变；</li>
<li>watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</li>
</ul>
<p>watch 监听属性：是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用；</p>
<p>computed 计算属性：属性的结果会被缓存，当 computed 中的函数所以来的属性没有发生变化时，调用当前函数时就会从缓存中读取结果，只有当依赖的响应式属性变化时才会重新计算，主要当做属性来使用；computed 中的函数必须用 return 返回最后的结果，computed 更高效，优先使用；</p>
<p>使用场景：</p>
<ul>
<li>computed：当一个属性受多个属性影响的时候使用；</li>
<li>watch：当一条数据影响多条数据的时候使用。</li>
</ul>
<h3 id="data-为何是函数"><a href="#data-为何是函数" class="headerlink" title="data 为何是函数"></a>data 为何是函数</h3><ol>
<li>一个组件被复用多次的的话，也就会创建多个实例。本质上这些实例都是用的同一个构造函数。</li>
<li>如果 data 是对象的话，对象是引用类型，会影响到所有的实例。</li>
</ol>
<p>所以为了<strong>保证组件不同的实例之间 data 不冲突</strong>，data 必须是一个函数。</p>
<h3 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a>v-for 和 v-if</h3><ol>
<li>当 v-for 和 v-if 处于一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中；如果要遍历的数组很大，而真正展示的数据又很少时，这将造成很大的性能浪费；</li>
<li>这种场景建议使用 computed，先对数据进行过滤；或者将 v-if 提至外层使用 template。</li>
</ol>
<blockquote>
<p>3.x 版本中 v-if 总是优先于 v-for 生效。</p>
</blockquote>
<p>由于语法上存在歧义，建议避免在同一元素上同时使用两者。</p>
<p>比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p>
<h3 id="React-Vue-中的-key"><a href="#React-Vue-中的-key" class="headerlink" title="React/Vue 中的 key"></a>React/Vue 中的 key</h3><ul>
<li><p>key 的作用是是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度，更高效的更新虚拟 DOM；</p>
<p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中，会根据节点的 key 去对比就跌点数组中的 key，从而找到相应旧节点，若没有找到则认为是一个新增节点。如果没有 key，就需要采用遍历查找的方式去找到对应的节点。一种是 map 映射，另一种是遍历查找，相比而言，map 映射的速度更快；</p>
</li>
<li><p>为了在数据变化时强制更新组件，以避免就地复用带来的副作用；</p>
<p>当 vue 用 v-for 更新已渲染的元素列表时，默认使用就地复用策略，如果数据项的顺序被改变，vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，重复的 key 将会造成渲染错误。</p>
</li>
</ul>
<h3 id="vue-组件的通信方式"><a href="#vue-组件的通信方式" class="headerlink" title="vue 组件的通信方式"></a>vue 组件的通信方式</h3><ul>
<li><code>props</code>/<code>$emit</code> 父子组件通信：<ul>
<li>父 -&gt; 子 <code>props</code>，子 -&gt; 父 <code>$on、$emit</code> 获取父子组件实例</li>
<li><code>parent、children</code> 获取实例的方式调用组件的属性或者方法</li>
<li>父 -&gt; 子孙 <code>Provide、inject</code> 官方不推荐使用，但写组件库时较为常用</li>
</ul>
</li>
<li><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信：<ul>
<li><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</li>
</ul>
</li>
<li>vuex 跨级组件通信<ul>
<li>Vuex、<code>$attrs、$listeners</code>、<code>Provide、reject</code> </li>
</ul>
</li>
</ul>
<h3 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h3><ol>
<li>nextTick 是 Vue 提供的一个全局 API，是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM；</li>
<li>Vue 在更新 DOM 时时异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 <code>watcher</code> 被多次触发，只会被推入到队列中一次。这种在缓存时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用；</li>
<li>会在 callbacks 中加入传入的函数，然后用 <code>timerFunc</code> 异步方式调用，首选的异步方式会是 Promise。</li>
</ol>
<h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在下次 DOM 更新循环之后执行延迟回调，在修改数据之后使用 nextTick 来获取更新后的 DOM。</p>
<p>nextTick 主要使用的宏任务和微任务，根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，若均不行则采用 setTimeout 定义一个异步方法，多次调用 nextTick 会将此方法存入队列中，通过这个异步方法清空当前队列。</p>
<h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>分为默认插槽、具名插槽和作用域插槽</p>
<h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。</p>
<p>场景：tabs 标签页、后台导航、vue 性能优化</p>
<p>原理：vue 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点而不是直接存储 DOM 结构。将满足条件（pruneCache）的组件在 cache 对象中缓存起来，在需要重新渲染时再将 VNode 节点从 cache 对象中取出并渲染。</p>
<h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>多个组件间有重复的逻辑就会用到 mixin，但 mixin 并不是完美的解决方案，会有一些问题（Vue3 提出的 Composition API 旨在解决这些问题）。</p>
<p>场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合</p>
<p>劣势：</p>
<ol>
<li>变量来源不明确，不利于阅读；</li>
<li>多 mixin 可能导致命名冲突；</li>
<li>mixin 和组件可能出现多对多的关系，使得项目复杂度变高。</li>
</ol>
<h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 的核心就是 store（仓库）。</p>
<ol>
<li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，则相应的组件也会得到高效更新；</li>
<li>改变 store 中的状态的唯一途径就是显式地提交（commit）mutation，这使得可以方便地跟踪每一个状态的变化。</li>
</ol>
<p>Vuex 包括以下核心模块：</p>
<ul>
<li><strong>State</strong>：定义了应用的状态数据；</li>
<li><strong>Getter</strong>：再 store 中定义 getter（相当于计算属性）；</li>
<li><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数；</li>
<li><strong>Action</strong>：用于提交 Mutation，而不是直接变更状态，可以包含任意异步操作；</li>
<li><strong>Module</strong>：允许将单一的 Store 拆分成多个 store 且同时保存在单一的状态树中。</li>
</ul>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/vuex.png" class title="vuex">

<h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>当一次操作中有多次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这些更新内容保存在本地一个 JS 对象中，最终将这个 JS 对象一次性更新到 DOM 树上，避免无谓的计算量；操作内存中的 JS 对象的速度显然要更快。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以下一个真实的 DOM 节点：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;real-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Real DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>before update<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用 JS 来模拟 DOM 节点实现虚拟 DOM：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Real DOM&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;virtualDom&#x27;</span>).appendChild(root)</span><br></pre></td></tr></table></figure>

<p><code>Element</code> 方法实现：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.tagName = tagName</span><br><span class="line">  <span class="built_in">this</span>.props = props || &#123;&#125;</span><br><span class="line">  <span class="built_in">this</span>.children = children || []</span><br><span class="line">  <span class="built_in">this</span>.key = props ? props.key : <span class="literal">undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      count += child.count</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName)</span><br><span class="line">  <span class="keyword">const</span> props = <span class="built_in">this</span>.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">    el.setAttributte(propName, props[propName])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> Element) ? child.render() : <span class="built_in">document</span>.createTextNode(child)</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Diff 实现 O(n) 复杂度：</p>
<p>新的 DOM 树：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),								<span class="comment">// REPLACE</span></span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]),						 	<span class="comment">// TEXT</span></span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;marginLeft10&#x27;</span> &#125;, [   			<span class="comment">// PROPS</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]), // REORDER remove</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure>

<p>diff 算法会从根节点开始，逐层向下比较旧虚拟 DOM 和新虚拟 DOM，如果在某一层的耨个节点发现不同，则判断变化类型，做出相应的处理，只有以下四种情况：</p>
<ol>
<li><p>节点类型变了，<code>p -&gt; h3</code>，此过程称为 <code>REPLACE</code>，<strong>直接将旧节点卸载并装载新节点</strong>，包括旧节点下的全部子节点也全部卸载；</p>
<p>当旧节点和新节点仅仅是类型变化，但下面的所有子节点都一样时，这种做法效率不高，但为了避免较高的时间复杂度，此做法值得；</p>
<p>所以开发时应避免无谓的节点类型的变化；</p>
</li>
<li><p>节点类型一样，仅仅属性或属性值变了，此过程称为 <code>PROPS</code>，此时不会触发节点卸载和装载，而是进行节点更新，查找不同属性的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span> (<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = oldNode</span><br><span class="line">  <span class="keyword">const</span> newProps = newNode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">const</span> propsPatches = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> isSame = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(oldProps.hasOwnProperty(key))) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>仅文本发生，直接修改文字内容即可，称为 <code>TEXT</code>；</p>
</li>
<li><p>移动/增加/删除 子节点，此过程称为 <code>REORDER</code>：</p>
<ul>
<li>若元素没有指定 key，或者在 for 循环中使用 index 作为 key，则会依次遍历，从改变项逐个向后做修改；</li>
<li>若有指定唯一不变的 key，则会直接找到改变项进行修改，极大提升了 diff 算法的效率。</li>
</ul>
</li>
</ol>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul>
<li>查看分支：<code>git branch</code> </li>
<li>创建分支：<code>git branch xxx</code> </li>
<li>切换分支：<code>git checkout xxx</code> </li>
<li>创建 + 切换分支：<code>git checkout -b xxx</code> </li>
<li>合并某分支到当前分支：<code>git merge xxx</code> </li>
<li>删除分支：<code>git branch -d xxx</code> </li>
</ul>
<h3 id="管理项目"><a href="#管理项目" class="headerlink" title="管理项目"></a>管理项目</h3><p>实际开发中，一个仓库主要存放两条主分支：master 与 develop 分支，生命周期为整个项目周期。</p>
<ul>
<li>master：这个分支最为稳定，这个分支表明项目处于可发布的状态；</li>
<li>develop：作为开发的分支，平行于 master 分支；</li>
<li>feature branches：功能分支，必须从 develop 分支建立，完成后合并回 develop 分支；</li>
<li>release branches：这个分支用来发布新版本。从 develop 分支建立，完成后合并回 develop 与 master 分支；</li>
<li>hotfix branches：这个分支主要为修复线上特别紧急的 bug 准备，必须从 master 分支建立，完成后合并回 develop 与 master 分支，主要是解决线上版本的紧急 bug 修复</li>
</ul>
<h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><ol>
<li>移除生产环境的控制台打印；<ul>
<li>eslint + pre-commit；</li>
<li>使用插件自动去除：如 <code>terser-webpack-plugin</code>，无需安装额外的插件，仅需在 configureWebpack 中设置 terser 插件的 drop_console 为 true 即可；</li>
<li>vscode 中的 turbo console；</li>
</ul>
</li>
<li>第三方库的按需加载；<ul>
<li>echarts：使用配置文件指定使用的模块；或使用 <code>babel-piugin-equire</code> 实现按需加载；</li>
<li>element-ui：使用 <code>babel-plugin-component</code> 实现按需引入；</li>
</ul>
</li>
<li>避免 CSS 表达式、滤镜，减少 DOM 操作，优化图片、精灵图，避免图片空链接等；</li>
</ol>
<p>优化技术方案：</p>
<ul>
<li>降低请求成本</li>
<li>减少请求数：<ul>
<li>JS、CSS打包到HTML；</li>
<li>JS 控制图片异步加载、懒加载；</li>
<li>小型图片使用 data-uri；</li>
</ul>
</li>
<li>减少传输体积：<ul>
<li>尽量使用 SVG/gradient 代替图片；</li>
<li>根据机型和网络状况控制图片清晰度；</li>
<li>对低清晰度图片使用锐化来提升体验；</li>
<li>设计上避免大型背景图；</li>
</ul>
</li>
<li>使用 CDN 加速</li>
</ul>
<h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 是跨站脚本攻击（Cross Site Scripting），俗称脚本注入；典型的例子是在留言板的输入框中输入带有 html 标签的关键字进行恶意的修改页面以及盗取 Cookie。</p>
<p>解决方法：</p>
<ol>
<li>对诸如 <code>script</code>、<code>img</code>、<code>a</code> 等标签进行过滤；</li>
<li>像一些常见的符号，如 <code>&lt;&gt;</code> 在输入时要对其进行转码；</li>
<li>通过限制输入长度强制截断来进行防御。</li>
</ol>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="代码报错位置"><a href="#代码报错位置" class="headerlink" title="代码报错位置"></a>代码报错位置</h3><p>使用 <code>source-map</code> 库进行错误定位。</p>
<p><code>Source Map</code> 是一个 JSON 文件，包含了代码转换前后的位置信息。也就是说，给定一个转换之后的压缩代码的位置，就可以通过 <code>Source Map</code> 获取转换之前的代码位置，有以下属性：</p>
<ul>
<li>version：Source Map 的版本号；</li>
<li>sources：转换前的文件列表；</li>
<li>names：转换前的所有变量名和属性名；</li>
<li><strong>mappings</strong>：记录位置信息的字符串，经过编码；</li>
<li>file：转换前后的文件名；</li>
<li>sourceRoot：转换前的文件所在的目录，若在同一目录，则为空；</li>
<li>sourceContent：转换前的文件内容列表，与 sources 列表依次对应；</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AgoniLay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://agonilay.github.io" target="_blank">AgoniLay的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/04/15/%E6%89%8B%E5%86%99JS%E7%9B%B8%E5%85%B3/"><img class="prev-cover" src="https://img2.baidu.com/it/u=147831657,1408237617&amp;fm=26&amp;fmt=auto" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">手写JS相关</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/10/Sass/"><img class="next-cover" src="https://img0.baidu.com/it/u=2134113155,1156622243&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=780&amp;h=484" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sass</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/04/20/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/" title="面经总结"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">面经总结</div></div></a></div><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="前端面试复习"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端面试复习</div></div></a></div><div><a href="/2021/07/30/ES7%E7%AC%94%E8%AE%B0/" title="ES7笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES7笔记</div></div></a></div><div><a href="/2021/07/30/ES8%E7%AC%94%E8%AE%B0/" title="ES8笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES8笔记</div></div></a></div><div><a href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%80/" title="JavaScript笔记(一)"><img class="cover" src="https://img2.baidu.com/it/u=147831657,1408237617&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">JavaScript笔记(一)</div></div></a></div><div><a href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%89/" title="JavaScript笔记(三)"><img class="cover" src="https://img2.baidu.com/it/u=147831657,1408237617&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">JavaScript笔记(三)</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS"><span class="toc-number">1.</span> <span class="toc-text">HTTP 和 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">区别以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">HTTPS 工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.2.</span> <span class="toc-text">TCP 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0"><span class="toc-number">2.3.</span> <span class="toc-text">保证数据包传输的有序可靠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP 请求跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">跨域的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-sessionStorage-localStorage"><span class="toc-number">3.</span> <span class="toc-text">Cookie sessionStorage localStorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96"><span class="toc-number">4.</span> <span class="toc-text">粘包问题分析与对策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.1.</span> <span class="toc-text">出现原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%AA%E6%96%BD"><span class="toc-number">4.2.</span> <span class="toc-text">避免措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">输入 URL 到页面加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92"><span class="toc-number">5.2.</span> <span class="toc-text">重绘与重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D"><span class="toc-number">5.2.2.</span> <span class="toc-text">避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#304"><span class="toc-number">5.3.</span> <span class="toc-text">304</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">5.4.</span> <span class="toc-text">强制缓存 协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">进程 线程 协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML"><span class="toc-number">6.</span> <span class="toc-text">HTML</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">HTML5 语义化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CSS"><span class="toc-number">7.</span> <span class="toc-text">CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.1.</span> <span class="toc-text">CSS 选择器及优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">7.1.1.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">7.1.2.</span> <span class="toc-text">优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position"><span class="toc-number">7.2.</span> <span class="toc-text">position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-sizing"><span class="toc-number">7.3.</span> <span class="toc-text">box-sizing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.4.</span> <span class="toc-text">CSS 盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">7.5.</span> <span class="toc-text">BFC(块级格式上下文)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">7.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99"><span class="toc-number">7.5.2.</span> <span class="toc-text">原理布局规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">7.5.3.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">7.5.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">7.6.</span> <span class="toc-text">水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">7.6.1.</span> <span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">7.6.2.</span> <span class="toc-text">垂直居中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%85%83%E7%B4%A0"><span class="toc-number">7.7.</span> <span class="toc-text">隐藏页面中元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-CSS-%E7%94%BB%E4%B8%89%E8%A7%92"><span class="toc-number">7.8.</span> <span class="toc-text">用 CSS 画三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#0-5px-%E8%BE%B9%E6%A1%86"><span class="toc-number">7.9.</span> <span class="toc-text">0.5px 边框</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">7.10.</span> <span class="toc-text">页面布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex-%E5%B8%83%E5%B1%80"><span class="toc-number">7.10.1.</span> <span class="toc-text">Flex 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rem-%E5%B8%83%E5%B1%80"><span class="toc-number">7.10.2.</span> <span class="toc-text">Rem 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"><span class="toc-number">7.10.3.</span> <span class="toc-text">百分比布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-number">7.10.4.</span> <span class="toc-text">浮动布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80-%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80"><span class="toc-number">7.11.</span> <span class="toc-text">圣杯布局 双飞翼布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80"><span class="toc-number">7.11.1.</span> <span class="toc-text">圣杯布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80"><span class="toc-number">7.11.2.</span> <span class="toc-text">双飞翼布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rem-%E6%88%96-viewport-%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-number">7.12.</span> <span class="toc-text">使用 rem 或 viewport 进行移动端适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">7.12.1.</span> <span class="toc-text">rem 适配原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewport-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">7.12.2.</span> <span class="toc-text">viewport 适配原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">7.13.</span> <span class="toc-text">清除浮动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E4%B8%AD%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">7.14.</span> <span class="toc-text">CSS 中可以继承的属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2"><span class="toc-number">7.15.</span> <span class="toc-text">媒体查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-TS-ES6"><span class="toc-number">8.</span> <span class="toc-text">JS TS ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E7%9A%84-8-%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">8.1.</span> <span class="toc-text">JS 的 8 种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Object"><span class="toc-number">8.1.1.</span> <span class="toc-text">Object</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInt"><span class="toc-number">8.1.2.</span> <span class="toc-text">BigInt</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Set"><span class="toc-number">8.1.3.</span> <span class="toc-text">Set</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Map"><span class="toc-number">8.1.4.</span> <span class="toc-text">Map</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">8.1.5.</span> <span class="toc-text">包装类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="toc-number">8.2.</span> <span class="toc-text">数据类型检测方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-number">8.2.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">8.2.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">8.2.3.</span> <span class="toc-text">Object.prototype.toString.call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var-let-const"><span class="toc-number">8.2.4.</span> <span class="toc-text">var let const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95"><span class="toc-number">8.3.</span> <span class="toc-text">数组方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">8.4.</span> <span class="toc-text">JS 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">8.5.</span> <span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%9A%E4%BF%9D%E5%AD%98-%E4%BF%9D%E6%8A%A4"><span class="toc-number">8.6.</span> <span class="toc-text">闭包：保存&#x2F;保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">8.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">8.6.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">8.6.3.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">8.6.4.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">8.6.5.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">8.7.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0"><span class="toc-number">8.8.</span> <span class="toc-text">箭头函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">8.9.</span> <span class="toc-text">原型 原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">8.10.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop"><span class="toc-number">8.11.</span> <span class="toc-text">EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.11.1.</span> <span class="toc-text">浏览器中的事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%8F%E4%BB%BB%E5%8A%A1"><span class="toc-number">8.11.1.1.</span> <span class="toc-text">宏任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BE%AE%E4%BB%BB%E5%8A%A1"><span class="toc-number">8.11.1.2.</span> <span class="toc-text">微任务</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Node-%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">8.11.2.</span> <span class="toc-text">Node 中的事件循环</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-Promise-Async-Await"><span class="toc-number">8.12.</span> <span class="toc-text">setTimeout Promise Async&#x2F;Await</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8A%82%E6%B5%81-%E9%98%B2%E6%8A%96"><span class="toc-number">8.13.</span> <span class="toc-text">节流&#x2F;防抖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%92%8C"><span class="toc-number">8.14.</span> <span class="toc-text">&#x3D;&#x3D; 和 &#x3D;&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%E6%8D%95%E8%8E%B7"><span class="toc-number">8.15.</span> <span class="toc-text">事件冒泡捕获</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue"><span class="toc-number">9.</span> <span class="toc-text">Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MVVM"><span class="toc-number">9.1.</span> <span class="toc-text">MVVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">9.2.</span> <span class="toc-text">Vue 底层原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">9.3.</span> <span class="toc-text">生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#computed-watch"><span class="toc-number">9.4.</span> <span class="toc-text">computed watch</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#data-%E4%B8%BA%E4%BD%95%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">9.5.</span> <span class="toc-text">data 为何是函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#v-for-%E5%92%8C-v-if"><span class="toc-number">9.6.</span> <span class="toc-text">v-for 和 v-if</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#React-Vue-%E4%B8%AD%E7%9A%84-key"><span class="toc-number">9.7.</span> <span class="toc-text">React&#x2F;Vue 中的 key</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vue-%E7%BB%84%E4%BB%B6%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">9.8.</span> <span class="toc-text">vue 组件的通信方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#nextTick-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.9.</span> <span class="toc-text">nextTick 的实现</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">9.9.1.</span> <span class="toc-text">实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E6%A7%BD"><span class="toc-number">9.10.</span> <span class="toc-text">插槽</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#keep-alive"><span class="toc-number">9.11.</span> <span class="toc-text">keep-alive</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mixin"><span class="toc-number">9.12.</span> <span class="toc-text">mixin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vuex"><span class="toc-number">9.13.</span> <span class="toc-text">Vuex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F-DOM"><span class="toc-number">9.14.</span> <span class="toc-text">虚拟 DOM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A5%BD%E5%A4%84"><span class="toc-number">9.14.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0"><span class="toc-number">9.14.2.</span> <span class="toc-text">实现</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Git"><span class="toc-number">10.</span> <span class="toc-text">Git</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4"><span class="toc-number">10.1.</span> <span class="toc-text">常用命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE"><span class="toc-number">10.2.</span> <span class="toc-text">管理项目</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96"><span class="toc-number">10.3.</span> <span class="toc-text">项目优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8"><span class="toc-number">11.</span> <span class="toc-text">安全</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#XSS"><span class="toc-number">11.1.</span> <span class="toc-text">XSS</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E5%8C%96"><span class="toc-number">12.</span> <span class="toc-text">工程化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%8A%A5%E9%94%99%E4%BD%8D%E7%BD%AE"><span class="toc-number">12.1.</span> <span class="toc-text">代码报错位置</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&amp;refer=http%3A%2F%2Fwww.xuekebaba.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1652630370&amp;t=7aa679493e509726dbb151dd49072ebe')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AgoniLay</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz',
      appKey: 'k49y92c0BEE6zL2mCA2AUHKu',
      avatar: 'monsterid',
      serverURLs: 'https://fmlk1v2u.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>