<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>前端面试八股 | AgoniLay的博客</title><meta name="keywords" content="前端,面试"><meta name="author" content="AgoniLay"><meta name="copyright" content="AgoniLay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="HTTP 和 HTTPS基本概念 HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。  区别以及优缺点 HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTT">
<meta property="og:type" content="article">
<meta property="og:title" content="前端面试八股">
<meta property="og:url" content="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/index.html">
<meta property="og:site_name" content="AgoniLay的博客">
<meta property="og:description" content="HTTP 和 HTTPS基本概念 HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议； HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。  区别以及优缺点 HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTT">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://agonilay.github.io/img/meihao3.png">
<meta property="article:published_time" content="2022-04-11T07:34:22.000Z">
<meta property="article:modified_time" content="2022-04-14T06:46:19.538Z">
<meta property="article:author" content="AgoniLay">
<meta property="article:tag" content="前端">
<meta property="article:tag" content="面试">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://agonilay.github.io/img/meihao3.png"><link rel="shortcut icon" href="/img/zoro3.jpg"><link rel="canonical" href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?050530911bbf514fb098003dafd2a51e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '前端面试八股',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-14 14:46:19'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/zoro3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/meihao3.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AgoniLay的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">前端面试八股</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-04-11T07:34:22.000Z" title="发表于 2022-04-11 15:34:22">2022-04-11</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-14T06:46:19.538Z" title="更新于 2022-04-14 14:46:19">2022-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>34分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="前端面试八股"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul>
<li>HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议；</li>
<li>HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li>
</ul>
<h3 id="区别以及优缺点"><a href="#区别以及优缺点" class="headerlink" title="区别以及优缺点"></a>区别以及优缺点</h3><ul>
<li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTTP 协议安全，https 是具有安全性的 ssl 的加密传输协议，可以防止数据在传输过程中被窃取、改变，确保数据的完整性；</li>
<li>http 协议的默认端口是 80，https 是 443；</li>
<li>http 的连接比较简单，是无状态的；https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10% ~ 20% 的耗电；</li>
<li>https 缓存没有 http 高效，会增加数据开销；</li>
<li>https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高；</li>
<li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPv4 资源支持不了这种消耗；</li>
</ul>
<h3 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p>
<ol>
<li>客户端使用 https url 访问服务器，则要求 web 服务器<strong>建立 ssl 链接</strong>；</li>
<li>web 服务器接收到客户端的请求后，会<strong>将网站的证书（包含公钥）传输给客户端</strong>；</li>
<li>客户端和 web 服务器端开始<strong>协商 SSL 链接的安全等级</strong>，也就是加密等级；</li>
<li>客户端浏览器通过双方协商一致的安全等级，<strong>建立会话密钥</strong>，然后通过网站的公钥来加密会话密钥，并传送给网站；</li>
<li>web 服务器<strong>通过自己的私钥解密出会话密钥</strong>；</li>
<li>web 服务器<strong>通过会话密钥加密与客户端之间的通信</strong>。</li>
</ol>
<h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ol>
<li>第一次握手：建立连接时，客户端发送 <code>SYN</code> 包（SYN = j）到服务器，并进入 <code>SYN_SENT</code> 状态，等待服务器确认（SYN：同步序列编号，Synchronize Sequence Numbers）；</li>
<li>第二次握手：服务器收到 <code>SYN</code> 包并确认客户端的 <code>SYN</code>（ACK = j + 1），同时也发送一个自己的 <code>SYN</code> 包（SYN = k），即 SYN + ACK 包，此时服务器进入 <code>SYN_RECV</code>；</li>
<li>第三次握手：客户端收到服务器的 <code>SYN + ACK</code> 包，向服务器发送确认包 <code>ACK</code>（ACK = k + 1），此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（TCP 连接成功）状态，完成三次握手。</li>
</ol>
<blockquote>
<p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p>
</blockquote>
<h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol>
<li><strong>客户端进程发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN = 1，其序列号为 seq = u（的等于之前已经传送过来的数据的最后一个字节的序号加 1），此时，<strong>客户端进入 FIN-WAIT-1(终止等待 1)状态</strong>；</li>
<li><strong>服务器收到连接释放报文，发出确认报文</strong>，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，<strong>服务端就进入了 CLOSE-WAIT(关闭等待)状态</strong>；</li>
<li>客户端收到服务器的确认请求后，此时，<strong>客户端就进入 FIN-WAIT-2(终止等待 2)状态</strong>，等待服务器发送连接释放报文；</li>
<li><strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</strong>，FIN = 1，ack = u + 1，由于在半关闭状态，服务器可能又发送了一部分数据，此时的序列号是 seq = w，此时，<strong>服务器就进入了 LAST-ACK(最后确认)状态</strong>，等待客户端的确认；</li>
<li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong>，ACK = 1，ack = w + 1，自己的序列号是 seq = u + 1，此时，<strong>客户端就进入了 TIME-WAIT(时间等待)状态</strong>，此时 TCP 连接还没有释放，必须经过 2**MSL(最长报文段寿命)的时间后，<strong>当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>；</li>
<li>服务器只要收到了客户端发出的确认，<strong>立即进入 CLOSED 状态</strong>。同样，撤销 TCB 后，就结束了这次的 TCP 连接，服务器结束 TCP 连接要比客户端稍早一些。</li>
</ol>
<h3 id="保证数据包传输的有序可靠"><a href="#保证数据包传输的有序可靠" class="headerlink" title="保证数据包传输的有序可靠"></a>保证数据包传输的有序可靠</h3><p>对字节流分段并进行编号然后 <code>通过 ACK 回复</code> 和 <code>超时重发</code> 两个机制来保证：</p>
<ul>
<li>为了保证数据包的可靠传递，发送方必须把已发送的数据包留在缓存区；</li>
<li>并为每个已发送的数据包启动一个超时定时器；</li>
<li>如在定时器超时之前收到了对方的应答信息，则释放改数据包占用的缓冲区；</li>
<li>否则，重传改数据包，直到收到应答或重传次数超过规定的最大次数为止；</li>
<li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已接收到，如果接收方正好也有数据要发，则应答包可以放在数据包中稍带过去。</li>
</ul>
<h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol>
<li>TCP 是面向<strong>链接</strong>的，而 UDP 是面向无连接的；</li>
<li>TCP 仅支持 <strong>单播传输</strong>，UDP 提供了单播，多播，广播的功能；</li>
<li>TCP 的三次握手保证了连接的<strong>可靠性</strong>；UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收；</li>
<li>UDP 的<strong>头部开销</strong>比 TCP 的更小，数据<strong>传输速率更高，实时性更好</strong>。</li>
</ol>
<h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><h4 id="跨域的原理"><a href="#跨域的原理" class="headerlink" title="跨域的原理"></a>跨域的原理</h4><p>跨域，是指浏览器不能执行其他网址的脚本，是由浏览器的同源策略造成的；</p>
<p>同源策略，是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，就被当作是不同的域；</p>
<p>跨域原理，即通过各种方式，避开浏览器的安全限制。</p>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>JSONP：</p>
<p>ajax 受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，从而实现跨域。</p>
<ol>
<li>去创建一个 script 标签</li>
<li>script 的 src 属性设置接口地址</li>
<li>接口参数必须要携带一个自定义函数名，否则后台无法返回数据</li>
<li>通过定义函数名去接受返回的数据</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/?callback=getData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 srcipt 生效</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure>

<p>缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求；JSONP 需要后端配合返回指定格式的数据。</p>
<p>document.domain：</p>
<p>基本域名相同 子域名不同</p>
<p>window.name：</p>
<p>利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p>
<p>CORS：</p>
<p>CORS（Cross-origin resourse sharing）跨域资源共享服务器设置对 CORS 的支持原理：服务器设置 Accesss-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求。</p>
<p>proxy 代理：</p>
<p>目前常用的方式，通过服务器设置代理</p>
<p>window.postMessage()：</p>
<p>利用 H5 新特性 <code>window.postMessage()</code></p>
<h2 id="Cookie-sessionStorage-localStorage"><a href="#Cookie-sessionStorage-localStorage" class="headerlink" title="Cookie sessionStorage localStorage"></a>Cookie sessionStorage localStorage</h2><p>相同点：</p>
<ul>
<li>均存储在客户端</li>
</ul>
<p>不同点：</p>
<ul>
<li>cookie 数据大小不能超过 4K；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+；</li>
<li>cookie 的设置的过期时间之前一直有效；localStorage 永久储存，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；</li>
<li>cookie 的数据会自动传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li>
</ul>
<h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接受缓冲区看，后一包数据的头紧接着前一包数据的尾。</p>
<h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>在流传输中出现，UDP 不会出现粘包，因为它有消息边界。</p>
<p>粘包情况有两种，一种是 <strong>粘在一起的包都是完整的数据包</strong>，另一种是 <strong>粘在一起的包有不完整的包</strong>。</p>
<h3 id="避免措施"><a href="#避免措施" class="headerlink" title="避免措施"></a>避免措施</h3><ol>
<li>对于发送方引起的粘包现象，用户可以通过编程设置来避免，<strong>TCP 提供了强制数据立即传送的操作指令 push</strong>，TCP 软件收到改操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<ul>
<li>虽然可以避免发送方引起的粘包，但关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用</li>
</ul>
</li>
<li>对于接收方引起的粘包现象，则可通过优化程序设计、精简接收进程工作量、<strong>提高接收进程优先级</strong>等措施，使其即使接收数据，从而尽量避免出现粘包现象；<ul>
<li>只能减少出现粘包的可能性，并不能完全避免粘包</li>
</ul>
</li>
<li>由接收方控制，将一包数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>分包多发</strong>。<ul>
<li>虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li>
</ul>
</li>
</ol>
<blockquote>
<p>周全的对策：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开，高效可行。</p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="输入-URL-到页面加载"><a href="#输入-URL-到页面加载" class="headerlink" title="输入 URL 到页面加载"></a>输入 URL 到页面加载</h3><ol>
<li>在浏览器地址栏输入 URL；</li>
<li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则直接显示页面内容，如果没有则进行下一步；<ul>
<li>浏览器缓存：浏览器会记录 DNS 一段时间；</li>
<li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的 DNS 查询缓存）；</li>
<li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续 搜索路由器缓存；</li>
<li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li>
</ul>
</li>
<li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址，<strong>DNS 服务器是基于 UDP 的，因此会用到 UDP 协议</strong>；</li>
<li>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接；</li>
<li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该 i 请求作为 TCP 三次握手的第三次数据发送给服务器；</li>
<li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给服务器</li>
<li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li>
<li>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后进行解析：<ul>
<li>构建 DOM 树：词法分析然后解析成 DOM 树，是由 DOM 元素及属性节点组成，树的根是 document 对象；</li>
<li>构建 CSS 规则树：生成 CSS 规则树（CSSOM）；</li>
<li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，病候检出渲染树（render tree）；</li>
<li>布局（Layout）：计算出每个节点在屏幕中的位置；</li>
<li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li>
</ul>
</li>
<li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码：<ul>
<li>创建 window 对象：window 对象也叫全局变量环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，DOM 树也会映射在 window 的 document 对象上；当关闭网页或者浏览器时，全局执行环境会被销毁；</li>
<li>加载文件：JS 引擎分析它的语法和词法是否合法，合法则进入预编译；</li>
<li>预编译：浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并赋值为 <code>undefined</code>；寻找全局函数声明，作为 window 的方法加入到 window 对象中，将函数体赋值给它（匿名函数是不参与预编译的，它是变量）；</li>
<li>解释执行：执行到变量就赋值，若变量未定义，在 ES5 严格模式下此变量会变成 window 的一个属性，也就是成为全局变量；函数执行，就将函数的环境推入一个环境的栈中，执行完成后弹出，交回控制权；</li>
</ul>
</li>
</ol>
<h3 id="重绘与重排"><a href="#重绘与重排" class="headerlink" title="重绘与重排"></a>重绘与重排</h3><ul>
<li>重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，即重排；表现为重新生成布局，重新排列元素；</li>
<li>重绘（Repaint）：当一个元素的外观发生改变，但没有影响布局，重新把元素外观绘制出来的过程，叫重绘；表现为元素的外观被改变。</li>
</ul>
<blockquote>
<p>重绘不一定会出现重排，但重排一定会重绘！</p>
</blockquote>
<p>重排和重绘的代价是高昂的，会破坏用户体验，让 UI 展示非常迟缓，相比之下重排的性能影响更大，两者无法避免的情况下一般选择代价更小的重绘。</p>
<h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul>
<li>添加、删除、更新 DOM 节点；</li>
<li>通过 <code>display: none</code> 隐藏一个 DOM 节点，触发重排和重绘；</li>
<li>通过 <code>visibility: hidden</code> 隐藏一个 DOM 节点，只触发重绘；</li>
<li>移动或者给页面中的 DOM 节点添加动画；</li>
<li>添加一个样式表，调整样式属性；</li>
<li>用户行为：调整窗口大小、改变字号、滚动等。</li>
</ul>
<h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ol>
<li><p><strong>集中改变样式</strong>，不要一条一条多次修改 DOM 中的样式；</p>
</li>
<li><p>不要把 DOM 节点的属性放在循环里当成循环里的变量；</p>
</li>
<li><p>为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会触发整个页面的 reflow 的；</p>
</li>
<li><p>不要使用 table 布局，很小的改动会造成整个 table 的重新布局；</p>
</li>
<li><p>尽量只修改 <code>position: absolute</code> 或 <code>fixed</code> 的元素，影响较小；</p>
</li>
<li><p>动画开启 GPU 加速，translate 使用 3D 变化；</p>
</li>
<li><p>提升为合成层：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他层；</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<p>提升合成层的最好方式是使用 CSS 的 <code>will-change</code> 属性：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="304"><a href="#304" class="headerlink" title="304"></a>304</h3><ul>
<li>浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍返回 200，但不会请求数据；</li>
<li>强缓存失效，进入协商缓存阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化，服务器根据客户端上送的 If-No 该资源的最后 ne-Match 值来判断是否命中缓存；</li>
<li>协商缓存 LastModify/If-Modify-Since 阶段，客户端第一次请求资源时，服务器返回的 header 中会加上 Last-Modify，Last-Modify 标识该资源的最后修改时间，再次请求该资源时，request 的请求头中会包含 If-Modify-Since，为缓存之前返回的 Last-Modify，服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li>
</ul>
<h3 id="强制缓存-协商缓存"><a href="#强制缓存-协商缓存" class="headerlink" title="强制缓存 协商缓存"></a>强制缓存 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 - 服务器响应该请求。</p>
<p>浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p>
<img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220412153039501.png" class title="第一次发起 HTTP 请求">

<ul>
<li>浏览器每次发起请求，都会<strong>先在浏览器缓存中查找该请求的结果以及缓存标识</strong>；</li>
<li>浏览器每次拿到返回的请求结果都会<strong>将该结果和缓存标识存入浏览器缓存中</strong>。</li>
</ul>
<p>强制缓存：</p>
<p>就是<strong>向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 Cache-Control 优先级更高。</p>
<p>强制缓存的情况主要有三种：</p>
<ol>
<li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（与首次发请求一致）；</li>
<li>存在该缓存结果和缓存标识，但已失效，强制缓存失效，则使用协商缓存；</li>
<li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li>
</ol>
<p>协商缓存：</p>
<p>就是<strong>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，字段包括：<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>，其中 Etag/If-None-Match 的优先级更高。</p>
<p>情况有两种：</p>
<ol>
<li>协商缓存生效，返回 304；</li>
<li>协商缓存失效，返回 200 和请求结果。</li>
</ol>
<h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h3><p>进程：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p>
<p>线程：是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。</p>
<ul>
<li>一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成；</li>
<li>进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</li>
</ul>
<p>协程（Coroutines）：是一种基于线程之上，但又比线程更加轻量级的存在。</p>
<p>进程和线程的区别：</p>
<ol>
<li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li>
<li>并发性：进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行；</li>
<li>拥有资源：进程拥有资源，线程不拥有系统资源，但可以访问隶属于进程的资源；</li>
<li>系统开销：创建或撤销进程比线程的开销大，因为系统都要为之分配和回收资源；多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差；</li>
</ol>
<p>联系：</p>
<ul>
<li>一个线程只能属于一个进程，而一个进程可以有一个或多个线程；</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li>
<li>处理机分给线程，即真正在处理机上运行的是线程；</li>
<li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li>
</ul>
<h2 id="HTML-CSS"><a href="#HTML-CSS" class="headerlink" title="HTML CSS"></a>HTML CSS</h2><h3 id="HTML5-语义化"><a href="#HTML5-语义化" class="headerlink" title="HTML5 语义化"></a>HTML5 语义化</h3><p>HTML5 的语义化指的是<strong>合理正确的使用语义化的标签来创建页面结构</strong>。</p>
<p>语义化标签包括：</p>
<ul>
<li>header、nav、main、article、section、aside、footer</li>
</ul>
<p>优点：</p>
<ul>
<li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果；</li>
<li>代码结构清晰，易于阅读；</li>
<li>利于开发和维护，方便其他设备解析（如屏幕阅读器），根据语义渲染网页；</li>
<li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。</li>
</ul>
<h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>id 选择器 <code>#</code>、类选择器 <code>.</code>、属性选择器 <code>[a=&quot;b&quot;]</code>、伪类选择器 <code>:</code>、标签选择器 <code>div h1...</code>、相邻选择器 <code>+</code>、子选择器 <code>&gt;</code>、后代选择器 <code>(空格)</code>、通配符选择器 <code>*</code>。</p>
<h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul>
<li><code>!important</code></li>
<li>内联样式（1000）</li>
<li>ID 选择器（0100）</li>
<li>类选择器/属性选择器/伪类选择器（0010）</li>
<li>元素选择器/伪元素选择器（0001）</li>
<li>关系选择器/通配符选择器（0000）</li>
</ul>
<p>带 important 标记的样式属性优先级最高；样式表的来源相同时：</p>
<p><code>!important</code> &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</p>
<h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p><strong>固定定位 fixed</strong>：元素的位置相对于浏览器窗口是固定位置，即使窗口滚动也不会移动；fixed 定位使元素的位置与文档流无关，因此不占据空间，fixed 定位的元素和其他元素重叠；</p>
<p><strong>相对定位 relative</strong>：如果一个元素相对定位，它将依旧出现在所在的位置上，可以通过设置垂直水平距离让此元素相对于原先的位置进行移动，但元素仍占据原先的空间，会覆盖其他元素；</p>
<p><strong>绝对定位 absolute</strong>：绝对定位的元素的位置相对于最近的已定位父元素，若无已定位的父元素，则位置相对于 body，absolute 定位使元素的位置与文档流无关，因此不占据空间，absolute 定位的元素和其他元素重叠；</p>
<p><strong>粘性定位 sticky</strong>：元素先按照普通文档流定位，相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位，在跨越特定阈值前为相对定位，之后为固定定位；</p>
<p><strong>默认定位 static</strong>：默认值。没有定位，元素出现在正常的流中，忽略 top、bottom、left、right 以及 z-index 声明。</p>
<p>也可以设置为 <code>inherit</code>：来从父元素继承 position 属性的值。</p>
<h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>box-sizing 规定两个并排的带边框的框：</p>
<ul>
<li><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框【标准盒模型】；</li>
<li><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒【IE 盒模型/怪异盒模型】；</li>
<li>inherit：继承父元素的 box-sizing 值</li>
</ul>
<h3 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h3><p>CSS 盒模型本质上是一个盒子，包括：边距、边框、填充盒实际内容；CSS 中的盒模型包括 IE 盒模型和标准 W3C 盒模型。</p>
<ul>
<li>在标准的盒模型中，width 指 <code>content</code> 部分的宽度；</li>
<li>在 IE 盒模型中，width 表示 <code>content + padding + border</code> 三个部分的宽度。</li>
</ul>
<p>总宽度都是 <code>width + margin(左右)</code>，高度同理。</p>
<h3 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>BFC（Block Formatting Context），块级格式上下文，是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有：</p>
<ul>
<li>内部 box 垂直放置；</li>
<li>计算 BFC 的高度的时候，浮动元素也参与计算。</li>
</ul>
<h4 id="原理布局规则"><a href="#原理布局规则" class="headerlink" title="原理布局规则"></a>原理布局规则</h4><ul>
<li>内部的 Box 会在垂直方向，一个一个的放置；</li>
<li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；</li>
<li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于默认的从左往右排列的格式）；</li>
<li>BFC 的区域不会与 float box 重叠；</li>
<li>BFC 是一个独立容器，容器里的子元素不会影响到外面的元素；</li>
<li>计算 BFC 高度时，浮动元素也参与计算；</li>
<li>元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box 会参与不同的 <code>Formatting Context</code>。</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul>
<li>根元素，即 HTML 元素</li>
<li>float 的值不为 none</li>
<li>position 为 absolute 或 fixed</li>
<li>display 的值为 inline-block、table-cell、table-caption</li>
<li>overflow 的值不为 visible</li>
</ul>
<h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul>
<li>去除边距重叠现象；</li>
<li>清除浮动（让父元素的高度包含子浮动元素）；</li>
<li>避免某元素被浮动元素覆盖；</li>
<li>避免多列布局由于宽度计算四舍五入而自动换行。</li>
</ul>
<h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul>
<li>对于行内元素：<code>text-align: center;</code></li>
<li>对于确定宽度的块级元素：<ul>
<li><code>margin: 0 auto;</code></li>
<li><code>position: absolute; margin-left: (父width - 子width) / 2;</code>，需要父元素 <code>position: relative;</code></li>
</ul>
</li>
<li>对于宽度未知的块级元素：<ul>
<li><code>display: table; margin: 0 auto;</code></li>
<li><code>display: inline-block; text-align: center;</code></li>
<li><code>position: absolute; left: 50%; transform: translateX(-50%);</code></li>
<li><code>display: flex; justify-content: center;</code></li>
</ul>
</li>
</ul>
<h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol>
<li><code>inline-height: height;</code> 适合纯文字类；</li>
<li>通过设置父容器相对定位，子元素设置绝对定位，标签通过 margin 实现自适应居中；</li>
<li>弹性布局 flex：父级设置 <code>display: flex;</code>，子级设置 margin 为 auto 实现自适应居中；</li>
<li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现；</li>
<li>利用 table 布局，子级设置 <code>vertical-align: middle;</code>，使用的前提条件：内联元素以及 display 值为 table-cell 的元素</li>
</ol>
<h3 id="隐藏页面中元素"><a href="#隐藏页面中元素" class="headerlink" title="隐藏页面中元素"></a>隐藏页面中元素</h3><ol>
<li><code>opacity: 0</code>，元素变透明，即隐藏，不会改变页面布局，且绑定的一些事件仍然可以触发（如点击事件）；</li>
<li><code>visibility: hidden</code>，同样不会改变页面布局，但无法触发已绑定的事件，隐藏对应元素，在文档布局中仍保留原来的空间；</li>
<li><code>display: none</code>，会改变页面布局，在文档布局中不再分配空间（重排重绘）</li>
</ol>
<h3 id="用-CSS-画三角"><a href="#用-CSS-画三角" class="headerlink" title="用 CSS 画三角"></a>用 CSS 画三角</h3><p><strong>盒子宽高均为零，三面边框均透明</strong>。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid pink;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒模型提供最大的灵活性，指定 <code>display: flex</code> 即可。</p>
<p>容器属性：</p>
<ul>
<li>flex-direction：决定主轴的方向(即子 item 的排列方法)，取值：<ul>
<li>row | row-reverse | column | column-reverse</li>
</ul>
</li>
<li>flex-wrap：决定换行规则，取值：<ul>
<li>nowrap | wrap | wrap-reverse</li>
</ul>
</li>
<li>flex-flow：flex-direction 和 flex-wrap 的简写形式；</li>
<li>justify-content：水平主轴对齐方式；</li>
<li>align-items：竖直轴线方向对齐方式；</li>
<li>align-content：元素排列大于一行时 align-items 需换成 align-content；</li>
</ul>
<p>元素属性：</p>
<ul>
<li>order：定义项目的排列顺序，默认为 0，越小越靠前；</li>
<li>flex-grow：定义项目的放大比例，即使存在空间，也不会放大；</li>
<li>flex-shrink：定义项目的缩小比例，当空间不足的情况下会等比例的缩小，0 为不缩小；</li>
<li>flex-basis：定义了在分配多余的空间项目所占的空间；</li>
<li>flex：flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 <code>0 1 auto</code>；</li>
<li>align-self：允许单个项目于其他项目不同的对齐方式，可覆盖；</li>
<li>align-items：默认值为 auto，表示继承父元素的 align-items 值。</li>
</ul>
<h4 id="Rem-布局"><a href="#Rem-布局" class="headerlink" title="Rem 布局"></a>Rem 布局</h4><p>Rem 相对于根（html）的 font-size 大小来计算，就是一个相对比例（如：<code>font-size: 10px</code>，那么），rem 布局的本质是等比缩放，一般是基于宽度。</p>
<p>优点：可以快速使用移动端布局，字体，图片高度；</p>
<p>缺点：</p>
<ol>
<li>目前 IE 不支持，对 pc 页面来讲使用次数不多；</li>
<li>数据量大：所有的图片、盒子都需要给一个准确的值，才能保证不同机型的适配；</li>
<li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小，且必须将改变 font-size 的代码放在 css 样式之前。</li>
</ol>
<h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>通过百分比单位 <code>%</code> 来实现响应式的效果，可以使得浏览器中的组件的宽高随着浏览器的变化而变化。</p>
<ul>
<li>height 相对于 height；</li>
<li>width 相对于 width；</li>
<li>padding、bording、margin 等不论是垂直还是水平方向都相对于直接父元素的 width；</li>
<li>除了 border-radius 外，translate、background-szie 等都相对于自身。</li>
</ul>
<p>缺点：计算困难，可能使布局问题复杂</p>
<h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当元素浮动以后可以向左或向右移动，直到它的边缘碰到包含它的框或者另外一个浮动元素的边框为止；元素浮动后会脱离正常的文档流，所以文档的普通流中的框就会变得好像浮动元素不存在一样。</p>
<p>优点：</p>
<ul>
<li>在图文混排的时候可以很好的实现文字环绕图片；</li>
<li>当元素浮动起来后，它有着块级元素的一些性质，如设置宽高；</li>
</ul>
<p>缺点：会造成父级元素高度塌陷，需要进行清除浮动。</p>
<h3 id="使用-rem-或-viewport-进行移动端适配"><a href="#使用-rem-或-viewport-进行移动端适配" class="headerlink" title="使用 rem 或 viewport 进行移动端适配"></a>使用 rem 或 viewport 进行移动端适配</h3><h4 id="rem-适配原理"><a href="#rem-适配原理" class="headerlink" title="rem 适配原理"></a>rem 适配原理</h4><p>改变了一个元素在不同设备上占据的 css 像素的个数。</p>
<p>优点：没有破坏完美视口</p>
<p>缺点：px 转换 rem 较为复杂</p>
<h4 id="viewport-适配原理"><a href="#viewport-适配原理" class="headerlink" title="viewport 适配原理"></a>viewport 适配原理</h4><p>每一个元素在不同设备上占据的 css 像素的个数是一样的，但 css 像素和物理像素的比例是不一样的。</p>
<p>优点：在设计图上所取量的大小即为可以设置的像素大小（所量及所设）</p>
<p>缺点：破坏完美视口</p>
<h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol>
<li><p>添加额外标签：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加额外标签并添加 clear 属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以添加一个 br 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li><p>父级添加 overflow 属性，或者设置高度；</p>
</li>
<li><p>建立伪类选择器清除浮动：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 css 中添加 :after 伪元素 */</span></span><br><span class="line"><span class="selector-class">.parent</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="JS-TS-ES6"><a href="#JS-TS-ES6" class="headerlink" title="JS TS ES6"></a>JS TS ES6</h2><h3 id="JS-的-8-种数据类型"><a href="#JS-的-8-种数据类型" class="headerlink" title="JS 的 8 种数据类型"></a>JS 的 8 种数据类型</h3><p>包含值类型(基本对象类型)和引用类型(复杂对象类型)</p>
<p>基本类型：在内存中占据固定大小，保存在栈内存中</p>
<ul>
<li>Number（数字类型）</li>
<li>String（字符串类型）</li>
<li>Boolean（布尔类型）</li>
<li>null（空）</li>
<li>undefined（未定义）</li>
<li>Symbol（符号类型，ES6）</li>
<li>bigInt（ES10）</li>
</ul>
<p>引用类型：引用类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址</p>
<ul>
<li>Object（对象）</li>
<li>Function（函数）</li>
<li>Array（数组）</li>
<li>Date（日期）</li>
<li>RegExp（正则表达式）</li>
<li>特殊的包装类型：String、Number、Boolean</li>
<li>单体内置对象：Global、Math 等</li>
</ul>
<h4 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h4><p>Symbol 指的是独一无二的值，每个通过 <code>Symbol()</code> 生成的值都是唯一的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var_symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> other_symbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(var_symbol === other_symbol); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> var_symbol); <span class="comment">// symbol</span></span><br><span class="line"><span class="built_in">console</span>.log(var_symbol.constructor === <span class="built_in">Symbol</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>可以用 <code>Symbol.for(key)</code> 创建相等的变量：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> other_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(var_symbol === other_symbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>Symbol.for(key)</code> 会根据给定的建 key(字符串)，来存运行时的 symbol 注册表中找到对应的 symbol，如找到则返回，未找到则新建一个与该键相关联的 symbol 返回，并放入全局 symbol 注册表中。</p>
<p>应用场景：</p>
<ol>
<li>使用 Symbol 来作为对象属性名（key）</li>
<li>使用 Symbol 来替代常量</li>
<li>使用 Symbol 定义类的私有属性/方法</li>
</ol>
<h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种数字类型的数据，可以表示任意精度格式的整数。</p>
<p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 <code>Infinity/-Infinity</code>:</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>

<p>ES10 引入了一种新的数据类型 BigInt 来解决这个问题，只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，为了与 Number 进行区分，BigInt 类型的数据必须添加后缀 <code>n</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>; <span class="comment">// 普通 Number</span></span><br><span class="line"><span class="number">12n</span>; <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span>; <span class="comment">// 3n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Number 类型进行运算</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>; <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<p>BigInt 与普通整数时两种值，它们之间并不相等：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12n</span> === <span class="number">12</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于 BigInt 与 Number 完全属于两种类型，并且不会进行隐式转换，所以没有办法进行混合运算。想要运算的话，必须将两种数据类型转换为同一种后，方可进行计算：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(number);</span><br><span class="line"><span class="built_in">Number</span>(bigint);</span><br></pre></td></tr></table></figure>

<p>typeof 运算符对于 BigInt 类型的数据返回 <code>bigint</code> 字符串；BigInt 并不是一个构造函数，不能使用 new 来创建实例；创建一个 BigInt 时，参数必须为整数，否则会报错：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12n</span>; <span class="comment">// &#x27;bigint&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">BigInt</span>(); <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="number">1.2</span>); <span class="comment">// Uncaught RangeError</span></span><br></pre></td></tr></table></figure>

<h3 id="数据类型检测方案"><a href="#数据类型检测方案" class="headerlink" title="数据类型检测方案"></a>数据类型检测方案</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>; <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>; <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&quot;mc&quot;</span>; <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log(); <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> []; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>; <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>; <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>优点：可以快速区分基本数据类型</p>
<p>缺点：无法区分 Object、Array 和 null，均返回 object</p>
<h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>                <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>            <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            <span class="comment">// false</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>                <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>               <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>优点：能够区分 Array、Object 和 Function，适用于判断自定义的类实例对象</p>
<p>缺点：不能判断 NUmber、Boolean、String 基本数据类型</p>
<h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">toString.call(<span class="number">1</span>); <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="literal">true</span>); <span class="comment">// [object Boolean]</span></span><br><span class="line">toString.call(<span class="string">&quot;mc&quot;</span>); <span class="comment">// [object String]</span></span><br><span class="line">toString.call([]); <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;); <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;); <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>); <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>); <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure>

<p>优点：精准判断数据类型</p>
<p>缺点：较前两种方法写法较为繁琐不易于记忆，可以进行封装后使用</p>
<h4 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h4><p>ES6 之前创建变量使用 var，之后创建变量用的是 let/const</p>
<p>区别：</p>
<ol>
<li><p>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问；<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；<br>const 用来定义常量，使用时必须初始化（即创建时必须赋值），只能在块作用域里访问，且不能修改；</p>
</li>
<li><p>var 可以先使用，后声明，因为存在变量提升，let/const 必须先声明后使用；</p>
</li>
<li><p>var 允许在相同作用域内重复声明同一个变量，但 let/const 不允许；</p>
</li>
<li><p>在全局上下文中，基于 let 声明的全局变量与全局对象（window）没有任何关系，var 声明的会有映射关系；</p>
</li>
<li><p>会产生暂时性死区：</p>
<p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，而会返回 undefined</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a;</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b); <span class="comment">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">let</span> b;</span><br></pre></td></tr></table></figure></li>
<li><p>let/const/function 会把当前所在的大括号（除函数之外）作为一个全新的块级上下文。</p>
</li>
</ol>
<h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><p>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢；当某些代码操作不能被合理释放，就会造成内存泄漏。</p>
<p>浏览器垃圾回收机制/内存回收机制：</p>
<ol>
<li>标记清除</li>
<li>谷歌浏览器：查找引用</li>
<li>IE 浏览器：引用计数法</li>
</ol>
<p>优化手段：</p>
<ol>
<li>堆内存：fn = null【null：空指针对象】</li>
<li>栈内存：将上下文中被外部占用的堆取消掉即可</li>
</ol>
<p>内存泄漏：</p>
<ul>
<li>全局变量</li>
<li>闭包</li>
<li>DOM 元素的引用</li>
<li>定时器</li>
</ul>
<h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域 -&gt; 当前创建函数所处的上下文。如果是在全局下创建的函数就是 <code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文 <code>EC(FN)</code>，供字符串代码执行（进栈执行）。</p>
<p>定义：作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成</p>
<ol>
<li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域；</li>
<li>函数作用域：在固定的代码片段才能被访问</li>
</ol>
<p>作用：作用域的最大用处就是 <strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p>
<p>一般情况下，变量到创建该变量的函数的作用域中取值。但如果没有查询到，就会向上级作用域去查，直到查到全局作用域，这一个查找过程所构成的链条就叫做作用域链。</p>
<h3 id="闭包：保存-保护"><a href="#闭包：保存-保护" class="headerlink" title="闭包：保存/保护"></a>闭包：保存/保护</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数执行时形成的私有上下文 <code>EC(FN)</code>，正常情况下，代码执行完会出栈然后释放；但是特殊情况下，如果当前私有上下文中的数据被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不会被销毁的上下文。</p>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol>
<li>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰；</li>
<li>保存：如果当前上下文不被释放，则存储的私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</li>
</ol>
<p>把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。</p>
<blockquote>
<p>闭包是指有权访问另一个函数作用域中的变量的函数。</p>
</blockquote>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol>
<li>内部函数可以访问定义它们外部函数的参数和变量，设计私有的方法和变量，避免全局变量的污染；</li>
<li>函数嵌套函数；</li>
<li>本质是将函数内部和外部连接起来，优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除。</li>
</ol>
<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol>
<li>模仿块级作用域</li>
<li>保护外部函数的变量，能够访问函数定义时所在的词法作用域（阻止其被回收）</li>
<li>封装私有化变量</li>
<li>创建模块</li>
</ol>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>会导致函数的变量一致保存在内存中，过多的闭包会导致内存泄漏。</p>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol>
<li>作为普通函数执行时，<code>this</code> 指向 <code>window</code>；</li>
<li>当函数作为对象的方法被调用时，<code>this</code> 就会指向该对象；</li>
<li>构造器调用，this 指向返回的这个对象；</li>
<li>箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象，如果有嵌套的情况，则 this 绑定到最近的一层对象上；</li>
<li>基于 Function.prototype 上的 apply、call 和 bind 调用模式，可以显示指定调用函数的 this 指向。</li>
</ol>
<h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h3><p>原型关系：</p>
<ul>
<li>每个 class 都有显示原型 prototype</li>
<li>每个实例都有隐式原型 __proto__</li>
<li>实例的 __proto__ 指向对应 class 的 prototype</li>
</ul>
<p>原型：在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code> 属性，这个属性指向函数的原型对象。</p>
<p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 __proto**，该指针是指向上一层的原型对象，而上一层的原型对象的结构以此类推。因此可以利用 <code>**proto**</code>一直指向 Object 的原型对象上，而 Object 的原型对象用<code>Object.prototype.**proto\_\_ = null</code> 表示原型链顶端，如此形成了 js 的原型链继承；</p>
<p>特点：JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。</p>
<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol>
<li>创建一个空的新对象；</li>
<li>设置原型，将对象的原型设置为函数的 <code>prototype</code> 对象；</li>
<li>让函数的 this 指向这个对象，执行构造函数的代码（添加属性）；</li>
<li>判断函数的返回类型，若是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象；</li>
</ol>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>JS 是单线程的，为了防止一个函数执行时间过长而阻塞后面的代码，所以会先将同步代码压入执行栈中，一次执行，将异步代码突入异步队列，异步队列又分为宏任务队列和微任务队列，微任务队列优先于宏任务队列。</p>
<p>JS 运行的环境一般为浏览器或者 Node，在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p>
<h4 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h4><p>先执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后取宏任务清微任务不停循环。</p>
<p>EventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p>
<ol>
<li>函数入栈，当 Stack 中执行到异步任务时，就将它丢给 WebAPIs，接着执行同步任务，直到 Stack 为空；</li>
<li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行；</li>
<li>执行栈为空时</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AgoniLay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/">https://agonilay.github.io/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://agonilay.github.io" target="_blank">AgoniLay的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/img/meihao3.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2022/01/10/Sass/"><img class="next-cover" src="https://img0.baidu.com/it/u=2134113155,1156622243&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=780&amp;h=484" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Sass</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/" title="前端面试复习"><img class="cover" src="/img/meihao3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端面试复习</div></div></a></div><div><a href="/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/" title="NodeJS 黑马笔记"><img class="cover" src="https://img2.baidu.com/it/u=2903413025,1209967719&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-11</div><div class="title">NodeJS 黑马笔记</div></div></a></div><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/" title="前端综合笔记"><img class="cover" src="/img/meihao3.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端综合笔记</div></div></a></div><div><a href="/2021/07/30/ES8%E7%AC%94%E8%AE%B0/" title="ES8笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES8笔记</div></div></a></div><div><a href="/2021/07/30/ES7%E7%AC%94%E8%AE%B0/" title="ES7笔记"><img class="cover" src="https://img1.baidu.com/it/u=3836703405,2855810575&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES7笔记</div></div></a></div><div><a href="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/" title="ES6笔记"><img class="cover" src="https://img1.baidu.com/it/u=310238766,3824396698&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-07-30</div><div class="title">ES6笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#HTTP-%E5%92%8C-HTTPS"><span class="toc-number">1.</span> <span class="toc-text">HTTP 和 HTTPS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">1.2.</span> <span class="toc-text">区别以及优缺点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTPS-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.3.</span> <span class="toc-text">HTTPS 工作原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TCP-IP"><span class="toc-number">2.</span> <span class="toc-text">TCP&#x2F;IP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B"><span class="toc-number">2.1.</span> <span class="toc-text">TCP 三次握手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">2.2.</span> <span class="toc-text">TCP 四次挥手</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E5%8C%85%E4%BC%A0%E8%BE%93%E7%9A%84%E6%9C%89%E5%BA%8F%E5%8F%AF%E9%9D%A0"><span class="toc-number">2.3.</span> <span class="toc-text">保证数据包传输的有序可靠</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-%E5%92%8C-UDP-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.4.</span> <span class="toc-text">TCP 和 UDP 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP-%E8%AF%B7%E6%B1%82%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98"><span class="toc-number">2.5.</span> <span class="toc-text">HTTP 请求跨域问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.1.</span> <span class="toc-text">跨域的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">2.5.2.</span> <span class="toc-text">解决方案</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie-sessionStorage-localStorage"><span class="toc-number">3.</span> <span class="toc-text">Cookie sessionStorage localStorage</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B2%98%E5%8C%85%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90%E4%B8%8E%E5%AF%B9%E7%AD%96"><span class="toc-number">4.</span> <span class="toc-text">粘包问题分析与对策</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BA%E7%8E%B0%E5%8E%9F%E5%9B%A0"><span class="toc-number">4.1.</span> <span class="toc-text">出现原因</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%8E%AA%E6%96%BD"><span class="toc-number">4.2.</span> <span class="toc-text">避免措施</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8"><span class="toc-number">5.</span> <span class="toc-text">浏览器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD"><span class="toc-number">5.1.</span> <span class="toc-text">输入 URL 到页面加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E7%BB%98%E4%B8%8E%E9%87%8D%E6%8E%92"><span class="toc-number">5.2.</span> <span class="toc-text">重绘与重排</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6"><span class="toc-number">5.2.1.</span> <span class="toc-text">触发条件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%81%BF%E5%85%8D"><span class="toc-number">5.2.2.</span> <span class="toc-text">避免</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#304"><span class="toc-number">5.3.</span> <span class="toc-text">304</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%BA%E5%88%B6%E7%BC%93%E5%AD%98-%E5%8D%8F%E5%95%86%E7%BC%93%E5%AD%98"><span class="toc-number">5.4.</span> <span class="toc-text">强制缓存 协商缓存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B-%E7%BA%BF%E7%A8%8B-%E5%8D%8F%E7%A8%8B"><span class="toc-number">5.5.</span> <span class="toc-text">进程 线程 协程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HTML-CSS"><span class="toc-number">6.</span> <span class="toc-text">HTML CSS</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5-%E8%AF%AD%E4%B9%89%E5%8C%96"><span class="toc-number">6.1.</span> <span class="toc-text">HTML5 语义化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E9%80%89%E6%8B%A9%E5%99%A8%E5%8F%8A%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.2.</span> <span class="toc-text">CSS 选择器及优先级</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A7%8D%E7%B1%BB"><span class="toc-number">6.2.1.</span> <span class="toc-text">种类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">6.2.2.</span> <span class="toc-text">优先级</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#position"><span class="toc-number">6.3.</span> <span class="toc-text">position</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#box-sizing"><span class="toc-number">6.4.</span> <span class="toc-text">box-sizing</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B"><span class="toc-number">6.5.</span> <span class="toc-text">CSS 盒模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BFC-%E5%9D%97%E7%BA%A7%E6%A0%BC%E5%BC%8F%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">6.6.</span> <span class="toc-text">BFC(块级格式上下文)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">6.6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8E%9F%E7%90%86%E5%B8%83%E5%B1%80%E8%A7%84%E5%88%99"><span class="toc-number">6.6.2.</span> <span class="toc-text">原理布局规则</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">6.6.3.</span> <span class="toc-text">创建</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">6.6.4.</span> <span class="toc-text">使用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">6.7.</span> <span class="toc-text">水平垂直居中</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD"><span class="toc-number">6.7.1.</span> <span class="toc-text">水平居中</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9E%82%E7%9B%B4%E5%B1%85%E4%B8%AD"><span class="toc-number">6.7.2.</span> <span class="toc-text">垂直居中</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E9%A1%B5%E9%9D%A2%E4%B8%AD%E5%85%83%E7%B4%A0"><span class="toc-number">6.8.</span> <span class="toc-text">隐藏页面中元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8-CSS-%E7%94%BB%E4%B8%89%E8%A7%92"><span class="toc-number">6.9.</span> <span class="toc-text">用 CSS 画三角</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E9%9D%A2%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.</span> <span class="toc-text">页面布局</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Flex-%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.1.</span> <span class="toc-text">Flex 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Rem-%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.2.</span> <span class="toc-text">Rem 布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%99%BE%E5%88%86%E6%AF%94%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.3.</span> <span class="toc-text">百分比布局</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E5%8A%A8%E5%B8%83%E5%B1%80"><span class="toc-number">6.10.4.</span> <span class="toc-text">浮动布局</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-rem-%E6%88%96-viewport-%E8%BF%9B%E8%A1%8C%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D"><span class="toc-number">6.11.</span> <span class="toc-text">使用 rem 或 viewport 进行移动端适配</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#rem-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">6.11.1.</span> <span class="toc-text">rem 适配原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#viewport-%E9%80%82%E9%85%8D%E5%8E%9F%E7%90%86"><span class="toc-number">6.11.2.</span> <span class="toc-text">viewport 适配原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B8%85%E9%99%A4%E6%B5%AE%E5%8A%A8"><span class="toc-number">6.12.</span> <span class="toc-text">清除浮动</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JS-TS-ES6"><span class="toc-number">7.</span> <span class="toc-text">JS TS ES6</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E7%9A%84-8-%E7%A7%8D%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">7.1.</span> <span class="toc-text">JS 的 8 种数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Symbol"><span class="toc-number">7.1.1.</span> <span class="toc-text">Symbol</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#BigInt"><span class="toc-number">7.1.2.</span> <span class="toc-text">BigInt</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A3%80%E6%B5%8B%E6%96%B9%E6%A1%88"><span class="toc-number">7.2.</span> <span class="toc-text">数据类型检测方案</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#typeof"><span class="toc-number">7.2.1.</span> <span class="toc-text">typeof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#instanceof"><span class="toc-number">7.2.2.</span> <span class="toc-text">instanceof</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Object-prototype-toString-call"><span class="toc-number">7.2.3.</span> <span class="toc-text">Object.prototype.toString.call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#var-let-const"><span class="toc-number">7.2.4.</span> <span class="toc-text">var let const</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="toc-number">7.3.</span> <span class="toc-text">JS 垃圾回收机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE"><span class="toc-number">7.4.</span> <span class="toc-text">作用域和作用域链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AD%E5%8C%85%EF%BC%9A%E4%BF%9D%E5%AD%98-%E4%BF%9D%E6%8A%A4"><span class="toc-number">7.5.</span> <span class="toc-text">闭包：保存&#x2F;保护</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">7.5.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">7.5.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%80%A7"><span class="toc-number">7.5.3.</span> <span class="toc-text">特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8%E9%80%94"><span class="toc-number">7.5.4.</span> <span class="toc-text">用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">7.5.5.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this"><span class="toc-number">7.6.</span> <span class="toc-text">this</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E5%9E%8B-%E5%8E%9F%E5%9E%8B%E9%93%BE"><span class="toc-number">7.7.</span> <span class="toc-text">原型 原型链</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new"><span class="toc-number">7.8.</span> <span class="toc-text">new</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EventLoop"><span class="toc-number">7.9.</span> <span class="toc-text">EventLoop</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-number">7.9.1.</span> <span class="toc-text">浏览器中的事件循环</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('/img/meihao3.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AgoniLay</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz',
      appKey: 'k49y92c0BEE6zL2mCA2AUHKu',
      avatar: 'monsterid',
      serverURLs: 'https://fmlk1v2u.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>