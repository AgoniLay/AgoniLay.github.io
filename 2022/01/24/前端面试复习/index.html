

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/zoro3.jpg">
  <link rel="icon" href="/img/zoro3.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  
  <meta name="theme-color" content="#efb9b9">
  <meta name="description" content="">
  <meta name="author" content="AgoniLay">
  <meta name="keywords" content="">
  
  <title>前端面试复习 - AgoniLay的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/scroller.css">
<link rel="stylesheet" href="/css/bynode.css">
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"agonilay.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":150,"cursorChar":"❤","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/three2.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>AgoniLay</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-bookmark"></i>
                索引
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h3" id="subtitle" title="前端面试复习">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      AgoniLay
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-24 14:41" pubdate>
        2022年1月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      39.2k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
			
			
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">前端面试复习</h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年3月2日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// AgoniLay</span><br></code></pre></div></td></tr></table></figure>

<p>Person 就是一个构造函数，使用 new 创建了一个实例对象 person。</p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>每一个函数都有一个 prototype 属性，指向正在调用该构造函数而创建的实例的<strong>原型</strong>（每一个 JavaScript 对象(null 除外)在创建的时候会与另一个对象关联，也就是原型，每一个对象都会从原型上继承属性）。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065312e706e67.png" srcset="/img/three2.gif" lazyload class title="原型和构造函数">

<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>每一个JavaScript对象(null除外)都具有一个属性，也就是 <code>__proto__</code>，这个属性指向该对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>关系图：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065322e706e67.png" srcset="/img/three2.gif" lazyload class title="实例与实例原型的关系图">

<blockquote>
<p>绝大部分浏览器都支持这个非标准的方法访问原型，但并不存在于 Person.prototype 中，而是来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解为返回了 <code>Object.getPrototypeOf(obj)</code>。</p>
</blockquote>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>一个构造函数可以生成多个实例，原型没有属性指向实例，但有原型指向构造函数的属性 <code>constructor</code>，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-built_in">console</span>.log(Person === Person.prototype.constructor) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065332e706e67.png" srcset="/img/three2.gif" lazyload class title="实例原型与构造函数的关系图">

<p>综上：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.__proto__ === Person.prototype <span class="hljs-comment">// true</span><br>Person.prototype.constructor === Person <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 一个 ES5 的方法，可以得到对象的原型</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220124151146083.png" srcset="/img/three2.gif" lazyload class title="image-20220124151146083">

<h4 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h4><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&#x27;agoni&#x27;</span><br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// &#x27;agoni&#x27;</span><br><br><span class="hljs-keyword">delete</span> person.name<br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>原型的最顶层是 <code>Object</code>，<code>Object</code> 的原型是 null</p>
<blockquote>
<p>null 表示“没有对象”，即此处不应该有值。参考：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">undefined 和 null</a> </p>
</blockquote>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67.png" srcset="/img/three2.gif" lazyload class title="原型链示意图">

<p>上图中由相互关联的原型组成的链状结构就是原型链（蓝色的那条）。</p>
<blockquote>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，而是在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数，所以其实叫委托更准确。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child()<br>child.getName() <span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>引用类型的属性将被所有实例共享；</li>
<li>在创建 Child 实例时，不能向 Person 传参</li>
</ol>
<h4 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.names = [<span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-string">&#x27;lay&#x27;</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params"></span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child()<br>child1.names.push(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(child1.names) <span class="hljs-comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;, &#x27;AgoniLay&#x27;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> Child()<br><span class="hljs-built_in">console</span>.log(child2.names) <span class="hljs-comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以在 Child 中向 Parent 传参</li>
</ol>
<p>缺点：</p>
<ol>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li>
</ol>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>结合了原型链继承和经典继承：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br>Parent.prototpye.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>, name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br>child.prototype = <span class="hljs-keyword">new</span> Parent()<br>child.prototype.constructor = Child<br><br><span class="hljs-keyword">var</span> child11 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">20</span>)<br>child1.colors.push(<span class="hljs-string">&#x27;pink&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(child1.name)		<span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br><span class="hljs-built_in">console</span>.log(child1.age)			<span class="hljs-comment">// 20</span><br><span class="hljs-built_in">console</span>.log(child1.colors)	<span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]</span><br><br><span class="hljs-keyword">var</span> child11 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">18</span>)<br><br><span class="hljs-built_in">console</span>.log(child2.name)		<span class="hljs-comment">// &#x27;agoni&#x27;</span><br><span class="hljs-built_in">console</span>.log(child2.age)			<span class="hljs-comment">// 18</span><br><span class="hljs-built_in">console</span>.log(child2.colors)	<span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<p>缺点：会调用两次父构造函数</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>就是 ES5 <code>Object.create()</code> 的模拟实现，将传入的对象多为创建的对象的原型。</p>
<p>缺点：包含引用类型的属性始终都会共享相应的值，同原型链继承。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(o)<br>  clone.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>缺点：和借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>避免组合继承中的两次调用父构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br>Parent.prototpye.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>, name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">// 关键步骤</span><br><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>F.prototype = Parent.prototype<br>Child.prototype = <span class="hljs-keyword">new</span> F()<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">console</span>.log(child1)<br></code></pre></div></td></tr></table></figure>

<p>对这个继承方法进行封装：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prototype</span> (<span class="hljs-params">child, parent</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> prototype = object(parent.prototype)<br>  prototype.constructor = child<br>  child.prototype = prototype<br>&#125;<br><br>prototype(Child, Parent)<br></code></pre></div></td></tr></table></figure>

<p>优点：高效率，体现在只调用了一次 Parent 构造函数，并且因此避免了在 <code>Parent.prototype</code> 上创建不必要的属性，同时原型链还能保持不变，因此也可以正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。</p>
<blockquote>
<p>普遍认为 寄生组合式继承式引用类型最理想的继承方式。</p>
</blockquote>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 JavaScript 代码执行一段可执行代码（execution code）时，会创建对应的执行上下文（execution context）。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li></li>
<li><p>变量对象（Variable Object，VO）</p>
</li>
<li><p>作用域链（Scope chain）</p>
</li>
<li><p>this</p>
</li>
</ul>
<p>函数的作用域在函数定义的时候就确定了，因为函数有一个内部属性 <code>[[scope]]</code>，当函数创建时，就会保存多有父变量对象到其中，可以将 <code>[[scope]]</code> 理解为所有父变量对象的层级链，但 <code>[[scope]]</code> 并不代表完整的作用域链。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>函数创建时，各自的 <code>[[scope]]</code> 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">foo.[[scope]] = [<br>  globalContext.VO<br>]<br><br>bar.[[scope]] = [<br>  fooContext.AO,<br>  globalContext.VO<br>]<br></code></pre></div></td></tr></table></figure>

<p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用域链的前端：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 执行上下文的作用域链</span><br>Scope = [AO].concat([[scope]])<br></code></pre></div></td></tr></table></figure>

<p>作用域链创建完毕。</p>
<h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><ol>
<li>可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象；</li>
<li>全局对象是由 Object 构造函数实例化的一个对象；</li>
<li>预定义了一些函数和属性；</li>
<li>作为全局变量的宿主；</li>
<li>客户端 JavaScript 中，全局对象由 window 属性指向自身；</li>
</ol>
<p>全局上下文中的变量对象就是全局对象。</p>
<h4 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h4><p>在函数上下文中，用活动对象（Activation object，AO）来表示变量对象。</p>
<p>变量对象是规范上或者说是引擎上实现的，不可以在 JavaScript 环境中访问，只有在进入到一个执行上下文中，变量对象才会被激活，也就成为了活动对象，其中的各种属性才可以被访问。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行上下文的代码会分为两个阶段进行处理：分析和执行</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h5 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h5><p>变量对象包括：</p>
<ol>
<li>函数的所有形参（是函数上下文的话）<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 <code>undefined</code> </li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则<strong>完全替代</strong>这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明<strong>不会干扰</strong>已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  b = <span class="hljs-number">3</span><br>&#125;<br>foo(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>

<p>进入执行上下文后，这时候的 AO 为：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">AO = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>在代码执行阶段，顺序执行代码，根据代码修改变量对象的值：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">AO = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>  <span class="hljs-attr">d</span>: reference to FunctionExpression <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象；</li>
<li>函数上下文的变量对象初始化只包括 arguments 对象；</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>ECMAScript 的类型分为语言类型和规范类型。</p>
<ul>
<li>语言类型是开发者直接使用 ECMAScript 可以操作的，包括：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 和 <code>Object</code>；</li>
<li>规范类型先相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的，包括：<code>Reference</code>、<code>List</code>、<code>Completion</code>、<code>Property Descriptor</code>、<code>Property Identifier</code>、<code>Lexical Environment</code> 和 <code>Environment Record</code> </li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>Reference 类型是用来解释 delete、typeof 以及赋值等操作行为的</p>
<blockquote>
<p>这里的 Reference 是一个 Specification Type，也就是只存在于规范里的抽象类型。是为了更好地描述语言的底层行为逻辑而存在，并不存在于实际的 js 代码中。</p>
</blockquote>
<p>Reference 由三部分构成：</p>
<ul>
<li>base value：属性所在的对象，它的值只能是 <code>Undefined</code>、<code>Object</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 或者 <code>environment record</code> 其中的一种</li>
<li>referenced name：属性的名称</li>
<li>strict reference：一个 <code>Boolean</code> 值，用来检测 strict mode 下的一些限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>  &#125;<br>&#125;<br>foo.bar()<br><br><span class="hljs-comment">// foo 对应的 Reference 是：</span><br><span class="hljs-keyword">var</span> fooReference = &#123;<br>  <span class="hljs-attr">base</span>: EnvironmentRecord,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>  <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// bar 对应的 Rederence 是：</span><br><span class="hljs-keyword">var</span> barReference = &#123;<br>  <span class="hljs-attr">base</span>: foo,<br>  <span class="hljs-attr">propertyName</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>  <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Reference 方法：</p>
<ul>
<li><code>GetBase()</code>：返回 reference 的 base value</li>
<li><code>IsPropertyReference()</code>：如果 base value 是一个对象则返回 true</li>
<li><code>GetValue()</code>：返回对象属性真正的值，<strong>返回的将是具体的值，而不再是一个 Reference</strong>。</li>
</ul>
<h4 id="确定-this"><a href="#确定-this" class="headerlink" title="确定 this"></a>确定 this</h4><ol>
<li>计算 <code>MemeberExpression</code> 的结果赋值给 ref</li>
<li>判断 ref 是不是一个 Reference 类型<ol>
<li>是，并且 <code>IsPropertyReference(ref)</code> 是 true，那么 this 的值为 <code>GetBase(ref)</code> </li>
<li>不是，this 为 undefined</li>
</ol>
</li>
</ol>
<p><code>MemeberExpression</code>：</p>
<ul>
<li><code>PrimaryExpression</code>：原始表达式</li>
<li><code>FunctionExpression</code>：函数定义表达式</li>
<li><code>MemeberExpression[Expression]</code>：属性访问表达式</li>
<li><code>MemeberExpression.IdentifierName</code>：属性访问表达式</li>
<li><code>new MemeberExpression Arguments</code>：对象创建表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>foo() <span class="hljs-comment">// MemeberExpression 是 foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br>foo()() <span class="hljs-comment">// MemeberExpression 是 foo()</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br>foo.bar() <span class="hljs-comment">// MemeberExpression 是 foo.bar</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>可以简单理解 <code>MemeberExpression</code> 就是 <code>()</code> 左侧的部分</p>
</blockquote>
<p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//示例1</span><br><span class="hljs-built_in">console</span>.log(foo.bar())		<span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例2</span><br><span class="hljs-built_in">console</span>.log((foo.bar)())	<span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例3</span><br><span class="hljs-built_in">console</span>.log((foo.bar = foo.bar)())	<span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例4</span><br><span class="hljs-built_in">console</span>.log((<span class="hljs-literal">false</span> || foo.bar)())		<span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例5</span><br><span class="hljs-built_in">console</span>.log((foo.bar, foo.bar)())		<span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>赋值、逻辑运算，逗号运算均会调用 <code>GetValue()</code> 方法，返回的并不是 Reference 类型，而是真正的值，所以不满足第二步判断，进而 this 指向 undefined（在非严格模式下，this 的值为 undefined 时将会隐式转换为全局对象）</p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>MDN 对于闭包的定义：闭包是指那些能够访问自由变量的函数</p>
<p>自由变量：指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</p>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
</blockquote>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br>foo()<br></code></pre></div></td></tr></table></figure>

<p>foo 函数可以访问变量 a，但 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量，所以理论上函数 foo + foo 函数访问的自由变量 a 就构成了一个闭包。</p>
<p>上面描述的是理论上的闭包，还有一个实践角度的闭包：</p>
<p>ECMAScript 中，闭包指：</p>
<ol>
<li>从理论角度：所有的函数（在函数中访问全局变量就相当于是在访问自由变量）</li>
<li>从实践角度：<ol>
<li>即使创建它的上下文已经销毁，它依然存在（如内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> scope<br>  &#125;<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br><span class="hljs-keyword">var</span> foo = checkscope()<br>foo()<br></code></pre></div></td></tr></table></figure>

<p>执行过程：</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；</li>
<li>全局执行上下文初始化；</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等；</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this 等；</li>
<li>f 函数执行完毕，f 执行上下文从执行上下文栈中弹出。</li>
</ol>
<p>f 之所以可以访问到 checkscope 作用域中的值，是因为 f 执行上下文维护了一个作用域链：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fContext = &#123;<br>	<span class="hljs-attr">Scope</span>: [AO, checkscopeContext.AO, globalContext.VO]<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>因此，当 f 函数引用了 <code>checkscopeContext.AO</code> 中的值时，即使 <code>checkscopeContext</code> 被销毁了，但 JavaScript 仍会让 <code>checkscopeContext.AO</code> 存活在内存中，f 函数依然可以通过其自身的作用域链访问。</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>指被立即调用的函数表达式（Immediately-Invoked Function Expression，IIFE）</p>
<p>括号出现在函数周边的规则：</p>
<ul>
<li>当圆括号出现在匿名函数的末尾想要想要调用函数时，它会默认将函数当成是函数声明</li>
<li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明</li>
</ul>
<p>所以有以下两种 IIFE 的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;())<br><span class="hljs-comment">// 或</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;)()<br></code></pre></div></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，可以判断 <code>number</code>、<code>string</code>、<code>object</code>、<code>boolean</code>、<code>function</code>、<code>undefined</code>、<code>symbol</code> 七种类型，返回值为<strong>字符串</strong>类型。</p>
<p>在判断不是 object 类型的数据时，<code>typeof</code> 能比较清楚的返回具体是什么类型，但无法细分判断是那种 object 类型。</p>
<p>原理：</p>
<p>js 在底层存储变量时，会在变量的机器码的低位1-3位存储其类型信息：</p>
<ul>
<li>000：对象</li>
<li>010：浮点数</li>
<li>100：字符串</li>
<li>110：布尔值</li>
<li>1：整数</li>
</ul>
<p>对于 null 和 undefined 来说，这两个值的信息存储特殊：</p>
<ul>
<li>null：所有机器码均为 0</li>
<li>undefined：用 <code>-2^30</code> 整数来表示</li>
</ul>
<p>所以，<code>typeof</code> 在判断 null 时就会把 null 当为 object 来看待。</p>
<blockquote>
<p>避免使用 typeof 判断 null，也可以使用 <code>Object.prototype.toString.call()</code> 判断。</p>
</blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 用于：</p>
<ul>
<li>判断对象的具体类型</li>
<li>判断一个实例是否属于某种类型</li>
<li>判断一个实例是否是其父类型或祖先类型的实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> nicole = <span class="hljs-keyword">new</span> person()<br>nicole <span class="hljs-keyword">instanceof</span> person <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new_instance_of</span> (<span class="hljs-params">leftValue, rightValue</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> rightProto = rightValue.prototype<br>  leftValue = leftValue.__proto__<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (leftValue === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftValue === rightProto) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    leftValue = leftValue.__proto__<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>原型继承原理：</p>


<p><code>Object instanceof Object</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">leftValue = <span class="hljs-built_in">Object</span>.__proto__ = <span class="hljs-built_in">Function</span>.prototype<br>rightValue = <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// 第一次判断</span><br>leftValue !== rightValue<br>leftValue = <span class="hljs-built_in">Function</span>.prototype.__proto__ = <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// 第二次判断</span><br>leftValue === rightValue<br><span class="hljs-comment">// 返回 true</span><br></code></pre></div></td></tr></table></figure>

<p><code>Function instanceof Funciton</code> 和 <code>Function instanceof Object</code> 同理。</p>
<h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call apply"></a>call apply</h3><p>共同点：都能改变函数执行时的上下文，将一个对象交给另一个对象来执行，且立即执行。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>call 在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.call(object[, param1 [, param2[, ... [, paramN]]]])<br></code></pre></div></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>调用者必须是函数 Function</li>
<li>call 的第一个参数是一个对象，Function 的调用者将会指向这个对象，不传则默认为 window</li>
<li>第二个参数开始可以接收任意个参数</li>
</ul>
<p>使用场景：</p>
<ol>
<li>对象的继承</li>
<li>借用方法：比如类数组借用数组原型链上的方法</li>
</ol>
<p>模拟实现：</p>
<ol>
<li>将函数设置为对象的属性；</li>
<li>执行该函数；</li>
<li>删除该函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span><br>  context.fn = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> args = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>    args.push(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.apply(object[, argArray])<br></code></pre></div></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>调用者必须是函数 Function</li>
<li>最多接受两个参数，第一个参数于 call 一致</li>
<li>第二个参数必须是数组或者类数组，会被转换为类数组，传入 Function 中，并映射到 Function 对应的参数上</li>
</ul>
<blockquote>
<p>类数组：具备与数组特征类似的对象，可以通过角标调用，具有长度属性 length，可以通过 for 循环进行遍历；无法使用 forEach、splice、push 等数组原型链上的方法。</p>
</blockquote>
<p>使用场景：</p>
<ol>
<li><p><code>Math.max</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 获取数组中最大的一项</span><br><span class="hljs-keyword">let</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, array)<br><span class="hljs-comment">// 获取数组中最小的一项</span><br><span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, array)<br></code></pre></div></td></tr></table></figure></li>
<li><p>数组合并</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">Array</span>.prototype.push.apply(arr1, arr2)<br></code></pre></div></td></tr></table></figure></li>
</ol>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span><br>  context.fn = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> result<br>  <span class="hljs-keyword">if</span> (!arr) &#123;<br>    result = context.fn()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> args = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      args.push(<span class="hljs-string">&#x27;arr[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>    &#125;<br>    result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind()</code> 方法会创建一个新函数。当这个函数被调用时，bind 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure>

<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Function.prototype.bind - what is trying to be bound is not callable.&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)<br><br>  <span class="hljs-keyword">var</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>  <span class="hljs-keyword">var</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-keyword">return</span> self.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-built_in">this</span> : context, args.conact(bindArgs))<br>  &#125;<br><br>  fNOP.prototype = <span class="hljs-built_in">this</span>.prototype<br>  fBound.prototype = <span class="hljs-keyword">new</span> fNOP()<br>  <span class="hljs-keyword">return</span> fBound<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-comment">// 执行 add 函数，需一次传入两个参数</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 一个 curry 函数可以做到柯里化</span><br><span class="hljs-keyword">var</span> addCurry = curry(add)<br>addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>

<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>避免重复调用函数时的参数冗余，精简代码</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub_curry</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args.concat([].slice.call(<span class="hljs-built_in">arguments</span>)))<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, length</span>) </span>&#123;<br>  length = length || fn.length<br>  <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; length) &#123;<br>      <span class="hljs-keyword">var</span> combined = [fn].concat(slice.call(<span class="hljs-built_in">arguments</span>))<br>      <span class="hljs-keyword">return</span> curry(sub_curry.apply(<span class="hljs-built_in">this</span>, combined), length - <span class="hljs-built_in">arguments</span>.length)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br>curry(fn)<br>fn()()<br></code></pre></div></td></tr></table></figure>

<p><code>sub_curry</code> 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 <code>fn()()</code> 时，执行包裹函数，返回原函数，然后再调用 <code>sub_curry</code> 包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的数目达到要求为止。</p>
<h4 id="易懂实现"><a href="#易懂实现" class="headerlink" title="易懂实现"></a>易懂实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, args</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> length = fn.length<br>  args = args || []<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _args = args.slice(<span class="hljs-number">0</span>),<br>        arg, i<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      arg = <span class="hljs-built_in">arguments</span>[i]<br>      _args.push(arg)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_args.length &lt; length) &#123;<br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, _args)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, _args)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>增加占位符功能：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, args, holes</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> length = fn.length<br>  args = args || []<br>  holes = holes || []<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _args = args.slice(<span class="hljs-number">0</span>),<br>        _holes = holes.slice(<span class="hljs-number">0</span>),<br>        argsLen = args.length,<br>        holesLen = holes.length,<br>        arg, i, index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      arg = <span class="hljs-built_in">arguments</span>[i]<br>      <span class="hljs-comment">// 处理类似 fn(1, _, _, 4)(_, 3) 这种情况</span><br>      <span class="hljs-keyword">if</span> (arg === _ &amp;&amp; holesLen) &#123;<br>        index++<br>        <span class="hljs-keyword">if</span> (index &gt; holesLen) &#123;<br>          _args.push(arg)<br>          _holes.push(argsLen - <span class="hljs-number">1</span> + index - holesLen)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg === _) &#123;<br>        _args.push(arg)<br>        _holes.push(argsLen + i)<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holesLen) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= holesLen) &#123;<br>          _args.push(arg)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          _args.splice(_holes[index], <span class="hljs-number">1</span>, arg)<br>          _holes.splice(index, <span class="hljs-number">1</span>)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        _args.push(arg)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_holes.length || _args.length &lt; length) &#123;<br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, _args, _holes)<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, _args)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> _ = &#123;&#125;<br><br><span class="hljs-keyword">var</span> fn = curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log([a, b, c, d, e])<br>&#125;)<br><br><span class="hljs-comment">// 输出均为 [1, 2, 3, 4, 5]</span><br>fn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>fn(_, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">1</span>)<br>fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">2</span>)<br>fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>)(_, <span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br>fn(<span class="hljs-number">1</span>, _, _, <span class="hljs-number">4</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br>fn(_, <span class="hljs-number">2</span>)(_, _, <span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在这个实现中，实现了一个强大的 curry 函数，不仅可以传入一个参数，还可以一次传入两个参数甚至更多，这更像是一个柯里化（curry）和偏函数（partial application）的综合应用。</p>
</blockquote>
<h4 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> curry = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span><br>	judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><br>		args.length === fn.length<br>			? fn(...args)<br>			: <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> judge(...args, arg)<br></code></pre></div></td></tr></table></figure>

<h3 id="V8-垃圾回收"><a href="#V8-垃圾回收" class="headerlink" title="V8 垃圾回收"></a>V8 垃圾回收</h3><h4 id="为何垃圾回收"><a href="#为何垃圾回收" class="headerlink" title="为何垃圾回收"></a>为何垃圾回收</h4><p>V8 执行 JavaScript 代码时，当遇到函数时，会为其创建一个执行上下文环境并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所有变量，当函数执行完后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的变量也会统一释放并被自动回收。</p>
<p>若不进行回收，将会持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕后应还给操作系统以保证内存的重复利用。</p>
<p>JavaScript 作为一门高级编程语言，并不需要像 C 语言或 C++ 语言中手动地申请分配和释放内存，V8 引擎已经自动进行了内存的分配和管理。</p>
<h4 id="V8-引擎的内存限制"><a href="#V8-引擎的内存限制" class="headerlink" title="V8 引擎的内存限制"></a>V8 引擎的内存限制</h4><p>默认情况下，V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 <code>0.7GB</code> 的内存，这将会导致在 Node 中无法直接操作大内存对象。</p>
<p>限制原因：</p>
<ol>
<li>V8 引擎设计之初只是作为浏览器端 JavaScript 的执行环境，在浏览器中很少会遇到使用大量内存的情况，因此不必将最大内存设置得过高；</li>
<li>JS 是单线程机制，意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务，这意味着在 V8 执行垃圾回收时，程序中的其他逻辑都要进入暂停等待阶段，直到垃圾回收完成后才会再次执行 JS 逻辑；</li>
<li>垃圾回收本身也是一件非常耗时的操作，做一次小的垃圾回收需要 50ms 以上，而做一次非增量回收甚至需要 1s 以上，在这时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，会造成动画的卡顿掉帧情况，严重影响应用程序的性能。</li>
</ol>
<p>基于以上几点，V8 为了减少对应用性能造成的影响，就直接限制了堆内存的大小。</p>
<p>解决：</p>
<p>但在 node 端，涉及到的 <code>I/O</code> 操作可能会不够用，因此 V8 提供了可配置项来手动调整内存大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看 node 中可用的 v8 引擎的选项及其含义</span><br>node --v8-options<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125213324542.png" srcset="/img/three2.gif" lazyload class title="node V8 选项">

<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最小值，单位 MB</span><br>node --min-semi-space-size=1024 xxx.js<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最大值，单位 MB</span><br>node --max-semi-space-szie=1024 xxx.js<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置老生代内存最大值，单位 MB</span><br>node --max-old-space-size=2048 xxx.js<br></code></pre></div></td></tr></table></figure>

<p>通过上面的方法可以手动放宽 V8 引擎的内存使用限制，node 中提供了 <code>process.memoryUsage()</code> 方法来查看当前 node 进程中占用的实际内存大小。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125214633666.png" srcset="/img/three2.gif" lazyload class title="process.memoryUsage">

<p>上图中字段含义如下（单位均为字节）：</p>
<ul>
<li><p><code>rss</code>（resident set size）：表示驻留集大小，即给这个 node 进程分配了多少物理内存（包括堆、栈和代码片段）</p>
<blockquote>
<p>当使用  <code>Worker</code> 线程时，<code>rss</code> 是对整个进程都有效的值，其他字段只涉及当前线程</p>
</blockquote>
</li>
<li><p><code>heapTotal</code>：表示 V8 当前申请到的堆内存总大小</p>
</li>
<li><p><code>heapUsed</code>：表示当前内存使用量</p>
</li>
<li><p><code>external</code>：表示 V8 内部的 C++ 对象所占用的内存</p>
</li>
<li><p><code>arrayBuffers</code>：指为 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 分配的内存，包括所有 Node Buffer，包含在 <code>external</code> 值中</p>
</li>
</ul>
<h4 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h4><h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5><p>V8 的内存结构主要由以下几个部分组成：</p>
<ul>
<li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这个区域，此区域相对较小，但回收特别频繁；该区域被分为两半，一半用来回收内存，一半用于在垃圾回收时复制需要保留的对象；</li>
<li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会<strong>晋升</strong>到老生代内存区，相对于新生代该区域垃圾回收的频率较低；老生代分为：<ul>
<li> <code>老生代指针区</code>：包含大多数可能存在指向其他对象的指针的对象；</li>
<li><code>老生代数据区</code>：只保存原始数据对象，这些对象没有指向其他对象的指针；</li>
</ul>
</li>
<li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区；</li>
<li><code>代码区(code_space)</code>：代码对象分配区域，唯一拥有执行权限的内存区域；</li>
<li><code>map 区(map_space)</code>：存放 Cell 和 Map，每个区域都是存放相同大小的元素.</li>
</ul>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代主要用于存放存活时间较短的对象。新生代内存由两个 <code>semispace(半空间)</code> 构成，内存最大值在 64 位和 32 位系统默认分别为 <code>32MB</code> 和 <code>16MB</code>，在新生代的垃圾回收过程中主要采用了 <code>Scavenge</code> 算法。</p>
<p>Scavenge 算法：典型的牺牲空间换时间的算法，主要过程是<u>将存活对象在 <code>From</code> 空间和 <code>To</code> 空间之间进行复制，同时完成两个空间之间的角色互换</u>。</p>
<h5 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h5><p><u>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中</u>，即为 <strong>晋升</strong>。</p>
<p>晋升条件（两者满足其一）：</p>
<ol>
<li>对象是否经历过一次 <code>Scavenge</code> 算法</li>
<li><code>To</code> 空间的内存占比是否已经超过 <code>25%</code> </li>
</ol>
<h5 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h5><p>老生代中采用 <code>Mark-Sweep(标记清除)</code> 和 <code>Mark-Compact(标记整理)</code> 算法进行管理。</p>
<p><code>Mark-Sweep</code> 分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，<u>在标记阶段遍历堆中所有的对象，标记活着的对象，在清除对象，会将死亡的对象进行清除</u>，具体步骤如下：</p>
<ol>
<li>垃圾回收器在内部构建一个根列表，从根节点出发去寻找那些可以被访问到的变量（比如 window 全局对象可以看成一个根节点）；</li>
<li>垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，将其标记为活动的，未到达的即为非活动的；</li>
<li>最后，释放所有非活动的内存块，归还给操作系统。</li>
</ol>


<p>在 <code>Mark-Sweep</code> 之后，内存空间会出现大量不连续的状态，就会出现内存碎片的问题，可能导致后面无法分配大对象而提前触发垃圾清理，但其实毫无必要，所以需进行 <code>Mark-Compact</code>，来解决内存的碎片化问题，具体步骤：</p>
<p>在将死亡对象全部清除后，在整理过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。</p>
<p>至此完成了一次老生代垃圾回收的全部过程，之前提到由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会恢复执行主任务的逻辑，也就是 <strong>全停顿</strong>。</p>
<p>于是 V8 引擎引入了 <code>Incremental Marking(增量标记)</code> 的概念：<u>将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存</u>。</p>
<p>尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p>
<p>V8 还引入了 <code>Lazy Sweeping(延时清理)</code> 和 <code>Incremental Compation(增量式整理)</code>，使得清理和整理的过程也变为增量式的。</p>
<h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><ol>
<li><p>尽可能少地创建全局变量；</p>
</li>
<li><p>手动清除定时器：<code>clearInterval(timer)</code>、<code>clearTimeout(timer)</code>；</p>
</li>
<li><p>少用闭包；</p>
</li>
<li><p>清除 DOM 引用：使用 <code>document.body.removeChild(document.getElementById(&#39;button&#39;))</code>；</p>
</li>
<li><p>弱引用：<code>WeakMap</code> 和 <code>WeakSet</code>。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125230318519.png" srcset="/img/three2.gif" lazyload class title="弱引用"></li>
</ol>
<h3 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>ECMAScript 中 Number 类型使用 IEEE754 标准（IEEE 二进制浮点数算数标准）来表示整数和浮点数。</p>
<p>其中规定了四种表示浮点数值的方式：</p>
<ol>
<li>单精确度（32 位）</li>
<li>双精确度（64 位）：ECMAScript 采用的就是双精确度。</li>
<li>延伸单精确度</li>
<li>延伸双精确度</li>
</ol>
<h4 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h4><p>1020 用十进制表示：</p>
<blockquote>
<p>1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0</p>
</blockquote>
<p>1030 用二进制表示：</p>
<blockquote>
<p>1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0</p>
</blockquote>
<p>也就是 <code>1111111100</code> </p>
<hr>

<p>0.75 用二进制表示：</p>
<blockquote>
<p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p>
</blockquote>
<p>两边同时乘 2：</p>
<blockquote>
<p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3 + … (所以 a = 1)</p>
<p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3 + …</p>
</blockquote>
<p>再同时乘 2：</p>
<blockquote>
<p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3 + … (所以 b = 1)</p>
</blockquote>
<p>所以 0.75 就是 <code>0.11</code></p>
<hr>

<p>但一些小数计算会一直循环，如 0.1 用二进制表示就是 <code>0.00011001100110011......</code> </p>
<h4 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h4><p>IEEE 754 认为，一个浮点数（Value）可以这样表示：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Value = sign * exponent * fraction<br></code></pre></div></td></tr></table></figure>

<p>也就是科学计数法，如 -1020 用科学计数法表示就是：</p>
<blockquote>
<p>-1 * 10^3 * 1.02</p>
</blockquote>
<p>对于 0.1 的二进制 <code>0.00011001100110011......</code> 来说，可以表示为：</p>
<blockquote>
<p>1 * 2^-4 * 1.1001100110011……</p>
</blockquote>
<p>只做二进制可续计数法的表示时， Value 的表示可以更具体：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Value = (-<span class="hljs-number">1</span>)^S * (<span class="hljs-number">1</span> + Fraction) * <span class="hljs-number">2</span>^E<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；S = 1，V 为负数；</li>
<li><code>(1 + Fraction)</code>：因为所有的浮点数都可以表示为 <code>1.xxx * 2^xxx</code> 的形式，前面也一定是 <code>1.xxx</code>，故存储 Fraction 为 1 后面的 xxx；</li>
<li><code>2^E</code>：用 8 位来存储 E 这个数，只有正数则范围是 0 ~ 254，但由于有负值，所以值的范围是 -127 ~ 127。取值时，再减去 127，所以不是直接存储 E 而是 E + bias，bias 也就是 127。</li>
</ul>
<p>所以，要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 三个值即可</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067.jpeg" srcset="/img/three2.gif" lazyload class title="IEEE754">

<ul>
<li>使用 1 位存储 S，0 表示正数，1 表示负数；</li>
<li>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 <code>2^(11-1) - 1</code> 也就是 <code>1023</code>；</li>
<li>用 52 位存储 Fraction</li>
</ul>
<p>比如，0.1 的对应二进制是 <code>1 * 1.1001100110011...... * 2^-4</code>，Sign 是 1，E + bias 是 -4 + 1023 = 1019 也就是 <code>1111111011</code>，Fraction 是 1001100110011……</p>
<p>所以 0.1 对应 64 位的完整表示就是：</p>
<blockquote>
<p>0 | 01111111011 | 1001100110011001100110011001100110011001100110011010</p>
</blockquote>
<p>同理 0.2 的完整表示是：</p>
<blockquote>
<p>0 | 01111111100 | 1001100110011001100110011001100110011001100110011010</p>
</blockquote>
<p>所以当 0.1 存下来的时候，就已经发生了精度的丢失，再使用浮点数进行计算时，使用的其实是精度丢失后的数</p>
<h4 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h4><p>浮点数运算一般由五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。</p>
<p>以 0.1 + 0.2 为例：</p>
<p>首先进行对阶，也就是把阶码调整为相同，0.1 是 <code>1 * 1.1001100110011...... * 2^-4</code>，阶码是 -4，而 0.2 是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，调整原则为 <strong>小阶对大阶</strong>，也就是 0.1 调整为 <code>0.11001100110011…… * 2^-3</code>；</p>
<p>接下来是尾数计算：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">  0.1100110011001100110011001100110011001100110011001101<br>+ 1.1001100110011001100110011001100110011001100110011010<br>————————————————————————————————————————————————————————<br> 10.0110011001100110011001100110011001100110011001100111<br></code></pre></div></td></tr></table></figure>

<p>结果为：<code>10.0110011001100110011001100110011001100110011001100111</code>；</p>
<p>将结果进行规格化：<code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code>（括号里的 1 表示超出了范围，所以舍弃）；</p>
<p>然后进行舍入：四舍五入对应到二进制中，就是 0 舍 1 入，因为要把括号中的 1 舍弃，所以需要进 1，结果变为：<code>1.0011001100110011001100110011001100110011001100110100 * 2^-2</code>；</p>
<p>此处不涉及溢出判断，所以最终结果存成 64 位就是：</p>
<blockquote>
<p>0 | 01111111101 | 0011001100110011001100110011001100110011001100110100</p>
</blockquote>
<p>转换为 10 进制数就得到 <code>0.30000000000000004440892098500626</code> </p>
<p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致 <code>0.1 + 0.2 !== 0.3</code> </p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 十进制转二进制</span><br><span class="hljs-number">0.1</span>.toString(<span class="hljs-number">2</span>)<br>=&gt; <span class="hljs-string">&quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span><br><br><span class="hljs-comment">// 二进制转十进制</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1100100</span>, <span class="hljs-number">2</span>)<br>=&gt; <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 以指定精度返回该数值对象的字符串表示</span><br>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>).toPrecision(<span class="hljs-number">21</span>)<br>=&gt; <span class="hljs-string">&quot;0.300000000000000044409&quot;</span><br>(<span class="hljs-number">0.3</span>).toPrecision(<span class="hljs-number">21</span>)<br>=&gt; <span class="hljs-string">&quot;0.299999999999999988898&quot;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126001804188.png" srcset="/img/three2.gif" lazyload class title="浮点数相关方法">

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  obj.__proto__ = Constructor.prototype<br>  <span class="hljs-keyword">var</span> ret = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&#x27;object&#x27;</span> ? ret : obj<br>&#125;<br><br><span class="hljs-comment">// 模拟使用</span><br><span class="hljs-keyword">var</span> person = objectFactory(Perosn, <span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">20</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意点：若构造函数中手动返回了一个对象，则 new 构造出的实例中只能访问返回对象中的属性，但如果返回一个基本类型的值，则默认相当于无返回值处理</p>
</blockquote>
<blockquote>
<p>此处 <code>new Object()</code> 若使用 <code>Object.create(null)</code> 代替，则创建出的实例中的 <code>__proto__</code> 会有差别，后者只是将 <code>__proto__</code> 当成了一个属性，并非去修改原型。</p>
</blockquote>
<p>可以优化：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span> (<span class="hljs-params"></span>) </span>&#123;<br>  Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">var</span> ret = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(Constructor.prototype)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; ret !== <span class="hljs-literal">null</span> ? ret : obj<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h4><p>当调用一个方法时，js 会产生一个与这个方法对应的执行环境（context），即执行上下文。而当一系列方法被调用时，因为 js 时单线程的，同一时间只能执行一个方法，于是这些方法会被排队在一个单独的地方，就是 <strong>执行栈</strong>。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp" srcset="/img/three2.gif" lazyload class title="执行栈">

<p>一个方法执行时会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，也就会在执行栈中再添加一个执行环境，此过程可以是无限循环的，除非发生了栈溢出。</p>
<p>以上均是在说同步代码的执行，当一个异步代码执行后，实现就需要依赖 js 的另一大特点 —— 非阻塞，关键在于—— 事件队列（Task Queue）</p>
<p>js 在遇到一个异步任务后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入并一个队列 —— 事件队列，放入其中不会立刻执行其回调，而是等当前执行栈中的所有任务都执行完毕，主线程处于闲置状态后，主线程才会去查看事件队列中是否有任务，如果有，则取出排在第一位的事件，将对应回调放入执行栈，然后执行其中的同步代码，如此反复，这个过程就叫 <strong>事件循环（Event Loop）</strong>。</p>
<h4 id="marco-task-与-mirco-task"><a href="#marco-task-与-mirco-task" class="headerlink" title="marco task 与 mirco task"></a>marco task 与 mirco task</h4><p>因为异步任务之间并不相同，因此执行优先级也有区别，不同的异步任务分为两类：</p>
<ul>
<li>微任务（mirco task）<ul>
<li><code>Promise.resolve().then()</code> </li>
<li><code>new MutationObserver()</code> </li>
</ul>
</li>
<li>宏任务（macro task）<ul>
<li><code>setInterval()</code> </li>
<li><code>serTimeout()</code> </li>
</ul>
</li>
</ul>
<p>在一个事件循环中，异步事件返回结果后会被放到相对应的宏任务队列或者微任务队列中，在当前执行栈为空时，<u>主线程会先查看微任务队列中是否有事件存在，为空后再去查看宏任务队列</u>。</p>
<h4 id="node-环境中事件循环"><a href="#node-环境中事件循环" class="headerlink" title="node 环境中事件循环"></a>node 环境中事件循环</h4><h5 id="libuv-引擎"><a href="#libuv-引擎" class="headerlink" title="libuv 引擎"></a>libuv 引擎</h5><p>node 中事件循环的实现是依靠 libuv 引擎，node 使用 chrome V8 作为 js 解释器，V8 引擎在将 js 代码分析后去调用相应的 node api，这些 api 最后由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。</p>
<h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126134544019.png" srcset="/img/three2.gif" lazyload class title="libuv 事件模型">

<p>外部输入数据 ——&gt; 轮询阶段（poll）——&gt; 检查阶段（check）——&gt; 关闭时间回调阶段（close callbacks）——&gt; 定时器检测阶段（timer）——&gt; I/O 事件回调阶段（I/O callbacks）——&gt; 闲置阶段（idle, prepare）——&gt; 轮询阶段 ……</p>
<p>阶段大致功能：</p>
<ul>
<li>poll：等待新的 I/O 事件，node 在某些特殊情况下会阻塞此处；</li>
<li>check：执行 <code>setImmediate()</code> 的回调；</li>
<li>close callbacks：如 <code>socket.on(&#39;close&#39;, ...)</code> 这种 close 事件的回调；</li>
<li>timers：这个阶段执行定时器队列中的回调：<code>setTimeout()</code> 和 <code>setInterval()</code>；</li>
<li>I/O callbacks：这个阶段执行除 close 事件、定时器和 <code>setImmediate()</code> 的回调之外所有的回调；</li>
<li>idle, prepare：仅在内部使用。</li>
</ul>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调，若为空，则检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行，同时也会检查是否有到期的 timer，如果有就把这些到期的 timer 的 callback 按调用顺序放到 timer queue 中。</p>
<p>收到代码运行环境的影响，如果两者的 queue 均为空，则 loop 会在 poll 阶段停留，直到有一个 I/O 事件返回，进入 I/O callback 阶段并立即执行这个事件的 callback。</p>
<p>poll 阶段在执行 poll queue 中的回到时并不会无限的执行下去：</p>
<ol>
<li>所有回调执行完毕；</li>
<li>执行数超过了 node 的限制</li>
</ol>
<p>两者其一则会终止执行 poll queue 中的下一个回调。</p>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>专门用来执行 <code>setImmediate()</code> 方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有callback时，事件循环进入此阶段。</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>当一个 socket 连接或者一个 handle 被突然关闭时（如调用了 <code>socket.destroy()</code> 方法），close 事件会被发送到这个阶段执行回调，否则事件会用 <code>process.nextTick()</code> 方法发送出去。</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><p>以先进先出的方式执行所有到期的 timer 加入 timer queue 里的 callback。</p>
<p>一个 timer 指的是一个通过 setTimeout 或 setInterval 函数设置的回调函数</p>
<h5 id="I-O-callback"><a href="#I-O-callback" class="headerlink" title="I/O callback"></a>I/O callback</h5><p>主要执行大部分 I/O 事件的回调，包括一些为操作系统执行的回调。</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>node 中存在一个特殊的队列，即 nextTick queue，这些事件会在每一个阶段执行完毕后准备进入下一个阶段前优先执行。</p>
<p>与执行 poll queue 的区别在于这个操作在队列清空前是不会停止的，所以错误的使用 <code>process.nextTick()</code> 会导致 node 进入一个死循环，直到内存泄漏。</p>
<h5 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h5><p><code>setTimeout()</code> 方法是定义一个回调，在所指定的时间间隔后第一时间去执行，受到操作系统和当前执行任务的诸多影响，该回调并不会在预期时间间隔后精准的执行，会存在一定的偏差。</p>
<p><code>setImmediate()</code> 方法从意义上是立刻执行的意思，但其实是在一个固定的阶段才会执行回调，即 poll 阶段之后。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 输出顺序不一定，这取决于这段代码的运行环境。</span><br></code></pre></div></td></tr></table></figure>

<p>但下面的输出顺序是确定的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// immediate</span><br><span class="hljs-comment">// timeout</span><br></code></pre></div></td></tr></table></figure>

<p>因为在 I/O 事件的回调中，setImmediate 方法的回调永远在 timer 的回调前执行。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise 只有三种状态：等待（Pending）、执行（Fulfilled）、拒绝（Rejected）。一旦 Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）</p>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">1</span> &#125;)<br>    resolve(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">2</span> &#125;)<br>    reject(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">2</span> &#125;)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result1&#x27;</span>, data) <span class="hljs-comment">// &#x27;result1&#x27;, &#123; test: 1 &#125;</span><br>&#125;,<span class="hljs-function">(<span class="hljs-params">data1</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result2&#x27;</span>,data1)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result3&#x27;</span>, data) <span class="hljs-comment">// &#x27;result3&#x27;, undefined</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<ol>
<li>Promise 可以进行链式调用，且每次 then 返回了新的 Promise；</li>
<li>只输出第一次 resolve 的内容，即状态不可逆；</li>
<li>then 中注册的回调仍然是属于上一个 Promise 的</li>
</ol>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br><br>  <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 将新 Promise 的 resolve 方法放到前一个 promise 的回调对象中</span><br>      handle(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>        reject<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> ret = cb(value) <span class="hljs-comment">// 处理回调</span><br>    next(ret) <span class="hljs-comment">// 处理下一个 promise 的 resolve</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br><br>      <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = newValue<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          <span class="hljs-comment">// newValue 为新产生的 Promise，此时 resolve 为上个 promise 的 resolve</span><br>          <span class="hljs-comment">// 相当于调用了新产生 Promise 的 then 方法，注入了上个 promise 的 resolve 为其回调</span><br>          then.call(newValue, resolve)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br><br>      state = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>      value = newValue<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <br>      <span class="hljs-keyword">if</span> (error &amp;&amp; (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = error<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;funciton&#x27;</span>) &#123;<br>          then.call(error, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;rejected&#x27;</span><br>      value = error<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCb</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (callbacks.length) &#123;<br>      <span class="hljs-keyword">const</span> fn = callbacks.shift()<br>      handle(fn)<br>    &#125;<br>  &#125;<br><br>  fn(resolve, reject)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，使用 try-catch 来捕获异常，并将 Promise 设为 rejected 状态即可。</p>
<p>对 handle 函数进行改造：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br>  <br>  <span class="hljs-comment">// ...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> ret = cb(value)<br>      next(ret)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      callback.reject(e)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加 catch 方法来处理错误</span><br>  <span class="hljs-built_in">this</span>.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onError</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onError)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加 finally 用于执行最后的操作</span><br>  <span class="hljs-built_in">this</span>.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onDone</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.then(onDone, onDone)<br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="resolve-和-reject"><a href="#resolve-和-reject" class="headerlink" title="resolve 和 reject"></a>resolve 和 reject</h4><p>实际应用中，可以使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 方法将非 Promise 实例包装为 Promise 实例，传入的参数可能有：</p>
<ul>
<li>无参数</li>
<li>普通数据参数</li>
<li>一个 Promise 实例</li>
<li>一个 thenable 对象（指具有 then 方法的对象）</li>
</ul>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> value<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>				<span class="hljs-keyword">const</span> &#123; then &#125; = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>          then(resolve)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve())<br>  &#125;<br>  <br>  <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      reject(value)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(arr)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([])<br>      <span class="hljs-keyword">var</span> remaining = args.length<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span> (<span class="hljs-params">i, val</span>) </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (val &amp;&amp; (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">const</span> &#123; then &#125; = val<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>              then.call(cal, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>                res(i, val)<br>              &#125;)<br>              <span class="hljs-keyword">return</span><br>            &#125;<br>          &#125;<br>          args[i] = val<br>          <span class="hljs-keyword">if</span> (--remaining === <span class="hljs-number">0</span>) &#123;<br>            resolve(args)<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>          reject(ex)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = args.length; i &lt; len; i++) &#123;<br>        res(i, args[i])<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = values.length; i &lt; len; i++) &#123;<br>        values[i].then(resolve, reject)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="完整模型"><a href="#完整模型" class="headerlink" title="完整模型"></a>完整模型</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br><br>  <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      handle(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>				reject<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onError</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onError)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onDone</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(onDone, onDone)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> value<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>          then(resolve)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve())<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      rejecy(value)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(arr)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([])<br>      <span class="hljs-keyword">let</span> remaining = args.length<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span> (<span class="hljs-params">i ,val</span>) </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (val &amp;&amp; (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">const</span> &#123; then &#125; = val<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>              then.call(val, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                res(i, val)<br>              &#125;, reject)<br>              <span class="hljs-keyword">return</span><br>            &#125;<br>          &#125;<br>          args[i] = val<br>          <span class="hljs-keyword">if</span> (--remaining === <span class="hljs-number">0</span>) &#123;<br>            resolve(args)<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>          reject(ex)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.length; i &lt; len; i++) &#123;<br>        res(i, args[i])<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = values.length; i &lt; len; i++) &#123;<br>        values[i].then(resolve, reject)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> ret<br>    <span class="hljs-keyword">try</span> &#123;<br>      ret = cb(value)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      callback.reject(e)<br>    &#125;<br>    callback.resolve(ret)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;funciton&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = newValue<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(newValue, resolve, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>      value = newValue<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (error &amp;&amp; (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;funciton&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = error<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(error, resolve, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;rejected&#x27;</span><br>      value = error<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCb</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (callbacks.length) &#123;<br>      <span class="hljs-keyword">const</span> fn = callbacks.shift()<br>      handle(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    fn(resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>    reject(ex)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">example</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> iter = example()<br>iter.next() <span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></div></td></tr></table></figure>

<p>上述代码定义了一个生成器函数，调用时并非立即执行该函数，而是返回一个生成器对象。每当调用生成器函数的 <code>next()</code> 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身执行。</p>
<p>与普通函数的区别：</p>
<ul>
<li>普通函数使用 <code>function</code> 声明，生成器函数使用 <code>function*</code> 声明；</li>
<li>普通函数使用 <code>return</code> 返回值，生成器函数使用 <code>yield</code> 返回值；</li>
<li>普通函数是 <code>run to completion</code> 模式，即开始执行后会一直执行到该函数的所有语句完成，在此期间其他代码语句不会执行；生成器函数是 <code>run pause run</code> 模式，即可以在函数运行中被暂停一次或多次，并在后面再恢复执行，暂停期间允许其他代码语句被执行。</li>
</ul>
<p>js 执行引擎是一个基于事件循环的单线程环境，当生成器运行时，会在一个叫 caller 的同一个线程中运行，执行的顺序是有序、确定的，并且永远不会发生并发。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>盒模型又称框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）四个要素。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069519.png" srcset="/img/three2.gif" lazyload class title="盒模型示意图">

<h4 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h4><p>由于 IE 模型的怪异模式，导致 IE 模型和标准模型的内容计算方式不同：</p>
<p><strong>IE 模型元素宽度 width = content + padding + border</strong>，高度计算相同：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069520.png" srcset="/img/three2.gif" lazyload class title="IE模型宽度计算示意图">

<p><strong>标准模型元素宽度 width = content</strong>，高度计算相同：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069521.png" srcset="/img/three2.gif" lazyload class title="标准模型计算示意图">

<h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>通过 CSS3 新增的属性 <code>box-sizing: content-box | border-box</code> 分别设置盒模型为标准模型（content-box） 和 IE 模型（border-box）。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid red;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">15px</span>;<br>&#125;<br><span class="hljs-selector-class">.content-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: content-box;<br>&#125;<br><span class="hljs-selector-class">.border-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>.content-box</code> 设置为标准模型，元素宽度 <code>wight = 100px</code>；</p>
<p><code>.border-box</code> 设置为 IE 模型，元素宽度为 <code>width = content + 2 * padding + 2 * border = 75px + 2 * 10px + 2 * 5px = 100px</code>。</p>
<h4 id="js-获取盒模型宽高"><a href="#js-获取盒模型宽高" class="headerlink" title="js 获取盒模型宽高"></a>js 获取盒模型宽高</h4><ol>
<li><code>dom.style.width/height</code>：只能获取到行内样式的宽和高，style 标签中和 link 外链中的样式取不到；</li>
<li><code>dom.currentStyle.width/height</code>：取到的是最终渲染后的宽和高，只有 IE 支持此属性；</li>
<li><code>window.getComputedStyle(dom).width/height</code>：取到的也是最终渲染的宽和高，多数浏览器支持（IE9 以上支持）；</li>
<li><code>dom.getBoundingClientRect().eidth/height</code>：得到渲染后的宽和高，大多数浏览器支持（IE9 以上支持），同时可以取到相对于视窗的上下左右的距离。</li>
</ol>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126170517922.png" srcset="/img/three2.gif" lazyload class title="js 获取 dom 宽高">

<blockquote>
<p>前三位取到的结果都是带单位的字符串类型值，第四种方法得到的是数字类型的值。</p>
</blockquote>
<h4 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h4><p>当两个垂直外边距相遇时，它们将合并为一个外边距，合并后的外边距高度等于两者较大者。</p>
<blockquote>
<p>注意：只有普通文档流中块级元素的垂直外边距才会发生外边距合并，行内元素、浮动元素或绝对定位之间的外边距不会合并。</p>
</blockquote>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069524.png" srcset="/img/three2.gif" lazyload class title="外边距重叠">

<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC（Block Formatting Context）：块级格式化上下文。</p>
<p>BFC 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计到可视化布局时，BFC 提供了一个环境，HTML 元素再这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环节中的布局。</p>
<h4 id="原理-渲染规则"><a href="#原理-渲染规则" class="headerlink" title="原理(渲染规则)"></a>原理(渲染规则)</h4><ul>
<li>BFC 内部的 Box 会再垂直方向一个接一个的放置</li>
<li>BFC 元素垂直方向的距离由 margin 决定，同属一个 BFC 的两个相邻 Box 的 margin 会发生重叠，若属于不同 BFC 则不会重叠</li>
<li>BFC 区域不会与浮动元素的布局重叠</li>
<li>BFC 元素是一个独立的容器，里外的元素不会相互影响</li>
<li>计算 BFC 高度时，浮动元素也会参数计算</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li><code>overflow</code> 不为 <code>visible</code> </li>
<li><code>float</code> 不为 <code>none</code> </li>
<li><code>position</code> 不为 <code>static | relative</code> </li>
<li><code>display</code> 为 <code>inline-block | table | table-cell | table-caption | flex | inline-flex</code> </li>
</ol>
<blockquote>
<p>注意：由于子元素浮动而引起的父元素高度丢失，可以再父元素创建 BFC 就可以使浮动子元素也参与高度计算。</p>
</blockquote>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC（Inline Formatting Context）：内联格式化上下文</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul>
<li>块级元素中仅包含内内联级别元素</li>
</ul>
<blockquote>
<p>需要注意当 IFC 中有 块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p>
</blockquote>
<h4 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h4><ul>
<li>子元素水平方向横向排列，并且垂直方向起点为元素顶部（即默认从左上开始从左到右依次排列）</li>
<li>子元素只会极端横向样式空间，垂直方向样式空间不会被计算（指垂直方向的 padding、border、margin）</li>
<li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li>
<li>能把在一行上的子元素全部包含进去的一个矩形边框，叫做该行的行框（line box）。其宽度取决于包含块以及其中的浮动来决定的</li>
<li>IFC 中的 line box 一般左右贴紧其包含块，但 float 元素会优先排列</li>
<li>IFC 中的 line box 的高度由 CSS 行高计算规则来确定，同个 IFC 下的多个 line box 高度可能不同</li>
<li>当 inline box 中子元素的总宽度少于包含它们的 inline box 时，其水平渲染规则由 text-align 属性值决定</li>
<li>当一个 inline box 超过父元素的宽度时，会被分割成多个 boxes，并分布在多个 line box 中；如果子元素未设置强制换行，则 inline box 将不可被分割而溢出父元素</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是 CSS 规则的一部分，处于 CSS 声明块前。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>简单选择器（Simple selectors）：通过 元素类型、class 或 id 匹配一个或多个元素</li>
<li>属性选择器（Attribute selectors）：通过 属性/属性值 匹配一个或多个元素</li>
<li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素…</li>
<li>伪元素（Pseudo-elements）：匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字…</li>
<li>组合器（Combinators）：以有效的方式组合两个或更多的选择器用于非常特定的选择的方法</li>
<li>多用选择器（Multiple selectors）：将以逗号分隔开的多个选择器放在一个 CSS 规则下面，以将一组声明应用于由这些选择器选择的所有元素</li>
</ul>
<h4 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h4><p><strong>类型选择器（元素选择器）</strong> </p>
<p>一个选择器名和指定的 HTML 元素名的不区分大小写的匹配。</p>
<p><strong>类选择器（Class selectors）</strong> </p>
<p>类选择器由一个点 <code>.</code> 以及后面的类名组成。类名是在 HTML 文档元素属性 class 中没有空格的任何值。</p>
<ul>
<li>文档中的多个元素可以具有相同的类名</li>
<li>单个元素可以由多个类名，用空格做间隔</li>
</ul>
<p><strong>ID 选择器</strong> </p>
<p>ID 选择器由一个哈希/磅符号 <code>#</code> 以及后面的 ID 名称组成。</p>
<ul>
<li>任何元素都可以使用 id 属性设置唯一的 ID 名称</li>
<li>这是选择单一元素最有效的方法</li>
</ul>
<blockquote>
<p>注意：一个 ID 名称必须在文件中是唯一的，在一些浏览器中只是第一个实例会计算，其余的将被忽略。</p>
</blockquote>
<p><strong>通用选择器</strong> </p>
<p>通用选择 <code>*</code> 允许选择在一个页面中的所有元素。</p>
<blockquote>
<p>注意：因为它适用于所有的元素，所以在大型页面使用可能对性能有明显的影响。</p>
</blockquote>
<h4 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h4><p>在 CSS 中，组合器允许将多个选择器组合在一起，四种可用的类型是：</p>
<ul>
<li>后代选择器 —— 空格 —— 选择嵌套在另一个元素中的某些元素（不一定是直系子代）</li>
<li>子选择器 —— <code>&gt;</code> —— 选择另一个元素的直接子元素</li>
<li>相邻兄弟选择器 —— <code>+</code> —— 选择另一个元素之后直接相连的兄弟元素（同层的相邻元素）</li>
<li>通用兄弟元素 —— <code>~</code> —— 选择一个元素之后的所有兄弟元素（同层的所有其他元素）</li>
</ul>
<blockquote>
<p>注意：相邻兄弟选择器和通用兄弟选择器只会向后选择，DOM 结构靠前的兄弟元素不在选择范围内。</p>
</blockquote>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>根据元素的属性和属性值来匹配元素，通用语法由 <code>[]</code> 组成，其中包含属性名称，后可跟可选条件一匹配属性的值。</p>
<p>可根据其匹配属性值的方式分为：</p>
<p><strong>存在和值（Presence and value）选择器</strong> </p>
<p>尝试匹配精确的属性值：</p>
<ul>
<li><code>[attr]</code>：选择包含 attr 属性的所有元素，不论 attr 的值是什么</li>
<li><code>[attr=val]</code>：仅选择 attr 属性被赋值为 val 的所有元素</li>
<li><code>[attr~=val]</code>：仅选择 attr 属性的值中包含 val 值的所有元素（多个值用空格做间隔）</li>
</ul>
<p><strong>子串值（Substring value）属性选择器</strong> </p>
<p>也被称为“伪正则选择器”，提供类似 regular expression 的灵活匹配方式：</p>
<ul>
<li><code>[attr|=val]</code>：选择 attr 属性的值 以 val 或 val- 开头的元素</li>
<li><code>[attr^=val]</code>：选择 attr 属性的值 以 val 开头的元素</li>
<li><code>[attr$=val]</code>：选择 attr 属性的值 以 val 结尾的元素</li>
<li><code>[attr*=val]</code>：选择 attr 属性的值中包含字符串 val 的元素</li>
</ul>
<blockquote>
<p>均包含 attr 属性就是 val 的情况。</p>
</blockquote>
<h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p><strong>伪类（Pseudo-class）</strong> </p>
<p>一个 CSS 伪类是一个以冒号 <code>:</code> 作为前缀的关键词。</p>
<p>当你需要样式在特定状态下才被呈现到指定的元素时，可以往元素的选择器后面加上对应的伪类。</p>
<p>伪类有：</p>
<table>
<thead>
<tr>
<th>伪类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>超链接点击之前的样式</td>
</tr>
<tr>
<td>:visited</td>
<td>超链接点击过后的样式</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标移上的样式</td>
</tr>
<tr>
<td>:actived</td>
<td>鼠标按下的样式</td>
</tr>
<tr>
<td>:focus</td>
<td>表单元素获取焦点的样式</td>
</tr>
<tr>
<td>:blur</td>
<td>表单元素失去焦点的样式</td>
</tr>
<tr>
<td>:checked</td>
<td>表单元素被选中的样式</td>
</tr>
<tr>
<td>:not(E)</td>
<td>匹配所有除 E 以外的元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>最后一个元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>n 表示具体的第几个，可以传入 odd/2n+1、even/2n 等</td>
</tr>
<tr>
<td>:only-child</td>
<td>本层级唯一的元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>倒数第 n 个元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>第一个同级兄弟元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>最后一个同级兄弟元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>唯一的一个兄弟元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>第 n 个同级的兄弟元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>倒数第 n 个同级的兄弟元素</td>
</tr>
<tr>
<td>:empty</td>
<td>空内容</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>匹配使用某种语言的元素</td>
</tr>
<tr>
<td>:target</td>
<td>匹配页面的 URI 中某个标识符的目标元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>未使用d 表单元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>不可用的表单元素</td>
</tr>
<tr>
<td>:root</td>
<td>匹配文档所有的根元素</td>
</tr>
</tbody></table>
<p><strong>伪元素（Pesudo-element）</strong> </p>
<p>以两个冒号 <code>::</code> 作为前缀的关键词，同样是添加到指定某个元素选择器的后面。</p>
<p>伪元素有：</p>
<table>
<thead>
<tr>
<th>伪元素</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>::after</td>
<td>可在元素的内容之后插入新内容，默认是一个行内元素<br>可使用属性 display 改变这一点</td>
</tr>
<tr>
<td>::before</td>
<td>与 ::after 类似，插入位置为内容之前</td>
</tr>
<tr>
<td>::first-letter</td>
<td>用于向文本的首字母设置特殊样式，只能用于块级元素</td>
</tr>
<tr>
<td>::first-line</td>
<td>用于向文本的首行设置特殊样式，只能用于块级元素</td>
</tr>
<tr>
<td>::selection</td>
<td>用于匹配突出显示的文本，浏览器默认情况下是深蓝背景白色字</td>
</tr>
<tr>
<td>::backdrop</td>
<td>任何处于全屏模式的元素下的即使渲染的盒子</td>
</tr>
</tbody></table>
<blockquote>
<p>大多数浏览器支持伪元素使用一个冒号或两个冒号两种表示方式。但 <code>::selection</code> 只能以两个冒号开头。</p>
</blockquote>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位允许从正常的文档流布局中取出元素，让他们具有不同的行为，使用 <code>position</code> 属性。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p><code>position</code> 属性用来指定一个元素在网页上的位置，一共有五种定位方式：</p>
<ul>
<li>static</li>
<li>relative</li>
<li>fixed</li>
<li>absolute</li>
<li>sticky（2017 年支持）</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>static</code> 是 <code>position</code> 属性的默认值，此时浏览器会按照源码的顺序，决定每个元素的位置，称为“正常的页面流”（normal flow）。</p>
<p>每个块级元素占据自己的区块（block），元素与元素之间不会重叠，这个位置就是元素的默认位置。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111720.jpg" srcset="/img/three2.gif" lazyload class title="static">

<blockquote>
<p>static 定位所导致的元素位置是浏览器自主决定的，这时 top、bottom、left、right 四个属性无效</p>
</blockquote>
<h4 id="relative-absolute-fixed"><a href="#relative-absolute-fixed" class="headerlink" title="relative, absolute, fixed"></a>relative, absolute, fixed</h4><p>这三个属性值都是相对于某个基点的定位，不同之处在于基点不同</p>
<p><strong>relative</strong> </p>
<p><code>relative</code> 表示，相对于默认位置（即 <code>static</code> 定位时的位置）进行偏移，即定位基点是元素的默认位置。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111721.jpg" srcset="/img/three2.gif" lazyload class title="relative">

<p>可以搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 四个属性一起使用，用来指定偏移的方向和距离。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111723.jpg" srcset="/img/three2.gif" lazyload class title="relative">

<p><strong>absolute</strong> </p>
<p><code>absolute</code> 表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。</p>
<p>限制条件：定位基点不能是 <code>static</code> 定位，否则定位基点就会变为整个页面的根元素 <code>html</code> 。</p>
<p>也需要搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111801.jpg" srcset="/img/three2.gif" lazyload class title="absolute">

<blockquote>
<p><code>absolute</code> 定位的元素会被“正常页面流”忽略，即在“正常页面流”中，该元素所占空间为零，周边元素不受影响。</p>
</blockquote>
<p><strong>fixed</strong> </p>
<p><code>fixed</code> 表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口，会导致元素的位置不会随页面滚动而变化，好像固定在网页上一样。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111802.jpg" srcset="/img/three2.gif" lazyload class title="fixed">

<p>一般搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p><code>sticky</code> 和之前四个属性值不一样，它会产生动态效果，很像 <code>relative</code> 和 <code>fixed</code> 的结合：一些时候是 <code>relative</code> 定位（定位基点是自身默认位置），另一些时候自动变成 <code>fixed</code> 定位（定位基点是视口）。</p>
<p><code>sticky</code> 生效的前提是必须搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 一起使用，不能省略，否则等同于 <code>relative</code> 定位，不产生动态固定的效果。</p>
<p>具体规则：当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 <code>sticky</code> 元素的距离达到生效门槛，<code>relative</code> 定位自动切换为 <code>fixed</code> 定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code> 定位自动切换回 <code>relative</code>。</p>
<blockquote>
<p>除 IE 外，其他浏览器均支持 sticky，但 Safari 浏览器需要加上前缀 <code>-webkit-</code>。</p>
</blockquote>
<p>应用场景：</p>
<ul>
<li>堆叠效果：（stacking）指的是页面滚动时，下方的元素覆盖上方的元素；</li>
<li>表格的表头锁定。</li>
</ul>
<blockquote>
<p>注意：表头锁定时 <code>sticky</code> 需要设在 <code>&lt;th&gt;</code> 元素上，不能设在 <code>&lt;thead&gt;</code> 和 <code>&lt;tr&gt;</code> 元素上，因为这两个元素没有 <code>relative</code> 定位，所以无法产生 <code>sticky</code> 效果</p>
</blockquote>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。给 flexbox 的子元素之间提供了强大的空空间分布和对齐能力。</p>
<h4 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h4><p>flex 布局中有两根轴线 —— 主轴和交叉轴。</p>
<p>主轴由 <code>flex-direction</code> 定义，可取值：</p>
<ul>
<li><code>row</code>：主轴沿着 inline 方向延伸</li>
<li><code>row-reverse</code>：沿着 inline 方向逆向延伸</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics1.png" srcset="/img/three2.gif" lazyload class title="flex:row">

<ul>
<li><code>column</code>：主轴沿着 block 排列的方向延伸</li>
<li><code>column-reverse</code>：于 column 相逆</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics2.png" srcset="/img/three2.gif" lazyload class title="flex:column">

<p>交叉轴垂直于主轴：</p>
<ul>
<li><code>flex-direction</code> (主轴) 设成了 <code>row</code> 或 <code>row-reverse</code>，则交叉轴的方向沿着列向下；</li>
<li>主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向</li>
</ul>
<h4 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h4><p>如果 <code>flex-direction</code> 是 <code>row</code>，书写英文时，则主轴的起始线是左边，终止线是右边：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics5.png" srcset="/img/three2.gif" lazyload class title="row英文">

<p>若书写阿拉伯文，则主轴起始线是右边，终止线是左边：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics6.png" srcset="/img/three2.gif" lazyload class title="row阿拉伯文">

<p>在这两种情况下，交叉轴的起始线是flex容器的顶部，终止线是底部，因为两种语言都是水平书写模式。</p>
<h4 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h4><p>文档中使用了 flexbox 的区域就叫做 flex 容器，创建 flex 容器需要将其 <code>display</code> 属性值改为 <code>flex</code> 或 <code>inline-flex</code>，容器中的直系子元素就会变为 flex 元素，flex 容器中的所有 flex 元素都会有下列默认行为：</p>
<ul>
<li>元素排列为一行（<code>flex-direction</code> 属性的初始值是 <code>row</code>）</li>
<li>元素从主轴的起始线开始</li>
<li>元素不会在主维度方向拉伸，但是可以缩小</li>
<li>元素被拉伸来填充交叉轴大小</li>
<li><code>flex-basis</code> 属性为 <code>auto</code> </li>
<li><code>flex-wrap</code> 属性为 <code>nowrap</code> </li>
</ul>
<h5 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h5><p>在 flex 容器中添加 <code>flex-direction</code> 属性可以更改 flex 元素的排列方向。</p>
<p><code>-reverse</code> 会让元素沿着 <code>row</code> 或 <code>column</code> 的方向显示，但 起始线和终止线位置会交换</p>
<h5 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h5><p>需要实现多行效果可以为属性 <code>flex-wrap</code> 添加一个属性值 <code>wrap</code>，项目的子元素若超出容器最大宽度则会换行显示。</p>
<h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>可以将 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性组合为简写属性 <code>flex-flow</code>，该属性第一个指定的值为 <code>flex-direction</code>，第二个指定的值为 <code>flex-wrap</code>。</p>
<h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p><code>align-items</code> 属性可以使元素在<strong>交叉轴方向对齐</strong>，初始值为 <code>stretch</code>，所以 flex 元素会默认被拉伸到最高元素的高度 —— 最高的元素定义了容器的高度。</p>
<p>可选值有：</p>
<ul>
<li><code>stretch</code>：默认值，拉伸；</li>
<li><code>flex-start</code>：按 flex 容器的交叉轴起始线对齐；</li>
<li><code>flex-end</code>：按 flex 容器的交叉轴终止线对齐；</li>
<li><code>center</code>：按交叉轴居中对齐</li>
</ul>
<h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h5><p><code>justify-content</code> 属性使元素在<strong>主轴方向对齐</strong>，即通过 <code>flex-direction</code> 设置的方向。初始值为 <code>flex-start</code>，元素从主轴起始线排列。</p>
<p>可选值有：</p>
<ul>
<li><code>stretch</code>：拉伸；</li>
<li><code>flex-start</code>：按主轴起始线对齐；</li>
<li><code>flex-end</code>：按主轴终止线对齐；</li>
<li><code>center</code>：按主轴居中对齐；</li>
<li><code>space-around</code>：将可用空间平均分配为元素间的间隔后居中对齐，包括两侧（两侧所占比例为中间间隔的一半）；</li>
<li><code>space-between</code>：同 <code>space-around</code>，但不包括两侧</li>
</ul>
<h4 id="flex-元素"><a href="#flex-元素" class="headerlink" title="flex 元素"></a>flex 元素</h4><p>为了更好地控制 flex 属性，有三个属性可以作用于它们：</p>
<ul>
<li><code>flex-grow</code> </li>
<li><code>flex-shrink</code> </li>
<li><code>flex-basis</code> </li>
</ul>
<h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h5><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器中除了元素所占的空间以外的富余空间就是可用空间，该属性的默认值为 <code>auto</code>。</p>
<p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容（content）的尺寸。</p>
<h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h5><p><code>flex-grow</code> 若被赋值为一个正整数，flex 元素会以 <code>flex-basis</code> 为基础，沿主轴方向增长尺寸。这会使该元素扩展，并占据该方向轴上的可用空间。</p>
<p>若有多个 flex 元素设定了 <code>flex-grow</code> 属性值，则它们将按找属性值的比例平分对应的可用空间。</p>
<h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h5><p><code>flex-shrink</code> 属性是处理 flex 元素收缩的问题。若 flex 容器中没有足够排列 flex 元素的空间，则可以把 flex 元素的 <code>flex-shrink</code> 属性设置为正整数来缩小它所占空间到 <code>flex-basis</code> 以下。</p>
<h5 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h5><p>以上三个属性很少单独使用，而是混合写在 <code>flex</code> 简写形式中，它允许把三个数值按这个顺序书写 —— <code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>。</p>
<p>预定义：</p>
<ul>
<li><code>flex: initial</code>：把 flex 元素重置为 flexbox 的初始值，相当于 <code>flex: 0 1 auto</code>；<ul>
<li><code>flex-grow</code> 的值为 0，所以 flex 元素不会超过它们 <code>flex-basis</code> 的尺寸；</li>
<li><code>flex-shrink</code> 的值为 1，所以可以缩小 flex 元素来防止它们溢出；</li>
<li><code>flex-basis</code> 的值为 auto，flex 元素尺寸可以是在主维度上设置也可以是根据内容自动得到。</li>
</ul>
</li>
<li><code>flex: auto</code>：等同于 <code>flex: 1 1 auto</code>，基本于 <code>initial</code> 相同，但此种在需要的时候既可以拉伸也可以收缩；</li>
<li><code>flex: none</code>：可以把 flex 元素设置为不可伸缩，等同于 <code>flex: 0 0 auto</code>，元素不能拉伸或收缩，但是元素会按具有 <code>flex-basis: auto</code> 属性的 flexbox 进行布局。</li>
</ul>
<blockquote>
<p>常见的 <code>flex: 1</code> 等等，相当于 <code>flex: 1 1 0</code>，元素可以在 <code>flex-basis</code> 为 0 的基础上伸缩。</p>
</blockquote>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ol>
<li>决定了 css 规则怎样被浏览器解析直到生效；</li>
<li>当多个相同样式被应用到同一个元素上时，权重是一个决定哪种样式生效，或者决定优先级的过程；</li>
<li>每个选择器都有自己的权重；</li>
<li>两个选择器同时作用到一个元素上，权重高者生效。</li>
</ol>
<p><strong>从 0 开始，一个行内样式  + 1000，一个 id 选择器 + 100，一个属性、伪类或者 class 选择器 + 10，一个元素或者伪元素选择器 + 1，通配符 + 0</strong> 。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-b1a9fedf320754acb1d7766c6548d5f6_720w.jpg" srcset="/img/three2.gif" lazyload class title="css权重值">

<ol>
<li>同样权重，样式重复多写则后写的覆盖前面的；</li>
<li>不同权重，则权重高者生效。</li>
</ol>
<h4 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h4><p><code>!important</code> 的作用是提升样式优先级，若加上则此条样式优先级变为最高。</p>
<ol>
<li>同个样式都使用了 <code>!important</code> 样式则权重高者优先；</li>
<li>若 <code>!important</code> 作用于简写的样式属性，则此条简写样式所代表的子属性都会被作用上 <code>!important</code>。<ul>
<li>比如 <code>flex</code>、<code>background</code>、<code>border</code>…</li>
</ul>
</li>
</ol>
<h4 id="行内-外联-内联"><a href="#行内-外联-内联" class="headerlink" title="行内 外联 内联"></a>行内 外联 内联</h4><ul>
<li>行内样式始终要比外联或者内联的优先级高</li>
<li>内联样式和外联样式的优先级和加载顺序有关</li>
<li><code>!important</code> &gt; 行内样式 &gt; 内联外联样式</li>
</ul>
<blockquote>
<p>补充：样式作用于非目标标签上时，则离目标接近者优先</p>
</blockquote>
<h3 id="圣杯-amp-双飞翼"><a href="#圣杯-amp-双飞翼" class="headerlink" title="圣杯&amp;双飞翼"></a>圣杯&amp;双飞翼</h3><p>圣杯布局和双飞翼布局从字面上的意思是：一个像圣杯或者像展翅的禽类这样的布局，就是<strong>左右两栏固定宽度，中间部分自适应的三栏布局</strong>。</p>


<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ol>
<li>首先将 left、middle、right 都放出来；</li>
<li>给三个元素设置 <code>float: left; position: relative;</code>，脱离文档流；</li>
<li>给三个元素的父元素 container 设置 <code>overflow: hidden;</code> 形成 BFC 防止浮动塌陷；</li>
<li>left、right 设置上各自的宽度；</li>
<li>middle 设置 <code>width: 100%;</code>；</li>
<li>left 设置 <code>left: -leftWidth;</code>，right 设置 <code>right: -rightWidth;</code>；</li>
<li>containter 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>，防止左右内容遮挡 middle 的内容。</li>
</ol>
<p>代码实例：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span>,</span><br><span class="css">    <span class="hljs-selector-class">.right</span>,</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">right</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>      middle<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>      left<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>      right<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129122542330.png" srcset="/img/three2.gif" lazyload class title="圣杯布局">

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局和圣杯布局很类似，就是在 middle 的 div 里又插入一个 div，通过调整内部 div 的 margin 值，实现中间栏自适应。</p>
<ol>
<li>middle 中增加 inner；</li>
<li>left 设置 <code>margin-left: -100%;</code>，right 设置 <code>margin-right: -rightWidth;</code>；</li>
<li>container 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>。</li>
</ol>
<p>代码实例：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span>,</span><br><span class="css">    <span class="hljs-selector-class">.right</span>,</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.inner</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: blue;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>        middle - inner<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>      left<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>      right<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129124500728.png" srcset="/img/three2.gif" lazyload class title="双飞翼布局">

<ul>
<li>圣杯布局在DOM结构上显得更加直观和自然；</li>
<li>双飞翼布局省去了很多css，而且由于不用使用定位，可以获得比圣杯布局更小最小宽度。</li>
</ul>
<blockquote>
<p>由于双飞翼布局会一直随着浏览器可视区域宽度减小从而不断挤压中间部分宽度，所以需要设置给页面一个 <code>min-width &gt; LeftWidth + RightWidth</code> </p>
</blockquote>
<h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>CSS3 过渡是元素从一种样式逐渐改变为另一种样式的效果，必须指定的两项内容：要添加过渡的 CSS 属性以及效果的持续时间。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: CSS 属性, 花费时间, 效果曲线(默认ease), 延迟时间;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 宽度从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s，0.2s 后执行过渡 */</span><br><span class="hljs-attribute">transition</span>: width, .<span class="hljs-number">5s</span>, ease, .<span class="hljs-number">2s</span>;<br><span class="hljs-comment">/* 所有属性从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s */</span><br><span class="hljs-attribute">transition</span>: all, .<span class="hljs-number">5s</span>;<br></code></pre></div></td></tr></table></figure>

<p>也可以分开写各个属性：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-property</span>: width;<br><span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">1s</span>;<br><span class="hljs-attribute">transition-timing-function</span>: linear;<br><span class="hljs-attribute">transition-delay</span>: <span class="hljs-number">2s</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: 动画名称 一个周期时间 运动曲线(默认ease) 动画延迟(默认<span class="hljs-number">0</span>) 播放次数(默认<span class="hljs-number">1</span>) 是否反向播放动画(默认normal) 是否暂停动画(默认running);<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear;<br><span class="hljs-comment">/* 2s 后执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear <span class="hljs-number">2s</span>;<br><span class="hljs-comment">/* 无限执行 logo-line 动画，每次运动时间 2s，运动曲线为 linear，并且执行反向动画 */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear alternate infinite;<br></code></pre></div></td></tr></table></figure>

<p>还有一个重要属性：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-fill-mode</span>: none | forwards | backwards | both;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>none：不改变默认行为；</li>
<li>forwards：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）；</li>
<li>backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）；</li>
<li>both：向前和向后填充模式都被应用。</li>
</ul>
<h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><p>分为 2D 转换 和 3D 转换</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: 适用于 <span class="hljs-number">2</span>D 或者 <span class="hljs-number">3</span>D 变换的元素;<br><span class="hljs-attribute">transform-origin</span>: 转换元素的位置转换元素的位置。默认(x,y,z):(<span class="hljs-number">50%</span>,<span class="hljs-number">50%</span>,<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">30px</span>, <span class="hljs-number">30px</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">8</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">10deg</span>, <span class="hljs-number">10deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate3d</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">90deg</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h4><p>CSS3 提供了一些新的选择器：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd2d.png" srcset="/img/three2.gif" lazyload class title="CSS3选择器">

<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认从里往外）;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#888</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p><strong>边框图片</strong>：</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-image</span>: 图片url 图像边界向内偏移 图像边界的宽度（默认为边框的宽度） 用于指定字啊边框外部绘制偏移的量（默认<span class="hljs-number">0</span>） 铺满方式（默认拉伸，repeat 重复、stretch 拉伸 或 round 铺满）;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid transparent;<br>  <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>);<br>  <span class="hljs-attribute">border-image-slice</span>: <span class="hljs-number">30</span>;<br>  <span class="hljs-attribute">border-image-repeat</span>: round;<br>  <span class="hljs-attribute">border-image-outset</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>边框圆角</strong>：</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: 左上 右上 右下 左下;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span> <span class="hljs-number">0</span> <span class="hljs-number">25px</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h5><p>制定背景绘制（显示）区域，默认从边框（border-box）开始绘制。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqt.png" srcset="/img/three2.gif" lazyload class title="border-box">

<p>从 padding 开始绘制，不算 border：<code>background-clip: padding-box;</code> </p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqv.png" srcset="/img/three2.gif" lazyload class title="padding-box">

<p>只在内容区绘制，不算 padding 和 border：<code>background-clip: content-box;</code> </p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqy.png" srcset="/img/three2.gif" lazyload class title="content-box">

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p><code>background-origin</code> 属性指定 <code>background-position</code> 属性应该是相对位置。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> dashed black;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">35px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;logo.png&#x27;</span>) no-repeat, <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVZGAM.jpeg" srcset="/img/three2.gif" lazyload class title="background-origin">

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>制定背景的大小。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgk7.png" srcset="/img/three2.gif" lazyload class title="background-size">

<h5 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h5><p>实例:</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;test.png&#x27;</span>) no-repeat left, <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;logo.png&#x27;</span>) no-repeat right;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTglS.png" srcset="/img/three2.gif" lazyload class title="多张背景图">

<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>也可以说是倒影。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">-webkit-box-reflect: 方向[ above-上 | below-下 | right-右 | left-左 ], 偏移量, 遮罩图片;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 下倒影 */</span><br>-webkit-box-reflect: below;<br><span class="hljs-comment">/* 右倒影同时有偏移 */</span><br>-webkit-box-reflect: right <span class="hljs-number">10px</span>;<br><span class="hljs-comment">/* 下阴影渐变 */</span><br>-webkit-box-reflect: below <span class="hljs-number">0</span> <span class="hljs-built_in">linear-gradient</span>(transparent, white);<br><span class="hljs-comment">/* 下阴影图片遮罩 */</span><br>-webkit-box-reflect: below <span class="hljs-number">0</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">shou.png</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-break</span>: normal | break-all | keep-all;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgo9.png" srcset="/img/three2.gif" lazyload class title="word-break">

<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-wrap</span>: normal | break-word;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220130163149441.png" srcset="/img/three2.gif" lazyload class title="word-wrap">

<h5 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-line-camp: <span class="hljs-number">2</span>;<br>  -webkit-box-orient: vertical;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd6V.png" srcset="/img/three2.gif" lazyload class title="文字多行超出省略号">

<h5 id="阴影-1"><a href="#阴影-1" class="headerlink" title="阴影"></a>阴影</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: 水平阴影 垂直阴影 模糊距离 阴影颜色;<br></code></pre></div></td></tr></table></figure>

<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>CSS3 提供了新的颜色表示方法。</p>
<h5 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h5><p>rgb 为颜色值，a 为透明度（0 ~ 1）</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">5</span>);<br></code></pre></div></td></tr></table></figure>

<h5 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h5><p>h：色相，s：饱和度，l：亮度，a：透明度</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-built_in">hsla</span>(<span class="hljs-number">112</span>, <span class="hljs-number">72%</span>, <span class="hljs-number">33%</span>, .<span class="hljs-number">68</span>);<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsla</span>(<span class="hljs-number">49</span>, <span class="hljs-number">65%</span>, <span class="hljs-number">60%</span>, .<span class="hljs-number">68</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>CSS3 提供了线性渐变，径向渐变，圆锥渐变。</p>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>CSS3 滤镜（Filter）</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 黑白色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br><span class="hljs-comment">/* 褐色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">sepia</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/* 饱和度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">saturate</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">/* 色相反转 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">90deg</span>);<br><span class="hljs-comment">/* 反色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">invert</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/* 透明度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">opacity</span>(.<span class="hljs-number">5</span>);<br><span class="hljs-comment">/* 亮度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">brightness</span>(.<span class="hljs-number">5</span>);<br><span class="hljs-comment">/* 对比度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">contrast</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">/* 模糊 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);<br><span class="hljs-comment">/* 阴影 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#000</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="弹性布局-amp-栅格布局"><a href="#弹性布局-amp-栅格布局" class="headerlink" title="弹性布局 &amp; 栅格布局"></a>弹性布局 &amp; 栅格布局</h4><p>也就是 Flex 和 grid</p>
<h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>使用 <code>column-count</code> 设定分列列数，<code>colum-rule</code> 设定分隔样式。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  -webkit-<span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  -moz-<span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  -webkit-<span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  -moz-<span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgRx.png" srcset="/img/three2.gif" lazyload class title="多列布局">

<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>) &#123;</span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: darkgoldenrod;</span><br><span class="css">    &#125;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;</span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: lightgreen;</span><br><span class="css">    &#125;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>重置浏览器窗口查看效果！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgPW.gif" srcset="/img/three2.gif" lazyload class title="监听屏幕尺寸改变样式">

<h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>CSS3 的混合模式，有两种写法：<code>background-blend-mode</code> 和 <code>mix-blend-mode</code>。</p>
<p>区别在于 <code>background-blend-mode</code> 是用于同一个元素的背景图片和背景颜色的。</p>
<h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p>书写 CSS 的几个阶段：</p>
<ol>
<li>手写原生 CSS；</li>
<li>使用预处理器 Sass/Less；</li>
<li>使用后处理器 PostCSS；</li>
<li>使用 css modules；</li>
<li>使用 css in js。</li>
</ol>
<h4 id="手写原生-CSS"><a href="#手写原生-CSS" class="headerlink" title="手写原生 CSS"></a>手写原生 CSS</h4><p>写 CSS 的几种情况：</p>
<ul>
<li>行内样式：直接在 html 元素的  style 属性中编写 css 代码；</li>
<li>内嵌样式：在 head 中的 style 标签内编写；</li>
<li>导入样式：在内联样式中通过 @import 方法，导入其他样式；</li>
<li>外部样式：使用 html 的 link 标签加载样式。</li>
</ul>
<blockquote>
<p>使用行内样式的缺点：</p>
<ul>
<li>样式不能复用；</li>
<li>样式权重过高，样式不好覆盖；</li>
<li>表现层与结构层没有分离；</li>
<li>不能进行缓存，影响加载效率。</li>
</ul>
</blockquote>
<p>不建议使用导入样式的原因：</p>
<ol>
<li>在 IE6-8 下，@import 声明指向的样式表并不会与页面其他资源并发加载，而是等页面所有资源加载完成后才开始下载；</li>
<li>如果在 link 标签中去 @import 其他 css，页面会等到所有资源加载完成后，才开始解析 link 标签中 @import 的 css。</li>
</ol>
<blockquote>
<p>使用导入样式的缺点：</p>
<ul>
<li>导入样式，只能放在 style 标签的第一行，放其他行会无效；</li>
<li>@import 声明的样式不能充分利用浏览器并发请求资源的行为，其加载行为往往会延后触发或被其他资源加载挂起；</li>
<li>由于 @import 样式表的延后加载，可能会导致页面样式闪烁。</li>
</ul>
</blockquote>
<h4 id="预处理器-Sass-Less"><a href="#预处理器-Sass-Less" class="headerlink" title="预处理器 Sass/Less"></a>预处理器 Sass/Less</h4><p>预处理器主要是强化了 css 的语法，弥补了原生 css 不支持变量、嵌套、父选择器种种问题，但打包出来的结果和原生的 css 是一样的。</p>
<h4 id="后处理器-PostCSS"><a href="#后处理器-PostCSS" class="headerlink" title="后处理器 PostCSS"></a>后处理器 PostCSS</h4><p>PostCSS 可以称作为 CSS 界的 babel，实现原理是通过 ast 去分析 css 代码，然后将分析的结果进行处理。</p>
<p>常用的 PostCSS 使用场景有：</p>
<ol>
<li>配合 stylelint 校验 css 语法；</li>
<li>自动增加浏览器前缀 autoprefixer；</li>
<li>编译 css next 的语法</li>
</ol>
<h4 id="CSS-模块化实现方式"><a href="#CSS-模块化实现方式" class="headerlink" title="CSS 模块化实现方式"></a>CSS 模块化实现方式</h4><h5 id="BEM-命名规范"><a href="#BEM-命名规范" class="headerlink" title="BEM 命名规范"></a>BEM 命名规范</h5><p>BEM 的意思就是 块（block）、元素（element）、修饰符（modifier），是由 Yandex 团队提出的一种前端命名方法论。</p>
<p>命名规则如下：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 块即是通常所说的 Web 应用开发中的组件或模块，每个块在逻辑上和功能上都是相互独立的。 */</span><br><span class="hljs-selector-class">.block</span> &#123;<br>&#125;<br><br><span class="hljs-comment">/* 元素是块中的组成部分。元素不能离开块来使用。BEM 不推荐在元素中嵌套其他元素。 */</span><br><span class="hljs-selector-class">.block__element</span> &#123;<br>&#125;<br><br><span class="hljs-comment">/* 修饰符用来定义块或元素的外观和行为。同样的块在应用不同的修饰符之后，会有不同的外观。 */</span><br><span class="hljs-selector-class">.block--modifier</span> &#123;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>通过 BEM 的命名规范，可以让我们的 css 代码层次结构清晰，通过严格的命名也可以也解决命名冲突的问题，但无法完全避免。</p>
<h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>指像 import js 一样去引入 css 代码，代码中的每一个类名都是引入对象的一个属性，通过这种方式，即可在使用时明确指定所引用的 css 样式。</p>
<p>并且 CSS Modules 在打包的时候会自动将类名转换成 hash 值，完全杜绝 css 类名冲突的问题。</p>
<h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h4><p>CSS in JS，意思就是使用 js 语言写 css，完全不需要写单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。</p>
<p>CSS in JS 其实是一种编写思想，有很多方案的实现，最出名的是 <code>styled-components</code> </p>
<p>除此之外，还有：<code>emotion</code>、<code>radium</code>、<code>glamorous</code>…</p>


<h3 id="CSS-性能优化"><a href="#CSS-性能优化" class="headerlink" title="CSS 性能优化"></a>CSS 性能优化</h3><p>提高新能的方法：</p>
<ol>
<li>合并 css 文件，如果页面加载 10 个 css 文件，每个文件 1k，那么也要比只加载一个 100k 的 css 文件慢；</li>
<li>减少 css 嵌套，最好不要嵌套三层以上；</li>
<li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能；</li>
<li>建立公共样式类，把相同样式提取出来作为公共类使用；</li>
<li>减少通配符 <code>*</code> 或者类似 <code>[hidden=&quot;true&quot;]</code> 这类选择器的使用，挨个查找所有性能很差；</li>
<li>巧妙运用 css 的继承机制，如果父节点定义了，子节点就无需定义；</li>
<li>拆分出公共 css 文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独 css 文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定；</li>
<li>不用 css 表达式，表达式只会让代码显得更加酷炫，但是对性能的浪费特别大；</li>
<li>少用 css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择 normolize.css；</li>
<li>cssSprite，合成所有icon图片，用宽高加上 <code>background-position</code> 的背景图方式显现 icon 图，这样很实用，减少了http请求；</li>
<li>善后工作，css 压缩(在线压缩工具 YUI Compressor)；</li>
<li>GZIP 压缩，是一种流行的文件压缩算法。</li>
</ol>
<blockquote>
<p> 避免使用 @import，外部的 css 文件中使用 @import 会使得页面在加载时增加额外的延迟；</p>
</blockquote>
<blockquote>
<p>避免过分重排；</p>
</blockquote>
<ul>
<li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做重排 reflow；</li>
<li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，就是重排 reflow；</li>
<li>页面上任何一个节点触发 reflow，会导致它的子节点和祖先节点重新渲染；</li>
<li>导致 reflow发生的情况有：<ol>
<li>改变窗口的大小；</li>
<li>改变文字的大小；</li>
<li>增加、删除样式表；</li>
<li>内容的改变，输入框输入内容也会；</li>
<li>伪类的激活；</li>
<li>操作 class 属性；</li>
<li>脚本操作 dom，js 改变 css 类；</li>
<li>计算 offsetWidth 和 offsetHeight；</li>
<li>设置 style 属性；</li>
<li>改变元素的内外边距。</li>
</ol>
</li>
<li>常见重排元素：<ul>
<li>大小有关的 width,height,padding,margin,border-width,border,min-height</li>
<li>布局有关的 display,top,position,float,left,right,bottom</li>
<li>字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</li>
<li>隐藏有关的 overflow,overflow-x,overflow-y</li>
</ul>
</li>
<li>减少 reflow 对性能影响的建议：<ol>
<li>不要一条一条的修改 dom 的样式，预先定义好 class，然后修改 dom 的 classname；</li>
<li>不要修改范围比较大的 dom；</li>
<li>为动画元素使用绝对定位；</li>
<li>不要 table 布局，因为一个很小的改动会造成整个 table 重新布局；</li>
<li>避免设置大量的 style 属性，最好使用 class 属性；</li>
<li>如果 css 里面有计算表达式，每次都会重新计算一遍，触发一次 reflow。</li>
</ol>
</li>
</ul>
<blockquote>
<p>repaint - 重绘</p>
</blockquote>
<ol>
<li>当一个元素的外观被改变，但是布局没有改变的情况；</li>
<li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li>
<li>常见的重绘元素<ul>
<li>颜色 color,background</li>
<li>边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</li>
<li>背景有关 background,backgound-image,background-position,background-repeat,background-size</li>
</ul>
</li>
</ol>
<blockquote>
<p>CSS 动画</p>
</blockquote>
<ol>
<li>css 动画启用 GPU 加速，应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成：<ul>
<li>canvans 2D、布局合成、CSS3 转换、CSS 3D变换、webGL、视频…</li>
</ul>
</li>
</ol>
<blockquote>
<p>文件压缩</p>
</blockquote>
<p>文件的大小会直接影响到浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具 webpack，gulp/grunt，rollup 压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p>
<blockquote>
<p>去除无用 CSS</p>
</blockquote>
<ol>
<li>不同元素或者其他情况下的重复代码；</li>
<li>整个页面内没有生效的CSS代码</li>
</ol>
<blockquote>
<p>有选择地使用选择器</p>
</blockquote>
<p>CSS 选择器的匹配是从右往左进行的，原因：css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p>
<p>在使用选择器时，尽量要遵循：</p>
<ol>
<li>保持简单，不要使用嵌套过多过于复杂的选择器；</li>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，要尽量避免使用；</li>
<li>不要使用 类选择器 和 ID 选择器 修饰元素标签，如：<code>h3#markdown-content</code>，这多此一举，还会降低效率；</li>
<li>不要为了追求速度而放弃可读性和可维护性。</li>
</ol>
<blockquote>
<p>减少使用昂贵的属性</p>
</blockquote>
<p>应该尽量减少使用昂贵属性，如：box-shadow, border-radius, filter, 透明度, :nth-child …</p>
<p>有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p>
<blockquote>
<p>硬件加速的好坏</p>
</blockquote>
<ol>
<li>仅仅依靠 GPU 还是不行的，许多动画还是需要 CPU 的介入，连接 CPU 和 GPU 的总带宽不是无限的，所以需要注意数据在 CPU 和 GPU 之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输；</li>
<li>要了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存；</li>
<li>每一个 dom 元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层；</li>
<li>另一个重点是保持 GPU 和 CPU 之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给 GPU；</li>
<li>动画开始之后避免层的更新，避免动画进行中其他层一直更新导致拥堵；</li>
<li>尽量使用这些 css 属性来实现动画：transformation, opacity, filter；</li>
<li>使用性能工具检测优化的合理性，timeline 检测优化是否合理，还需要实现自动操作来做性能回归测试；</li>
</ol>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。</p>
<p>如果一个元素含有层叠上下文，可以理解为这个元素在 z 轴 上就高人一等，离用户更近。</p>
<h4 id="层叠水平"><a href="#层叠水平" class="headerlink" title="层叠水平"></a>层叠水平</h4><p>层叠水平（stacking level），决定了同一个层叠上下文中元素在 z 轴上的显示顺序。</p>
<p>普通元素的层叠水平优先由层叠上下文决定，因此层叠水平的比较只有在当前层叠上下文元素中才有意义。</p>
<blockquote>
<p>注意：不可以把层叠水平和 CSS 的 z-index 属性混为一谈，某些情况下 z-index 确实可以影响层叠水平，但只限于定位元素以及 flex 盒子的子元素，而层叠水平所有的元素都存在。</p>
</blockquote>
<h4 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h4><p>层叠顺序（stacking order），表示当元素发生层叠时有着特定的垂直显示顺序，上面的层叠上下文和层叠水平是概念，而层叠顺序是规则。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214173741026.png" srcset="/img/three2.gif" lazyload class title="层叠顺序">

<ol>
<li>位于最低水平的 <code>border/background</code> 指层叠上下文元素的边框和背景，每一个层叠顺序规则适用于一个完整的层叠上下文元素；</li>
<li><code>z-index: auto</code> 和 <code>z-index: 0</code> 单纯从层叠水平上看，是可以认为是一样的，但实际上两者在层叠上下文领域有着根本性的差异。</li>
</ol>
<h4 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h4><p>当元素发生层叠时，其覆盖关系遵循以下两个准则：</p>
<ol>
<li><strong>谁大谁上</strong>：当具有明显的层叠水平标示时（如 z-index 值），在统一个层叠上下文领域，层叠水平值大的哪一个覆盖小的那一个；</li>
<li><strong>后来居上</strong>：当元素的层叠水平一致、层叠顺序相同时，在 DOM 流中处于后面的元素覆盖前面的元素。</li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>层叠上下文的层叠水平要比普通元素高；</li>
<li>层叠上下文可以阻断元素的混合模式；</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受限于外部的层叠上下文；</li>
<li>每个层叠上下文和兄弟元素独立，也就是进行层叠变化或渲染时，只需要考虑后代元素；</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中。</li>
</ul>
<h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>根层叠上下文：页面根元素 <code>&lt;html&gt;</code> 天生具有层叠上下文；</p>
<p>传统层叠上下文：</p>
<p>对于包含有 <code>position: relative</code> / <code>position: absolute</code> 的定位元素，以及 FireFox/IE 浏览器下含有 <code>position: fixed</code> 声明的定位元素，当其 <code>z-index</code> 值不是 <code>auto</code> 的时候就会创建层叠上下文；</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm1.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm2.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>上面的效果为 mm1 覆盖在 mm2 上面，因为两者处于同一个层叠上下文中，且 mm1 图片的 z-index 更大；</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm1.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute; z-index: 2;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm2.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 1;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>稍作修改，效果就会反转，mm1 被 mm2 覆盖，因为两个 div 的 z-index 不再是 auto 而是数值，所以分别创建了层叠上下文，故两张图片不在同一个层叠上下文中，层叠顺序相同，层叠准则遵循后来居上。</p>
<p>其他 CSS3 属性：</p>
<ul>
<li><code>z-index</code> 不为 <code>auto</code> 的 <code>flex</code> 项（父元素 <code>display: flex|inline-flex</code>）；</li>
<li>元素的 <code>opacity</code> 值不是 1；</li>
<li>元素的 <code>transform</code> 值不是 <code>none</code>；</li>
<li>元素的 <a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/"><code>mix-blend-mode</code></a> 值不是 <code>normal</code>；</li>
<li>元素的 <code>filter</code> 值不是 <code>none</code>；</li>
<li>元素的 <a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=5155"><code>isolation</code></a> 值不是 <code>isolate</code>；</li>
<li><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/"><code>will-change</code> </a>指定的属性值为上面的任意一个；</li>
<li>元素的 <code>-webkit-overflow-scrolling</code> 设为 <code>touch</code>。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一旦普通元素具有了层叠上下文，其层叠顺序就会变高，层叠顺序与 <code>z-index: 0</code> 同一位置：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214182400866.png" srcset="/img/three2.gif" lazyload class title="层叠顺序">

<p>定位元素层叠在普通元素上的根本原因在于：元素一旦成为定位元素，其 <code>z-index</code> 就会生效，此时其 <code>z-index</code> 就是默认的 <code>auto</code> 也就是 0 级别，也就会覆盖 <code>inline</code> 或 <code>block</code> 或 <code>float</code> 元素。</p>
<blockquote>
<p>CSS3 的 fadeIn 淡入 animation 效果本质上就是元素 <code>opacity</code> 透明度的变化，而当 <code>opacity</code> 的值不是 1 的时候，是具有层叠上下文的。</p>
</blockquote>
<h3 id="div-居中"><a href="#div-居中" class="headerlink" title="div 居中"></a>div 居中</h3><h4 id="div-水平垂直居中"><a href="#div-水平垂直居中" class="headerlink" title="div 水平垂直居中"></a>div 水平垂直居中</h4><h5 id="flex-布局实现-已知宽"><a href="#flex-布局实现-已知宽" class="headerlink" title="flex 布局实现(已知宽)"></a>flex 布局实现(已知宽)</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">    <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: deeppink;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="position-已知宽"><a href="#position-已知宽" class="headerlink" title="position(已知宽)"></a>position(已知宽)</h5><p>父元素设置为：<code>position: relative</code>；</p>
<p>子元素设置为：<code>position: absolute</code>；</p>
<p>据离上面 50%，距离下面 50%，然后减去元素自身宽度的一半距离就可以实现。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="position-transform-未知宽"><a href="#position-transform-未知宽" class="headerlink" title="position transform(未知宽)"></a>position transform(未知宽)</h5><p>将上面例子中的 <code>margin: -50px 0 0 -50px;</code> 替换为 <code>transfrom: translate(-50%, -50%);</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="position-margin-已知宽"><a href="#position-margin-已知宽" class="headerlink" title="position margin(已知宽)"></a>position margin(已知宽)</h5><p>left、right、top、bottom 为 0，<code>margin: auto</code> 即可：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;            <br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此情况下，如果子元素不设置宽度和高度，将会铺满整个父盒子（应用：模态框）</p>
<h5 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h5><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="内容水平垂直居中"><a href="#内容水平垂直居中" class="headerlink" title="内容水平垂直居中"></a>内容水平垂直居中</h4><h5 id="table-cell-1"><a href="#table-cell-1" class="headerlink" title="table-cell"></a>table-cell</h5><ul>
<li><code>text-align: center</code>：给元素的父级加，可以使文本或者行级元素水平居中；</li>
<li><code>line-height</code>：值为元素的高度，可以使元素的文本内容垂直居中；</li>
<li><code>margin: 0 auto</code>：父级元素宽度可有可无，子级元素必须是块元素，而且要有宽度（否则继承父级）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">display</span>: table-cell;</span><br><span class="css">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">    <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>AgoniLay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>给父级设置 <code>display: table</code>，子集设置 <code>display: tablecell</code>，子集会充满全屏。</p>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h4><p>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，间接影响包含块的布局。</p>
<p>浮动元素的摆放包含如下原则：</p>
<ul>
<li>尽量靠上靠左，且一个挨着一个；</li>
<li>不能超出包含块，除非元素比包含块更宽；</li>
<li>不能超出所在行的最高点；</li>
<li>不能超过它前面浮动的元素的最高点；</li>
<li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素。</li>
</ul>
<blockquote>
<p>注意：浮动元素不能撑起包含块，所以需要消除浮动</p>
</blockquote>
<h4 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h4><ul>
<li><p>BFC</p>
</li>
<li><p>伪元素</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br> 	<span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>包含块也浮动</p>
</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="块级和行内元素"><a href="#块级和行内元素" class="headerlink" title="块级和行内元素"></a>块级和行内元素</h3><h4 id="罗列"><a href="#罗列" class="headerlink" title="罗列"></a>罗列</h4><p>行内元素（内联元素，inline element）：</p>
<ul>
<li>a - 锚点</li>
<li>abbr - 缩写</li>
<li>acronym - 首字</li>
<li>b - 粗体</li>
<li>bdo - 文本方向</li>
<li>big - 大字体</li>
<li>br - 换行</li>
<li>cite - 引用</li>
<li>code - 计算机代码</li>
<li>dfn - 定义字段</li>
<li>em - 强调</li>
<li>font - 字体设定</li>
<li>i - 斜体</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>kbd - 定义键盘文本</li>
<li>label - 表格标签</li>
<li>q - 短引用</li>
<li>s - 中划线</li>
<li>strong - 粗体强调</li>
<li>sub - 下标</li>
<li>sup - 上标</li>
<li>textarea - 多行文本输入框</li>
<li>tt - 电传文本</li>
<li>u - 下划线</li>
<li>var - 定义变量</li>
</ul>
<p>块级元素（block element）：</p>
<ul>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>center - 居中对齐块</li>
<li>div - 常用块级元素</li>
<li>dl - 定义列表</li>
<li>fieldset - 表单控制组</li>
<li>form - 交互表单</li>
<li>h1 ~ h6 - 标题</li>
<li>hr - 水平分割线</li>
<li>isindex - 单行文本输入框</li>
<li>menu - 菜单列表</li>
<li>noframes - frames 可选内容（对于不支持 frame 的浏览器显示此区块内容）</li>
<li>noscript - 可选脚本内容（对于不支持 script 的浏览器显示此内容）</li>
<li>ol - 排序表单</li>
<li>p - 段落</li>
<li>pre - 格式化文本</li>
<li>table - 表格</li>
<li>ul - 无序列表</li>
</ul>
<p>可变元素：</p>
<p>可变元素根据上下文语境决定该元素为块元素或者行内元素。</p>
<ul>
<li>applet - java applet（已不支持，使用 object 代替）</li>
<li>button - 按钮</li>
<li>del - 删除文本</li>
<li>iframe - 内联框架</li>
<li>ins - 插入的文本</li>
<li>map - 图片区块</li>
<li>object - object 对象</li>
<li>script - 客户端脚本</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>块级元素会独占一行，其宽度自动填满其父元素宽度；</p>
<p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排列不下，才会换行，其宽度随元素的内容的宽度而变化</p>
</li>
<li><p>块级元素可以设置 width height 属性（即使设置了 width，也仍是独占一行的）；</p>
<p>行内元素设置 width height 无效</p>
</li>
<li><p>块级元素可以设置 margin padding 属性；</p>
<p>行内元素的竖直方向的 margin 不会产生边距效果（竖直方向的 padding 在 ie6 中不起作用），水平方向的正常</p>
</li>
<li><p>块级元素可以包含行内元素和块级元素；</p>
<p>行内元素不能包含块级元素</p>
</li>
</ol>
<blockquote>
<p>注意：p 标签中不能包含 div 标签。</p>
</blockquote>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以需要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM，DOM 提供了对 HTML 文档结构化的表述，DOM 有三个层面的作用：</p>
<ul>
<li>页面的视角：DOM 是生成页面的基础数据结构；</li>
<li>从 JavaScript 脚本视角来看：DOM 提供给 JavaScript 脚本操作的接口，从而可以对 DOM 结构进行访问，进而改变文档的结构、样式和内容；</li>
<li>从安全视角来看：DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就可以拦截。</li>
</ul>
<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤掉部分不安全的内容。</p>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>在渲染引擎中，有一个叫 HTML 解析器（HTMLParser）的模块，其职责就是负责将 HTML 字节流转换为 DOM 结构。</p>
<p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据：</p>
<ul>
<li>网络进程接收到响应头后，会根据响应头中的 <code>content-type</code> 字段来判断文件的类型，然后为该请求选择或者创建一个渲染进程；</li>
<li>然后网络进程和渲染进程之间就会建立一个共享数据的管道，网络进程将接收到的数据放在此管道中，而渲染进程则从管道的另一端不断地读取数据，并同时传给 HTML 解析器，将其动态实时解析为 DOM。</li>
</ul>
<p>DOM 生成流程：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232307492.png" srcset="/img/three2.gif" lazyload class title="字节流 -&gt; DOM">

<p><strong>第一个阶段，通过分词器将字节流转换为 Token</strong>；</p>
<p>V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个一个 Token；解析 HTML 也同理，需要通过分词器将字节流转换成一个一个 Token，分为 <code>Tag Token</code> 和 <code>文本 Token</code>：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232646991.png" srcset="/img/three2.gif" lazyload class title="Token 示意图">

<p>其中，Tag Token 又分为 StartTag 和 EndTag。</p>
<p><strong>后续的二和三阶段是同步进行的，需要将 Token 解析为 DOM 阶段，并将 DOM 节点添加到 DOM 树中</strong>。</p>
<p>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段生成的 Token 会依次压到这个栈中，处理规则如下：</p>
<ol>
<li><p>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时将一个 StartTag document 压入栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223233942311.png" srcset="/img/three2.gif" lazyload class title="初始化阶段"></li>
<li><p>若压入的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，父节点就是栈中相邻的那个元素生成的节点；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234022765.png" srcset="/img/three2.gif" lazyload class title="startTag Token"></li>
<li><p>若分词器解析到的是 文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 无需压入到栈中，父节点就是当前栈顶 Token 所对应的 DOM 节点；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234041536.png" srcset="/img/three2.gif" lazyload class title="文本 Token"></li>
<li><p>若解析到的是 EndTag 标签，HTML 解析器会查看 Token 栈顶的元素是否与之对应，是，则将对应的 StartTag Token 从栈中弹出，表示该节点解析完成；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234106295.png" srcset="/img/three2.gif" lazyload class title="EndTag"></li>
<li><p>以此反复，直到分词器将所有字节流分词完成。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234125004.png" srcset="/img/three2.gif" lazyload class title="解析完成"></li>
</ol>
<h4 id="JS-影响-DOM"><a href="#JS-影响-DOM" class="headerlink" title="JS 影响 DOM"></a>JS 影响 DOM</h4><p>内嵌式：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>agoni<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]</span><br><span class="javascript">      div1.innerText = <span class="hljs-string">&#x27;AgoniLay&#x27;</span></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>lay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>在遇到 <code>script</code> 标签之前，所有的解析流程不变，但是当解析到 <code>script</code> 标签时，渲染引擎会判断到这是一段内嵌脚本，此时 HTML 解析器就会暂停 DOM 的解析（因为 JS 中可能会修改当前已经生成的 DOM 结构），JavaScript 引擎介入，并执行 <code>script</code> 标签中的脚本，在执行脚本完成之后，脚本中所修改的 DOM 节点相关内容就已经改变，此时 HTML 解析器恢复解析过程，继续解析后续节点，直至生成最终的 DOM 树。</p>
<p>引入式：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// demo.js</span><br><span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<br>div1.innerText = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>agoni<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>lay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>整个执行流程和上面是一样的，但在执行 JavaScript 之前需要先下载这段 JavaScript 代码；</p>
<blockquote>
<p>下载过程会阻塞 DOM 解析，且通常会十分耗时，Chorme 浏览器做了许多优化，如预解析操作：当渲染引擎收到字节流后，会首先开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
</blockquote>
<p>可以采用一些相关的策略来规避：</p>
<ul>
<li><p>使用 CDN 来加速 JavaScript 文件的加载；</p>
</li>
<li><p>压缩 JavaScript 文件的体积；</p>
</li>
<li><p>若某 JavaScript 文件中未进行操作 DOM 相关代码，可以通过 <code>async</code> 或 <code>defer</code> 标记来将该 JavaScript 脚本设置为异步加载：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>或<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
<blockquote>
<p>async 和 defer 的差异：</p>
<ul>
<li>使用 async 标记的脚本文件一旦加载完成，会立即执行；</li>
<li>而使用 defer 标记的脚本文件，需要在 <code>DOMContentLoaded</code> 事件之前执行。</li>
</ul>
</blockquote>
<p>CSSOM 相关：</p>
<p>JavaScript 脚本中出现了操作 CSSOM 的代码，在执行 JavaScript 之前需要先解析 JavaScript 语句之上所有的 CSS 样式，若代码引用了外部的 CSS 文件，那么还需再执行 JavaScript 代码之前等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象后，才能执行脚本。</p>
<p>JavaScript 引擎再解析 JavaScript 之前是不知道其中是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时不管是否操纵了 CSSOM，都会执行 CSS 文件下载、解析操作，再执行 JavaScript 脚本。</p>
<blockquote>
<p>CSSOM 有关文章：<a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html">https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html</a></p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h3><h4 id="同源页面间通信"><a href="#同源页面间通信" class="headerlink" title="同源页面间通信"></a>同源页面间通信</h4><h5 id="Broadcast-Channel"><a href="#Broadcast-Channel" class="headerlink" title="Broadcast Channel"></a>Broadcast Channel</h5><p>Broadcast Channel 可以创建一个用于广播的通信频道。当所有的页面都监听同一频道的消息时，其中的某一个页面通过它发送的消息就会被其他所有页面收到。</p>
<p>创建：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bc = <span class="hljs-keyword">new</span> BroadcastChannel(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>监听：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Broadcast Channel] receive message:&#x27;</span>, text)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>广播：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.postMessage(myData)<br></code></pre></div></td></tr></table></figure>

<h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Sercvice Worker 可以共享，将 Service Worker 作为消息的处理中心即可实现广播效果。</p>
<blockquote>
<p>Service Worker 是 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903588691443725">PWA</a> 中的核心技术之一。</p>
</blockquote>
<p>首先在页面中注册 Service Worker：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.register(<span class="hljs-string">&#x27;../util.sw.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Service Worker 注册成功&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p><code>../util.sw.js</code> 是对应的 Service Worker 脚本，Service Worker 本身并不具备广播通信的功能，需要进行改造：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ../util.sw.js Service Worker 逻辑</span><br>self.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;service worker receive message&#x27;</span>, e.data)<br>  e.waitUntil(<br>    self.clients.matchAll().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clients</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (!clients || clients.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      clients.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>&#123;<br>        client.postMessage(e.data)<br>      &#125;)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>在 Service Worker 中监听了 <code>message</code> 事件，获取页面发送的信息。然后通过 <code>self.clients.matchAll()</code> 获取当前注册了该 Service Worker 的所有页面，通过调用每个 Client 的 <code>postMessage</code> 方法，向页面发送信息，从而达到广播效果。</p>
<p>然后再页面中监听 Service Worker 发送来的消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Service Worker] receive message:&#x27;</span>, text)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>需要同步消息时，调用 Service Worker 的 <code>postMessage</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.controller.postMessage(mydata)<br></code></pre></div></td></tr></table></figure>

<h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><p>当 LocalStorage 变化时，会触发 <code>storage</code> 事件，利用这个特性，可以在发送消息时把消息写入到某个 LocalStorage 中，然后在各个页面内监听 storage 事件即可收到通知。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (e.key === <span class="hljs-string">&#x27;AgoniLay&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(e.newValue)<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Storage I] receive message:&#x27;</span>, text)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>发送消息使用 <code>setItem</code> 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">mydata.st = +(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>)<br><span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(mydata))<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意：此处在 <code>mydata</code> 上添加了一个取当前毫秒时间戳的 <code>st</code> 属性，这是因为 <code>storage</code> 事件只有在值真正发生改变时才会触发。设置 <code>st</code> 属性可以保证每次调用时一定会触发 <code>storage</code> 事件。</p>
</blockquote>
<h5 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h5><p>普通的 Worker 之间是独立运行、数据互不相通的；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>
<p>首先，在页面中启动一个 Shared Worker：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shareWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;../util.shared.js&#x27;</span>, <span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br><span class="hljs-comment">// 第二个参数是名称，可以留空</span><br></code></pre></div></td></tr></table></figure>

<p>然后在该 Shared Worker 中支持 get 与 post 形式的消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ../util.shared.js: Shared Worker 代码</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-literal">null</span><br>self.addEventListener(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> port = e.ports[<span class="hljs-number">0</span>]<br>  port.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>    <span class="hljs-comment">// get 指令返回存储的消息数据</span><br>    <span class="hljs-keyword">if</span> (event.data.get) &#123;<br>      data &amp;&amp; port.postMessage(data)<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则存储该消息数据</span><br>      data = event.data<br>    &#125;<br>  &#125;)<br>  port.start()<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听时返回：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定时轮询，发送 get 指令的消息</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  sharedWorker.port.postMessage(&#123; <span class="hljs-attr">get</span>: <span class="hljs-literal">true</span> &#125;)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 监听 get 消息的返回数据</span><br>sharedWorker.port.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Shared Worker] receive message:&#x27;</span>, text)<br>&#125;, <span class="hljs-literal">false</span>)<br>sharedWorker.port.start()<br></code></pre></div></td></tr></table></figure>

<p>需要跨页面通信时，给 Shared Worker <code>postMessage</code> 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">sharedWorker.port.postMessage(mydata)<br></code></pre></div></td></tr></table></figure>

<h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><p>还可以使用一些“全局性”的存储方案，例如 IndexedDB 或 cookie，思路与 Shared Worker 类似：消息发送方将消息存至 IndexedDB 中，接收方则通过轮询去获取最新的消息。</p>
<h5 id="window-open-window-opener"><a href="#window-open-window-opener" class="headerlink" title="window.open + window.opener"></a>window.open + window.opener</h5><p>当使用 <code>window.open</code> 打开页面时，方法会返回一个被打开页面 <code>window</code> 的引用，而在未指定 <code>noopener</code> 时，被打开的页面可以通过 <code>window.opener</code> 获取到打开它的页面的引用 —— 通过这种方式可以在页面之间建立联系（一种树形结构）。</p>
<p>首先，把 <code>window.open</code> 打开的页面的 <code>window</code> 对象收集起来：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> childWins = []<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;./some/sample&#x27;</span>)<br>  childWins.push(win)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>发送消息时，同时通知它打开的页面和打开它的页面：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 过滤掉已经关闭的窗口</span><br>childWins = childWins.filter(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.closed)<br><span class="hljs-keyword">if</span> (childWins.length &gt; <span class="hljs-number">0</span>) &#123;<br>  mydata.fromOpenner = <span class="hljs-literal">false</span><br>  childWins.forEach(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.postMessage(mydata))<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.opener &amp;&amp; !<span class="hljs-built_in">window</span>.opener.closed) &#123;<br>  mydata.fromOpenner = <span class="hljs-literal">true</span><br>	<span class="hljs-built_in">window</span>.opener.postMessage(mydata)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>收到消息的页面再进行传递：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; —— tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Cross-document Messaging] receive message:&#x27;</span>, text)<br>  <span class="hljs-comment">// 避免消息回传</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.opener &amp;&amp; !<span class="hljs-built_in">window</span>.opener.closed &amp;&amp; data.fromOpenner) &#123;<br>    <span class="hljs-built_in">window</span>.opener.postMessage(data)<br>  &#125;<br>  <span class="hljs-comment">// 过滤掉已经关闭的窗口</span><br>  childWins = childWins.filter(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.closed)<br>  <span class="hljs-comment">// 避免消息回传</span><br>  <span class="hljs-keyword">if</span> (childWins &amp;&amp; !data.fromOpenner) &#123;<br>    childWins.forEach(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.postMessage(data))<br>  &#125;<br>&#125;)<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在这种 “口口相传” 模式下，如果页面不是通过在另一个页面内的 <code>window.open</code> 打开的（比如直接在地址栏输入，或从其他网站链接过来），就无法做到消息传递。</p>
</blockquote>
<h4 id="非同源页面之间的通信"><a href="#非同源页面之间的通信" class="headerlink" title="非同源页面之间的通信"></a>非同源页面之间的通信</h4><p>可以使用一个用户不可见的 iframe 作为桥。由于 iframe 与父页面间可以通过指定 <code>origin</code> 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe，这些 iframe 由于使用的是同一个 url，因此属于同源页面，就可以使用同源页面间的通信方式。</p>
<p>首先，在页面中监听 iframe 发来的消息，做相应的业务处理：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-comment">// ... do something</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>当页面要与其他同源或非同源页面通信时，会先给 iframe 发送消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.frame[<span class="hljs-number">0</span>].window.postMessage(mydata, <span class="hljs-string">&#x27;...&#x27;</span>) <span class="hljs-comment">// ... 可以设为 ifrmae 的 URL</span><br></code></pre></div></td></tr></table></figure>

<p>iframe 收到消息后，使用某种同源跨页面通信技术在所有 iframe 间同步消息，其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.parent.postMessage(e.data, <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>同源跨页面通信的方式：</p>
<ul>
<li>前三种都是 “广播模式”，一个页面将消息通知给一个“中央站”，在由“中央站”通知给各个页面，中央站可以是一个 Broadcast Cannel 实例，一个 Service Worker 或是 LocalStorage；</li>
<li>Shared Worker 和 IndexedDB、cookie 等是 “共享存储+长轮询” 模式，但有时不一定非要长轮询；</li>
<li>最后 window.open + window.opener 是 “口口相传” 模式。</li>
<li>还有一种做法是通过 WebSocket 这类的 “<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903618043183111">服务器推</a>” 技术来进行同步，好比将 “中央站” 从前端移动到了后端，还有：Comet / SSE 等。</li>
</ul>
<p>非同源页面则可以通过嵌入同源 iframe 作为 “桥”，将非同源页面通信转化为同源页面通信。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li>当浏览器地址变化时，切换页面；</li>
<li>当点击前进后退时，网页内容跟随变化；</li>
<li>刷新浏览器，网页加载当前路由对应内容。</li>
</ol>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>hash 模式：监听浏览器地址 hash 值变化，执行相对应的 js 切换网页</li>
<li>history 模式：利用 history API 实现 url 地址改变，网页内容改变</li>
</ul>
<p>最大的区别在于 hash 模式下会在浏览器地址后面增加 <code>#</code> 号，而 history 可以自定义地址</p>
<h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>使用 <code>window.location.hash</code> 属性及窗口的 <code>onhashchange</code> 事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换界面：</p>
<ol>
<li>hash 指的是地址中 <code>#</code> 号以及之后的字符，也称为散列值；hash 也称作锚点，本身用来做页面跳转定位：<ul>
<li>如 <code>http:/localhost/index.html#abc</code> 中的 <code>#abc</code> 就是 hash；</li>
</ul>
</li>
<li>散列值是不会随请求发送到服务器端的，所以改变 hash 不会重新加载页面；</li>
<li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置 hash 值；</li>
<li>location.hash 值的变化会直接反映到浏览器地址栏。</li>
</ol>
<p>触发 <code>hashchange</code> 事件的情况：</p>
<ul>
<li>浏览器地址栏散列值变化（包括浏览器的前进、后退）会触发 <code>window.location.hash</code> 值的变化，从而触发 <code>onhashchange</code> 事件；</li>
<li>当浏览器地址栏中 URL 包含 hash 时访问，浏览器发送请求至服务器，请求完毕后设置散列值，从而触发 <code>onhashchange</code> 事件；</li>
<li>只改变浏览器地址栏 URL 的哈希部分后访问，不会发送请求至服务器，只是设置散列值，并触发 <code>onhashchange</code> 事件；</li>
<li>html 中 a 标签的 href 属性可以设置为页面的元素 ID 如 <code>#top</code>，当点击该 a 链接时页面跳转至该 id 元素所在区域，同时浏览器自动设置 <code>window.location.hash</code> 属性，地址栏中的哈希值也会发生改变，并触发 <code>onhashchange</code> 事件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 设置 URL 的 hash，会在当前 url 后加上 #abc</span><br><span class="hljs-built_in">window</span>.location.hash = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">let</span> hash = <span class="hljs-built_in">window</span>.location.hash <span class="hljs-comment">// &#x27;#abc&#x27;</span><br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 监听 hash 变化，点击浏览器的前进后退会触发</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><ul>
<li><code>window.history</code> 属性指向 History 对象，表示当前窗口的浏览历史。发生改变时只会改变页面的路径，不会刷新页面；</li>
<li>History 对象保存了当前窗口访问过的所有页面地址。通过 <code>history.length</code> 可以得到当前窗口一共访问过几个网址；</li>
<li>浏览器不允许脚本读取这些地址，但是允许在地址之间导航；</li>
<li>浏览器工具栏的前进后退其实就是对 History 对象进行操作。</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>History.length</code>：当前窗口访问过的网址数量</p>
<p><code>History.state</code>：History 堆栈最上层的状态值，通常为 <code>undefined</code>（未设置）</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键；</p>
<p><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键；</p>
<p><code>History.go()</code>：接受一个整数为参数，以当前网页为基准，移动到参数指定的网页：</p>
<ul>
<li>为 1，则相当于 <code>history.forward()</code>；为 -1，则相当于 <code>history.back()</code>；</li>
<li>若为 0，相当于刷新页面；</li>
<li>若超出实际存在的网址范围，该方法无效果。</li>
</ul>
<blockquote>
<p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
</blockquote>
<p><code>History.pushState(object, title, url)</code>：在历史中添加一条记录：</p>
<ul>
<li><code>object</code>：一个对象，通过 pushState 方法可以将该对象内容传递到新页面中，若不需要此对象则可以填 <code>null</code>；</li>
<li><code>title</code>：指标题，几乎没有浏览器支持该参数，传空即可；</li>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。不指定则默认为当前的路径，若设置了一个跨域网址，则会报错。</li>
</ul>
<blockquote>
<p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。</p>
</blockquote>
<p><code>History.replaceState(object)</code>：修改 History 对象的当前记录，用法与 pushState() 方法一样；</p>
<p><code>popstate</code> 事件：每当 history 对象出现变化时，就会触发 popstae 事件：</p>
<ul>
<li>调用 pushState() 或 replaceState() 方法，并不会触发该事件；</li>
<li>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 <code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code> 方法时才会触发；</li>
<li>该事件只针对同一个文档，如果浏览器历史的切换导致加载不同的文档，也不会触发</li>
<li>页面第一次加载的时候，浏览器不会触发 <code>popstate</code> 事件</li>
</ul>
<h3 id="事件模型-1"><a href="#事件模型-1" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件的本质是程序各个组成之间的一种通信方式，也是异步编程的一种体现。</p>
<h4 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h4><p>DOM 的事件操作（监听和触发）都定义在 <code>EventTarget</code> 接口，所有的节点对象都部署了这个接口，其他一些需要事件通信的了浏览器内置对象（如：<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p><code>EventTarget</code> 接口主要提供三个实例方法：</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数；</li>
<li><code>removeEventListener</code>：移除事件的监听函数；</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p><code>EventTarget.addEventListener()</code> 用于在当前节点或对象上，定义一个特定事件的监听函数，一旦事件发生就会执行监听函数，无返回值。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">target.addEventListener(type, listener[, useCapture])<br><span class="hljs-comment">// 例子：</span><br><span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>)<br>button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello AgoniLay!&#x27;</span>)<br>&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：事件名称，大小写敏感；</li>
<li><code>listener</code>：监听函数，也可以是一个具有 <code>handleEvent</code> 方法的对象；</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为 <code>false</code>，参数可选；第三个参数也可以是一个属性配置对象：<ul>
<li>capture：布尔值，表示该事件是否在捕获阶段触发监听函数；</li>
<li>once：布尔值，表示监听函数是否只触发一次，随后就自动移除；</li>
<li>passive：布尔值，表示监听函数不会调用事件的 preventDefault 方法，若监听函数调用了浏览器将会忽略并在控制台输出警告</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ol>
<li><p><code>addEventListener</code> 方法可以为针对当前对象的同一个事件添加多个不同的监听函数，并按顺序触发（先添加先触发）；</p>
</li>
<li><p>如果为同一个事件多次添加同一个监听函数，则该函数只会执行一次，其余的将会自动被去除；</p>
</li>
<li><p>可以用匿名函数包装监听函数达到向监听函数传参的目的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>)<br>el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; print(<span class="hljs-string">&#x27;Hello AgoniLay!&#x27;</span>) &#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure></li>
<li><p>监听函数内部的 <code>this</code> 指向当前事件所在的对象。</p>
</li>
</ol>
<h5 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h5><p><code>EventTarget.removeEventListener()</code> 方法用来移除 <code>addEventListener</code> 方法添加的事件监听函数，无返回值。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener, <span class="hljs-literal">false</span>)<br>div.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<p>参数和 <code>addEventListener</code> 方法的参数完全一致，<code>removeEventListener</code> 方法移除的监听函数必须是 <code>addEventListener</code> 方法添加的那个监听函数，且在同一个元素节点，且第三个参数也必须完全相同，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;&#125;, <span class="hljs-literal">false</span>)<br>div.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code> 方法无效，因为监听函数不是同一个函数</p>
<h5 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent()"></a>dispatchEvent()</h5><p><code>EventTarget.dispatchEvent()</code> 方法在当前节点上触发指定事件，从而触发监听函数的执行。返回值为一个布尔值：只要有一个监听函数调用了 <code>Event.preventDefault()</code>，则返回值为 <code>false</code>，反而为 <code>true</code>。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">target.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, hello, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;click&#x27;</span>)<br>target.dispatchEvent(event)<br></code></pre></div></td></tr></table></figure>

<ul>
<li>参数是一个 <code>Event</code> 对象的实例。</li>
</ul>
<h4 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h4><h5 id="HTML-on-属性"><a href="#HTML-on-属性" class="headerlink" title="HTML on 属性"></a>HTML on 属性</h5><p>HTML 语言允许在元素的属性中直接定义某些事件的监听代码：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;触发点击事件&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>元素的事件监听属性，都是 <code>on + 事件名</code>，这些属性的值时将会执行的代码，而不是一个函数，且只会在冒泡阶段触发：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 正确 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 错误 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>直接设置 on 属性与通过元素节点的 <code>setAttribute</code> 方法设置 on 属性的效果是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">el.setAttribute(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-string">&#x27;doSomething()&#x27;</span>)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-comment">// &lt;Element onclick=&quot;doSomething()&quot; /&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h5><p>元素节点对象的事件属性，同样可以指定监听函数，也是只在冒泡阶段触发：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = doSomething<br><br>div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;触发点击事件&#x27;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>与 HTML on 属性的区别在于，此方式的值是函数本身或函数名，而不是可执行代码。</p>
<h5 id="addEventListener-1"><a href="#addEventListener-1" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p>所有 DOM 节点实例都有 <code>addEventListener</code> 方法，用来为该节点定义事件的监听函数。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>第一种 HTML 的 on 属性：违反了 HTML 与 JavaScript 代码相分离的原则，不利于代码分工，不推荐使用；</p>
<p>第二种 元素节点的事件属性缺点在于同一个事件只能定义一个监听函数，因此也不推荐使用；</p>
<p>故推荐使用第三种 <code>EventTarget.addEventListener</code> 方法：</p>
<ol>
<li>同一个事件可以添加多个监听函数；</li>
<li>能够指定在那个阶段（冒泡或捕获）触发监听函数；</li>
<li>除了 DOM 节点，其他一些对象也有此接口。</li>
</ol>
<h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p>当一个事件发生后，会在子元素和父元素之间传播，分为三个阶段：</p>
<ol>
<li>从 window 对象传导到目标节点（从上层传到底层），称为 “捕获阶段”（capture phase）；</li>
<li>在目标节点上触发，称为 “目标阶段”（target phase）；</li>
<li>从目标节点传导回 window 对象（从底层传回上层），称为 “冒泡阶段”（bubbling phase）</li>
</ol>
<p>事件传播的最上层对象是 <code>window</code>，接着依次是 <code>document</code>、<code>html</code>（<code>document.documentElement</code>）和 <code>body</code>（<code>document.body</code>）。</p>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>由于事件会在冒泡阶段向上传播到父节点，所以可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，也就是事件的代理（delegation）。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (event.target.tagName.toLowerCase() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-comment">// do something</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>如果希望事件到某个节点为止不在传播，可以使用事件对象的 <code>stopPropagation</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 事件传播到 p 元素后，就不再向下传播</span><br>p.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  event.stopPropagation()<br>&#125;, <span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 事件冒泡到 p 元素后，就不再向上冒泡</span><br>p.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  event.stopPropagation()<br>&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意：<code>stopPropagation</code> 方法只会阻止事件的传播，不会阻止该事件触发已到达节点的其他监听函数，若需要彻底阻止事件传播，包括不再触发后面所有的监听函数，可以使用 <code>stopImmediatePropagation</code> 方法。</p>
</blockquote>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>事件发生后会产生一个事件对象作为参数传给监听函数。</p>
<p>浏览器原生提供一个 <code>Event</code> 对象，所有的事件都继承了 <code>Event.prototype</code> 对象。</p>
<p><code>Event</code> 对象本身就是一个构造函数，可以用来生成新的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ev = <span class="hljs-keyword">new</span> Event(<br>  <span class="hljs-string">&#x27;look&#x27;</span>,<br>  &#123;<br>    <span class="hljs-string">&#x27;bubbles&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 如若不显式指定为 true，则默认捕获</span><br>    <span class="hljs-string">&#x27;cancelable&#x27;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>)<br><span class="hljs-built_in">document</span>.dispatchEvent(ev) <span class="hljs-comment">//触发该事件</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：字符串，表示事件的名称；</li>
<li><code>options</code>：对象，表示事件对象的配置：<ul>
<li>bubbles：布尔值，可选，默认为 false，表示事件对象是否冒泡；</li>
<li>cancelable：布尔值，可选，默认为 false，表示事件是否可以被取消（<code>Event.parentDefault()</code>）</li>
</ul>
</li>
</ul>
<p><strong>实例属性</strong>：</p>
<ul>
<li><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡，只读，默认不冒泡；</li>
<li><code>Event.eventPhase</code> 属性返回一个整数变量，表示事件当前所处的阶段，只读：<ul>
<li>0：事件当前未发生</li>
<li>1：事件目前处于捕获阶段，从祖先节点向目标节点的传播过程中</li>
<li>2：事件到达目标节点，即 Event.target 指向的节点</li>
<li>3：事件处于冒泡阶段，从目标节点向祖先节点的反向传播过程中</li>
</ul>
</li>
<li><code>Event.cancelable</code> 属性返回一个布尔值，表示事件是否可以取消，只读：<ul>
<li>大多数浏览器的原生事件是可以取消的；</li>
<li>除非显式声明，<code>Event</code> 构造函数生成的事件，默认是不可以取消的；</li>
<li>此属性为 true 时，调用 <code>Event.preventDefault()</code> 就可以取消这个使劲按，阻止浏览器对该事件的默认行为；为 false 则没有效果；</li>
</ul>
</li>
<li><code>Event.cancelBubble</code> 属性返回一个布尔值，若设为 <code>true</code>，则相当于执行 <code>Event.stopPropagation()</code>，可以阻止事件的传播；</li>
<li><code>Event.defaultPrevented</code> 属性返回一个布尔值，表示该事件是否调用过 <code>Event.preventDefault</code> 方法，只读；</li>
<li><code>Event.currentTarget</code> 属性返回事件当前所在的节点，即当前执行的监听函数所绑定的节点；</li>
<li><code>Event.target</code> 属性返回原始触发事件的那个节点，即事件最初发生的节点；</li>
<li><code>Event.type</code> 属性返回一个字符串，表示事件类型，只读；</li>
<li><code>Event.timeStamp</code> 属性返回一个毫秒时间戳，表示事件发生的时间，相对于网页加载成功开始计算的：<ul>
<li>可能是整数，也可能是小数（高精度时间戳），取决于浏览器的设置；</li>
</ul>
</li>
<li><code>Event.isTrusted</code> 属性返回一个布尔值，表示该事件是否由真实的用户行为产生；</li>
<li><code>Event.detail</code> 属性只有浏览器的 UI 事件才有，返回一个数值，表示事件的某种信息：<ul>
<li>比如 <code>click</code> 和 <code>dbclick</code> 事件中，指鼠标按下的次数；</li>
<li>鼠标滚轮事件中，表示滚轮滚动的距离（正向和负向，总为 3 的倍数）；</li>
</ul>
</li>
</ul>
<p><strong>实例方法</strong>：</p>
<ul>
<li><code>Event.preventDefault()</code> 方法取消浏览器对当前事件的默认行为，前提是事件对象的 <code>cancelable</code> 属性为 <code>true</code>；</li>
<li><code>Event.stopPropagation()</code> 方法阻止事件再 DOM 中的继续传播，不包括在当前节点上的其他事件监听函数；</li>
<li><code>Event.stopImmediatePropagation()</code> 方法阻止同一个事件的其他监听函数继续调用，阻止事件的传播，比 <code>Event.stopPropagation()</code> 更彻底；</li>
<li><code>Event.composedPath()</code> 方法返回一个数组，成员是事件的最底层节点和一次冒泡经过的所有上层节点；</li>
</ul>
<h4 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h4><p><code>CustomEvent</code> 接口用于生成自定义的事件实例。如果需要在触发事件的同时，传入指定的数据，可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> CustomEvent(type, options)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：字符串，表示事件的名字，必须；</li>
<li><code>options</code>：事件的配置对象，可选：<ul>
<li>除了接受 Event 事件的配置属性，只有一个 detail 属性表示事件的附带数据，默认为 <code>null</code>；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myEvent = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&#x27;myevent&#x27;</span>, &#123;<br>  <span class="hljs-attr">detail</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span><br>&#125;)<br><br>el.addEventListener(<span class="hljs-string">&#x27;myevent&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + event.detail.name)<br>&#125;)<br><br>el.dispatchEvent(myEvent)<br></code></pre></div></td></tr></table></figure>

<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器的缓存机制就是 HTTP 缓存机制，是根据 HTTP 报文的缓存标识进行的。</p>
<h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>HTTP 报文分为两种：</p>
<ul>
<li><p>HTTP 请求(Request)报文，报文格式为：<code>请求行 - HTTP头(通用信息头、请求头、实体头) - 请求报文主体(POST才有)</code>；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000219031.png" srcset="/img/three2.gif" lazyload class title="HTTP请求报文"></li>
<li><p>HTTP 响应(Response)报文，报文格式为：<code>状态行 - HTTP头(通用信息头、响应头、实体头) - 响应报文主体</code>；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000341773.png" srcset="/img/three2.gif" lazyload class title="HTTP响应报文"></li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li>通用信息头指的是请求和响应报文都支持的头域，包括：<ul>
<li>Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</li>
</ul>
</li>
<li>实体头则是实体信息的实体头域，分别为：<ul>
<li>Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header.</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h4><p>浏览器与服务器通信的方式为应答模式：浏览器发起 HTTP 请求 - 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果，会根据请求报文中 HTTP 头中的缓存标识决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301001224385.png" srcset="/img/three2.gif" lazyload class title="浏览器第一次发起HTTP请求">

<ul>
<li>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果以及缓存标识；</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li>
</ul>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p>
<ol>
<li>不存在缓存结果和缓存标识，强制缓存失败，直接向服务器发起请求（与首次一致）；</li>
<li>存在该缓存结果和缓存标识，但结果已失效，强制缓存失败，使用协商缓存；</li>
<li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li>
</ol>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 <code>Cache-Control</code> 的优先级更高。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><code>Expires</code> 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，再次请求时间小于该缓存值，直接使用缓存结果。</p>
<blockquote>
<p>到了 HTTP/1.1，<code>Expires</code> 已经被 <code>Cache-Control</code> 替代，原因：Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，但如果两者因某些原因发生误差，那么强制缓存则会直接失效。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在 HTTP/1.1 中，<code>Cache-Control</code> 是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li><code>public</code>：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li><code>private</code>：所有内容只有客户端可以缓存，默认为此值</li>
<li><code>no-cache</code>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li><code>max-age=xxx (xxx is numeric)</code>：缓存内容将在 xxx 秒后失效</li>
</ul>
<p>例如：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301003329024.png" srcset="/img/three2.gif" lazyload class title="expires 和 cache-control">

<ul>
<li>HTTP 响应报文中 expires 的时间值是一个绝对值，而 cache-control 的值是相对值；</li>
<li>无法确定客户端是否与服务端的时间同步的情况下，cache-control 比 expires 是更好的选择。</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/162db635afa6f7f7tplv-t2oaga2asx-watermark.awebp" srcset="/img/three2.gif" lazyload class title="img">

<p>上图中，状态码为灰色的请求代表使用了强制缓存，对应的 Size 值代表了则代表该缓存存放的位置，分别为：</p>
<ul>
<li><code>from memory cache</code>：内存缓存，代表使用内存中的缓存，先读取此项；</li>
<li><code>from disk cache</code>：硬盘缓存，代表使用硬盘中的缓存。</li>
</ul>
<p>硬盘缓存与内存缓存：</p>
<ol>
<li>内存缓存具有快速读取和时效性（进程关闭则内存清空）两个特点；</li>
<li>硬盘缓存是直接将缓存写入硬盘文件中，读取时需进行 I/O 操作，读取复杂，速度比内存缓存慢。</li>
</ol>
<p>在浏览器中，会在 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时只需直接从内存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache）。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要由两种情况：</p>
<ol>
<li><p>协商缓存生效，返回 304：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005038564.png" srcset="/img/three2.gif" lazyload class width="304"></li>
<li><p>协商缓存失效，返回 200 和请求结果：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005110494.png" srcset="/img/three2.gif" lazyload class title="协商缓存"></li>
</ol>
<p>同样，协商缓存的标识也是字啊响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified</code> / <code>If-Modified-Since</code> 和 <code>Etag</code> / <code>If-None-Match</code>，后者优先级更高。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code> 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间；</p>
<p><code>If-Modified-Since</code> 是客户端再次发起该请求时，携带上次请求返回的 <code>Last-Modified</code> 值，以此做对比决定是 200 还是 304；</p>
<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p><code>Etag</code> 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）；</p>
<p><code>If-None-Match</code> 是客户端再次发起该请求时，携带上次请求返回的唯一标识 <code>Etag</code> 值，以此做判断。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>强制缓存优先于协商缓存进行，若协商缓存生效则直接使用缓存，若不生效则进行协商缓存（<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>），协商缓存由服务器决定是否使用缓存，若协商缓存失效，代表该请求的缓存失效，则重新获取请求结果再存入浏览器缓存中；生效则返回 304，继续使用缓存：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301010337843.png" srcset="/img/three2.gif" lazyload class title="浏览器缓存策略">

<h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><h4 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h4><p>CPU 与 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能。</p>
<ul>
<li>CPU（Center Processing Unit）：CPU 是计算机的大脑，负责处理各种不同的任务，过去大多数 CPU 是单芯片的，核心被安置再同一个芯片上，较新的 CPU 可以支持多核心，运算能力大大加强；</li>
<li>GPU（Graphics Processing Unit）：GPU 更擅长利用多核心同时处理单一的任务，最初被用来处理图像，这也是 GPU 可以更快、更流畅的渲染页面内容。</li>
</ul>
<h4 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h4><p>可以把计算机自下而上分为三层：硬件（Machine Hardware）、操作系统（Operating System）和应用（Application），有了操作系统的存在，上层应用可以使用操作系统提供的能力使用硬件资源而不是直接访问硬件资源。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>一个进程（Process）是应用正在运行的程序，而线程（Thread）是进程中更小的一部分；</p>
<ul>
<li>当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作；</li>
<li>操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，私有内存就会被释放；</li>
<li>还有比进程更小的存在：协程，是运行再线程中更小的单位。</li>
</ul>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以使用 IPC（Inter Process Communcation），好处在于当一个进程给另一个进程发消息而并没有回应时，并不影响当前进程继续工作。</p>
<h4 id="浏览器架构-1"><a href="#浏览器架构-1" class="headerlink" title="浏览器架构"></a>浏览器架构</h4><p>借助进程和线程，浏览器可以被设计成但 单进程-多线程架构，或者利用 IPC 实现 多进程-多线程架构。</p>
<p>Chrome 就是采用了多进程架构，浏览器进程作为 Chrome 最核心的进程管理这其他进程，而 Renderer 则负责渲染不同的站点：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301160300551.png" srcset="/img/three2.gif" lazyload class title="Chorme 多进程">

<h5 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h5><ul>
<li><strong>浏览器进程（Browser process）</strong>：负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责不可见的功能，如网络请求、文件访问等，也负责其他进程的调度；</li>
<li><strong>渲染进程（Renderer process）</strong>：负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理；</li>
<li><strong>插件进程（Plugin process）</strong>：负责为浏览器提供各种额外的插件功能，如 flash；</li>
<li><strong>GPU 进程（GPU process）</strong>：负责提供成像的功能；</li>
<li>还有负责扩展进程、工具进程等的其他进程</li>
</ul>
<h5 id="多进程架构好处"><a href="#多进程架构好处" class="headerlink" title="多进程架构好处"></a>多进程架构好处</h5><p>当访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当在 Chrome 中打开多个页签同时访问三个站点时，如果其中一个无响应，同样可以正常使用其他的页签：</p>
<p>因为 Chrome 为每个站点均创建了独立的渲染进程，专门负责当前站点的渲染工作；若所有页面运行在同一个进程中，当有一个页面无响应时，则其他页面均无法使用。</p>
<p>借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。</p>
<p>但同样由于进程独享自己的私有内存，为了节省内存，Chrome 限制了最大进程数，取决于硬件的能力，且使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。</p>
<h5 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h5><p>Chrome 将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式实现，以解决多进程架构中的问题。</p>
<p>当 Chrome 运行在硬件强大的计算机上时，会将一个服务以多个进程的方式实现，提供稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p>
<h5 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h5><p>浏览器进程负责处理除了渲染外的大部分工作，包括以下线程：</p>
<ul>
<li>UI 线程负责绘制工具栏中的按钮、地址栏等；</li>
<li>网络线程负责从网络中获取数据；</li>
<li>存储线程负责文件等功能。</li>
</ul>
<h4 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h4><ol>
<li><p>输入处理：当在地址栏输入时，UI 线程会先判断输入的内容是要搜索的内容还是要访问一个站点；</p>
</li>
<li><p>访问开始：按下回车或开始访问时，UI 线程将借助网络线程访问站点资源，浏览器页签的标题会出现加载中的图标，同时网络线程会根据适当的网络协议，如 DNS lookup 和 TLS 为此次请求建立连接，当服务器返回给浏览器重定向请求时，网络线程会通知 UI 线程需要重定向，然后会以新的地址开始请求资源；</p>
</li>
<li><p>处理响应数据：当网络线程收到来自服务器的数据时，会试图从数据中的前面一些字节得到数据的类型（<code>Content-Type</code>），以试图了解数据的格式：</p>
<ul>
<li>当返回的数据类型时 HTML 时，会将数据传递给渲染进程做进一步的渲染工作；</li>
<li>数据类型时 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或下载工作；</li>
</ul>
<blockquote>
<p>注意：在开始渲染之前，网络进程会先检查数据的安全性，这也是浏览器保证安全的地方，如果返回的数据来自一些恶意的站点，网络进程会显示警告的页面；与此同时，Cross Origin Read Blocking（CORB）策略也会确保跨域的敏感数据不会被传递给渲染进程。</p>
</blockquote>
</li>
<li><p>渲染过程：当所有的检查结束后，网络进程确信浏览器可以访问该站点时，网络进程通知 UI 线程数据准备完毕，UI 线程根据当前站点找到一个渲染进程完成接下来的渲染工作；</p>
<blockquote>
<p>在访问开始时，UI 线程将请求地址传递给网络线程时，UI 线程就已经知道了要访问的站点，就会开始查找或启动一个渲染进程，这与网络进程下载数据是同时的，会减少渲染所需要的时间，提高效率。</p>
</blockquote>
</li>
<li><p>提交访问：浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过为了进程继续获取数据；此时地址栏显示出表明安全的图标，同时显示出站点的信息，访问历史中也会加入当前的站点信息；</p>
</li>
<li><p>加载完毕：当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面；当渲染进程结束渲染工作（页面及其中所有子页面结束加载，也就是 onLoad 事件触发后发送），会给浏览器进程发送消息，UI 线程则会隐藏页签标题上的加载图标，表明页面加载完毕。</p>
</li>
</ol>
<p>当输入另外一个地址时，浏览器进程会重复上面的过程，但在开始新的访问前，会确认当前站点是否关心 <code>beforeunload</code> 事件：可以提醒用户是否要访问新的站点或者关闭此页签，若用户拒绝则新的访问或关闭会被阻止。</p>
<p>如果一次访问是从一个渲染进程中发起的，如用户点击一个链接或者运行 JavaScript 代码 <code>location = &#39;xxx&#39;</code> 时，渲染进程会首先检查 <code>beforeunload</code>，然后再执行和浏览器进程初始化访问同样的操作。</p>
<h4 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h4><p><code>Service worker</code> 是一种可以 web 开发者控制缓存的技术，它的代码是运行在渲染进程中的。</p>
<p>当访问开始时，网络线程会根据域名检查是否有 Service worker 会处理当前地址的请求，若有，则 UI 线程会找到对应的渲染进程去执行 Service worker 的代码，而 Service worker 可以让开发者决定此请求从本地缓存还是从网络中获取数据。</p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>渲染进程负责所有发生在浏览器页签中的事情，在一个渲染进程中，主线程负责解析、编译或运行代码等工作，当使用 Worker 时，Worker 线程会负责运行一部分代码。合成线程和关栅线程也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。</p>
<p>渲染进程最重要的工作就是将 HTML、CSS 和 JavaScript 代码转换为一个可以与用户产生交互的页面。</p>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><h5 id="DOM-的创建"><a href="#DOM-的创建" class="headerlink" title="DOM 的创建"></a>DOM 的创建</h5><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受 HTML 数据，主线程开始解析 HTML 文本字符串，并将其转化成 <strong>Document Object Model（DOM）</strong>。</p>
<p>当预加载扫描（Preload Scanner）在分析器分析 HTML 的过程中发现了类似 img 或 link 这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p>
<p>当 HTML 分析器发现 <code>script</code> 标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 JavaScript 代码（因为其中可能会操作 DOM 或 CSSOM）。</p>
<blockquote>
<p>如果 JavaScript 代码并不需要改变 DOM，可以为 <code>script</code> 标签添加 <code>async</code> 或 <code>defer</code> 属性从而达到异步加载这些资源而不阻塞 HTML 转化过程的目的。</p>
</blockquote>
<h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><p>主线程会解析样式并决定每个 DOM 元素的样式（Style calculation）。</p>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>完成样式计算后，渲染进程已经知道了 DOM 的结构和每个节点的样式，还需要确定节点在页面上的位置。</p>
<p>布局（layout）时为元素指定几何信息的过程，主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的<strong>布局树（Layout tree）</strong>：</p>
<ul>
<li>布局树的结构与 DOM 树的结构非常类似，但只包含将会在页面中显示的元素；</li>
<li>元素样式设置为 <code>display: none</code> 时，不会出现在布局树中，但样式设置为 <code>visibility: hidden</code> 的元素会出现在布局树中；</li>
<li>一个包含内容的伪元素不会出现在 DOM 树中，但会出现在布局树中。</li>
</ul>
<h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><p>有了 DOM、样式和布局之后，还需要知道 <strong>绘制（Paint）</strong>的顺序（层叠上下文相关）。</p>
<p>在这个阶段，主线程遍历布局树并创建绘制记录：一系列由绘制步骤组成的流程。</p>
<h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><p>完成了上述的步骤，浏览器已经知道了文档结构、每一个元素的样式、几何信息以及绘制的顺序，将这些信息转化成屏幕上像素的过程叫做 <strong>光栅化</strong>，光栅化时图形学的范畴。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/9ed512afc63c664458faf1bd42247cc0.gif" srcset="/img/three2.gif" lazyload class title="传统做法">

<p>传统的做法是将可视区域的内容进行光栅化，随着用户滚动页面，不断的光栅化更多的区域；现代的浏览器有着更为复杂的过程：<strong>合成</strong>：</p>
<p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层来合成新的帧，动画则可以通过移动层来实现：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/ae1b6d19e8aeb45841f04bbfa72760dd.gif" srcset="/img/three2.gif" lazyload class title="合成">

<p><strong>层（Layer）</strong>：</p>
<p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对于开发者来说，当某一部分需要使用独立的层来渲染，可以使用 <code>will-change</code> 让浏览器创建层。</p>
<p><strong>栅格线程</strong>和<strong>合成线程</strong>：</p>
<p>当布局树和绘制顺序确定后，主线程会将这些信息提交给合成线程，合成线程会光栅化每个层。一个层包含的内容可能是一个完整的页面，也可能只是页面的一部分，所以合成线程将层拆分成许多块，并发送给栅格线程，栅格线程光栅化这些块并将它们存储再 GPU 缓存中。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/371b5fa654d59f0c8ccb2f4f0658c20a.png" srcset="/img/three2.gif" lazyload class title="栅格化">

<p>合成线程可以决定栅格线程光栅化的优先级，以此来确保用户能看到的部分优先光栅化；一个层也会包含多种块以支持类似缩放这样的功能，当块被光栅化后，合成线程会使用 <code>draw quads</code> 收集这些信息并创建合成帧（Compositor frame）。</p>
<ul>
<li><strong>Draw quads</strong>：存储在缓存中，包换类似块位置的信息，用于描述如何使用块合成页面；</li>
<li><strong>Compositor frame</strong>：用于存储表现页面一帧中包含哪些 Draw quads 的集合。</li>
</ul>
<p>然后一个合成帧被提交给浏览器进程，这时如果浏览器 UI 有变化，或者插件的 UI 有变化时，另一个合成帧就会被创建出来。每当有交互发生时，合成线程就会创建更多的合成帧然后通过 GPU 将新的部分渲染出来。</p>
<p>好处在于：其独立于主线程，合成线程不需要等待样式计算和 JavaScript 代码的运行。</p>
<h4 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h4><p>对于浏览器来说，输入事件意味着所有用户动作（如鼠标滚轮滚动或屏幕触摸等）。</p>
<p>当用户与页面发生交互时，浏览器进程首先接受到事件，但只关心事件发生位置，将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会找到事件发生的元素并触发事件监听器。</p>
<p><strong>合成线程对事件的处理</strong>：</p>
<p>当页面被合成线程合成过，合成线程会标记那些有事件监听的区域，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理；如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p>
<p><strong>事件代理引发的问题</strong>：</p>
<p>在事件代理中，利用事件冒泡，可以在目标元素的上层元素中监听事件，可以更高效的监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.target === area) &#123;<br>    event.preventDefault()<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>但从浏览器角度来看，此时整个页面都会标记成 “慢滚动” 区域，意味着页面中某些部分并不需要事件监听，但合成线程依然需要在每次交互发生后等待主线程处理事件，造成效率降低。</p>
<p>解决：可以在事件代理时传入 <code>passive: true</code> 选项参数，告诉渲染进程，依然需要将事件发送给主线程处理，但不需要等待：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.target === area) &#123;<br>    event.preventDefault()<br>  &#125;<br>&#125;, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></div></td></tr></table></figure>

<p><strong>浏览器动画事件优化</strong>：</p>
<p>类似 <code>touchmove</code> 这样的事件每秒向主线程发送 120 次可能会造成主程序执行时间过长而影响性能：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/6101cc07df5e744efb2a88208f1d1e52.png" srcset="/img/three2.gif" lazyload class title="img">

<p>为了减少发送给主线程的事件数量，Chrome 合并了连续的事件，类似：<code>wheel</code>、<code>mousewheel</code>、<code>mousemove</code>、<code>pointermove</code>、<code>touchmove</code> 等这样的事件会被延迟到下一次 <code>requestAnimationFrame</code> 前触发：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/53005a8114a736ca071a333946664ffd.png" srcset="/img/three2.gif" lazyload class title="img">

<p>而其他任何的离散时间，类似：<code>keydown</code>、<code>keyup</code>、<code>mouseup</code>、<code>touchstart</code>、<code>touchend</code> 等都会立即被发送给主线程处理。</p>
<h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><p>目前主流的浏览器有五个：Internet Explorer、FireFox、Safari、Chrome 和 Opera。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示请求的网络资源，一般为 HTML 文档，也可以是 PDF、图片或其他的类型，资源的位置由用户使用 UPI（统一资源标示符）指定。</p>
<h4 id="高层结构"><a href="#高层结构" class="headerlink" title="高层结构"></a>高层结构</h4><p>浏览器的主要组件为：</p>
<ul>
<li>用户界面：包括地址栏、前进/后退按钮、书签菜单等，除了浏览器主窗口显示的页面外，其他显示的各个部分都属于用户界面；</li>
<li>浏览器引擎：在用户界面和呈现引擎之间传送指令；</li>
<li>呈现引擎：负责显示请求的内容；</li>
<li>网络：用于网络调用，比如 HTTP 请求；</li>
<li>用户界面后端：用于绘制基本的窗口小部件，不如组合框和窗口；</li>
<li>JavaScript 解释器：用于解析和执行 JavaScript 代码；</li>
<li>数据存储：持久层</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/layers.png" srcset="/img/three2.gif" lazyload class title="浏览器的主要组件">



<p>呈现引擎主流程（webkit 引擎）：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webkitflow.png" srcset="/img/three2.gif" lazyload class title="webkit 引擎">

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在硬件级别上，计算机内存由大量触发器组成，每个触发器包含几个晶导管，能够存储一个位；单个触发器可以通过唯一标识符寻址，可与进行读取与覆盖操作（可以把整个计算机内存看作是一个巨大的可读写的位数组）</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul>
<li>分配器：分配所需要的内存；</li>
<li>使用期：使用分配到的内存（读写）；</li>
<li>释放期：不需要时将其释放并归还</li>
</ul>
<p>内存分配 -&gt; 内存使用 -&gt; 内存释放</p>
<h5 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><blockquote>
<p>在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存；内存泄漏并非物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
</blockquote>
<p>如果内存不再需要时，没有经过生命周期的释放期，那么就存在内存泄漏。</p>
<p>简单来说：无用的内存还在占用，得不到释放和归还。</p>
<h4 id="JS-内存管理机制"><a href="#JS-内存管理机制" class="headerlink" title="JS 内存管理机制"></a>JS 内存管理机制</h4><p>JavaScript 是在创建变量时自动进行了分配内存，并在不使用它们时自动释放（垃圾回收）。</p>
<p>JS 不需要程序员手动分配内存，绝大部分情况下也不需要手动释放内存，只需要直接使用内存即可</p>
<ul>
<li>内存分配：JS 定义变量就会自动分配内存，无需了解过深；</li>
<li>内存使用：使用值的过程实际上是对分配内存进行读取和写入的操作；</li>
<li>内存回收：一般称为垃圾内存回收（Garbage Collection）。</li>
</ul>
<p>内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，那么就需要手动清理内存。</p>
<h5 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h5><p>最初级的垃圾收集算法，把 “对象是否不在需要” 简化定义为 “对象有没有其他对象引用到它”；如果没有引用指向该对象，对象将被垃圾回收机制回收。</p>
<p>ES6 中把引用分为强引用和弱引用：</p>
<ul>
<li>强引用才会有引用计数叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（前提是标记清除还没有执行）；</li>
<li>弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。</li>
</ul>
<h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p>当变量进入执行环境时标记为 “进入环境”，当变量离开执行环境时则标记为 “离开环境”；被标记为 “进入环境” 的变量不能被回收，因为正在被使用；标记为 “离开环境” 的变量则可以被回收。</p>
<p>环境可以理解为作用域，但全局作用域的变量只有在页面关闭时才会销毁。</p>
<h4 id="泄漏场景"><a href="#泄漏场景" class="headerlink" title="泄漏场景"></a>泄漏场景</h4><p><strong>意外的全局变量</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在全局作用域下定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">number</span>) </span>&#123;<br>  <span class="hljs-comment">// count 相当于 window.count = 2</span><br>  count = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">return</span> count + number<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的计时器</strong>：</p>
<p>组件销毁时，<code>setInterval</code> 还是在运行的，里面涉及的内存都是无法回收的，需要在组件销毁时清除计时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      this.refreshInterval = setInterval(() =&gt; &#123;<br>        // 轮询获取数据<br>        this.refresh()<br>      &#125;, 2000)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      clearInterval(this.refreshInterval)<br>    &#125;,<br>    methods: &#123;<br>      refresh () &#123;<br>        // 获取一些数据<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的事件监听器</strong>：</p>
<p>组件销毁时，一些事件（如 resize）依然会在监听中，其涉及的内存无法回收，需要在组件销毁时移除相关的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      this.resize = () =&gt; &#123;<br>        // 这里做一些操作<br>      &#125;<br>      window.addEventListener(&#x27;resize&#x27;, this.resize)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      window.removeEventListener(&#x27;resize&#x27;, this.resize)<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的 ES6 Set</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span> &#125;<br>map.add(obj)<br><br><span class="hljs-comment">// 若不进行 delete 操作，则 obj 相关内存无法清除</span><br>map.delete(obj)<br>obj = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p>也可以使用 WeakSet，WeakSet 的成员是弱引用，内存回收不会考虑此引用是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span> &#125;<br>map.add(obj)<br><br>obj = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的 ES6 Map 键名</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br><span class="hljs-keyword">let</span> key = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>map.set(key, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 与 Set 同理，不进行 delete 操作则无法进行回收</span><br>map.delete(key)<br>key = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p>也可以使用 WeakMap，与 WeakSet 同理。</p>
<p><strong>被遗忘的订阅发布事件监听器</strong>：</p>
<p>当组件销毁时，自定义事件依然在监听中，其涉及到的内存无法回收，需要在组件销毁时移除相关的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div @click=&quot;onClick&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  import customEvent from &#x27;event&#x27;<br><br>  export default &#123;<br>    mounted () &#123;<br>      customEvent.on(&#x27;test&#x27;, data =&gt; &#123;<br>        // 一些逻辑<br>        console.log(data)<br>      &#125;)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      customEvent.off(&#x27;test&#x27;)<br>    &#125;,<br>    methods: &#123;<br>      onClick () &#123;<br>        customEvent.emit(&#x27;test&#x27;, &#123; type: &#x27;click&#x27; &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的闭包</strong>：</p>
<p>闭包在带来便利的同时，有可能会带来内存的泄漏：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closure</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> name<br>      .split(<span class="hljs-string">&#x27;&#x27;</span>)<br>      .reverse()<br>      .join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> reverseName = closure()<br><span class="hljs-comment">// name 不是必须的，但还是占用了内存，也无法被回收</span><br></code></pre></div></td></tr></table></figure>

<p><strong>脱离 DOM 的引用</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.elements = &#123;<br>      <span class="hljs-attr">button</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#button&#x27;</span>),<br>      <span class="hljs-attr">div</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div&#x27;</span>),<br>      <span class="hljs-attr">span</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#span&#x27;</span>)<br>    &#125;<br>  &#125;<br>  removeButton () &#123;<br>    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">this</span>.elements.button)<br>    <span class="hljs-comment">// 需要手动释放内存</span><br>    <span class="hljs-comment">// this.elements.button = null</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> Test()<br>a.removeButton()<br></code></pre></div></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能指标-RAIL"><a href="#性能指标-RAIL" class="headerlink" title="性能指标 RAIL"></a>性能指标 RAIL</h3><p>RAIL 是一个以用户为中心的性能模型，把用户的体验拆分成几个关键点，并制定了每一个的性能指标：</p>
<ul>
<li>Response</li>
<li>Animation</li>
<li>Idle</li>
<li>Load</li>
</ul>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>用户的输入到响应的时间不超过 100ms，事件处理最好在 50ms 内完成。</p>
<p>优化方案：</p>
<ul>
<li>考虑到 idle task 的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations 等，不适用于 drag 和 scroll；</li>
<li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞；</li>
<li>超过 50ms 的响应，一定要提供反馈，比如倒计时、进度百分比等。</li>
</ul>
<blockquote>
<p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/173489db13875e5btplv-t2oaga2asx-watermark.awebp" srcset="/img/three2.gif" lazyload class title="Idle Task示意图">
</blockquote>
<h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>产生每一帧的时间不要超过 10ms，旨在视觉上的平滑，用户对于帧率变化感知很敏感。</p>
<p>优化方案：</p>
<ul>
<li>在一些高压节点上，比如动画，不要去挑战 CPU，尽可能的少做事；</li>
<li>在渲染性能上，针对不同的动画做一些特定优化。</li>
</ul>
<blockquote>
<p>动画不只是 UI 的视觉效果，以下行为都属于：</p>
<ul>
<li>视觉动画：如渐隐渐显，tweens，loading 等；</li>
<li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离；</li>
<li>拖拽，缩放等等。</li>
</ul>
</blockquote>
<h4 id="Idle"><a href="#Idle" class="headerlink" title="Idle"></a>Idle</h4><p>最大化空闲时间，以增大 50ms 内响应用户输入的几率。</p>
<p>优化方案：</p>
<ul>
<li>用空闲时间来完成一些延后的工作：<ul>
<li>比如先加载页面可见的部分，然后利用空闲时间加载剩余部分（可以使用 <code>requestIdleCallback API</code>）；</li>
</ul>
</li>
<li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间；</li>
<li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务。</li>
</ul>
<h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><p>根据设备网络等条件优化加载速度，在一个中配 3G 网络手机打开时间不超过 5s，对于第二次打开不超过 2s。</p>
<p>优化方案：</p>
<ul>
<li>在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 <a href="https://link.juejin.cn/?target=https://www.webpagetest.org/easy">WebPageTest</a> 来测试；</li>
<li>要考虑到丢包或者网络波动等情况导致比预期加载慢；</li>
<li>禁用渲染阻塞的资源，延后加载；</li>
<li>可以采用 lazy load，code-splitting 等其他优化手段，是第一次加载的资源更少</li>
</ul>
<h4 id="分析工具使用"><a href="#分析工具使用" class="headerlink" title="分析工具使用"></a>分析工具使用</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li>
<li><a href="https://link.juejin.cn/?target=https://web.dev/measure/">Lighthouse</a></li>
<li><a href="https://link.juejin.cn/?target=https://webpagetest.org/easy">WebPageTest</a></li>
</ul>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>聚焦用户</li>
<li>100ms 内响应用户的输入</li>
<li>10ms 内产生 1 帧，在滚动或者动画执行时</li>
<li>最大化主线程的空闲时间</li>
<li>5s 内让网页变得可交互</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><h3 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h3><h3 id="白屏"><a href="#白屏" class="headerlink" title="白屏"></a>白屏</h3><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><h3 id="动画性能"><a href="#动画性能" class="headerlink" title="动画性能"></a>动画性能</h3><h3 id="渲染合成层"><a href="#渲染合成层" class="headerlink" title="渲染合成层"></a>渲染合成层</h3><h1 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h1><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><br></code></pre></div></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                  <div class="post-meta mr-3">
                    <i class="iconfont icon-category"></i>
                    
                      <a class="hover-with-bg" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
                
                  <div class="post-meta">
                    <i class="iconfont icon-tags"></i>
                    
                      <a class="hover-with-bg" href="/tags/%E5%89%8D%E7%AB%AF/">前端</a>
                    
                  </div>
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均为本人原创，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/10/Sass/">
                        <span class="hidden-mobile">Sass</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz","appKey":"k49y92c0BEE6zL2mCA2AUHKu","placeholder":"说点什么","path":"window.location.pathname","avatar":"monsterid","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://fmlk1v2u.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="/img/万事胜意.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;"> <h5 style="text-align: center; margin-top: 1rem;">谢谢您的光临噢！！！</h5> 
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>张宝文</span> ❤ <span>郑佳丽</span>  
	<!--《添加网站运行时间 -->
<br/>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
var now = new Date(); 

function createtime() {
    //此处修改你的建站时间或者网站上线时间
    var grt = new Date('07/28/2020 17:53:14');
    now.setTime(now.getTime() + 250);
    days = (now - grt) / 1000 / 60 / 60 / 24;

    dnum = Math.floor(days);
    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
        hnum = "0" + hnum;
    }
    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
        mnum = "0" + mnum;
    }
    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
        snum = "0" + snum;
    }
    document.getElementById("timeDate").innerHTML = " 本站已安全运行 " + dnum + " 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()", 250);
</script>

<!-- 添加网站运行时间》-->
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>

  <script>
    function typing(id, title){
        var typed = new Typed('#' + id, {
            strings: [
              '  ',
              title + "&nbsp;",
            ],
            cursorChar: "❤",
            typeSpeed: 150,
            loop: false,
        });
        typed.stop();
        $(document).ready(function () {
            $(".typed-cursor").addClass("h2");
            typed.start();
        });
    }

    
        typing("subtitle", document.getElementById('subtitle').title)
    

  </script>













  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/yinghua.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>