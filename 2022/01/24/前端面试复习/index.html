

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=&#34;auto&#34;>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/zoro3.jpg">
  <link rel="icon" href="/img/zoro3.jpg">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  
  <meta name="theme-color" content="#efb9b9">
  <meta name="description" content="">
  <meta name="author" content="AgoniLay">
  <meta name="keywords" content="">
  
  <title>AgoniLay的博客</title>

  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/css/bootstrap.min.css" />


  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/github-markdown-css@4.0.0/github-markdown.min.css" />
  <link  rel="stylesheet" href="/lib/hint/hint.min.css" />

  
    
    
      
      <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@10.7.2/styles/vs2015.min.css" />
    
  

  
    <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.css" />
  



<!-- 主题依赖的图标库，不要自行修改 -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_ba1fz6golrf.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />

<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/scroller.css">
<link rel="stylesheet" href="/css/bynode.css">
<link rel="stylesheet" href="/css/mouse.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    var CONFIG = {"hostname":"agonilay.github.io","root":"/","version":"1.8.11","typing":{"enable":true,"typeSpeed":150,"cursorChar":"❤","loop":false},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"copy_btn":true,"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/three2.gif","onlypost":true,"offset_factor":2},"web_analytics":{"enable":false,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null}},"search_path":"/local-search.xml"};
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>AgoniLay</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item dropdown">
              <a class="nav-link dropdown-toggle" target="_self" role="button"
                 data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">
                <i class="iconfont icon-bookmark"></i>
                索引
              </a>
              <div class="dropdown-menu" aria-labelledby="navbarDropdown">
                
                  
                  
                  
                  <a class="dropdown-item" href="/archives/">
                    <i class="iconfont icon-archive-fill"></i>
                    归档
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/categories/">
                    <i class="iconfont icon-category-fill"></i>
                    分类
                  </a>
                
                  
                  
                  
                  <a class="dropdown-item" href="/tags/">
                    <i class="iconfont icon-tags-fill"></i>
                    标签
                  </a>
                
              </div>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" data-toggle="modal" data-target="#modalSearch">&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;</a>
          </li>
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="banner" id="banner" parallax=true
         style="background: url('/img/%E8%83%8C%E6%99%AF%E5%9B%BE.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
          <div class="page-header text-center fade-in-up">
            <span class="h3" id="subtitle" title="">
              
            </span>

            
              <div class="mt-3">
  
    <span class="post-meta mr-2">
      <i class="iconfont icon-author" aria-hidden="true"></i>
      AgoniLay
    </span>
  
  
    <span class="post-meta">
      <i class="iconfont icon-date-fill" aria-hidden="true"></i>
      <time datetime="2022-01-24 14:41" pubdate>
        2022年1月24日 下午
      </time>
    </span>
  
</div>

<div class="mt-1">
  
    
    <span class="post-meta mr-2">
      <i class="iconfont icon-chart"></i>
      59.4k 字
    </span>
  

  

  
  
    
      <!-- 不蒜子统计文章PV -->
      <span id="busuanzi_container_page_pv" style="display: none">
        <i class="iconfont icon-eye" aria-hidden="true"></i>
        <span id="busuanzi_value_page_pv"></span> 次
      </span>
    
  
</div>

            
			
			
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div class="py-5" id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none"></h1>
            
              <p class="note note-info">
                
                  本文最后更新于：2022年4月11日 凌晨
                
              </p>
            
            <div class="markdown-body">
              <h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// AgoniLay</span><br></code></pre></div></td></tr></table></figure>

<p>Person 就是一个构造函数，使用 new 创建了一个实例对象 person。</p>
<h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>每一个函数都有一个 prototype 属性，指向正在调用该构造函数而创建的实例的<strong>原型</strong>（每一个 JavaScript 对象(null 除外)在创建的时候会与另一个对象关联，也就是原型，每一个对象都会从原型上继承属性）。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065312e706e67.png" srcset="/img/three2.gif" lazyload class title="原型和构造函数">

<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>每一个JavaScript对象(null除外)都具有一个属性，也就是 <code>__proto__</code>，这个属性指向该对象的原型。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br><span class="hljs-built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>关系图：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065322e706e67.png" srcset="/img/three2.gif" lazyload class title="实例与实例原型的关系图">

<blockquote>
<p>绝大部分浏览器都支持这个非标准的方法访问原型，但并不存在于 Person.prototype 中，而是来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解为返回了 <code>Object.getPrototypeOf(obj)</code>。</p>
</blockquote>
<h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>一个构造函数可以生成多个实例，原型没有属性指向实例，但有原型指向构造函数的属性 <code>constructor</code>，每个原型都有一个 constructor 属性指向关联的构造函数。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;<br>&#125;<br><span class="hljs-built_in">console</span>.log(Person === Person.prototype.constructor) <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065332e706e67.png" srcset="/img/three2.gif" lazyload class title="实例原型与构造函数的关系图">

<p>综上：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.__proto__ === Person.prototype <span class="hljs-comment">// true</span><br>Person.prototype.constructor === Person <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 一个 ES5 的方法，可以得到对象的原型</span><br><span class="hljs-built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220124151146083.png" srcset="/img/three2.gif" lazyload class title="image-20220124151146083">

<h4 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h4><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Person</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Person.prototype.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br><br><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Person()<br>person.name = <span class="hljs-string">&#x27;agoni&#x27;</span><br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// &#x27;agoni&#x27;</span><br><br><span class="hljs-keyword">delete</span> person.name<br><span class="hljs-built_in">console</span>.log(person.name) <span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>原型的最顶层是 <code>Object</code>，<code>Object</code> 的原型是 null</p>
<blockquote>
<p>null 表示“没有对象”，即此处不应该有值。参考：<a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">undefined 和 null</a> </p>
</blockquote>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67.png" srcset="/img/three2.gif" lazyload class title="原型链示意图">

<p>上图中由相互关联的原型组成的链状结构就是原型链（蓝色的那条）。</p>
<blockquote>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，而是在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数，所以其实叫委托更准确。</p>
</blockquote>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>&#125;<br>Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>Child.prototype = <span class="hljs-keyword">new</span> Parent()<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child()<br>child.getName() <span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>注意：</p>
<ol>
<li>引用类型的属性将被所有实例共享；</li>
<li>在创建 Child 实例时，不能向 Person 传参</li>
</ol>
<h4 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.names = [<span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-string">&#x27;lay&#x27;</span>]<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params"></span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child()<br>child1.names.push(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br><span class="hljs-built_in">console</span>.log(child1.names) <span class="hljs-comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;, &#x27;AgoniLay&#x27;]</span><br><br><span class="hljs-keyword">var</span> child2 = <span class="hljs-keyword">new</span> Child()<br><span class="hljs-built_in">console</span>.log(child2.names) <span class="hljs-comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<p>优点：</p>
<ol>
<li>避免了引用类型的属性被所有实例共享</li>
<li>可以在 Child 中向 Parent 传参</li>
</ol>
<p>缺点：</p>
<ol>
<li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li>
</ol>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>结合了原型链继承和经典继承：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br>Parent.prototpye.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>, name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br>child.prototype = <span class="hljs-keyword">new</span> Parent()<br>child.prototype.constructor = Child<br><br><span class="hljs-keyword">var</span> child11 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">20</span>)<br>child1.colors.push(<span class="hljs-string">&#x27;pink&#x27;</span>)<br><br><span class="hljs-built_in">console</span>.log(child1.name)		<span class="hljs-comment">// &#x27;AgoniLay&#x27;</span><br><span class="hljs-built_in">console</span>.log(child1.age)			<span class="hljs-comment">// 20</span><br><span class="hljs-built_in">console</span>.log(child1.colors)	<span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]</span><br><br><span class="hljs-keyword">var</span> child11 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">18</span>)<br><br><span class="hljs-built_in">console</span>.log(child2.name)		<span class="hljs-comment">// &#x27;agoni&#x27;</span><br><span class="hljs-built_in">console</span>.log(child2.age)			<span class="hljs-comment">// 18</span><br><span class="hljs-built_in">console</span>.log(child2.colors)	<span class="hljs-comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span><br></code></pre></div></td></tr></table></figure>

<p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p>
<p>缺点：会调用两次父构造函数</p>
<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>就是 ES5 <code>Object.create()</code> 的模拟实现，将传入的对象多为创建的对象的原型。</p>
<p>缺点：包含引用类型的属性始终都会共享相应的值，同原型链继承。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createObj</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> clone = <span class="hljs-built_in">Object</span>.create(o)<br>  clone.sayName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hi&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">return</span> clone<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>缺点：和借用构造函数模式一样，每次创建对象都会创建一遍方法。</p>
<h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>避免组合继承中的两次调用父构造函数：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span> (<span class="hljs-params">name</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.name = name<br>  <span class="hljs-built_in">this</span>.colors = [<span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-string">&#x27;blue&#x27;</span>, <span class="hljs-string">&#x27;green&#x27;</span>]<br>&#125;<br>Parent.prototpye.getName = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span> (<span class="hljs-params">name, age</span>) </span>&#123;<br>  Parent.call(<span class="hljs-built_in">this</span>, name)<br>  <span class="hljs-built_in">this</span>.age = age<br>&#125;<br><br><span class="hljs-comment">// 关键步骤</span><br><span class="hljs-keyword">var</span> F = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>F.prototype = Parent.prototype<br>Child.prototype = <span class="hljs-keyword">new</span> F()<br><br><span class="hljs-keyword">var</span> child1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-number">20</span>)<br><span class="hljs-built_in">console</span>.log(child1)<br></code></pre></div></td></tr></table></figure>

<p>对这个继承方法进行封装：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">object</span> (<span class="hljs-params">o</span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">F</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  F.prototype = o<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> F()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">prototype</span> (<span class="hljs-params">child, parent</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> prototype = object(parent.prototype)<br>  prototype.constructor = child<br>  child.prototype = prototype<br>&#125;<br><br>prototype(Child, Parent)<br></code></pre></div></td></tr></table></figure>

<p>优点：高效率，体现在只调用了一次 Parent 构造函数，并且因此避免了在 <code>Parent.prototype</code> 上创建不必要的属性，同时原型链还能保持不变，因此也可以正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。</p>
<blockquote>
<p>普遍认为 寄生组合式继承式引用类型最理想的继承方式。</p>
</blockquote>
<h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 JavaScript 代码执行一段可执行代码（execution code）时，会创建对应的执行上下文（execution context）。</p>
<p>对于每个执行上下文，都有三个重要属性：</p>
<ul>
<li></li>
<li><p>变量对象（Variable Object，VO）</p>
</li>
<li><p>作用域链（Scope chain）</p>
</li>
<li><p>this</p>
</li>
</ul>
<p>函数的作用域在函数定义的时候就确定了，因为函数有一个内部属性 <code>[[scope]]</code>，当函数创建时，就会保存多有父变量对象到其中，可以将 <code>[[scope]]</code> 理解为所有父变量对象的层级链，但 <code>[[scope]]</code> 并不代表完整的作用域链。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">bar</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>函数创建时，各自的 <code>[[scope]]</code> 如下：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">foo.[[scope]] = [<br>  globalContext.VO<br>]<br><br>bar.[[scope]] = [<br>  fooContext.AO,<br>  globalContext.VO<br>]<br></code></pre></div></td></tr></table></figure>

<p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用域链的前端：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 执行上下文的作用域链</span><br>Scope = [AO].concat([[scope]])<br></code></pre></div></td></tr></table></figure>

<p>作用域链创建完毕。</p>
<h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p>
<h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><ol>
<li>可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象；</li>
<li>全局对象是由 Object 构造函数实例化的一个对象；</li>
<li>预定义了一些函数和属性；</li>
<li>作为全局变量的宿主；</li>
<li>客户端 JavaScript 中，全局对象由 window 属性指向自身；</li>
</ol>
<p>全局上下文中的变量对象就是全局对象。</p>
<h4 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h4><p>在函数上下文中，用活动对象（Activation object，AO）来表示变量对象。</p>
<p>变量对象是规范上或者说是引擎上实现的，不可以在 JavaScript 环境中访问，只有在进入到一个执行上下文中，变量对象才会被激活，也就成为了活动对象，其中的各种属性才可以被访问。</p>
<h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行上下文的代码会分为两个阶段进行处理：分析和执行</p>
<ol>
<li>进入执行上下文</li>
<li>代码执行</li>
</ol>
<h5 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h5><p>变量对象包括：</p>
<ol>
<li>函数的所有形参（是函数上下文的话）<ul>
<li>由名称和对应值组成的一个变量对象的属性被创建</li>
<li>没有实参，属性值设为 <code>undefined</code> </li>
</ul>
</li>
<li>函数声明<ul>
<li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li>
<li>如果变量对象已经存在相同名称的属性，则<strong>完全替代</strong>这个属性</li>
</ul>
</li>
<li>变量声明<ul>
<li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li>
<li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明<strong>不会干扰</strong>已经存在的这类属性</li>
</ul>
</li>
</ol>
<p>例子：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params">a</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> b = <span class="hljs-number">2</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  <span class="hljs-keyword">var</span> d = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>  b = <span class="hljs-number">3</span><br>&#125;<br>foo(<span class="hljs-number">1</span>)<br></code></pre></div></td></tr></table></figure>

<p>进入执行上下文后，这时候的 AO 为：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">AO = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-literal">undefined</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span> (<span class="hljs-params"></span>) </span>&#123;&#125;,<br>  <span class="hljs-attr">d</span>: <span class="hljs-literal">undefined</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>在代码执行阶段，顺序执行代码，根据代码修改变量对象的值：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">AO = &#123;<br>  <span class="hljs-attr">arguments</span>: &#123;<br>    <span class="hljs-number">0</span>: <span class="hljs-number">1</span><br>    <span class="hljs-attr">length</span>: <span class="hljs-number">1</span><br>  &#125;,<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">b</span>: <span class="hljs-number">3</span>,<br>  <span class="hljs-attr">c</span>: reference to <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c</span>(<span class="hljs-params"></span>)</span>&#123;&#125;,<br>  <span class="hljs-attr">d</span>: reference to FunctionExpression <span class="hljs-string">&quot;d&quot;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>总结：</p>
<ol>
<li>全局上下文的变量对象初始化是全局对象；</li>
<li>函数上下文的变量对象初始化只包括 arguments 对象；</li>
<li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；</li>
<li>在代码执行阶段，会再次修改变量对象的属性值</li>
</ol>
<h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>ECMAScript 的类型分为语言类型和规范类型。</p>
<ul>
<li>语言类型是开发者直接使用 ECMAScript 可以操作的，包括：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 和 <code>Object</code>；</li>
<li>规范类型先相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的，包括：<code>Reference</code>、<code>List</code>、<code>Completion</code>、<code>Property Descriptor</code>、<code>Property Identifier</code>、<code>Lexical Environment</code> 和 <code>Environment Record</code> </li>
</ul>
<h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>Reference 类型是用来解释 delete、typeof 以及赋值等操作行为的</p>
<blockquote>
<p>这里的 Reference 是一个 Specification Type，也就是只存在于规范里的抽象类型。是为了更好地描述语言的底层行为逻辑而存在，并不存在于实际的 js 代码中。</p>
</blockquote>
<p>Reference 由三部分构成：</p>
<ul>
<li>base value：属性所在的对象，它的值只能是 <code>Undefined</code>、<code>Object</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 或者 <code>environment record</code> 其中的一种</li>
<li>referenced name：属性的名称</li>
<li>strict reference：一个 <code>Boolean</code> 值，用来检测 strict mode 下的一些限制</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span><br>  &#125;<br>&#125;<br>foo.bar()<br><br><span class="hljs-comment">// foo 对应的 Reference 是：</span><br><span class="hljs-keyword">var</span> fooReference = &#123;<br>  <span class="hljs-attr">base</span>: EnvironmentRecord,<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;foo&#x27;</span>,<br>  <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;<br><br><span class="hljs-comment">// bar 对应的 Rederence 是：</span><br><span class="hljs-keyword">var</span> barReference = &#123;<br>  <span class="hljs-attr">base</span>: foo,<br>  <span class="hljs-attr">propertyName</span>: <span class="hljs-string">&#x27;bar&#x27;</span>,<br>  <span class="hljs-attr">strict</span>: <span class="hljs-literal">false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>Reference 方法：</p>
<ul>
<li><code>GetBase()</code>：返回 reference 的 base value</li>
<li><code>IsPropertyReference()</code>：如果 base value 是一个对象则返回 true</li>
<li><code>GetValue()</code>：返回对象属性真正的值，<strong>返回的将是具体的值，而不再是一个 Reference</strong>。</li>
</ul>
<h4 id="确定-this"><a href="#确定-this" class="headerlink" title="确定 this"></a>确定 this</h4><ol>
<li>计算 <code>MemeberExpression</code> 的结果赋值给 ref</li>
<li>判断 ref 是不是一个 Reference 类型<ol>
<li>是，并且 <code>IsPropertyReference(ref)</code> 是 true，那么 this 的值为 <code>GetBase(ref)</code> </li>
<li>不是，this 为 undefined</li>
</ol>
</li>
</ol>
<p><code>MemeberExpression</code>：</p>
<ul>
<li><code>PrimaryExpression</code>：原始表达式</li>
<li><code>FunctionExpression</code>：函数定义表达式</li>
<li><code>MemeberExpression[Expression]</code>：属性访问表达式</li>
<li><code>MemeberExpression.IdentifierName</code>：属性访问表达式</li>
<li><code>new MemeberExpression Arguments</code>：对象创建表达式</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>foo() <span class="hljs-comment">// MemeberExpression 是 foo</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br>foo()() <span class="hljs-comment">// MemeberExpression 是 foo()</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br>&#125;<br>foo.bar() <span class="hljs-comment">// MemeberExpression 是 foo.bar</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>可以简单理解 <code>MemeberExpression</code> 就是 <code>()</code> 左侧的部分</p>
</blockquote>
<p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> value = <span class="hljs-number">1</span><br><br><span class="hljs-keyword">var</span> foo = &#123;<br>  <span class="hljs-attr">value</span>: <span class="hljs-number">2</span>,<br>  <span class="hljs-attr">bar</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.value<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//示例1</span><br><span class="hljs-built_in">console</span>.log(foo.bar())		<span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例2</span><br><span class="hljs-built_in">console</span>.log((foo.bar)())	<span class="hljs-comment">// 2</span><br><span class="hljs-comment">//示例3</span><br><span class="hljs-built_in">console</span>.log((foo.bar = foo.bar)())	<span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例4</span><br><span class="hljs-built_in">console</span>.log((<span class="hljs-literal">false</span> || foo.bar)())		<span class="hljs-comment">// 1</span><br><span class="hljs-comment">//示例5</span><br><span class="hljs-built_in">console</span>.log((foo.bar, foo.bar)())		<span class="hljs-comment">// 1</span><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>赋值、逻辑运算，逗号运算均会调用 <code>GetValue()</code> 方法，返回的并不是 Reference 类型，而是真正的值，所以不满足第二步判断，进而 this 指向 undefined（在非严格模式下，this 的值为 undefined 时将会隐式转换为全局对象）</p>
</blockquote>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote>
<p>MDN 对于闭包的定义：闭包是指那些能够访问自由变量的函数</p>
<p>自由变量：指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</p>
<p>闭包 = 函数 + 函数能够访问的自由变量</p>
</blockquote>
<p>如：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(a)<br>&#125;<br>foo()<br></code></pre></div></td></tr></table></figure>

<p>foo 函数可以访问变量 a，但 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量，所以理论上函数 foo + foo 函数访问的自由变量 a 就构成了一个闭包。</p>
<p>上面描述的是理论上的闭包，还有一个实践角度的闭包：</p>
<p>ECMAScript 中，闭包指：</p>
<ol>
<li>从理论角度：所有的函数（在函数中访问全局变量就相当于是在访问自由变量）</li>
<li>从实践角度：<ol>
<li>即使创建它的上下文已经销毁，它依然存在（如内部函数从父函数中返回）</li>
<li>在代码中引用了自由变量</li>
</ol>
</li>
</ol>
<h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;global scope&#x27;</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">checkscope</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> scope = <span class="hljs-string">&#x27;local scope&#x27;</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">f</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> scope<br>  &#125;<br>  <span class="hljs-keyword">return</span> f<br>&#125;<br><span class="hljs-keyword">var</span> foo = checkscope()<br>foo()<br></code></pre></div></td></tr></table></figure>

<p>执行过程：</p>
<ol>
<li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；</li>
<li>全局执行上下文初始化；</li>
<li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；</li>
<li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等；</li>
<li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；</li>
<li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；</li>
<li>f 执行上下文初始化，创建变量对象、作用域链、this 等；</li>
<li>f 函数执行完毕，f 执行上下文从执行上下文栈中弹出。</li>
</ol>
<p>f 之所以可以访问到 checkscope 作用域中的值，是因为 f 执行上下文维护了一个作用域链：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">fContext = &#123;<br>	<span class="hljs-attr">Scope</span>: [AO, checkscopeContext.AO, globalContext.VO]<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>因此，当 f 函数引用了 <code>checkscopeContext.AO</code> 中的值时，即使 <code>checkscopeContext</code> 被销毁了，但 JavaScript 仍会让 <code>checkscopeContext.AO</code> 存活在内存中，f 函数依然可以通过其自身的作用域链访问。</p>
<h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>指被立即调用的函数表达式（Immediately-Invoked Function Expression，IIFE）</p>
<p>括号出现在函数周边的规则：</p>
<ul>
<li>当圆括号出现在匿名函数的末尾想要想要调用函数时，它会默认将函数当成是函数声明</li>
<li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明</li>
</ul>
<p>所以有以下两种 IIFE 的写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;())<br><span class="hljs-comment">// 或</span><br>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;)()<br></code></pre></div></td></tr></table></figure>

<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，可以判断 <code>number</code>、<code>string</code>、<code>object</code>、<code>boolean</code>、<code>function</code>、<code>undefined</code>、<code>symbol</code> 七种类型，返回值为<strong>字符串</strong>类型。</p>
<p>在判断不是 object 类型的数据时，<code>typeof</code> 能比较清楚的返回具体是什么类型，但无法细分判断是那种 object 类型。</p>
<p>原理：</p>
<p>js 在底层存储变量时，会在变量的机器码的低位1-3位存储其类型信息：</p>
<ul>
<li>000：对象</li>
<li>010：浮点数</li>
<li>100：字符串</li>
<li>110：布尔值</li>
<li>1：整数</li>
</ul>
<p>对于 null 和 undefined 来说，这两个值的信息存储特殊：</p>
<ul>
<li>null：所有机器码均为 0</li>
<li>undefined：用 <code>-2^30</code> 整数来表示</li>
</ul>
<p>所以，<code>typeof</code> 在判断 null 时就会把 null 当为 object 来看待。</p>
<blockquote>
<p>避免使用 typeof 判断 null，也可以使用 <code>Object.prototype.toString.call()</code> 判断。</p>
</blockquote>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 用于：</p>
<ul>
<li>判断对象的具体类型</li>
<li>判断一个实例是否属于某种类型</li>
<li>判断一个实例是否是其父类型或祖先类型的实例</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> person = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><span class="hljs-keyword">let</span> nicole = <span class="hljs-keyword">new</span> person()<br>nicole <span class="hljs-keyword">instanceof</span> person <span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure>

<p>原理：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">new_instance_of</span> (<span class="hljs-params">leftValue, rightValue</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> rightProto = rightValue.prototype<br>  leftValue = leftValue.__proto__<br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (leftValue === <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>    &#125;<br>    <span class="hljs-keyword">if</span> (leftValue === rightProto) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>    &#125;<br>    leftValue = leftValue.__proto__<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>原型继承原理：</p>


<p><code>Object instanceof Object</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">leftValue = <span class="hljs-built_in">Object</span>.__proto__ = <span class="hljs-built_in">Function</span>.prototype<br>rightValue = <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// 第一次判断</span><br>leftValue !== rightValue<br>leftValue = <span class="hljs-built_in">Function</span>.prototype.__proto__ = <span class="hljs-built_in">Object</span>.prototype<br><span class="hljs-comment">// 第二次判断</span><br>leftValue === rightValue<br><span class="hljs-comment">// 返回 true</span><br></code></pre></div></td></tr></table></figure>

<p><code>Function instanceof Funciton</code> 和 <code>Function instanceof Object</code> 同理。</p>
<h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call apply"></a>call apply</h3><p>共同点：都能改变函数执行时的上下文，将一个对象交给另一个对象来执行，且立即执行。</p>
<h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>call 在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.call(object[, param1 [, param2[, ... [, paramN]]]])<br></code></pre></div></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>调用者必须是函数 Function</li>
<li>call 的第一个参数是一个对象，Function 的调用者将会指向这个对象，不传则默认为 window</li>
<li>第二个参数开始可以接收任意个参数</li>
</ul>
<p>使用场景：</p>
<ol>
<li>对象的继承</li>
<li>借用方法：比如类数组借用数组原型链上的方法</li>
</ol>
<p>模拟实现：</p>
<ol>
<li>将函数设置为对象的属性；</li>
<li>执行该函数；</li>
<li>删除该函数</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span><br>  context.fn = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> args = []<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>    args.push(<span class="hljs-string">&#x27;arguments[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">var</span> result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.apply(object[, argArray])<br></code></pre></div></td></tr></table></figure>

<p>注意点：</p>
<ul>
<li>调用者必须是函数 Function</li>
<li>最多接受两个参数，第一个参数于 call 一致</li>
<li>第二个参数必须是数组或者类数组，会被转换为类数组，传入 Function 中，并映射到 Function 对应的参数上</li>
</ul>
<blockquote>
<p>类数组：具备与数组特征类似的对象，可以通过角标调用，具有长度属性 length，可以通过 for 循环进行遍历；无法使用 forEach、splice、push 等数组原型链上的方法。</p>
</blockquote>
<p>使用场景：</p>
<ol>
<li><p><code>Math.max</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 获取数组中最大的一项</span><br><span class="hljs-keyword">let</span> max = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, array)<br><span class="hljs-comment">// 获取数组中最小的一项</span><br><span class="hljs-keyword">let</span> min = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, array)<br></code></pre></div></td></tr></table></figure></li>
<li><p>数组合并</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-keyword">let</span> arr2 = [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>]<br><span class="hljs-built_in">Array</span>.prototype.push.apply(arr1, arr2)<br></code></pre></div></td></tr></table></figure></li>
</ol>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context, arr</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> context = context || <span class="hljs-built_in">window</span><br>  context.fn = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> result<br>  <span class="hljs-keyword">if</span> (!arr) &#123;<br>    result = context.fn()<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">var</span> args = []<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      args.push(<span class="hljs-string">&#x27;arr[&#x27;</span> + i + <span class="hljs-string">&#x27;]&#x27;</span>)<br>    &#125;<br>    result = <span class="hljs-built_in">eval</span>(<span class="hljs-string">&#x27;context.fn(&#x27;</span> + args + <span class="hljs-string">&#x27;)&#x27;</span>)<br>  &#125;<br>  <span class="hljs-keyword">delete</span> context.fn<br>  <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind()</code> 方法会创建一个新函数。当这个函数被调用时，bind 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p>
<p>写法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></div></td></tr></table></figure>

<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myBind = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">this</span> !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;Function.prototype.bind - what is trying to be bound is not callable.&#x27;</span>)<br>  &#125;<br><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-built_in">this</span><br>  <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)<br><br>  <span class="hljs-keyword">var</span> fNOP = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;&#125;<br><br>  <span class="hljs-keyword">var</span> fBound = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> bindArgs = <span class="hljs-built_in">Array</span>.prototype.slice.call(<span class="hljs-built_in">arguments</span>)<br>    <span class="hljs-keyword">return</span> self.apply(<span class="hljs-built_in">this</span> <span class="hljs-keyword">instanceof</span> fNOP ? <span class="hljs-built_in">this</span> : context, args.conact(bindArgs))<br>  &#125;<br><br>  fNOP.prototype = <span class="hljs-built_in">this</span>.prototype<br>  fBound.prototype = <span class="hljs-keyword">new</span> fNOP()<br>  <span class="hljs-keyword">return</span> fBound<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-comment">// 执行 add 函数，需一次传入两个参数</span><br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br><br><span class="hljs-comment">// 一个 curry 函数可以做到柯里化</span><br><span class="hljs-keyword">var</span> addCurry = curry(add)<br>addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>

<h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>避免重复调用函数时的参数冗余，精简代码</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sub_curry</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> args = [].slice.call(<span class="hljs-built_in">arguments</span>, <span class="hljs-number">1</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, args.concat([].slice.call(<span class="hljs-built_in">arguments</span>)))<br>  &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, length</span>) </span>&#123;<br>  length = length || fn.length<br>  <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt; length) &#123;<br>      <span class="hljs-keyword">var</span> combined = [fn].concat(slice.call(<span class="hljs-built_in">arguments</span>))<br>      <span class="hljs-keyword">return</span> curry(sub_curry.apply(<span class="hljs-built_in">this</span>, combined), length - <span class="hljs-built_in">arguments</span>.length)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>)<br>    &#125;<br>  &#125;<br>&#125;<br><br>curry(fn)<br>fn()()<br></code></pre></div></td></tr></table></figure>

<p><code>sub_curry</code> 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 <code>fn()()</code> 时，执行包裹函数，返回原函数，然后再调用 <code>sub_curry</code> 包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的数目达到要求为止。</p>
<h4 id="易懂实现"><a href="#易懂实现" class="headerlink" title="易懂实现"></a>易懂实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, args</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> length = fn.length<br>  args = args || []<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _args = args.slice(<span class="hljs-number">0</span>),<br>        arg, i<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      arg = <span class="hljs-built_in">arguments</span>[i]<br>      _args.push(arg)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_args.length &lt; length) &#123;<br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, _args)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, _args)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>增加占位符功能：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">curry</span> (<span class="hljs-params">fn, args, holes</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> length = fn.length<br>  args = args || []<br>  holes = holes || []<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> _args = args.slice(<span class="hljs-number">0</span>),<br>        _holes = holes.slice(<span class="hljs-number">0</span>),<br>        argsLen = args.length,<br>        holesLen = holes.length,<br>        arg, i, index = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>, len = <span class="hljs-built_in">arguments</span>.length; i &lt; len; i++) &#123;<br>      arg = <span class="hljs-built_in">arguments</span>[i]<br>      <span class="hljs-comment">// 处理类似 fn(1, _, _, 4)(_, 3) 这种情况</span><br>      <span class="hljs-keyword">if</span> (arg === _ &amp;&amp; holesLen) &#123;<br>        index++<br>        <span class="hljs-keyword">if</span> (index &gt; holesLen) &#123;<br>          _args.push(arg)<br>          _holes.push(argsLen - <span class="hljs-number">1</span> + index - holesLen)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (arg === _) &#123;<br>        _args.push(arg)<br>        _holes.push(argsLen + i)<br>      &#125;<br>      <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (holesLen) &#123;<br>        <span class="hljs-keyword">if</span> (index &gt;= holesLen) &#123;<br>          _args.push(arg)<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>          _args.splice(_holes[index], <span class="hljs-number">1</span>, arg)<br>          _holes.splice(index, <span class="hljs-number">1</span>)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">else</span> &#123;<br>        _args.push(arg)<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (_holes.length || _args.length &lt; length) &#123;<br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-built_in">this</span>, fn, _args, _holes)<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, _args)<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> _ = &#123;&#125;<br><br><span class="hljs-keyword">var</span> fn = curry(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b, c, d, e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log([a, b, c, d, e])<br>&#125;)<br><br><span class="hljs-comment">// 输出均为 [1, 2, 3, 4, 5]</span><br>fn(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)<br>fn(_, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">1</span>)<br>fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)(<span class="hljs-number">2</span>)<br>fn(<span class="hljs-number">1</span>, _, <span class="hljs-number">3</span>)(_, <span class="hljs-number">4</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br>fn(<span class="hljs-number">1</span>, _, _, <span class="hljs-number">4</span>)(_, <span class="hljs-number">3</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">5</span>)<br>fn(_, <span class="hljs-number">2</span>)(_, _, <span class="hljs-number">4</span>)(<span class="hljs-number">1</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">5</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在这个实现中，实现了一个强大的 curry 函数，不仅可以传入一个参数，还可以一次传入两个参数甚至更多，这更像是一个柯里化（curry）和偏函数（partial application）的综合应用。</p>
</blockquote>
<h4 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> curry = <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span><br>	judge = <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span><br>		args.length === fn.length<br>			? fn(...args)<br>			: <span class="hljs-function"><span class="hljs-params">arg</span> =&gt;</span> judge(...args, arg)<br></code></pre></div></td></tr></table></figure>

<h3 id="V8-垃圾回收"><a href="#V8-垃圾回收" class="headerlink" title="V8 垃圾回收"></a>V8 垃圾回收</h3><h4 id="为何垃圾回收"><a href="#为何垃圾回收" class="headerlink" title="为何垃圾回收"></a>为何垃圾回收</h4><p>V8 执行 JavaScript 代码时，当遇到函数时，会为其创建一个执行上下文环境并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所有变量，当函数执行完后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的变量也会统一释放并被自动回收。</p>
<p>若不进行回收，将会持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕后应还给操作系统以保证内存的重复利用。</p>
<p>JavaScript 作为一门高级编程语言，并不需要像 C 语言或 C++ 语言中手动地申请分配和释放内存，V8 引擎已经自动进行了内存的分配和管理。</p>
<h4 id="V8-引擎的内存限制"><a href="#V8-引擎的内存限制" class="headerlink" title="V8 引擎的内存限制"></a>V8 引擎的内存限制</h4><p>默认情况下，V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 <code>0.7GB</code> 的内存，这将会导致在 Node 中无法直接操作大内存对象。</p>
<p>限制原因：</p>
<ol>
<li>V8 引擎设计之初只是作为浏览器端 JavaScript 的执行环境，在浏览器中很少会遇到使用大量内存的情况，因此不必将最大内存设置得过高；</li>
<li>JS 是单线程机制，意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务，这意味着在 V8 执行垃圾回收时，程序中的其他逻辑都要进入暂停等待阶段，直到垃圾回收完成后才会再次执行 JS 逻辑；</li>
<li>垃圾回收本身也是一件非常耗时的操作，做一次小的垃圾回收需要 50ms 以上，而做一次非增量回收甚至需要 1s 以上，在这时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，会造成动画的卡顿掉帧情况，严重影响应用程序的性能。</li>
</ol>
<p>基于以上几点，V8 为了减少对应用性能造成的影响，就直接限制了堆内存的大小。</p>
<p>解决：</p>
<p>但在 node 端，涉及到的 <code>I/O</code> 操作可能会不够用，因此 V8 提供了可配置项来手动调整内存大小：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看 node 中可用的 v8 引擎的选项及其含义</span><br>node --v8-options<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125213324542.png" srcset="/img/three2.gif" lazyload class title="node V8 选项">

<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最小值，单位 MB</span><br>node --min-semi-space-size=1024 xxx.js<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最大值，单位 MB</span><br>node --max-semi-space-szie=1024 xxx.js<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 设置老生代内存最大值，单位 MB</span><br>node --max-old-space-size=2048 xxx.js<br></code></pre></div></td></tr></table></figure>

<p>通过上面的方法可以手动放宽 V8 引擎的内存使用限制，node 中提供了 <code>process.memoryUsage()</code> 方法来查看当前 node 进程中占用的实际内存大小。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125214633666.png" srcset="/img/three2.gif" lazyload class title="process.memoryUsage">

<p>上图中字段含义如下（单位均为字节）：</p>
<ul>
<li><p><code>rss</code>（resident set size）：表示驻留集大小，即给这个 node 进程分配了多少物理内存（包括堆、栈和代码片段）</p>
<blockquote>
<p>当使用  <code>Worker</code> 线程时，<code>rss</code> 是对整个进程都有效的值，其他字段只涉及当前线程</p>
</blockquote>
</li>
<li><p><code>heapTotal</code>：表示 V8 当前申请到的堆内存总大小</p>
</li>
<li><p><code>heapUsed</code>：表示当前内存使用量</p>
</li>
<li><p><code>external</code>：表示 V8 内部的 C++ 对象所占用的内存</p>
</li>
<li><p><code>arrayBuffers</code>：指为 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 分配的内存，包括所有 Node Buffer，包含在 <code>external</code> 值中</p>
</li>
</ul>
<h4 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h4><h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5><p>V8 的内存结构主要由以下几个部分组成：</p>
<ul>
<li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这个区域，此区域相对较小，但回收特别频繁；该区域被分为两半，一半用来回收内存，一半用于在垃圾回收时复制需要保留的对象；</li>
<li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会<strong>晋升</strong>到老生代内存区，相对于新生代该区域垃圾回收的频率较低；老生代分为：<ul>
<li> <code>老生代指针区</code>：包含大多数可能存在指向其他对象的指针的对象；</li>
<li><code>老生代数据区</code>：只保存原始数据对象，这些对象没有指向其他对象的指针；</li>
</ul>
</li>
<li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区；</li>
<li><code>代码区(code_space)</code>：代码对象分配区域，唯一拥有执行权限的内存区域；</li>
<li><code>map 区(map_space)</code>：存放 Cell 和 Map，每个区域都是存放相同大小的元素.</li>
</ul>
<h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代主要用于存放存活时间较短的对象。新生代内存由两个 <code>semispace(半空间)</code> 构成，内存最大值在 64 位和 32 位系统默认分别为 <code>32MB</code> 和 <code>16MB</code>，在新生代的垃圾回收过程中主要采用了 <code>Scavenge</code> 算法。</p>
<p>Scavenge 算法：典型的牺牲空间换时间的算法，主要过程是<u>将存活对象在 <code>From</code> 空间和 <code>To</code> 空间之间进行复制，同时完成两个空间之间的角色互换</u>。</p>
<h5 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h5><p><u>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中</u>，即为 <strong>晋升</strong>。</p>
<p>晋升条件（两者满足其一）：</p>
<ol>
<li>对象是否经历过一次 <code>Scavenge</code> 算法</li>
<li><code>To</code> 空间的内存占比是否已经超过 <code>25%</code> </li>
</ol>
<h5 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h5><p>老生代中采用 <code>Mark-Sweep(标记清除)</code> 和 <code>Mark-Compact(标记整理)</code> 算法进行管理。</p>
<p><code>Mark-Sweep</code> 分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，<u>在标记阶段遍历堆中所有的对象，标记活着的对象，在清除对象，会将死亡的对象进行清除</u>，具体步骤如下：</p>
<ol>
<li>垃圾回收器在内部构建一个根列表，从根节点出发去寻找那些可以被访问到的变量（比如 window 全局对象可以看成一个根节点）；</li>
<li>垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，将其标记为活动的，未到达的即为非活动的；</li>
<li>最后，释放所有非活动的内存块，归还给操作系统。</li>
</ol>


<p>在 <code>Mark-Sweep</code> 之后，内存空间会出现大量不连续的状态，就会出现内存碎片的问题，可能导致后面无法分配大对象而提前触发垃圾清理，但其实毫无必要，所以需进行 <code>Mark-Compact</code>，来解决内存的碎片化问题，具体步骤：</p>
<p>在将死亡对象全部清除后，在整理过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。</p>
<p>至此完成了一次老生代垃圾回收的全部过程，之前提到由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会恢复执行主任务的逻辑，也就是 <strong>全停顿</strong>。</p>
<p>于是 V8 引擎引入了 <code>Incremental Marking(增量标记)</code> 的概念：<u>将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存</u>。</p>
<p>尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p>
<p>V8 还引入了 <code>Lazy Sweeping(延时清理)</code> 和 <code>Incremental Compation(增量式整理)</code>，使得清理和整理的过程也变为增量式的。</p>
<h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><ol>
<li><p>尽可能少地创建全局变量；</p>
</li>
<li><p>手动清除定时器：<code>clearInterval(timer)</code>、<code>clearTimeout(timer)</code>；</p>
</li>
<li><p>少用闭包；</p>
</li>
<li><p>清除 DOM 引用：使用 <code>document.body.removeChild(document.getElementById(&#39;button&#39;))</code>；</p>
</li>
<li><p>弱引用：<code>WeakMap</code> 和 <code>WeakSet</code>。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125230318519.png" srcset="/img/three2.gif" lazyload class title="弱引用"></li>
</ol>
<h3 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>ECMAScript 中 Number 类型使用 IEEE754 标准（IEEE 二进制浮点数算数标准）来表示整数和浮点数。</p>
<p>其中规定了四种表示浮点数值的方式：</p>
<ol>
<li>单精确度（32 位）</li>
<li>双精确度（64 位）：ECMAScript 采用的就是双精确度。</li>
<li>延伸单精确度</li>
<li>延伸双精确度</li>
</ol>
<h4 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h4><p>1020 用十进制表示：</p>
<blockquote>
<p>1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0</p>
</blockquote>
<p>1030 用二进制表示：</p>
<blockquote>
<p>1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0</p>
</blockquote>
<p>也就是 <code>1111111100</code> </p>
<hr>
0.75 用二进制表示：

<blockquote>
<p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p>
</blockquote>
<p>两边同时乘 2：</p>
<blockquote>
<p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3 + … (所以 a = 1)</p>
<p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3 + …</p>
</blockquote>
<p>再同时乘 2：</p>
<blockquote>
<p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3 + … (所以 b = 1)</p>
</blockquote>
<p>所以 0.75 就是 <code>0.11</code></p>
<hr>
但一些小数计算会一直循环，如 0.1 用二进制表示就是 `0.00011001100110011......` 

<h4 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h4><p>IEEE 754 认为，一个浮点数（Value）可以这样表示：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Value = sign * exponent * fraction<br></code></pre></div></td></tr></table></figure>

<p>也就是科学计数法，如 -1020 用科学计数法表示就是：</p>
<blockquote>
<p>-1 * 10^3 * 1.02</p>
</blockquote>
<p>对于 0.1 的二进制 <code>0.00011001100110011......</code> 来说，可以表示为：</p>
<blockquote>
<p>1 * 2^-4 * 1.1001100110011……</p>
</blockquote>
<p>只做二进制可续计数法的表示时， Value 的表示可以更具体：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">Value = (-<span class="hljs-number">1</span>)^S * (<span class="hljs-number">1</span> + Fraction) * <span class="hljs-number">2</span>^E<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；S = 1，V 为负数；</li>
<li><code>(1 + Fraction)</code>：因为所有的浮点数都可以表示为 <code>1.xxx * 2^xxx</code> 的形式，前面也一定是 <code>1.xxx</code>，故存储 Fraction 为 1 后面的 xxx；</li>
<li><code>2^E</code>：用 8 位来存储 E 这个数，只有正数则范围是 0 ~ 254，但由于有负值，所以值的范围是 -127 ~ 127。取值时，再减去 127，所以不是直接存储 E 而是 E + bias，bias 也就是 127。</li>
</ul>
<p>所以，要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 三个值即可</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067.jpeg" srcset="/img/three2.gif" lazyload class title="IEEE754">

<ul>
<li>使用 1 位存储 S，0 表示正数，1 表示负数；</li>
<li>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 <code>2^(11-1) - 1</code> 也就是 <code>1023</code>；</li>
<li>用 52 位存储 Fraction</li>
</ul>
<p>比如，0.1 的对应二进制是 <code>1 * 1.1001100110011...... * 2^-4</code>，Sign 是 1，E + bias 是 -4 + 1023 = 1019 也就是 <code>1111111011</code>，Fraction 是 1001100110011……</p>
<p>所以 0.1 对应 64 位的完整表示就是：</p>
<blockquote>
<p>0 | 01111111011 | 1001100110011001100110011001100110011001100110011010</p>
</blockquote>
<p>同理 0.2 的完整表示是：</p>
<blockquote>
<p>0 | 01111111100 | 1001100110011001100110011001100110011001100110011010</p>
</blockquote>
<p>所以当 0.1 存下来的时候，就已经发生了精度的丢失，再使用浮点数进行计算时，使用的其实是精度丢失后的数</p>
<h4 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h4><p>浮点数运算一般由五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。</p>
<p>以 0.1 + 0.2 为例：</p>
<p>首先进行对阶，也就是把阶码调整为相同，0.1 是 <code>1 * 1.1001100110011...... * 2^-4</code>，阶码是 -4，而 0.2 是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，调整原则为 <strong>小阶对大阶</strong>，也就是 0.1 调整为 <code>0.11001100110011…… * 2^-3</code>；</p>
<p>接下来是尾数计算：</p>
<figure class="highlight shell"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs shell">  0.1100110011001100110011001100110011001100110011001101<br>+ 1.1001100110011001100110011001100110011001100110011010<br>————————————————————————————————————————————————————————<br> 10.0110011001100110011001100110011001100110011001100111<br></code></pre></div></td></tr></table></figure>

<p>结果为：<code>10.0110011001100110011001100110011001100110011001100111</code>；</p>
<p>将结果进行规格化：<code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code>（括号里的 1 表示超出了范围，所以舍弃）；</p>
<p>然后进行舍入：四舍五入对应到二进制中，就是 0 舍 1 入，因为要把括号中的 1 舍弃，所以需要进 1，结果变为：<code>1.0011001100110011001100110011001100110011001100110100 * 2^-2</code>；</p>
<p>此处不涉及溢出判断，所以最终结果存成 64 位就是：</p>
<blockquote>
<p>0 | 01111111101 | 0011001100110011001100110011001100110011001100110100</p>
</blockquote>
<p>转换为 10 进制数就得到 <code>0.30000000000000004440892098500626</code> </p>
<p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致 <code>0.1 + 0.2 !== 0.3</code> </p>
<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 十进制转二进制</span><br><span class="hljs-number">0.1</span>.toString(<span class="hljs-number">2</span>)<br>=&gt; <span class="hljs-string">&quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span><br><br><span class="hljs-comment">// 二进制转十进制</span><br><span class="hljs-built_in">parseInt</span>(<span class="hljs-number">1100100</span>, <span class="hljs-number">2</span>)<br>=&gt; <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 以指定精度返回该数值对象的字符串表示</span><br>(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>).toPrecision(<span class="hljs-number">21</span>)<br>=&gt; <span class="hljs-string">&quot;0.300000000000000044409&quot;</span><br>(<span class="hljs-number">0.3</span>).toPrecision(<span class="hljs-number">21</span>)<br>=&gt; <span class="hljs-string">&quot;0.299999999999999988898&quot;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126001804188.png" srcset="/img/three2.gif" lazyload class title="浮点数相关方法">

<h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>()<br>  Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  obj.__proto__ = Constructor.prototype<br>  <span class="hljs-keyword">var</span> ret = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&#x27;object&#x27;</span> ? ret : obj<br>&#125;<br><br><span class="hljs-comment">// 模拟使用</span><br><span class="hljs-keyword">var</span> person = objectFactory(Perosn, <span class="hljs-string">&#x27;agoni&#x27;</span>, <span class="hljs-number">20</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意点：若构造函数中手动返回了一个对象，则 new 构造出的实例中只能访问返回对象中的属性，但如果返回一个基本类型的值，则默认相当于无返回值处理</p>
</blockquote>
<blockquote>
<p>此处 <code>new Object()</code> 若使用 <code>Object.create(null)</code> 代替，则创建出的实例中的 <code>__proto__</code> 会有差别，后者只是将 <code>__proto__</code> 当成了一个属性，并非去修改原型。</p>
</blockquote>
<p>可以优化：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">objectFactory</span> (<span class="hljs-params"></span>) </span>&#123;<br>  Constructor = [].shift.call(<span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">var</span> ret = Constructor.apply(obj, <span class="hljs-built_in">arguments</span>)<br>  <span class="hljs-keyword">var</span> obj = <span class="hljs-built_in">Object</span>.create(Constructor.prototype)<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> ret === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; ret !== <span class="hljs-literal">null</span> ? ret : obj<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h4><p>当调用一个方法时，js 会产生一个与这个方法对应的执行环境（context），即执行上下文。而当一系列方法被调用时，因为 js 时单线程的，同一时间只能执行一个方法，于是这些方法会被排队在一个单独的地方，就是 <strong>执行栈</strong>。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp" srcset="/img/three2.gif" lazyload class title="执行栈">

<p>一个方法执行时会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，也就会在执行栈中再添加一个执行环境，此过程可以是无限循环的，除非发生了栈溢出。</p>
<p>以上均是在说同步代码的执行，当一个异步代码执行后，实现就需要依赖 js 的另一大特点 —— 非阻塞，关键在于—— 事件队列（Task Queue）</p>
<p>js 在遇到一个异步任务后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入并一个队列 —— 事件队列，放入其中不会立刻执行其回调，而是等当前执行栈中的所有任务都执行完毕，主线程处于闲置状态后，主线程才会去查看事件队列中是否有任务，如果有，则取出排在第一位的事件，将对应回调放入执行栈，然后执行其中的同步代码，如此反复，这个过程就叫 <strong>事件循环（Event Loop）</strong>。</p>
<h4 id="marco-task-与-mirco-task"><a href="#marco-task-与-mirco-task" class="headerlink" title="marco task 与 mirco task"></a>marco task 与 mirco task</h4><p>因为异步任务之间并不相同，因此执行优先级也有区别，不同的异步任务分为两类：</p>
<ul>
<li>微任务（mirco task）<ul>
<li><code>Promise.resolve().then()</code> </li>
<li><code>new MutationObserver()</code> </li>
</ul>
</li>
<li>宏任务（macro task）<ul>
<li><code>setInterval()</code> </li>
<li><code>serTimeout()</code> </li>
</ul>
</li>
</ul>
<p>在一个事件循环中，异步事件返回结果后会被放到相对应的宏任务队列或者微任务队列中，在当前执行栈为空时，<u>主线程会先查看微任务队列中是否有事件存在，为空后再去查看宏任务队列</u>。</p>
<h4 id="node-环境中事件循环"><a href="#node-环境中事件循环" class="headerlink" title="node 环境中事件循环"></a>node 环境中事件循环</h4><h5 id="libuv-引擎"><a href="#libuv-引擎" class="headerlink" title="libuv 引擎"></a>libuv 引擎</h5><p>node 中事件循环的实现是依靠 libuv 引擎，node 使用 chrome V8 作为 js 解释器，V8 引擎在将 js 代码分析后去调用相应的 node api，这些 api 最后由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。</p>
<h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126134544019.png" srcset="/img/three2.gif" lazyload class title="libuv 事件模型">

<p>外部输入数据 ——&gt; 轮询阶段（poll）——&gt; 检查阶段（check）——&gt; 关闭时间回调阶段（close callbacks）——&gt; 定时器检测阶段（timer）——&gt; I/O 事件回调阶段（I/O callbacks）——&gt; 闲置阶段（idle, prepare）——&gt; 轮询阶段 ……</p>
<p>阶段大致功能：</p>
<ul>
<li>poll：等待新的 I/O 事件，node 在某些特殊情况下会阻塞此处；</li>
<li>check：执行 <code>setImmediate()</code> 的回调；</li>
<li>close callbacks：如 <code>socket.on(&#39;close&#39;, ...)</code> 这种 close 事件的回调；</li>
<li>timers：这个阶段执行定时器队列中的回调：<code>setTimeout()</code> 和 <code>setInterval()</code>；</li>
<li>I/O callbacks：这个阶段执行除 close 事件、定时器和 <code>setImmediate()</code> 的回调之外所有的回调；</li>
<li>idle, prepare：仅在内部使用。</li>
</ul>
<h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调，若为空，则检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行，同时也会检查是否有到期的 timer，如果有就把这些到期的 timer 的 callback 按调用顺序放到 timer queue 中。</p>
<p>收到代码运行环境的影响，如果两者的 queue 均为空，则 loop 会在 poll 阶段停留，直到有一个 I/O 事件返回，进入 I/O callback 阶段并立即执行这个事件的 callback。</p>
<p>poll 阶段在执行 poll queue 中的回到时并不会无限的执行下去：</p>
<ol>
<li>所有回调执行完毕；</li>
<li>执行数超过了 node 的限制</li>
</ol>
<p>两者其一则会终止执行 poll queue 中的下一个回调。</p>
<h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>专门用来执行 <code>setImmediate()</code> 方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有callback时，事件循环进入此阶段。</p>
<h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>当一个 socket 连接或者一个 handle 被突然关闭时（如调用了 <code>socket.destroy()</code> 方法），close 事件会被发送到这个阶段执行回调，否则事件会用 <code>process.nextTick()</code> 方法发送出去。</p>
<h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><p>以先进先出的方式执行所有到期的 timer 加入 timer queue 里的 callback。</p>
<p>一个 timer 指的是一个通过 setTimeout 或 setInterval 函数设置的回调函数</p>
<h5 id="I-O-callback"><a href="#I-O-callback" class="headerlink" title="I/O callback"></a>I/O callback</h5><p>主要执行大部分 I/O 事件的回调，包括一些为操作系统执行的回调。</p>
<h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>node 中存在一个特殊的队列，即 nextTick queue，这些事件会在每一个阶段执行完毕后准备进入下一个阶段前优先执行。</p>
<p>与执行 poll queue 的区别在于这个操作在队列清空前是不会停止的，所以错误的使用 <code>process.nextTick()</code> 会导致 node 进入一个死循环，直到内存泄漏。</p>
<h5 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h5><p><code>setTimeout()</code> 方法是定义一个回调，在所指定的时间间隔后第一时间去执行，受到操作系统和当前执行任务的诸多影响，该回调并不会在预期时间间隔后精准的执行，会存在一定的偏差。</p>
<p><code>setImmediate()</code> 方法从意义上是立刻执行的意思，但其实是在一个固定的阶段才会执行回调，即 poll 阶段之后。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><br>setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>&#125;)<br><br><span class="hljs-comment">// 输出顺序不一定，这取决于这段代码的运行环境。</span><br></code></pre></div></td></tr></table></figure>

<p>但下面的输出顺序是确定的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><br>fs.readFile(__filename, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;timeout&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  setImmediate(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>  &#125;)<br>&#125;)<br><br><span class="hljs-comment">// immediate</span><br><span class="hljs-comment">// timeout</span><br></code></pre></div></td></tr></table></figure>

<p>因为在 I/O 事件的回调中，setImmediate 方法的回调永远在 timer 的回调前执行。</p>
<h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise 只有三种状态：等待（Pending）、执行（Fulfilled）、拒绝（Rejected）。一旦 Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）</p>
<h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    resolve(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">1</span> &#125;)<br>    resolve(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">2</span> &#125;)<br>    reject(&#123; <span class="hljs-attr">test</span>: <span class="hljs-number">2</span> &#125;)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result1&#x27;</span>, data) <span class="hljs-comment">// &#x27;result1&#x27;, &#123; test: 1 &#125;</span><br>&#125;,<span class="hljs-function">(<span class="hljs-params">data1</span>)=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result2&#x27;</span>,data1)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;result3&#x27;</span>, data) <span class="hljs-comment">// &#x27;result3&#x27;, undefined</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<ol>
<li>Promise 可以进行链式调用，且每次 then 返回了新的 Promise；</li>
<li>只输出第一次 resolve 的内容，即状态不可逆；</li>
<li>then 中注册的回调仍然是属于上一个 Promise 的</li>
</ol>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br><br>  <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-comment">// 将新 Promise 的 resolve 方法放到前一个 promise 的回调对象中</span><br>      handle(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>        reject<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> ret = cb(value) <span class="hljs-comment">// 处理回调</span><br>    next(ret) <span class="hljs-comment">// 处理下一个 promise 的 resolve</span><br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br><br>      <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = newValue<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          <span class="hljs-comment">// newValue 为新产生的 Promise，此时 resolve 为上个 promise 的 resolve</span><br>          <span class="hljs-comment">// 相当于调用了新产生 Promise 的 then 方法，注入了上个 promise 的 resolve 为其回调</span><br>          then.call(newValue, resolve)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br><br>      state = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>      value = newValue<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <br>      <span class="hljs-keyword">if</span> (error &amp;&amp; (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = error<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;funciton&#x27;</span>) &#123;<br>          then.call(error, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;rejected&#x27;</span><br>      value = error<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCb</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (callbacks.length) &#123;<br>      <span class="hljs-keyword">const</span> fn = callbacks.shift()<br>      handle(fn)<br>    &#125;<br>  &#125;<br><br>  fn(resolve, reject)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，使用 try-catch 来捕获异常，并将 Promise 设为 rejected 状态即可。</p>
<p>对 handle 函数进行改造：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br>  <br>  <span class="hljs-comment">// ...</span><br>  <br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br><br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-keyword">const</span> ret = cb(value)<br>      next(ret)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      callback.reject(e)<br>    &#125;<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加 catch 方法来处理错误</span><br>  <span class="hljs-built_in">this</span>.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onError</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onError)<br>  &#125;<br>  <br>  <span class="hljs-comment">// 增加 finally 用于执行最后的操作</span><br>  <span class="hljs-built_in">this</span>.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onDone</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.then(onDone, onDone)<br>  &#125;<br>  <br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="resolve-和-reject"><a href="#resolve-和-reject" class="headerlink" title="resolve 和 reject"></a>resolve 和 reject</h4><p>实际应用中，可以使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 方法将非 Promise 实例包装为 Promise 实例，传入的参数可能有：</p>
<ul>
<li>无参数</li>
<li>普通数据参数</li>
<li>一个 Promise 实例</li>
<li>一个 thenable 对象（指具有 then 方法的对象）</li>
</ul>
<p>模拟实现：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> value<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>				<span class="hljs-keyword">const</span> &#123; then &#125; = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>          then(resolve)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve())<br>  &#125;<br>  <br>  <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      reject(value)<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(arr)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([])<br>      <span class="hljs-keyword">var</span> remaining = args.length<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span> (<span class="hljs-params">i, val</span>) </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (val &amp;&amp; (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">const</span> &#123; then &#125; = val<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>              then.call(cal, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">val</span>) </span>&#123;<br>                res(i, val)<br>              &#125;)<br>              <span class="hljs-keyword">return</span><br>            &#125;<br>          &#125;<br>          args[i] = val<br>          <span class="hljs-keyword">if</span> (--remaining === <span class="hljs-number">0</span>) &#123;<br>            resolve(args)<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>          reject(ex)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = args.length; i &lt; len; i++) &#123;<br>        res(i, args[i])<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-comment">// ...</span><br>  <span class="hljs-built_in">this</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">resolve, reject</span>) </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, len = values.length; i &lt; len; i++) &#123;<br>        values[i].then(resolve, reject)<br>      &#125;<br>    &#125;)<br>  &#125;<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="完整模型"><a href="#完整模型" class="headerlink" title="完整模型"></a>完整模型</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Promise</span> (<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">let</span> state = <span class="hljs-string">&#x27;pending&#x27;</span>,<br>      value = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">const</span> callbacks = []<br><br>  <span class="hljs-built_in">this</span>.then = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onFulfilled, onRejected</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      handle(&#123;<br>        onFulfilled,<br>        onRejected,<br>        resolve,<br>				reject<br>      &#125;)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.catch = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onError</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(<span class="hljs-literal">null</span>, onError)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.finally = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">onDone</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.then(onDone, onDone)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.resolve = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (value) &#123;<br>      <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Promise</span>) &#123;<br>        <span class="hljs-keyword">return</span> value<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;object&#x27;</span> &amp;&amp; <span class="hljs-keyword">typeof</span> value.then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = value<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>          then(resolve)<br>        &#125;)<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve(value))<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> resolve())<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.reject = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      rejecy(value)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.all = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">arr</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> args = <span class="hljs-built_in">Array</span>.prototype.slice.call(arr)<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (args.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> resolve([])<br>      <span class="hljs-keyword">let</span> remaining = args.length<br>      <br>      <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">res</span> (<span class="hljs-params">i ,val</span>) </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          <span class="hljs-keyword">if</span> (val &amp;&amp; (<span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> val === <span class="hljs-string">&#x27;function&#x27;</span>)) &#123;<br>            <span class="hljs-keyword">const</span> &#123; then &#125; = val<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>              then.call(val, <span class="hljs-function"><span class="hljs-params">val</span> =&gt;</span> &#123;<br>                res(i, val)<br>              &#125;, reject)<br>              <span class="hljs-keyword">return</span><br>            &#125;<br>          &#125;<br>          args[i] = val<br>          <span class="hljs-keyword">if</span> (--remaining === <span class="hljs-number">0</span>) &#123;<br>            resolve(args)<br>          &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>          reject(ex)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.length; i &lt; len; i++) &#123;<br>        res(i, args[i])<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-built_in">this</span>.race = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">values</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = values.length; i &lt; len; i++) &#123;<br>        values[i].then(resolve, reject)<br>      &#125;<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handle</span> (<span class="hljs-params">callback</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span> (state === <span class="hljs-string">&#x27;pending&#x27;</span>) &#123;<br>      callbacks.push(callback)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> cb = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected<br>    <span class="hljs-keyword">const</span> next = state === <span class="hljs-string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject<br><br>    <span class="hljs-keyword">if</span> (!cb) &#123;<br>      next(value)<br>      <span class="hljs-keyword">return</span><br>    &#125;<br>    <span class="hljs-keyword">let</span> ret<br>    <span class="hljs-keyword">try</span> &#123;<br>      ret = cb(value)<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      callback.reject(e)<br>    &#125;<br>    callback.resolve(ret)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolve</span> (<span class="hljs-params">newValue</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (newValue &amp;&amp; (<span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> newValue === <span class="hljs-string">&#x27;funciton&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = newValue<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(newValue, resolve, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;fulfilled&#x27;</span><br>      value = newValue<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reject</span> (<span class="hljs-params">error</span>) </span>&#123;<br>    <span class="hljs-keyword">const</span> fn = <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-keyword">if</span> (state !== <span class="hljs-string">&#x27;pending&#x27;</span>) <span class="hljs-keyword">return</span><br>      <span class="hljs-keyword">if</span> (error &amp;&amp; (<span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;object&#x27;</span> || <span class="hljs-keyword">typeof</span> error === <span class="hljs-string">&#x27;funciton&#x27;</span>)) &#123;<br>        <span class="hljs-keyword">const</span> &#123; then &#125; = error<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> then === <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>          then.call(error, resolve, reject)<br>          <span class="hljs-keyword">return</span><br>        &#125;<br>      &#125;<br>      state = <span class="hljs-string">&#x27;rejected&#x27;</span><br>      value = error<br>      handleCb()<br>    &#125;<br>    <span class="hljs-built_in">setTimeout</span>(fn, <span class="hljs-number">0</span>)<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleCb</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">while</span> (callbacks.length) &#123;<br>      <span class="hljs-keyword">const</span> fn = callbacks.shift()<br>      handle(fn)<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">try</span> &#123;<br>    fn(resolve, reject)<br>  &#125; <span class="hljs-keyword">catch</span> (ex) &#123;<br>    reject(ex)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span>* <span class="hljs-title">example</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">1</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">2</span><br>  <span class="hljs-keyword">yield</span> <span class="hljs-number">3</span><br>&#125;<br><span class="hljs-keyword">var</span> iter = example()<br>iter.next() <span class="hljs-comment">// &#123; value: 1, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: 2, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: 3, done: false &#125;</span><br>iter.next() <span class="hljs-comment">// &#123; value: undefined, done: true &#125;</span><br></code></pre></div></td></tr></table></figure>

<p>上述代码定义了一个生成器函数，调用时并非立即执行该函数，而是返回一个生成器对象。每当调用生成器函数的 <code>next()</code> 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身执行。</p>
<p>与普通函数的区别：</p>
<ul>
<li>普通函数使用 <code>function</code> 声明，生成器函数使用 <code>function*</code> 声明；</li>
<li>普通函数使用 <code>return</code> 返回值，生成器函数使用 <code>yield</code> 返回值；</li>
<li>普通函数是 <code>run to completion</code> 模式，即开始执行后会一直执行到该函数的所有语句完成，在此期间其他代码语句不会执行；生成器函数是 <code>run pause run</code> 模式，即可以在函数运行中被暂停一次或多次，并在后面再恢复执行，暂停期间允许其他代码语句被执行。</li>
</ul>
<p>js 执行引擎是一个基于事件循环的单线程环境，当生成器运行时，会在一个叫 caller 的同一个线程中运行，执行的顺序是有序、确定的，并且永远不会发生并发。</p>
<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>盒模型又称框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）四个要素。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069519.png" srcset="/img/three2.gif" lazyload class title="盒模型示意图">

<h4 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h4><p>由于 IE 模型的怪异模式，导致 IE 模型和标准模型的内容计算方式不同：</p>
<p><strong>IE 模型元素宽度 width = content + padding + border</strong>，高度计算相同：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069520.png" srcset="/img/three2.gif" lazyload class title="IE模型宽度计算示意图">

<p><strong>标准模型元素宽度 width = content</strong>，高度计算相同：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069521.png" srcset="/img/three2.gif" lazyload class title="标准模型计算示意图">

<h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>通过 CSS3 新增的属性 <code>box-sizing: content-box | border-box</code> 分别设置盒模型为标准模型（content-box） 和 IE 模型（border-box）。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">50px</span>;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">10px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">5px</span> solid red;<br>  <span class="hljs-attribute">margin</span>: <span class="hljs-number">15px</span>;<br>&#125;<br><span class="hljs-selector-class">.content-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: content-box;<br>&#125;<br><span class="hljs-selector-class">.border-box</span> &#123;<br>  <span class="hljs-attribute">box-sizing</span>: border-box;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>.content-box</code> 设置为标准模型，元素宽度 <code>wight = 100px</code>；</p>
<p><code>.border-box</code> 设置为 IE 模型，元素宽度为 <code>width = content + 2 * padding + 2 * border = 75px + 2 * 10px + 2 * 5px = 100px</code>。</p>
<h4 id="js-获取盒模型宽高"><a href="#js-获取盒模型宽高" class="headerlink" title="js 获取盒模型宽高"></a>js 获取盒模型宽高</h4><ol>
<li><code>dom.style.width/height</code>：只能获取到行内样式的宽和高，style 标签中和 link 外链中的样式取不到；</li>
<li><code>dom.currentStyle.width/height</code>：取到的是最终渲染后的宽和高，只有 IE 支持此属性；</li>
<li><code>window.getComputedStyle(dom).width/height</code>：取到的也是最终渲染的宽和高，多数浏览器支持（IE9 以上支持）；</li>
<li><code>dom.getBoundingClientRect().eidth/height</code>：得到渲染后的宽和高，大多数浏览器支持（IE9 以上支持），同时可以取到相对于视窗的上下左右的距离。</li>
</ol>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126170517922.png" srcset="/img/three2.gif" lazyload class title="js 获取 dom 宽高">

<blockquote>
<p>前三位取到的结果都是带单位的字符串类型值，第四种方法得到的是数字类型的值。</p>
</blockquote>
<h4 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h4><p>当两个垂直外边距相遇时，它们将合并为一个外边距，合并后的外边距高度等于两者较大者。</p>
<blockquote>
<p>注意：只有普通文档流中块级元素的垂直外边距才会发生外边距合并，行内元素、浮动元素或绝对定位之间的外边距不会合并。</p>
</blockquote>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069524.png" srcset="/img/three2.gif" lazyload class title="外边距重叠">

<h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC（Block Formatting Context）：块级格式化上下文。</p>
<p>BFC 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计到可视化布局时，BFC 提供了一个环境，HTML 元素再这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环节中的布局。</p>
<h4 id="原理-渲染规则"><a href="#原理-渲染规则" class="headerlink" title="原理(渲染规则)"></a>原理(渲染规则)</h4><ul>
<li>BFC 内部的 Box 会再垂直方向一个接一个的放置</li>
<li>BFC 元素垂直方向的距离由 margin 决定，同属一个 BFC 的两个相邻 Box 的 margin 会发生重叠，若属于不同 BFC 则不会重叠</li>
<li>BFC 区域不会与浮动元素的布局重叠</li>
<li>BFC 元素是一个独立的容器，里外的元素不会相互影响</li>
<li>计算 BFC 高度时，浮动元素也会参数计算</li>
</ul>
<h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol>
<li><code>overflow</code> 不为 <code>visible</code> </li>
<li><code>float</code> 不为 <code>none</code> </li>
<li><code>position</code> 不为 <code>static | relative</code> </li>
<li><code>display</code> 为 <code>inline-block | table | table-cell | table-caption | flex | inline-flex</code> </li>
</ol>
<blockquote>
<p>注意：由于子元素浮动而引起的父元素高度丢失，可以再父元素创建 BFC 就可以使浮动子元素也参与高度计算。</p>
</blockquote>
<h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC（Inline Formatting Context）：内联格式化上下文</p>
<h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul>
<li>块级元素中仅包含内内联级别元素</li>
</ul>
<blockquote>
<p>需要注意当 IFC 中有 块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p>
</blockquote>
<h4 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h4><ul>
<li>子元素水平方向横向排列，并且垂直方向起点为元素顶部（即默认从左上开始从左到右依次排列）</li>
<li>子元素只会极端横向样式空间，垂直方向样式空间不会被计算（指垂直方向的 padding、border、margin）</li>
<li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li>
<li>能把在一行上的子元素全部包含进去的一个矩形边框，叫做该行的行框（line box）。其宽度取决于包含块以及其中的浮动来决定的</li>
<li>IFC 中的 line box 一般左右贴紧其包含块，但 float 元素会优先排列</li>
<li>IFC 中的 line box 的高度由 CSS 行高计算规则来确定，同个 IFC 下的多个 line box 高度可能不同</li>
<li>当 inline box 中子元素的总宽度少于包含它们的 inline box 时，其水平渲染规则由 text-align 属性值决定</li>
<li>当一个 inline box 超过父元素的宽度时，会被分割成多个 boxes，并分布在多个 line box 中；如果子元素未设置强制换行，则 inline box 将不可被分割而溢出父元素</li>
</ul>
<h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是 CSS 规则的一部分，处于 CSS 声明块前。</p>
<h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul>
<li>简单选择器（Simple selectors）：通过 元素类型、class 或 id 匹配一个或多个元素</li>
<li>属性选择器（Attribute selectors）：通过 属性/属性值 匹配一个或多个元素</li>
<li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素…</li>
<li>伪元素（Pseudo-elements）：匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字…</li>
<li>组合器（Combinators）：以有效的方式组合两个或更多的选择器用于非常特定的选择的方法</li>
<li>多用选择器（Multiple selectors）：将以逗号分隔开的多个选择器放在一个 CSS 规则下面，以将一组声明应用于由这些选择器选择的所有元素</li>
</ul>
<h4 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h4><p><strong>类型选择器（元素选择器）</strong> </p>
<p>一个选择器名和指定的 HTML 元素名的不区分大小写的匹配。</p>
<p><strong>类选择器（Class selectors）</strong> </p>
<p>类选择器由一个点 <code>.</code> 以及后面的类名组成。类名是在 HTML 文档元素属性 class 中没有空格的任何值。</p>
<ul>
<li>文档中的多个元素可以具有相同的类名</li>
<li>单个元素可以由多个类名，用空格做间隔</li>
</ul>
<p><strong>ID 选择器</strong> </p>
<p>ID 选择器由一个哈希/磅符号 <code>#</code> 以及后面的 ID 名称组成。</p>
<ul>
<li>任何元素都可以使用 id 属性设置唯一的 ID 名称</li>
<li>这是选择单一元素最有效的方法</li>
</ul>
<blockquote>
<p>注意：一个 ID 名称必须在文件中是唯一的，在一些浏览器中只是第一个实例会计算，其余的将被忽略。</p>
</blockquote>
<p><strong>通用选择器</strong> </p>
<p>通用选择 <code>*</code> 允许选择在一个页面中的所有元素。</p>
<blockquote>
<p>注意：因为它适用于所有的元素，所以在大型页面使用可能对性能有明显的影响。</p>
</blockquote>
<h4 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h4><p>在 CSS 中，组合器允许将多个选择器组合在一起，四种可用的类型是：</p>
<ul>
<li>后代选择器 —— 空格 —— 选择嵌套在另一个元素中的某些元素（不一定是直系子代）</li>
<li>子选择器 —— <code>&gt;</code> —— 选择另一个元素的直接子元素</li>
<li>相邻兄弟选择器 —— <code>+</code> —— 选择另一个元素之后直接相连的兄弟元素（同层的相邻元素）</li>
<li>通用兄弟元素 —— <code>~</code> —— 选择一个元素之后的所有兄弟元素（同层的所有其他元素）</li>
</ul>
<blockquote>
<p>注意：相邻兄弟选择器和通用兄弟选择器只会向后选择，DOM 结构靠前的兄弟元素不在选择范围内。</p>
</blockquote>
<h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>根据元素的属性和属性值来匹配元素，通用语法由 <code>[]</code> 组成，其中包含属性名称，后可跟可选条件一匹配属性的值。</p>
<p>可根据其匹配属性值的方式分为：</p>
<p><strong>存在和值（Presence and value）选择器</strong> </p>
<p>尝试匹配精确的属性值：</p>
<ul>
<li><code>[attr]</code>：选择包含 attr 属性的所有元素，不论 attr 的值是什么</li>
<li><code>[attr=val]</code>：仅选择 attr 属性被赋值为 val 的所有元素</li>
<li><code>[attr~=val]</code>：仅选择 attr 属性的值中包含 val 值的所有元素（多个值用空格做间隔）</li>
</ul>
<p><strong>子串值（Substring value）属性选择器</strong> </p>
<p>也被称为“伪正则选择器”，提供类似 regular expression 的灵活匹配方式：</p>
<ul>
<li><code>[attr|=val]</code>：选择 attr 属性的值 以 val 或 val- 开头的元素</li>
<li><code>[attr^=val]</code>：选择 attr 属性的值 以 val 开头的元素</li>
<li><code>[attr$=val]</code>：选择 attr 属性的值 以 val 结尾的元素</li>
<li><code>[attr*=val]</code>：选择 attr 属性的值中包含字符串 val 的元素</li>
</ul>
<blockquote>
<p>均包含 attr 属性就是 val 的情况。</p>
</blockquote>
<h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p><strong>伪类（Pseudo-class）</strong> </p>
<p>一个 CSS 伪类是一个以冒号 <code>:</code> 作为前缀的关键词。</p>
<p>当你需要样式在特定状态下才被呈现到指定的元素时，可以往元素的选择器后面加上对应的伪类。</p>
<p>伪类有：</p>
<table>
<thead>
<tr>
<th>伪类</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>:link</td>
<td>超链接点击之前的样式</td>
</tr>
<tr>
<td>:visited</td>
<td>超链接点击过后的样式</td>
</tr>
<tr>
<td>:hover</td>
<td>鼠标移上的样式</td>
</tr>
<tr>
<td>:actived</td>
<td>鼠标按下的样式</td>
</tr>
<tr>
<td>:focus</td>
<td>表单元素获取焦点的样式</td>
</tr>
<tr>
<td>:blur</td>
<td>表单元素失去焦点的样式</td>
</tr>
<tr>
<td>:checked</td>
<td>表单元素被选中的样式</td>
</tr>
<tr>
<td>:not(E)</td>
<td>匹配所有除 E 以外的元素</td>
</tr>
<tr>
<td>:last-child</td>
<td>最后一个元素</td>
</tr>
<tr>
<td>:nth-child(n)</td>
<td>n 表示具体的第几个，可以传入 odd/2n+1、even/2n 等</td>
</tr>
<tr>
<td>:only-child</td>
<td>本层级唯一的元素</td>
</tr>
<tr>
<td>:nth-last-child(n)</td>
<td>倒数第 n 个元素</td>
</tr>
<tr>
<td>:first-of-type</td>
<td>第一个同级兄弟元素</td>
</tr>
<tr>
<td>:last-of-type</td>
<td>最后一个同级兄弟元素</td>
</tr>
<tr>
<td>:only-of-type</td>
<td>唯一的一个兄弟元素</td>
</tr>
<tr>
<td>:nth-of-type(n)</td>
<td>第 n 个同级的兄弟元素</td>
</tr>
<tr>
<td>:nth-last-of-type(n)</td>
<td>倒数第 n 个同级的兄弟元素</td>
</tr>
<tr>
<td>:empty</td>
<td>空内容</td>
</tr>
<tr>
<td>:lang(language)</td>
<td>匹配使用某种语言的元素</td>
</tr>
<tr>
<td>:target</td>
<td>匹配页面的 URI 中某个标识符的目标元素</td>
</tr>
<tr>
<td>:enabled</td>
<td>未使用d 表单元素</td>
</tr>
<tr>
<td>:disabled</td>
<td>不可用的表单元素</td>
</tr>
<tr>
<td>:root</td>
<td>匹配文档所有的根元素</td>
</tr>
</tbody></table>
<p><strong>伪元素（Pesudo-element）</strong> </p>
<p>以两个冒号 <code>::</code> 作为前缀的关键词，同样是添加到指定某个元素选择器的后面。</p>
<p>伪元素有：</p>
<table>
<thead>
<tr>
<th>伪元素</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>::after</td>
<td>可在元素的内容之后插入新内容，默认是一个行内元素<br>可使用属性 display 改变这一点</td>
</tr>
<tr>
<td>::before</td>
<td>与 ::after 类似，插入位置为内容之前</td>
</tr>
<tr>
<td>::first-letter</td>
<td>用于向文本的首字母设置特殊样式，只能用于块级元素</td>
</tr>
<tr>
<td>::first-line</td>
<td>用于向文本的首行设置特殊样式，只能用于块级元素</td>
</tr>
<tr>
<td>::selection</td>
<td>用于匹配突出显示的文本，浏览器默认情况下是深蓝背景白色字</td>
</tr>
<tr>
<td>::backdrop</td>
<td>任何处于全屏模式的元素下的即使渲染的盒子</td>
</tr>
</tbody></table>
<blockquote>
<p>大多数浏览器支持伪元素使用一个冒号或两个冒号两种表示方式。但 <code>::selection</code> 只能以两个冒号开头。</p>
</blockquote>
<h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位允许从正常的文档流布局中取出元素，让他们具有不同的行为，使用 <code>position</code> 属性。</p>
<h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p><code>position</code> 属性用来指定一个元素在网页上的位置，一共有五种定位方式：</p>
<ul>
<li>static</li>
<li>relative</li>
<li>fixed</li>
<li>absolute</li>
<li>sticky（2017 年支持）</li>
</ul>
<h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>static</code> 是 <code>position</code> 属性的默认值，此时浏览器会按照源码的顺序，决定每个元素的位置，称为“正常的页面流”（normal flow）。</p>
<p>每个块级元素占据自己的区块（block），元素与元素之间不会重叠，这个位置就是元素的默认位置。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111720.jpg" srcset="/img/three2.gif" lazyload class title="static">

<blockquote>
<p>static 定位所导致的元素位置是浏览器自主决定的，这时 top、bottom、left、right 四个属性无效</p>
</blockquote>
<h4 id="relative-absolute-fixed"><a href="#relative-absolute-fixed" class="headerlink" title="relative, absolute, fixed"></a>relative, absolute, fixed</h4><p>这三个属性值都是相对于某个基点的定位，不同之处在于基点不同</p>
<p><strong>relative</strong> </p>
<p><code>relative</code> 表示，相对于默认位置（即 <code>static</code> 定位时的位置）进行偏移，即定位基点是元素的默认位置。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111721.jpg" srcset="/img/three2.gif" lazyload class title="relative">

<p>可以搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 四个属性一起使用，用来指定偏移的方向和距离。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111723.jpg" srcset="/img/three2.gif" lazyload class title="relative">

<p><strong>absolute</strong> </p>
<p><code>absolute</code> 表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。</p>
<p>限制条件：定位基点不能是 <code>static</code> 定位，否则定位基点就会变为整个页面的根元素 <code>html</code> 。</p>
<p>也需要搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111801.jpg" srcset="/img/three2.gif" lazyload class title="absolute">

<blockquote>
<p><code>absolute</code> 定位的元素会被“正常页面流”忽略，即在“正常页面流”中，该元素所占空间为零，周边元素不受影响。</p>
</blockquote>
<p><strong>fixed</strong> </p>
<p><code>fixed</code> 表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口，会导致元素的位置不会随页面滚动而变化，好像固定在网页上一样。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111802.jpg" srcset="/img/three2.gif" lazyload class title="fixed">

<p>一般搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p>
<h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p><code>sticky</code> 和之前四个属性值不一样，它会产生动态效果，很像 <code>relative</code> 和 <code>fixed</code> 的结合：一些时候是 <code>relative</code> 定位（定位基点是自身默认位置），另一些时候自动变成 <code>fixed</code> 定位（定位基点是视口）。</p>
<p><code>sticky</code> 生效的前提是必须搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 一起使用，不能省略，否则等同于 <code>relative</code> 定位，不产生动态固定的效果。</p>
<p>具体规则：当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 <code>sticky</code> 元素的距离达到生效门槛，<code>relative</code> 定位自动切换为 <code>fixed</code> 定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code> 定位自动切换回 <code>relative</code>。</p>
<blockquote>
<p>除 IE 外，其他浏览器均支持 sticky，但 Safari 浏览器需要加上前缀 <code>-webkit-</code>。</p>
</blockquote>
<p>应用场景：</p>
<ul>
<li>堆叠效果：（stacking）指的是页面滚动时，下方的元素覆盖上方的元素；</li>
<li>表格的表头锁定。</li>
</ul>
<blockquote>
<p>注意：表头锁定时 <code>sticky</code> 需要设在 <code>&lt;th&gt;</code> 元素上，不能设在 <code>&lt;thead&gt;</code> 和 <code>&lt;tr&gt;</code> 元素上，因为这两个元素没有 <code>relative</code> 定位，所以无法产生 <code>sticky</code> 效果</p>
</blockquote>
<h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。给 flexbox 的子元素之间提供了强大的空空间分布和对齐能力。</p>
<h4 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h4><p>flex 布局中有两根轴线 —— 主轴和交叉轴。</p>
<p>主轴由 <code>flex-direction</code> 定义，可取值：</p>
<ul>
<li><code>row</code>：主轴沿着 inline 方向延伸</li>
<li><code>row-reverse</code>：沿着 inline 方向逆向延伸</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics1.png" srcset="/img/three2.gif" lazyload class title="flex:row">

<ul>
<li><code>column</code>：主轴沿着 block 排列的方向延伸</li>
<li><code>column-reverse</code>：于 column 相逆</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics2.png" srcset="/img/three2.gif" lazyload class title="flex:column">

<p>交叉轴垂直于主轴：</p>
<ul>
<li><code>flex-direction</code> (主轴) 设成了 <code>row</code> 或 <code>row-reverse</code>，则交叉轴的方向沿着列向下；</li>
<li>主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向</li>
</ul>
<h4 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h4><p>如果 <code>flex-direction</code> 是 <code>row</code>，书写英文时，则主轴的起始线是左边，终止线是右边：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics5.png" srcset="/img/three2.gif" lazyload class title="row英文">

<p>若书写阿拉伯文，则主轴起始线是右边，终止线是左边：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics6.png" srcset="/img/three2.gif" lazyload class title="row阿拉伯文">

<p>在这两种情况下，交叉轴的起始线是flex容器的顶部，终止线是底部，因为两种语言都是水平书写模式。</p>
<h4 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h4><p>文档中使用了 flexbox 的区域就叫做 flex 容器，创建 flex 容器需要将其 <code>display</code> 属性值改为 <code>flex</code> 或 <code>inline-flex</code>，容器中的直系子元素就会变为 flex 元素，flex 容器中的所有 flex 元素都会有下列默认行为：</p>
<ul>
<li>元素排列为一行（<code>flex-direction</code> 属性的初始值是 <code>row</code>）</li>
<li>元素从主轴的起始线开始</li>
<li>元素不会在主维度方向拉伸，但是可以缩小</li>
<li>元素被拉伸来填充交叉轴大小</li>
<li><code>flex-basis</code> 属性为 <code>auto</code> </li>
<li><code>flex-wrap</code> 属性为 <code>nowrap</code> </li>
</ul>
<h5 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h5><p>在 flex 容器中添加 <code>flex-direction</code> 属性可以更改 flex 元素的排列方向。</p>
<p><code>-reverse</code> 会让元素沿着 <code>row</code> 或 <code>column</code> 的方向显示，但 起始线和终止线位置会交换</p>
<h5 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h5><p>需要实现多行效果可以为属性 <code>flex-wrap</code> 添加一个属性值 <code>wrap</code>，项目的子元素若超出容器最大宽度则会换行显示。</p>
<h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>可以将 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性组合为简写属性 <code>flex-flow</code>，该属性第一个指定的值为 <code>flex-direction</code>，第二个指定的值为 <code>flex-wrap</code>。</p>
<h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p><code>align-items</code> 属性可以使元素在<strong>交叉轴方向对齐</strong>，初始值为 <code>stretch</code>，所以 flex 元素会默认被拉伸到最高元素的高度 —— 最高的元素定义了容器的高度。</p>
<p>可选值有：</p>
<ul>
<li><code>stretch</code>：默认值，拉伸；</li>
<li><code>flex-start</code>：按 flex 容器的交叉轴起始线对齐；</li>
<li><code>flex-end</code>：按 flex 容器的交叉轴终止线对齐；</li>
<li><code>center</code>：按交叉轴居中对齐</li>
</ul>
<h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h5><p><code>justify-content</code> 属性使元素在<strong>主轴方向对齐</strong>，即通过 <code>flex-direction</code> 设置的方向。初始值为 <code>flex-start</code>，元素从主轴起始线排列。</p>
<p>可选值有：</p>
<ul>
<li><code>stretch</code>：拉伸；</li>
<li><code>flex-start</code>：按主轴起始线对齐；</li>
<li><code>flex-end</code>：按主轴终止线对齐；</li>
<li><code>center</code>：按主轴居中对齐；</li>
<li><code>space-around</code>：将可用空间平均分配为元素间的间隔后居中对齐，包括两侧（两侧所占比例为中间间隔的一半）；</li>
<li><code>space-between</code>：同 <code>space-around</code>，但不包括两侧</li>
</ul>
<h4 id="flex-元素"><a href="#flex-元素" class="headerlink" title="flex 元素"></a>flex 元素</h4><p>为了更好地控制 flex 属性，有三个属性可以作用于它们：</p>
<ul>
<li><code>flex-grow</code> </li>
<li><code>flex-shrink</code> </li>
<li><code>flex-basis</code> </li>
</ul>
<h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h5><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器中除了元素所占的空间以外的富余空间就是可用空间，该属性的默认值为 <code>auto</code>。</p>
<p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容（content）的尺寸。</p>
<h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h5><p><code>flex-grow</code> 若被赋值为一个正整数，flex 元素会以 <code>flex-basis</code> 为基础，沿主轴方向增长尺寸。这会使该元素扩展，并占据该方向轴上的可用空间。</p>
<p>若有多个 flex 元素设定了 <code>flex-grow</code> 属性值，则它们将按找属性值的比例平分对应的可用空间。</p>
<h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h5><p><code>flex-shrink</code> 属性是处理 flex 元素收缩的问题。若 flex 容器中没有足够排列 flex 元素的空间，则可以把 flex 元素的 <code>flex-shrink</code> 属性设置为正整数来缩小它所占空间到 <code>flex-basis</code> 以下。</p>
<h5 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h5><p>以上三个属性很少单独使用，而是混合写在 <code>flex</code> 简写形式中，它允许把三个数值按这个顺序书写 —— <code>flex-grow</code>、<code>flex-shrink</code>、<code>flex-basis</code>。</p>
<p>预定义：</p>
<ul>
<li><code>flex: initial</code>：把 flex 元素重置为 flexbox 的初始值，相当于 <code>flex: 0 1 auto</code>；<ul>
<li><code>flex-grow</code> 的值为 0，所以 flex 元素不会超过它们 <code>flex-basis</code> 的尺寸；</li>
<li><code>flex-shrink</code> 的值为 1，所以可以缩小 flex 元素来防止它们溢出；</li>
<li><code>flex-basis</code> 的值为 auto，flex 元素尺寸可以是在主维度上设置也可以是根据内容自动得到。</li>
</ul>
</li>
<li><code>flex: auto</code>：等同于 <code>flex: 1 1 auto</code>，基本于 <code>initial</code> 相同，但此种在需要的时候既可以拉伸也可以收缩；</li>
<li><code>flex: none</code>：可以把 flex 元素设置为不可伸缩，等同于 <code>flex: 0 0 auto</code>，元素不能拉伸或收缩，但是元素会按具有 <code>flex-basis: auto</code> 属性的 flexbox 进行布局。</li>
</ul>
<blockquote>
<p>常见的 <code>flex: 1</code> 等等，相当于 <code>flex: 1 1 0</code>，元素可以在 <code>flex-basis</code> 为 0 的基础上伸缩。</p>
</blockquote>
<h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ol>
<li>决定了 css 规则怎样被浏览器解析直到生效；</li>
<li>当多个相同样式被应用到同一个元素上时，权重是一个决定哪种样式生效，或者决定优先级的过程；</li>
<li>每个选择器都有自己的权重；</li>
<li>两个选择器同时作用到一个元素上，权重高者生效。</li>
</ol>
<p><strong>从 0 开始，一个行内样式  + 1000，一个 id 选择器 + 100，一个属性、伪类或者 class 选择器 + 10，一个元素或者伪元素选择器 + 1，通配符 + 0</strong> 。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-b1a9fedf320754acb1d7766c6548d5f6_720w.jpg" srcset="/img/three2.gif" lazyload class title="css权重值">

<ol>
<li>同样权重，样式重复多写则后写的覆盖前面的；</li>
<li>不同权重，则权重高者生效。</li>
</ol>
<h4 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h4><p><code>!important</code> 的作用是提升样式优先级，若加上则此条样式优先级变为最高。</p>
<ol>
<li>同个样式都使用了 <code>!important</code> 样式则权重高者优先；</li>
<li>若 <code>!important</code> 作用于简写的样式属性，则此条简写样式所代表的子属性都会被作用上 <code>!important</code>。<ul>
<li>比如 <code>flex</code>、<code>background</code>、<code>border</code>…</li>
</ul>
</li>
</ol>
<h4 id="行内-外联-内联"><a href="#行内-外联-内联" class="headerlink" title="行内 外联 内联"></a>行内 外联 内联</h4><ul>
<li>行内样式始终要比外联或者内联的优先级高</li>
<li>内联样式和外联样式的优先级和加载顺序有关</li>
<li><code>!important</code> &gt; 行内样式 &gt; 内联外联样式</li>
</ul>
<blockquote>
<p>补充：样式作用于非目标标签上时，则离目标接近者优先</p>
</blockquote>
<h3 id="圣杯-amp-双飞翼"><a href="#圣杯-amp-双飞翼" class="headerlink" title="圣杯&amp;双飞翼"></a>圣杯&amp;双飞翼</h3><p>圣杯布局和双飞翼布局从字面上的意思是：一个像圣杯或者像展翅的禽类这样的布局，就是<strong>左右两栏固定宽度，中间部分自适应的三栏布局</strong>。</p>


<h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ol>
<li>首先将 left、middle、right 都放出来；</li>
<li>给三个元素设置 <code>float: left; position: relative;</code>，脱离文档流；</li>
<li>给三个元素的父元素 container 设置 <code>overflow: hidden;</code> 形成 BFC 防止浮动塌陷；</li>
<li>left、right 设置上各自的宽度；</li>
<li>middle 设置 <code>width: 100%;</code>；</li>
<li>left 设置 <code>left: -leftWidth;</code>，right 设置 <code>right: -rightWidth;</code>；</li>
<li>containter 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>，防止左右内容遮挡 middle 的内容。</li>
</ol>
<p>代码实例：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span>,</span><br><span class="css">    <span class="hljs-selector-class">.right</span>,</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">position</span>: relative;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">right</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>      middle<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>      left<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>      right<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129122542330.png" srcset="/img/three2.gif" lazyload class title="圣杯布局">

<h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局和圣杯布局很类似，就是在 middle 的 div 里又插入一个 div，通过调整内部 div 的 margin 值，实现中间栏自适应。</p>
<ol>
<li>middle 中增加 inner；</li>
<li>left 设置 <code>margin-left: -100%;</code>，right 设置 <code>margin-right: -rightWidth;</code>；</li>
<li>container 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>。</li>
</ol>
<p>代码实例：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">    <span class="hljs-selector-class">.container</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">overflow</span>: hidden;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: red;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span>,</span><br><span class="css">    <span class="hljs-selector-class">.right</span>,</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">float</span>: left;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.left</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.right</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.middle</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">height</span>: <span class="hljs-number">100%</span>;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: green;</span><br><span class="css">    &#125;</span><br><span class="css">    <span class="hljs-selector-class">.inner</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">100px</span>;</span><br><span class="css">      <span class="hljs-attribute">min-height</span>: <span class="hljs-number">130px</span>;</span><br><span class="css">      <span class="hljs-attribute">background</span>: blue;</span><br><span class="css">      <span class="hljs-attribute">word-break</span>: break-all;</span><br><span class="css">    &#125;</span><br><span class="css">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;middle&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;inner&quot;</span>&gt;</span><br>        middle - inner<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;left&quot;</span>&gt;</span><br>      left<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;right&quot;</span>&gt;</span><br>      right<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129124500728.png" srcset="/img/three2.gif" lazyload class title="双飞翼布局">

<ul>
<li>圣杯布局在DOM结构上显得更加直观和自然；</li>
<li>双飞翼布局省去了很多css，而且由于不用使用定位，可以获得比圣杯布局更小最小宽度。</li>
</ul>
<blockquote>
<p>由于双飞翼布局会一直随着浏览器可视区域宽度减小从而不断挤压中间部分宽度，所以需要设置给页面一个 <code>min-width &gt; LeftWidth + RightWidth</code> </p>
</blockquote>
<h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>CSS3 过渡是元素从一种样式逐渐改变为另一种样式的效果，必须指定的两项内容：要添加过渡的 CSS 属性以及效果的持续时间。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition</span>: CSS 属性, 花费时间, 效果曲线(默认ease), 延迟时间;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 宽度从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s，0.2s 后执行过渡 */</span><br><span class="hljs-attribute">transition</span>: width, .<span class="hljs-number">5s</span>, ease, .<span class="hljs-number">2s</span>;<br><span class="hljs-comment">/* 所有属性从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s */</span><br><span class="hljs-attribute">transition</span>: all, .<span class="hljs-number">5s</span>;<br></code></pre></div></td></tr></table></figure>

<p>也可以分开写各个属性：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transition-property</span>: width;<br><span class="hljs-attribute">transition-duration</span>: <span class="hljs-number">1s</span>;<br><span class="hljs-attribute">transition-timing-function</span>: linear;<br><span class="hljs-attribute">transition-delay</span>: <span class="hljs-number">2s</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation</span>: 动画名称 一个周期时间 运动曲线(默认ease) 动画延迟(默认<span class="hljs-number">0</span>) 播放次数(默认<span class="hljs-number">1</span>) 是否反向播放动画(默认normal) 是否暂停动画(默认running);<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear;<br><span class="hljs-comment">/* 2s 后执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear <span class="hljs-number">2s</span>;<br><span class="hljs-comment">/* 无限执行 logo-line 动画，每次运动时间 2s，运动曲线为 linear，并且执行反向动画 */</span><br><span class="hljs-attribute">animation</span>: logo-line <span class="hljs-number">2s</span> linear alternate infinite;<br></code></pre></div></td></tr></table></figure>

<p>还有一个重要属性：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">animation-fill-mode</span>: none | forwards | backwards | both;<br></code></pre></div></td></tr></table></figure>

<ul>
<li>none：不改变默认行为；</li>
<li>forwards：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）；</li>
<li>backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）；</li>
<li>both：向前和向后填充模式都被应用。</li>
</ul>
<h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><p>分为 2D 转换 和 3D 转换</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: 适用于 <span class="hljs-number">2</span>D 或者 <span class="hljs-number">3</span>D 变换的元素;<br><span class="hljs-attribute">transform-origin</span>: 转换元素的位置转换元素的位置。默认(x,y,z):(<span class="hljs-number">50%</span>,<span class="hljs-number">50%</span>,<span class="hljs-number">0</span>)<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate</span>(<span class="hljs-number">30deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(<span class="hljs-number">30px</span>, <span class="hljs-number">30px</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(.<span class="hljs-number">8</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">skew</span>(<span class="hljs-number">10deg</span>, <span class="hljs-number">10deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateX</span>(<span class="hljs-number">180deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotateY</span>(<span class="hljs-number">180deg</span>);<br><span class="hljs-attribute">transform</span>: <span class="hljs-built_in">rotate3d</span>(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">90deg</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h4><p>CSS3 提供了一些新的选择器：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd2d.png" srcset="/img/three2.gif" lazyload class title="CSS3选择器">

<h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认从里往外）;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">box-shadow</span>: <span class="hljs-number">10px</span> <span class="hljs-number">10px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#888</span>;<br></code></pre></div></td></tr></table></figure>

<h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p><strong>边框图片</strong>：</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-image</span>: 图片url 图像边界向内偏移 图像边界的宽度（默认为边框的宽度） 用于指定字啊边框外部绘制偏移的量（默认<span class="hljs-number">0</span>） 铺满方式（默认拉伸，repeat 重复、stretch 拉伸 或 round 铺满）;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">15px</span> solid transparent;<br>  <span class="hljs-attribute">border-image</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">border.png</span>);<br>  <span class="hljs-attribute">border-image-slice</span>: <span class="hljs-number">30</span>;<br>  <span class="hljs-attribute">border-image-repeat</span>: round;<br>  <span class="hljs-attribute">border-image-outset</span>: <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>边框圆角</strong>：</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">border-radius</span>: 左上 右上 右下 左下;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.demo</span> &#123;<br>  <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">25px</span> <span class="hljs-number">0</span> <span class="hljs-number">25px</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h5><p>制定背景绘制（显示）区域，默认从边框（border-box）开始绘制。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqt.png" srcset="/img/three2.gif" lazyload class title="border-box">

<p>从 padding 开始绘制，不算 border：<code>background-clip: padding-box;</code> </p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqv.png" srcset="/img/three2.gif" lazyload class title="padding-box">

<p>只在内容区绘制，不算 padding 和 border：<code>background-clip: content-box;</code> </p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqy.png" srcset="/img/three2.gif" lazyload class title="content-box">

<h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p><code>background-origin</code> 属性指定 <code>background-position</code> 属性应该是相对位置。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">10px</span> dashed black;<br>  <span class="hljs-attribute">padding</span>: <span class="hljs-number">35px</span>;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;logo.png&#x27;</span>) no-repeat, <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">background-position</span>: <span class="hljs-number">0px</span> <span class="hljs-number">0px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVZGAM.jpeg" srcset="/img/three2.gif" lazyload class title="background-origin">

<h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>制定背景的大小。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgk7.png" srcset="/img/three2.gif" lazyload class title="background-size">

<h5 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h5><p>实例:</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">background</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;test.png&#x27;</span>) no-repeat left, <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;logo.png&#x27;</span>) no-repeat right;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTglS.png" srcset="/img/three2.gif" lazyload class title="多张背景图">

<h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>也可以说是倒影。</p>
<p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css">-webkit-box-reflect: 方向[ above-上 | below-下 | right-右 | left-左 ], 偏移量, 遮罩图片;<br></code></pre></div></td></tr></table></figure>

<p>例子：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 下倒影 */</span><br>-webkit-box-reflect: below;<br><span class="hljs-comment">/* 右倒影同时有偏移 */</span><br>-webkit-box-reflect: right <span class="hljs-number">10px</span>;<br><span class="hljs-comment">/* 下阴影渐变 */</span><br>-webkit-box-reflect: below <span class="hljs-number">0</span> <span class="hljs-built_in">linear-gradient</span>(transparent, white);<br><span class="hljs-comment">/* 下阴影图片遮罩 */</span><br>-webkit-box-reflect: below <span class="hljs-number">0</span> <span class="hljs-built_in">url</span>(<span class="hljs-string">shou.png</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>语法：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-break</span>: normal | break-all | keep-all;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgo9.png" srcset="/img/three2.gif" lazyload class title="word-break">

<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">word-wrap</span>: normal | break-word;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220130163149441.png" srcset="/img/three2.gif" lazyload class title="word-wrap">

<h5 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;<br>  <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#ccc</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">text-overflow</span>: ellipsis;<br>  <span class="hljs-attribute">display</span>: -webkit-box;<br>  -webkit-line-camp: <span class="hljs-number">2</span>;<br>  -webkit-box-orient: vertical;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd6V.png" srcset="/img/three2.gif" lazyload class title="文字多行超出省略号">

<h5 id="阴影-1"><a href="#阴影-1" class="headerlink" title="阴影"></a>阴影</h5><figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">text-shadow</span>: 水平阴影 垂直阴影 模糊距离 阴影颜色;<br></code></pre></div></td></tr></table></figure>

<h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>CSS3 提供了新的颜色表示方法。</p>
<h5 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h5><p>rgb 为颜色值，a 为透明度（0 ~ 1）</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">255</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">rgba</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, .<span class="hljs-number">5</span>);<br></code></pre></div></td></tr></table></figure>

<h5 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h5><p>h：色相，s：饱和度，l：亮度，a：透明度</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-attribute">color</span>: <span class="hljs-built_in">hsla</span>(<span class="hljs-number">112</span>, <span class="hljs-number">72%</span>, <span class="hljs-number">33%</span>, .<span class="hljs-number">68</span>);<br><span class="hljs-attribute">background-color</span>: <span class="hljs-built_in">hsla</span>(<span class="hljs-number">49</span>, <span class="hljs-number">65%</span>, <span class="hljs-number">60%</span>, .<span class="hljs-number">68</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>CSS3 提供了线性渐变，径向渐变，圆锥渐变。</p>
<h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>CSS3 滤镜（Filter）</p>
<p>实例：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 黑白色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">grayscale</span>(<span class="hljs-number">100%</span>);<br><span class="hljs-comment">/* 褐色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">sepia</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/* 饱和度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">saturate</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">/* 色相反转 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">hue-rotate</span>(<span class="hljs-number">90deg</span>);<br><span class="hljs-comment">/* 反色 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">invert</span>(<span class="hljs-number">1</span>);<br><span class="hljs-comment">/* 透明度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">opacity</span>(.<span class="hljs-number">5</span>);<br><span class="hljs-comment">/* 亮度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">brightness</span>(.<span class="hljs-number">5</span>);<br><span class="hljs-comment">/* 对比度 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">contrast</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">/* 模糊 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">blur</span>(<span class="hljs-number">3px</span>);<br><span class="hljs-comment">/* 阴影 */</span><br><span class="hljs-attribute">filter</span>: <span class="hljs-built_in">drop-shadow</span>(<span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">5px</span> <span class="hljs-number">#000</span>);<br></code></pre></div></td></tr></table></figure>

<h4 id="弹性布局-amp-栅格布局"><a href="#弹性布局-amp-栅格布局" class="headerlink" title="弹性布局 &amp; 栅格布局"></a>弹性布局 &amp; 栅格布局</h4><p>也就是 Flex 和 grid</p>
<h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>使用 <code>column-count</code> 设定分列列数，<code>colum-rule</code> 设定分隔样式。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>  <span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  -webkit-<span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  -moz-<span class="hljs-attribute">column-count</span>: <span class="hljs-number">3</span>;<br>  <span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  -webkit-<span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>  -moz-<span class="hljs-attribute">column-rule</span>: <span class="hljs-number">2px</span> solid <span class="hljs-number">#000</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgRx.png" srcset="/img/three2.gif" lazyload class title="多列布局">

<h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式。</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">960px</span>) &#123;</span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: darkgoldenrod;</span><br><span class="css">    &#125;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">480px</span>) &#123;</span><br><span class="css">    <span class="hljs-selector-tag">body</span> &#123;</span><br><span class="css">      <span class="hljs-attribute">background-color</span>: lightgreen;</span><br><span class="css">    &#125;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>重置浏览器窗口查看效果！<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgPW.gif" srcset="/img/three2.gif" lazyload class title="监听屏幕尺寸改变样式">

<h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>CSS3 的混合模式，有两种写法：<code>background-blend-mode</code> 和 <code>mix-blend-mode</code>。</p>
<p>区别在于 <code>background-blend-mode</code> 是用于同一个元素的背景图片和背景颜色的。</p>
<h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p>书写 CSS 的几个阶段：</p>
<ol>
<li>手写原生 CSS；</li>
<li>使用预处理器 Sass/Less；</li>
<li>使用后处理器 PostCSS；</li>
<li>使用 css modules；</li>
<li>使用 css in js。</li>
</ol>
<h4 id="手写原生-CSS"><a href="#手写原生-CSS" class="headerlink" title="手写原生 CSS"></a>手写原生 CSS</h4><p>写 CSS 的几种情况：</p>
<ul>
<li>行内样式：直接在 html 元素的  style 属性中编写 css 代码；</li>
<li>内嵌样式：在 head 中的 style 标签内编写；</li>
<li>导入样式：在内联样式中通过 @import 方法，导入其他样式；</li>
<li>外部样式：使用 html 的 link 标签加载样式。</li>
</ul>
<blockquote>
<p>使用行内样式的缺点：</p>
<ul>
<li>样式不能复用；</li>
<li>样式权重过高，样式不好覆盖；</li>
<li>表现层与结构层没有分离；</li>
<li>不能进行缓存，影响加载效率。</li>
</ul>
</blockquote>
<p>不建议使用导入样式的原因：</p>
<ol>
<li>在 IE6-8 下，@import 声明指向的样式表并不会与页面其他资源并发加载，而是等页面所有资源加载完成后才开始下载；</li>
<li>如果在 link 标签中去 @import 其他 css，页面会等到所有资源加载完成后，才开始解析 link 标签中 @import 的 css。</li>
</ol>
<blockquote>
<p>使用导入样式的缺点：</p>
<ul>
<li>导入样式，只能放在 style 标签的第一行，放其他行会无效；</li>
<li>@import 声明的样式不能充分利用浏览器并发请求资源的行为，其加载行为往往会延后触发或被其他资源加载挂起；</li>
<li>由于 @import 样式表的延后加载，可能会导致页面样式闪烁。</li>
</ul>
</blockquote>
<h4 id="预处理器-Sass-Less"><a href="#预处理器-Sass-Less" class="headerlink" title="预处理器 Sass/Less"></a>预处理器 Sass/Less</h4><p>预处理器主要是强化了 css 的语法，弥补了原生 css 不支持变量、嵌套、父选择器种种问题，但打包出来的结果和原生的 css 是一样的。</p>
<h4 id="后处理器-PostCSS"><a href="#后处理器-PostCSS" class="headerlink" title="后处理器 PostCSS"></a>后处理器 PostCSS</h4><p>PostCSS 可以称作为 CSS 界的 babel，实现原理是通过 ast 去分析 css 代码，然后将分析的结果进行处理。</p>
<p>常用的 PostCSS 使用场景有：</p>
<ol>
<li>配合 stylelint 校验 css 语法；</li>
<li>自动增加浏览器前缀 autoprefixer；</li>
<li>编译 css next 的语法</li>
</ol>
<h4 id="CSS-模块化实现方式"><a href="#CSS-模块化实现方式" class="headerlink" title="CSS 模块化实现方式"></a>CSS 模块化实现方式</h4><h5 id="BEM-命名规范"><a href="#BEM-命名规范" class="headerlink" title="BEM 命名规范"></a>BEM 命名规范</h5><p>BEM 的意思就是 块（block）、元素（element）、修饰符（modifier），是由 Yandex 团队提出的一种前端命名方法论。</p>
<p>命名规则如下：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 块即是通常所说的 Web 应用开发中的组件或模块，每个块在逻辑上和功能上都是相互独立的。 */</span><br><span class="hljs-selector-class">.block</span> &#123;<br>&#125;<br><br><span class="hljs-comment">/* 元素是块中的组成部分。元素不能离开块来使用。BEM 不推荐在元素中嵌套其他元素。 */</span><br><span class="hljs-selector-class">.block__element</span> &#123;<br>&#125;<br><br><span class="hljs-comment">/* 修饰符用来定义块或元素的外观和行为。同样的块在应用不同的修饰符之后，会有不同的外观。 */</span><br><span class="hljs-selector-class">.block--modifier</span> &#123;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>通过 BEM 的命名规范，可以让我们的 css 代码层次结构清晰，通过严格的命名也可以也解决命名冲突的问题，但无法完全避免。</p>
<h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>指像 import js 一样去引入 css 代码，代码中的每一个类名都是引入对象的一个属性，通过这种方式，即可在使用时明确指定所引用的 css 样式。</p>
<p>并且 CSS Modules 在打包的时候会自动将类名转换成 hash 值，完全杜绝 css 类名冲突的问题。</p>
<h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h4><p>CSS in JS，意思就是使用 js 语言写 css，完全不需要写单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。</p>
<p>CSS in JS 其实是一种编写思想，有很多方案的实现，最出名的是 <code>styled-components</code> </p>
<p>除此之外，还有：<code>emotion</code>、<code>radium</code>、<code>glamorous</code>…</p>


<h3 id="CSS-性能优化"><a href="#CSS-性能优化" class="headerlink" title="CSS 性能优化"></a>CSS 性能优化</h3><p>提高新能的方法：</p>
<ol>
<li>合并 css 文件，如果页面加载 10 个 css 文件，每个文件 1k，那么也要比只加载一个 100k 的 css 文件慢；</li>
<li>减少 css 嵌套，最好不要嵌套三层以上；</li>
<li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能；</li>
<li>建立公共样式类，把相同样式提取出来作为公共类使用；</li>
<li>减少通配符 <code>*</code> 或者类似 <code>[hidden=&quot;true&quot;]</code> 这类选择器的使用，挨个查找所有性能很差；</li>
<li>巧妙运用 css 的继承机制，如果父节点定义了，子节点就无需定义；</li>
<li>拆分出公共 css 文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独 css 文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定；</li>
<li>不用 css 表达式，表达式只会让代码显得更加酷炫，但是对性能的浪费特别大；</li>
<li>少用 css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择 normolize.css；</li>
<li>cssSprite，合成所有icon图片，用宽高加上 <code>background-position</code> 的背景图方式显现 icon 图，这样很实用，减少了http请求；</li>
<li>善后工作，css 压缩(在线压缩工具 YUI Compressor)；</li>
<li>GZIP 压缩，是一种流行的文件压缩算法。</li>
</ol>
<blockquote>
<p> 避免使用 @import，外部的 css 文件中使用 @import 会使得页面在加载时增加额外的延迟；</p>
</blockquote>
<blockquote>
<p>避免过分重排；</p>
</blockquote>
<ul>
<li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做重排 reflow；</li>
<li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，就是重排 reflow；</li>
<li>页面上任何一个节点触发 reflow，会导致它的子节点和祖先节点重新渲染；</li>
<li>导致 reflow发生的情况有：<ol>
<li>改变窗口的大小；</li>
<li>改变文字的大小；</li>
<li>增加、删除样式表；</li>
<li>内容的改变，输入框输入内容也会；</li>
<li>伪类的激活；</li>
<li>操作 class 属性；</li>
<li>脚本操作 dom，js 改变 css 类；</li>
<li>计算 offsetWidth 和 offsetHeight；</li>
<li>设置 style 属性；</li>
<li>改变元素的内外边距。</li>
</ol>
</li>
<li>常见重排元素：<ul>
<li>大小有关的 width,height,padding,margin,border-width,border,min-height</li>
<li>布局有关的 display,top,position,float,left,right,bottom</li>
<li>字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</li>
<li>隐藏有关的 overflow,overflow-x,overflow-y</li>
</ul>
</li>
<li>减少 reflow 对性能影响的建议：<ol>
<li>不要一条一条的修改 dom 的样式，预先定义好 class，然后修改 dom 的 classname；</li>
<li>不要修改范围比较大的 dom；</li>
<li>为动画元素使用绝对定位；</li>
<li>不要 table 布局，因为一个很小的改动会造成整个 table 重新布局；</li>
<li>避免设置大量的 style 属性，最好使用 class 属性；</li>
<li>如果 css 里面有计算表达式，每次都会重新计算一遍，触发一次 reflow。</li>
</ol>
</li>
</ul>
<blockquote>
<p>repaint - 重绘</p>
</blockquote>
<ol>
<li>当一个元素的外观被改变，但是布局没有改变的情况；</li>
<li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li>
<li>常见的重绘元素<ul>
<li>颜色 color,background</li>
<li>边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</li>
<li>背景有关 background,backgound-image,background-position,background-repeat,background-size</li>
</ul>
</li>
</ol>
<blockquote>
<p>CSS 动画</p>
</blockquote>
<ol>
<li>css 动画启用 GPU 加速，应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成：<ul>
<li>canvans 2D、布局合成、CSS3 转换、CSS 3D变换、webGL、视频…</li>
</ul>
</li>
</ol>
<blockquote>
<p>文件压缩</p>
</blockquote>
<p>文件的大小会直接影响到浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具 webpack，gulp/grunt，rollup 压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p>
<blockquote>
<p>去除无用 CSS</p>
</blockquote>
<ol>
<li>不同元素或者其他情况下的重复代码；</li>
<li>整个页面内没有生效的CSS代码</li>
</ol>
<blockquote>
<p>有选择地使用选择器</p>
</blockquote>
<p>CSS 选择器的匹配是从右往左进行的，原因：css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p>
<p>在使用选择器时，尽量要遵循：</p>
<ol>
<li>保持简单，不要使用嵌套过多过于复杂的选择器；</li>
<li>通配符和属性选择器效率最低，需要匹配的元素最多，要尽量避免使用；</li>
<li>不要使用 类选择器 和 ID 选择器 修饰元素标签，如：<code>h3#markdown-content</code>，这多此一举，还会降低效率；</li>
<li>不要为了追求速度而放弃可读性和可维护性。</li>
</ol>
<blockquote>
<p>减少使用昂贵的属性</p>
</blockquote>
<p>应该尽量减少使用昂贵属性，如：box-shadow, border-radius, filter, 透明度, :nth-child …</p>
<p>有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p>
<blockquote>
<p>硬件加速的好坏</p>
</blockquote>
<ol>
<li>仅仅依靠 GPU 还是不行的，许多动画还是需要 CPU 的介入，连接 CPU 和 GPU 的总带宽不是无限的，所以需要注意数据在 CPU 和 GPU 之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输；</li>
<li>要了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存；</li>
<li>每一个 dom 元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层；</li>
<li>另一个重点是保持 GPU 和 CPU 之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给 GPU；</li>
<li>动画开始之后避免层的更新，避免动画进行中其他层一直更新导致拥堵；</li>
<li>尽量使用这些 css 属性来实现动画：transformation, opacity, filter；</li>
<li>使用性能工具检测优化的合理性，timeline 检测优化是否合理，还需要实现自动操作来做性能回归测试；</li>
</ol>
<h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。</p>
<p>如果一个元素含有层叠上下文，可以理解为这个元素在 z 轴 上就高人一等，离用户更近。</p>
<h4 id="层叠水平"><a href="#层叠水平" class="headerlink" title="层叠水平"></a>层叠水平</h4><p>层叠水平（stacking level），决定了同一个层叠上下文中元素在 z 轴上的显示顺序。</p>
<p>普通元素的层叠水平优先由层叠上下文决定，因此层叠水平的比较只有在当前层叠上下文元素中才有意义。</p>
<blockquote>
<p>注意：不可以把层叠水平和 CSS 的 z-index 属性混为一谈，某些情况下 z-index 确实可以影响层叠水平，但只限于定位元素以及 flex 盒子的子元素，而层叠水平所有的元素都存在。</p>
</blockquote>
<h4 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h4><p>层叠顺序（stacking order），表示当元素发生层叠时有着特定的垂直显示顺序，上面的层叠上下文和层叠水平是概念，而层叠顺序是规则。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214173741026.png" srcset="/img/three2.gif" lazyload class title="层叠顺序">

<ol>
<li>位于最低水平的 <code>border/background</code> 指层叠上下文元素的边框和背景，每一个层叠顺序规则适用于一个完整的层叠上下文元素；</li>
<li><code>z-index: auto</code> 和 <code>z-index: 0</code> 单纯从层叠水平上看，是可以认为是一样的，但实际上两者在层叠上下文领域有着根本性的差异。</li>
</ol>
<h4 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h4><p>当元素发生层叠时，其覆盖关系遵循以下两个准则：</p>
<ol>
<li><strong>谁大谁上</strong>：当具有明显的层叠水平标示时（如 z-index 值），在统一个层叠上下文领域，层叠水平值大的哪一个覆盖小的那一个；</li>
<li><strong>后来居上</strong>：当元素的层叠水平一致、层叠顺序相同时，在 DOM 流中处于后面的元素覆盖前面的元素。</li>
</ol>
<h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul>
<li>层叠上下文的层叠水平要比普通元素高；</li>
<li>层叠上下文可以阻断元素的混合模式；</li>
<li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受限于外部的层叠上下文；</li>
<li>每个层叠上下文和兄弟元素独立，也就是进行层叠变化或渲染时，只需要考虑后代元素；</li>
<li>每个层叠上下文是自成体系的，当元素发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中。</li>
</ul>
<h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>根层叠上下文：页面根元素 <code>&lt;html&gt;</code> 天生具有层叠上下文；</p>
<p>传统层叠上下文：</p>
<p>对于包含有 <code>position: relative</code> / <code>position: absolute</code> 的定位元素，以及 FireFox/IE 浏览器下含有 <code>position: fixed</code> 声明的定位元素，当其 <code>z-index</code> 值不是 <code>auto</code> 的时候就会创建层叠上下文；</p>
<p>例子：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm1.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute; z-index:2;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm2.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:relative; z-index:1;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>上面的效果为 mm1 覆盖在 mm2 上面，因为两者处于同一个层叠上下文中，且 mm1 图片的 z-index 更大；</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm1.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position:absolute; z-index: 2;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;mm2.jpg&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;position: relative; z-index: 1;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>稍作修改，效果就会反转，mm1 被 mm2 覆盖，因为两个 div 的 z-index 不再是 auto 而是数值，所以分别创建了层叠上下文，故两张图片不在同一个层叠上下文中，层叠顺序相同，层叠准则遵循后来居上。</p>
<p>其他 CSS3 属性：</p>
<ul>
<li><code>z-index</code> 不为 <code>auto</code> 的 <code>flex</code> 项（父元素 <code>display: flex|inline-flex</code>）；</li>
<li>元素的 <code>opacity</code> 值不是 1；</li>
<li>元素的 <code>transform</code> 值不是 <code>none</code>；</li>
<li>元素的 <a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/"><code>mix-blend-mode</code></a> 值不是 <code>normal</code>；</li>
<li>元素的 <code>filter</code> 值不是 <code>none</code>；</li>
<li>元素的 <a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/?p=5155"><code>isolation</code></a> 值不是 <code>isolate</code>；</li>
<li><a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/"><code>will-change</code> </a>指定的属性值为上面的任意一个；</li>
<li>元素的 <code>-webkit-overflow-scrolling</code> 设为 <code>touch</code>。</li>
</ul>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一旦普通元素具有了层叠上下文，其层叠顺序就会变高，层叠顺序与 <code>z-index: 0</code> 同一位置：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214182400866.png" srcset="/img/three2.gif" lazyload class title="层叠顺序">

<p>定位元素层叠在普通元素上的根本原因在于：元素一旦成为定位元素，其 <code>z-index</code> 就会生效，此时其 <code>z-index</code> 就是默认的 <code>auto</code> 也就是 0 级别，也就会覆盖 <code>inline</code> 或 <code>block</code> 或 <code>float</code> 元素。</p>
<blockquote>
<p>CSS3 的 fadeIn 淡入 animation 效果本质上就是元素 <code>opacity</code> 透明度的变化，而当 <code>opacity</code> 的值不是 1 的时候，是具有层叠上下文的。</p>
</blockquote>
<h3 id="div-居中"><a href="#div-居中" class="headerlink" title="div 居中"></a>div 居中</h3><h4 id="div-水平垂直居中"><a href="#div-水平垂直居中" class="headerlink" title="div 水平垂直居中"></a>div 水平垂直居中</h4><h5 id="flex-布局实现-已知宽"><a href="#flex-布局实现-已知宽" class="headerlink" title="flex 布局实现(已知宽)"></a>flex 布局实现(已知宽)</h5><figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">display</span>: flex;</span><br><span class="css">    <span class="hljs-attribute">justify-content</span>: center;</span><br><span class="css">    <span class="hljs-attribute">align-items</span>: center;</span><br><span class="css">  &#125;</span><br><span class="css">  <span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: deeppink;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;a&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="position-已知宽"><a href="#position-已知宽" class="headerlink" title="position(已知宽)"></a>position(已知宽)</h5><p>父元素设置为：<code>position: relative</code>；</p>
<p>子元素设置为：<code>position: absolute</code>；</p>
<p>据离上面 50%，距离下面 50%，然后减去元素自身宽度的一半距离就可以实现。</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: blue;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">margin</span>: -<span class="hljs-number">50px</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> -<span class="hljs-number">50px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="position-transform-未知宽"><a href="#position-transform-未知宽" class="headerlink" title="position transform(未知宽)"></a>position transform(未知宽)</h5><p>将上面例子中的 <code>margin: -50px 0 0 -50px;</code> 替换为 <code>transfrom: translate(-50%, -50%);</code>：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>  <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>, -<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="position-margin-已知宽"><a href="#position-margin-已知宽" class="headerlink" title="position margin(已知宽)"></a>position margin(已知宽)</h5><p>left、right、top、bottom 为 0，<code>margin: auto</code> 即可：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;            <br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>此情况下，如果子元素不设置宽度和高度，将会铺满整个父盒子（应用：模态框）</p>
<h5 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h5><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>  <span class="hljs-attribute">background-color</span>: pink;<br>  <span class="hljs-attribute">display</span>: table-cell;<br>  <span class="hljs-attribute">vertical-align</span>: middle;<br>&#125;<br><span class="hljs-selector-class">.box</span> <span class="hljs-selector-class">.a</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background-color</span>: deeppink;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="内容水平垂直居中"><a href="#内容水平垂直居中" class="headerlink" title="内容水平垂直居中"></a>内容水平垂直居中</h4><h5 id="table-cell-1"><a href="#table-cell-1" class="headerlink" title="table-cell"></a>table-cell</h5><ul>
<li><code>text-align: center</code>：给元素的父级加，可以使文本或者行级元素水平居中；</li>
<li><code>line-height</code>：值为元素的高度，可以使元素的文本内容垂直居中；</li>
<li><code>margin: 0 auto</code>：父级元素宽度可有可无，子级元素必须是块元素，而且要有宽度（否则继承父级）</li>
</ul>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="css"></span><br><span class="css">  <span class="hljs-selector-class">.box</span> &#123;</span><br><span class="css">    <span class="hljs-attribute">width</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;</span><br><span class="css">    <span class="hljs-attribute">background-color</span>: pink;</span><br><span class="css">    <span class="hljs-attribute">display</span>: table-cell;</span><br><span class="css">    <span class="hljs-attribute">text-align</span>: center;</span><br><span class="css">    <span class="hljs-attribute">vertical-align</span>: middle;</span><br><span class="css">  &#125;</span><br><span class="css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;box&quot;</span>&gt;</span>AgoniLay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>给父级设置 <code>display: table</code>，子集设置 <code>display: tablecell</code>，子集会充满全屏。</p>
<h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h4><p>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，间接影响包含块的布局。</p>
<p>浮动元素的摆放包含如下原则：</p>
<ul>
<li>尽量靠上靠左，且一个挨着一个；</li>
<li>不能超出包含块，除非元素比包含块更宽；</li>
<li>不能超出所在行的最高点；</li>
<li>不能超过它前面浮动的元素的最高点；</li>
<li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素。</li>
</ul>
<blockquote>
<p>注意：浮动元素不能撑起包含块，所以需要消除浮动</p>
</blockquote>
<h4 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h4><ul>
<li><p>BFC</p>
</li>
<li><p>伪元素</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br> 	<span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">clear</span>: both;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
<li><p>包含块也浮动</p>
</li>
</ul>
<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="块级和行内元素"><a href="#块级和行内元素" class="headerlink" title="块级和行内元素"></a>块级和行内元素</h3><h4 id="罗列"><a href="#罗列" class="headerlink" title="罗列"></a>罗列</h4><p>行内元素（内联元素，inline element）：</p>
<ul>
<li>a - 锚点</li>
<li>abbr - 缩写</li>
<li>acronym - 首字</li>
<li>b - 粗体</li>
<li>bdo - 文本方向</li>
<li>big - 大字体</li>
<li>br - 换行</li>
<li>cite - 引用</li>
<li>code - 计算机代码</li>
<li>dfn - 定义字段</li>
<li>em - 强调</li>
<li>font - 字体设定</li>
<li>i - 斜体</li>
<li>img - 图片</li>
<li>input - 输入框</li>
<li>kbd - 定义键盘文本</li>
<li>label - 表格标签</li>
<li>q - 短引用</li>
<li>s - 中划线</li>
<li>strong - 粗体强调</li>
<li>sub - 下标</li>
<li>sup - 上标</li>
<li>textarea - 多行文本输入框</li>
<li>tt - 电传文本</li>
<li>u - 下划线</li>
<li>var - 定义变量</li>
</ul>
<p>块级元素（block element）：</p>
<ul>
<li>address - 地址</li>
<li>blockquote - 块引用</li>
<li>center - 居中对齐块</li>
<li>div - 常用块级元素</li>
<li>dl - 定义列表</li>
<li>fieldset - 表单控制组</li>
<li>form - 交互表单</li>
<li>h1 ~ h6 - 标题</li>
<li>hr - 水平分割线</li>
<li>isindex - 单行文本输入框</li>
<li>menu - 菜单列表</li>
<li>noframes - frames 可选内容（对于不支持 frame 的浏览器显示此区块内容）</li>
<li>noscript - 可选脚本内容（对于不支持 script 的浏览器显示此内容）</li>
<li>ol - 排序表单</li>
<li>p - 段落</li>
<li>pre - 格式化文本</li>
<li>table - 表格</li>
<li>ul - 无序列表</li>
</ul>
<p>可变元素：</p>
<p>可变元素根据上下文语境决定该元素为块元素或者行内元素。</p>
<ul>
<li>applet - java applet（已不支持，使用 object 代替）</li>
<li>button - 按钮</li>
<li>del - 删除文本</li>
<li>iframe - 内联框架</li>
<li>ins - 插入的文本</li>
<li>map - 图片区块</li>
<li>object - object 对象</li>
<li>script - 客户端脚本</li>
</ul>
<h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol>
<li><p>块级元素会独占一行，其宽度自动填满其父元素宽度；</p>
<p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排列不下，才会换行，其宽度随元素的内容的宽度而变化</p>
</li>
<li><p>块级元素可以设置 width height 属性（即使设置了 width，也仍是独占一行的）；</p>
<p>行内元素设置 width height 无效</p>
</li>
<li><p>块级元素可以设置 margin padding 属性；</p>
<p>行内元素的竖直方向的 margin 不会产生边距效果（竖直方向的 padding 在 ie6 中不起作用），水平方向的正常</p>
</li>
<li><p>块级元素可以包含行内元素和块级元素；</p>
<p>行内元素不能包含块级元素</p>
</li>
</ol>
<blockquote>
<p>注意：p 标签中不能包含 div 标签。</p>
</blockquote>
<h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以需要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM，DOM 提供了对 HTML 文档结构化的表述，DOM 有三个层面的作用：</p>
<ul>
<li>页面的视角：DOM 是生成页面的基础数据结构；</li>
<li>从 JavaScript 脚本视角来看：DOM 提供给 JavaScript 脚本操作的接口，从而可以对 DOM 结构进行访问，进而改变文档的结构、样式和内容；</li>
<li>从安全视角来看：DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就可以拦截。</li>
</ul>
<p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤掉部分不安全的内容。</p>
<h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>在渲染引擎中，有一个叫 HTML 解析器（HTMLParser）的模块，其职责就是负责将 HTML 字节流转换为 DOM 结构。</p>
<p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据：</p>
<ul>
<li>网络进程接收到响应头后，会根据响应头中的 <code>content-type</code> 字段来判断文件的类型，然后为该请求选择或者创建一个渲染进程；</li>
<li>然后网络进程和渲染进程之间就会建立一个共享数据的管道，网络进程将接收到的数据放在此管道中，而渲染进程则从管道的另一端不断地读取数据，并同时传给 HTML 解析器，将其动态实时解析为 DOM。</li>
</ul>
<p>DOM 生成流程：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232307492.png" srcset="/img/three2.gif" lazyload class title="字节流 -&gt; DOM">

<p><strong>第一个阶段，通过分词器将字节流转换为 Token</strong>；</p>
<p>V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个一个 Token；解析 HTML 也同理，需要通过分词器将字节流转换成一个一个 Token，分为 <code>Tag Token</code> 和 <code>文本 Token</code>：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232646991.png" srcset="/img/three2.gif" lazyload class title="Token 示意图">

<p>其中，Tag Token 又分为 StartTag 和 EndTag。</p>
<p><strong>后续的二和三阶段是同步进行的，需要将 Token 解析为 DOM 阶段，并将 DOM 节点添加到 DOM 树中</strong>。</p>
<p>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段生成的 Token 会依次压到这个栈中，处理规则如下：</p>
<ol>
<li><p>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时将一个 StartTag document 压入栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223233942311.png" srcset="/img/three2.gif" lazyload class title="初始化阶段"></li>
<li><p>若压入的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，父节点就是栈中相邻的那个元素生成的节点；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234022765.png" srcset="/img/three2.gif" lazyload class title="startTag Token"></li>
<li><p>若分词器解析到的是 文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 无需压入到栈中，父节点就是当前栈顶 Token 所对应的 DOM 节点；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234041536.png" srcset="/img/three2.gif" lazyload class title="文本 Token"></li>
<li><p>若解析到的是 EndTag 标签，HTML 解析器会查看 Token 栈顶的元素是否与之对应，是，则将对应的 StartTag Token 从栈中弹出，表示该节点解析完成；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234106295.png" srcset="/img/three2.gif" lazyload class title="EndTag"></li>
<li><p>以此反复，直到分词器将所有字节流分词完成。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234125004.png" srcset="/img/three2.gif" lazyload class title="解析完成"></li>
</ol>
<h4 id="JS-影响-DOM"><a href="#JS-影响-DOM" class="headerlink" title="JS 影响 DOM"></a>JS 影响 DOM</h4><p>内嵌式：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>agoni<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="javascript"></span><br><span class="javascript">      <span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]</span><br><span class="javascript">      div1.innerText = <span class="hljs-string">&#x27;AgoniLay&#x27;</span></span><br><span class="javascript">    </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>lay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>在遇到 <code>script</code> 标签之前，所有的解析流程不变，但是当解析到 <code>script</code> 标签时，渲染引擎会判断到这是一段内嵌脚本，此时 HTML 解析器就会暂停 DOM 的解析（因为 JS 中可能会修改当前已经生成的 DOM 结构），JavaScript 引擎介入，并执行 <code>script</code> 标签中的脚本，在执行脚本完成之后，脚本中所修改的 DOM 节点相关内容就已经改变，此时 HTML 解析器恢复解析过程，继续解析后续节点，直至生成最终的 DOM 树。</p>
<p>引入式：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// demo.js</span><br><span class="hljs-keyword">let</span> div1 = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">&#x27;div&#x27;</span>)[<span class="hljs-number">0</span>]<br>div1.innerText = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>agoni<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>lay<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>整个执行流程和上面是一样的，但在执行 JavaScript 之前需要先下载这段 JavaScript 代码；</p>
<blockquote>
<p>下载过程会阻塞 DOM 解析，且通常会十分耗时，Chorme 浏览器做了许多优化，如预解析操作：当渲染引擎收到字节流后，会首先开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p>
</blockquote>
<p>可以采用一些相关的策略来规避：</p>
<ul>
<li><p>使用 CDN 来加速 JavaScript 文件的加载；</p>
</li>
<li><p>压缩 JavaScript 文件的体积；</p>
</li>
<li><p>若某 JavaScript 文件中未进行操作 DOM 相关代码，可以通过 <code>async</code> 或 <code>defer</code> 标记来将该 JavaScript 脚本设置为异步加载：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">async</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>或<br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">defer</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text/javascript&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;demo.js&#x27;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
<blockquote>
<p>async 和 defer 的差异：</p>
<ul>
<li>使用 async 标记的脚本文件一旦加载完成，会立即执行；</li>
<li>而使用 defer 标记的脚本文件，需要在 <code>DOMContentLoaded</code> 事件之前执行。</li>
</ul>
</blockquote>
<p>CSSOM 相关：</p>
<p>JavaScript 脚本中出现了操作 CSSOM 的代码，在执行 JavaScript 之前需要先解析 JavaScript 语句之上所有的 CSS 样式，若代码引用了外部的 CSS 文件，那么还需再执行 JavaScript 代码之前等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象后，才能执行脚本。</p>
<p>JavaScript 引擎再解析 JavaScript 之前是不知道其中是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时不管是否操纵了 CSSOM，都会执行 CSS 文件下载、解析操作，再执行 JavaScript 脚本。</p>
<blockquote>
<p>CSSOM 有关文章：<a target="_blank" rel="noopener" href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html">https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html</a></p>
</blockquote>
<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h3><h4 id="同源页面间通信"><a href="#同源页面间通信" class="headerlink" title="同源页面间通信"></a>同源页面间通信</h4><h5 id="Broadcast-Channel"><a href="#Broadcast-Channel" class="headerlink" title="Broadcast Channel"></a>Broadcast Channel</h5><p>Broadcast Channel 可以创建一个用于广播的通信频道。当所有的页面都监听同一频道的消息时，其中的某一个页面通过它发送的消息就会被其他所有页面收到。</p>
<p>创建：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> bc = <span class="hljs-keyword">new</span> BroadcastChannel(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br></code></pre></div></td></tr></table></figure>

<p>监听：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Broadcast Channel] receive message:&#x27;</span>, text)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>广播：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.postMessage(myData)<br></code></pre></div></td></tr></table></figure>

<h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Sercvice Worker 可以共享，将 Service Worker 作为消息的处理中心即可实现广播效果。</p>
<blockquote>
<p>Service Worker 是 <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903588691443725">PWA</a> 中的核心技术之一。</p>
</blockquote>
<p>首先在页面中注册 Service Worker：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.register(<span class="hljs-string">&#x27;../util.sw.js&#x27;</span>).then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Service Worker 注册成功&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p><code>../util.sw.js</code> 是对应的 Service Worker 脚本，Service Worker 本身并不具备广播通信的功能，需要进行改造：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ../util.sw.js Service Worker 逻辑</span><br>self.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;service worker receive message&#x27;</span>, e.data)<br>  e.waitUntil(<br>    self.clients.matchAll().then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">clients</span>) </span>&#123;<br>      <span class="hljs-keyword">if</span> (!clients || clients.length === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span><br>      &#125;<br>      clients.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">client</span>) </span>&#123;<br>        client.postMessage(e.data)<br>      &#125;)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>在 Service Worker 中监听了 <code>message</code> 事件，获取页面发送的信息。然后通过 <code>self.clients.matchAll()</code> 获取当前注册了该 Service Worker 的所有页面，通过调用每个 Client 的 <code>postMessage</code> 方法，向页面发送信息，从而达到广播效果。</p>
<p>然后再页面中监听 Service Worker 发送来的消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Service Worker] receive message:&#x27;</span>, text)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>需要同步消息时，调用 Service Worker 的 <code>postMessage</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">navigator.serviceWorker.controller.postMessage(mydata)<br></code></pre></div></td></tr></table></figure>

<h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><p>当 LocalStorage 变化时，会触发 <code>storage</code> 事件，利用这个特性，可以在发送消息时把消息写入到某个 LocalStorage 中，然后在各个页面内监听 storage 事件即可收到通知。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;storage&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (e.key === <span class="hljs-string">&#x27;AgoniLay&#x27;</span>) &#123;<br>    <span class="hljs-keyword">const</span> data = <span class="hljs-built_in">JSON</span>.parse(e.newValue)<br>    <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Storage I] receive message:&#x27;</span>, text)<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>发送消息使用 <code>setItem</code> 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">mydata.st = +(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>)<br><span class="hljs-built_in">window</span>.localStorage.setItem(<span class="hljs-string">&#x27;AgoniLay&#x27;</span>, <span class="hljs-built_in">JSON</span>.stringify(mydata))<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意：此处在 <code>mydata</code> 上添加了一个取当前毫秒时间戳的 <code>st</code> 属性，这是因为 <code>storage</code> 事件只有在值真正发生改变时才会触发。设置 <code>st</code> 属性可以保证每次调用时一定会触发 <code>storage</code> 事件。</p>
</blockquote>
<h5 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h5><p>普通的 Worker 之间是独立运行、数据互不相通的；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p>
<p>首先，在页面中启动一个 Shared Worker：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> shareWorker = <span class="hljs-keyword">new</span> SharedWorker(<span class="hljs-string">&#x27;../util.shared.js&#x27;</span>, <span class="hljs-string">&#x27;AgoniLay&#x27;</span>)<br><span class="hljs-comment">// 第二个参数是名称，可以留空</span><br></code></pre></div></td></tr></table></figure>

<p>然后在该 Shared Worker 中支持 get 与 post 形式的消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ../util.shared.js: Shared Worker 代码</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-literal">null</span><br>self.addEventListener(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> port = e.ports[<span class="hljs-number">0</span>]<br>  port.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>    <span class="hljs-comment">// get 指令返回存储的消息数据</span><br>    <span class="hljs-keyword">if</span> (event.data.get) &#123;<br>      data &amp;&amp; port.postMessage(data)<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 否则存储该消息数据</span><br>      data = event.data<br>    &#125;<br>  &#125;)<br>  port.start()<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听时返回：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定时轮询，发送 get 指令的消息</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  sharedWorker.port.postMessage(&#123; <span class="hljs-attr">get</span>: <span class="hljs-literal">true</span> &#125;)<br>&#125;, <span class="hljs-number">1000</span>)<br><br><span class="hljs-comment">// 监听 get 消息的返回数据</span><br>sharedWorker.port.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; -- tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Shared Worker] receive message:&#x27;</span>, text)<br>&#125;, <span class="hljs-literal">false</span>)<br>sharedWorker.port.start()<br></code></pre></div></td></tr></table></figure>

<p>需要跨页面通信时，给 Shared Worker <code>postMessage</code> 即可：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">sharedWorker.port.postMessage(mydata)<br></code></pre></div></td></tr></table></figure>

<h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><p>还可以使用一些“全局性”的存储方案，例如 IndexedDB 或 cookie，思路与 Shared Worker 类似：消息发送方将消息存至 IndexedDB 中，接收方则通过轮询去获取最新的消息。</p>
<h5 id="window-open-window-opener"><a href="#window-open-window-opener" class="headerlink" title="window.open + window.opener"></a>window.open + window.opener</h5><p>当使用 <code>window.open</code> 打开页面时，方法会返回一个被打开页面 <code>window</code> 的引用，而在未指定 <code>noopener</code> 时，被打开的页面可以通过 <code>window.opener</code> 获取到打开它的页面的引用 —— 通过这种方式可以在页面之间建立联系（一种树形结构）。</p>
<p>首先，把 <code>window.open</code> 打开的页面的 <code>window</code> 对象收集起来：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> childWins = []<br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> win = <span class="hljs-built_in">window</span>.open(<span class="hljs-string">&#x27;./some/sample&#x27;</span>)<br>  childWins.push(win)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>发送消息时，同时通知它打开的页面和打开它的页面：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 过滤掉已经关闭的窗口</span><br>childWins = childWins.filter(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.closed)<br><span class="hljs-keyword">if</span> (childWins.length &gt; <span class="hljs-number">0</span>) &#123;<br>  mydata.fromOpenner = <span class="hljs-literal">false</span><br>  childWins.forEach(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.postMessage(mydata))<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.opener &amp;&amp; !<span class="hljs-built_in">window</span>.opener.closed) &#123;<br>  mydata.fromOpenner = <span class="hljs-literal">true</span><br>	<span class="hljs-built_in">window</span>.opener.postMessage(mydata)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>收到消息的页面再进行传递：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> data = e.data<br>  <span class="hljs-keyword">const</span> text = <span class="hljs-string">&#x27;[receive] &#x27;</span> + data.msg + <span class="hljs-string">&#x27; —— tab &#x27;</span> + data.from<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;[Cross-document Messaging] receive message:&#x27;</span>, text)<br>  <span class="hljs-comment">// 避免消息回传</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.opener &amp;&amp; !<span class="hljs-built_in">window</span>.opener.closed &amp;&amp; data.fromOpenner) &#123;<br>    <span class="hljs-built_in">window</span>.opener.postMessage(data)<br>  &#125;<br>  <span class="hljs-comment">// 过滤掉已经关闭的窗口</span><br>  childWins = childWins.filter(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> !w.closed)<br>  <span class="hljs-comment">// 避免消息回传</span><br>  <span class="hljs-keyword">if</span> (childWins &amp;&amp; !data.fromOpenner) &#123;<br>    childWins.forEach(<span class="hljs-function"><span class="hljs-params">w</span> =&gt;</span> w.postMessage(data))<br>  &#125;<br>&#125;)<br><br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在这种 “口口相传” 模式下，如果页面不是通过在另一个页面内的 <code>window.open</code> 打开的（比如直接在地址栏输入，或从其他网站链接过来），就无法做到消息传递。</p>
</blockquote>
<h4 id="非同源页面之间的通信"><a href="#非同源页面之间的通信" class="headerlink" title="非同源页面之间的通信"></a>非同源页面之间的通信</h4><p>可以使用一个用户不可见的 iframe 作为桥。由于 iframe 与父页面间可以通过指定 <code>origin</code> 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe，这些 iframe 由于使用的是同一个 url，因此属于同源页面，就可以使用同源页面间的通信方式。</p>
<p>首先，在页面中监听 iframe 发来的消息，做相应的业务处理：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-comment">// ... do something</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>当页面要与其他同源或非同源页面通信时，会先给 iframe 发送消息：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.frame[<span class="hljs-number">0</span>].window.postMessage(mydata, <span class="hljs-string">&#x27;...&#x27;</span>) <span class="hljs-comment">// ... 可以设为 ifrmae 的 URL</span><br></code></pre></div></td></tr></table></figure>

<p>iframe 收到消息后，使用某种同源跨页面通信技术在所有 iframe 间同步消息，其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">bc.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>  <span class="hljs-built_in">window</span>.parent.postMessage(e.data, <span class="hljs-string">&#x27;*&#x27;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>



<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>同源跨页面通信的方式：</p>
<ul>
<li>前三种都是 “广播模式”，一个页面将消息通知给一个“中央站”，在由“中央站”通知给各个页面，中央站可以是一个 Broadcast Cannel 实例，一个 Service Worker 或是 LocalStorage；</li>
<li>Shared Worker 和 IndexedDB、cookie 等是 “共享存储+长轮询” 模式，但有时不一定非要长轮询；</li>
<li>最后 window.open + window.opener 是 “口口相传” 模式。</li>
<li>还有一种做法是通过 WebSocket 这类的 “<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903618043183111">服务器推</a>” 技术来进行同步，好比将 “中央站” 从前端移动到了后端，还有：Comet / SSE 等。</li>
</ul>
<p>非同源页面则可以通过嵌入同源 iframe 作为 “桥”，将非同源页面通信转化为同源页面通信。</p>
<h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol>
<li>当浏览器地址变化时，切换页面；</li>
<li>当点击前进后退时，网页内容跟随变化；</li>
<li>刷新浏览器，网页加载当前路由对应内容。</li>
</ol>
<h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul>
<li>hash 模式：监听浏览器地址 hash 值变化，执行相对应的 js 切换网页</li>
<li>history 模式：利用 history API 实现 url 地址改变，网页内容改变</li>
</ul>
<p>最大的区别在于 hash 模式下会在浏览器地址后面增加 <code>#</code> 号，而 history 可以自定义地址</p>
<h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>使用 <code>window.location.hash</code> 属性及窗口的 <code>onhashchange</code> 事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换界面：</p>
<ol>
<li>hash 指的是地址中 <code>#</code> 号以及之后的字符，也称为散列值；hash 也称作锚点，本身用来做页面跳转定位：<ul>
<li>如 <code>http:/localhost/index.html#abc</code> 中的 <code>#abc</code> 就是 hash；</li>
</ul>
</li>
<li>散列值是不会随请求发送到服务器端的，所以改变 hash 不会重新加载页面；</li>
<li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置 hash 值；</li>
<li>location.hash 值的变化会直接反映到浏览器地址栏。</li>
</ol>
<p>触发 <code>hashchange</code> 事件的情况：</p>
<ul>
<li>浏览器地址栏散列值变化（包括浏览器的前进、后退）会触发 <code>window.location.hash</code> 值的变化，从而触发 <code>onhashchange</code> 事件；</li>
<li>当浏览器地址栏中 URL 包含 hash 时访问，浏览器发送请求至服务器，请求完毕后设置散列值，从而触发 <code>onhashchange</code> 事件；</li>
<li>只改变浏览器地址栏 URL 的哈希部分后访问，不会发送请求至服务器，只是设置散列值，并触发 <code>onhashchange</code> 事件；</li>
<li>html 中 a 标签的 href 属性可以设置为页面的元素 ID 如 <code>#top</code>，当点击该 a 链接时页面跳转至该 id 元素所在区域，同时浏览器自动设置 <code>window.location.hash</code> 属性，地址栏中的哈希值也会发生改变，并触发 <code>onhashchange</code> 事件。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 设置 URL 的 hash，会在当前 url 后加上 #abc</span><br><span class="hljs-built_in">window</span>.location.hash = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-keyword">let</span> hash = <span class="hljs-built_in">window</span>.location.hash <span class="hljs-comment">// &#x27;#abc&#x27;</span><br><br><span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// 监听 hash 变化，点击浏览器的前进后退会触发</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><ul>
<li><code>window.history</code> 属性指向 History 对象，表示当前窗口的浏览历史。发生改变时只会改变页面的路径，不会刷新页面；</li>
<li>History 对象保存了当前窗口访问过的所有页面地址。通过 <code>history.length</code> 可以得到当前窗口一共访问过几个网址；</li>
<li>浏览器不允许脚本读取这些地址，但是允许在地址之间导航；</li>
<li>浏览器工具栏的前进后退其实就是对 History 对象进行操作。</li>
</ul>
<h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>History.length</code>：当前窗口访问过的网址数量</p>
<p><code>History.state</code>：History 堆栈最上层的状态值，通常为 <code>undefined</code>（未设置）</p>
<h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键；</p>
<p><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键；</p>
<p><code>History.go()</code>：接受一个整数为参数，以当前网页为基准，移动到参数指定的网页：</p>
<ul>
<li>为 1，则相当于 <code>history.forward()</code>；为 -1，则相当于 <code>history.back()</code>；</li>
<li>若为 0，相当于刷新页面；</li>
<li>若超出实际存在的网址范围，该方法无效果。</li>
</ul>
<blockquote>
<p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
</blockquote>
<p><code>History.pushState(object, title, url)</code>：在历史中添加一条记录：</p>
<ul>
<li><code>object</code>：一个对象，通过 pushState 方法可以将该对象内容传递到新页面中，若不需要此对象则可以填 <code>null</code>；</li>
<li><code>title</code>：指标题，几乎没有浏览器支持该参数，传空即可；</li>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。不指定则默认为当前的路径，若设置了一个跨域网址，则会报错。</li>
</ul>
<blockquote>
<p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。</p>
</blockquote>
<p><code>History.replaceState(object)</code>：修改 History 对象的当前记录，用法与 pushState() 方法一样；</p>
<p><code>popstate</code> 事件：每当 history 对象出现变化时，就会触发 popstae 事件：</p>
<ul>
<li>调用 pushState() 或 replaceState() 方法，并不会触发该事件；</li>
<li>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 <code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code> 方法时才会触发；</li>
<li>该事件只针对同一个文档，如果浏览器历史的切换导致加载不同的文档，也不会触发</li>
<li>页面第一次加载的时候，浏览器不会触发 <code>popstate</code> 事件</li>
</ul>
<h3 id="事件模型-1"><a href="#事件模型-1" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件的本质是程序各个组成之间的一种通信方式，也是异步编程的一种体现。</p>
<h4 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h4><p>DOM 的事件操作（监听和触发）都定义在 <code>EventTarget</code> 接口，所有的节点对象都部署了这个接口，其他一些需要事件通信的了浏览器内置对象（如：<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p>
<p><code>EventTarget</code> 接口主要提供三个实例方法：</p>
<ul>
<li><code>addEventListener</code>：绑定事件的监听函数；</li>
<li><code>removeEventListener</code>：移除事件的监听函数；</li>
<li><code>dispatchEvent</code>：触发事件</li>
</ul>
<h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p><code>EventTarget.addEventListener()</code> 用于在当前节点或对象上，定义一个特定事件的监听函数，一旦事件发生就会执行监听函数，无返回值。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">target.addEventListener(type, listener[, useCapture])<br><span class="hljs-comment">// 例子：</span><br><span class="hljs-keyword">var</span> button = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>)<br>button.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hello AgoniLay!&#x27;</span>)<br>&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：事件名称，大小写敏感；</li>
<li><code>listener</code>：监听函数，也可以是一个具有 <code>handleEvent</code> 方法的对象；</li>
<li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为 <code>false</code>，参数可选；第三个参数也可以是一个属性配置对象：<ul>
<li>capture：布尔值，表示该事件是否在捕获阶段触发监听函数；</li>
<li>once：布尔值，表示监听函数是否只触发一次，随后就自动移除；</li>
<li>passive：布尔值，表示监听函数不会调用事件的 preventDefault 方法，若监听函数调用了浏览器将会忽略并在控制台输出警告</li>
</ul>
</li>
</ul>
<p>注意：</p>
<ol>
<li><p><code>addEventListener</code> 方法可以为针对当前对象的同一个事件添加多个不同的监听函数，并按顺序触发（先添加先触发）；</p>
</li>
<li><p>如果为同一个事件多次添加同一个监听函数，则该函数只会执行一次，其余的将会自动被去除；</p>
</li>
<li><p>可以用匿名函数包装监听函数达到向监听函数传参的目的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">print</span>(<span class="hljs-params">x</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(x)<br>&#125;<br><span class="hljs-keyword">var</span> el = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;div1&#x27;</span>)<br>el.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; print(<span class="hljs-string">&#x27;Hello AgoniLay!&#x27;</span>) &#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure></li>
<li><p>监听函数内部的 <code>this</code> 指向当前事件所在的对象。</p>
</li>
</ol>
<h5 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h5><p><code>EventTarget.removeEventListener()</code> 方法用来移除 <code>addEventListener</code> 方法添加的事件监听函数，无返回值。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener, <span class="hljs-literal">false</span>)<br>div.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, listener, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<p>参数和 <code>addEventListener</code> 方法的参数完全一致，<code>removeEventListener</code> 方法移除的监听函数必须是 <code>addEventListener</code> 方法添加的那个监听函数，且在同一个元素节点，且第三个参数也必须完全相同，例如：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">div.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;&#125;, <span class="hljs-literal">false</span>)<br>div.removeEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<p>上面代码中，<code>removeEventListener</code> 方法无效，因为监听函数不是同一个函数</p>
<h5 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent()"></a>dispatchEvent()</h5><p><code>EventTarget.dispatchEvent()</code> 方法在当前节点上触发指定事件，从而触发监听函数的执行。返回值为一个布尔值：只要有一个监听函数调用了 <code>Event.preventDefault()</code>，则返回值为 <code>false</code>，反而为 <code>true</code>。</p>
<p>语法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">target.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, hello, <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">var</span> event = <span class="hljs-keyword">new</span> Event(<span class="hljs-string">&#x27;click&#x27;</span>)<br>target.dispatchEvent(event)<br></code></pre></div></td></tr></table></figure>

<ul>
<li>参数是一个 <code>Event</code> 对象的实例。</li>
</ul>
<h4 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h4><h5 id="HTML-on-属性"><a href="#HTML-on-属性" class="headerlink" title="HTML on 属性"></a>HTML on 属性</h5><p>HTML 语言允许在元素的属性中直接定义某些事件的监听代码：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">&quot;console.log(&#x27;触发点击事件&#x27;)&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>元素的事件监听属性，都是 <code>on + 事件名</code>，这些属性的值时将会执行的代码，而不是一个函数，且只会在冒泡阶段触发：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 正确 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething()&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 错误 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">onload</span>=<span class="hljs-string">&quot;doSomething&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>直接设置 on 属性与通过元素节点的 <code>setAttribute</code> 方法设置 on 属性的效果是一样的：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">el.setAttribute(<span class="hljs-string">&#x27;onclick&#x27;</span>, <span class="hljs-string">&#x27;doSomething()&#x27;</span>)<br><span class="hljs-comment">// 等同于</span><br><span class="hljs-comment">// &lt;Element onclick=&quot;doSomething()&quot; /&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h5><p>元素节点对象的事件属性，同样可以指定监听函数，也是只在冒泡阶段触发：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = doSomething<br><br>div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;触发点击事件&#x27;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>与 HTML on 属性的区别在于，此方式的值是函数本身或函数名，而不是可执行代码。</p>
<h5 id="addEventListener-1"><a href="#addEventListener-1" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p>所有 DOM 节点实例都有 <code>addEventListener</code> 方法，用来为该节点定义事件的监听函数。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>第一种 HTML 的 on 属性：违反了 HTML 与 JavaScript 代码相分离的原则，不利于代码分工，不推荐使用；</p>
<p>第二种 元素节点的事件属性缺点在于同一个事件只能定义一个监听函数，因此也不推荐使用；</p>
<p>故推荐使用第三种 <code>EventTarget.addEventListener</code> 方法：</p>
<ol>
<li>同一个事件可以添加多个监听函数；</li>
<li>能够指定在那个阶段（冒泡或捕获）触发监听函数；</li>
<li>除了 DOM 节点，其他一些对象也有此接口。</li>
</ol>
<h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p>当一个事件发生后，会在子元素和父元素之间传播，分为三个阶段：</p>
<ol>
<li>从 window 对象传导到目标节点（从上层传到底层），称为 “捕获阶段”（capture phase）；</li>
<li>在目标节点上触发，称为 “目标阶段”（target phase）；</li>
<li>从目标节点传导回 window 对象（从底层传回上层），称为 “冒泡阶段”（bubbling phase）</li>
</ol>
<p>事件传播的最上层对象是 <code>window</code>，接着依次是 <code>document</code>、<code>html</code>（<code>document.documentElement</code>）和 <code>body</code>（<code>document.body</code>）。</p>
<h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>由于事件会在冒泡阶段向上传播到父节点，所以可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，也就是事件的代理（delegation）。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;ul&#x27;</span>)<br>ul.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (event.target.tagName.toLowerCase() === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-comment">// do something</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>如果希望事件到某个节点为止不在传播，可以使用事件对象的 <code>stopPropagation</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 事件传播到 p 元素后，就不再向下传播</span><br>p.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  event.stopPropagation()<br>&#125;, <span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 事件冒泡到 p 元素后，就不再向上冒泡</span><br>p.addEventListener(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  event.stopPropagation()<br>&#125;, <span class="hljs-literal">false</span>)<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>注意：<code>stopPropagation</code> 方法只会阻止事件的传播，不会阻止该事件触发已到达节点的其他监听函数，若需要彻底阻止事件传播，包括不再触发后面所有的监听函数，可以使用 <code>stopImmediatePropagation</code> 方法。</p>
</blockquote>
<h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>事件发生后会产生一个事件对象作为参数传给监听函数。</p>
<p>浏览器原生提供一个 <code>Event</code> 对象，所有的事件都继承了 <code>Event.prototype</code> 对象。</p>
<p><code>Event</code> 对象本身就是一个构造函数，可以用来生成新的实例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ev = <span class="hljs-keyword">new</span> Event(<br>  <span class="hljs-string">&#x27;look&#x27;</span>,<br>  &#123;<br>    <span class="hljs-string">&#x27;bubbles&#x27;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 如若不显式指定为 true，则默认捕获</span><br>    <span class="hljs-string">&#x27;cancelable&#x27;</span>: <span class="hljs-literal">false</span><br>  &#125;<br>)<br><span class="hljs-built_in">document</span>.dispatchEvent(ev) <span class="hljs-comment">//触发该事件</span><br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：字符串，表示事件的名称；</li>
<li><code>options</code>：对象，表示事件对象的配置：<ul>
<li>bubbles：布尔值，可选，默认为 false，表示事件对象是否冒泡；</li>
<li>cancelable：布尔值，可选，默认为 false，表示事件是否可以被取消（<code>Event.parentDefault()</code>）</li>
</ul>
</li>
</ul>
<p><strong>实例属性</strong>：</p>
<ul>
<li><code>Event.bubbles</code>属性返回一个布尔值，表示当前事件是否会冒泡，只读，默认不冒泡；</li>
<li><code>Event.eventPhase</code> 属性返回一个整数变量，表示事件当前所处的阶段，只读：<ul>
<li>0：事件当前未发生</li>
<li>1：事件目前处于捕获阶段，从祖先节点向目标节点的传播过程中</li>
<li>2：事件到达目标节点，即 Event.target 指向的节点</li>
<li>3：事件处于冒泡阶段，从目标节点向祖先节点的反向传播过程中</li>
</ul>
</li>
<li><code>Event.cancelable</code> 属性返回一个布尔值，表示事件是否可以取消，只读：<ul>
<li>大多数浏览器的原生事件是可以取消的；</li>
<li>除非显式声明，<code>Event</code> 构造函数生成的事件，默认是不可以取消的；</li>
<li>此属性为 true 时，调用 <code>Event.preventDefault()</code> 就可以取消这个使劲按，阻止浏览器对该事件的默认行为；为 false 则没有效果；</li>
</ul>
</li>
<li><code>Event.cancelBubble</code> 属性返回一个布尔值，若设为 <code>true</code>，则相当于执行 <code>Event.stopPropagation()</code>，可以阻止事件的传播；</li>
<li><code>Event.defaultPrevented</code> 属性返回一个布尔值，表示该事件是否调用过 <code>Event.preventDefault</code> 方法，只读；</li>
<li><code>Event.currentTarget</code> 属性返回事件当前所在的节点，即当前执行的监听函数所绑定的节点；</li>
<li><code>Event.target</code> 属性返回原始触发事件的那个节点，即事件最初发生的节点；</li>
<li><code>Event.type</code> 属性返回一个字符串，表示事件类型，只读；</li>
<li><code>Event.timeStamp</code> 属性返回一个毫秒时间戳，表示事件发生的时间，相对于网页加载成功开始计算的：<ul>
<li>可能是整数，也可能是小数（高精度时间戳），取决于浏览器的设置；</li>
</ul>
</li>
<li><code>Event.isTrusted</code> 属性返回一个布尔值，表示该事件是否由真实的用户行为产生；</li>
<li><code>Event.detail</code> 属性只有浏览器的 UI 事件才有，返回一个数值，表示事件的某种信息：<ul>
<li>比如 <code>click</code> 和 <code>dbclick</code> 事件中，指鼠标按下的次数；</li>
<li>鼠标滚轮事件中，表示滚轮滚动的距离（正向和负向，总为 3 的倍数）；</li>
</ul>
</li>
</ul>
<p><strong>实例方法</strong>：</p>
<ul>
<li><code>Event.preventDefault()</code> 方法取消浏览器对当前事件的默认行为，前提是事件对象的 <code>cancelable</code> 属性为 <code>true</code>；</li>
<li><code>Event.stopPropagation()</code> 方法阻止事件再 DOM 中的继续传播，不包括在当前节点上的其他事件监听函数；</li>
<li><code>Event.stopImmediatePropagation()</code> 方法阻止同一个事件的其他监听函数继续调用，阻止事件的传播，比 <code>Event.stopPropagation()</code> 更彻底；</li>
<li><code>Event.composedPath()</code> 方法返回一个数组，成员是事件的最底层节点和一次冒泡经过的所有上层节点；</li>
</ul>
<h4 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h4><p><code>CustomEvent</code> 接口用于生成自定义的事件实例。如果需要在触发事件的同时，传入指定的数据，可以使用 CustomEvent 接口生成的自定义事件对象。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">new</span> CustomEvent(type, options)<br></code></pre></div></td></tr></table></figure>

<ul>
<li><code>type</code>：字符串，表示事件的名字，必须；</li>
<li><code>options</code>：事件的配置对象，可选：<ul>
<li>除了接受 Event 事件的配置属性，只有一个 detail 属性表示事件的附带数据，默认为 <code>null</code>；</li>
</ul>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> myEvent = <span class="hljs-keyword">new</span> CustomEvent(<span class="hljs-string">&#x27;myevent&#x27;</span>, &#123;<br>  <span class="hljs-attr">detail</span>: &#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">bubbles</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">cancelable</span>: <span class="hljs-literal">false</span><br>&#125;)<br><br>el.addEventListener(<span class="hljs-string">&#x27;myevent&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">event</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello &#x27;</span> + event.detail.name)<br>&#125;)<br><br>el.dispatchEvent(myEvent)<br></code></pre></div></td></tr></table></figure>

<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器的缓存机制就是 HTTP 缓存机制，是根据 HTTP 报文的缓存标识进行的。</p>
<h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>HTTP 报文分为两种：</p>
<ul>
<li><p>HTTP 请求(Request)报文，报文格式为：<code>请求行 - HTTP头(通用信息头、请求头、实体头) - 请求报文主体(POST才有)</code>；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000219031.png" srcset="/img/three2.gif" lazyload class title="HTTP请求报文"></li>
<li><p>HTTP 响应(Response)报文，报文格式为：<code>状态行 - HTTP头(通用信息头、响应头、实体头) - 响应报文主体</code>；</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000341773.png" srcset="/img/three2.gif" lazyload class title="HTTP响应报文"></li>
</ul>
<blockquote>
<p>注意：</p>
<ol>
<li>通用信息头指的是请求和响应报文都支持的头域，包括：<ul>
<li>Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</li>
</ul>
</li>
<li>实体头则是实体信息的实体头域，分别为：<ul>
<li>Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header.</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h4><p>浏览器与服务器通信的方式为应答模式：浏览器发起 HTTP 请求 - 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果，会根据请求报文中 HTTP 头中的缓存标识决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301001224385.png" srcset="/img/three2.gif" lazyload class title="浏览器第一次发起HTTP请求">

<ul>
<li>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果以及缓存标识；</li>
<li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li>
</ul>
<h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p>
<ol>
<li>不存在缓存结果和缓存标识，强制缓存失败，直接向服务器发起请求（与首次一致）；</li>
<li>存在该缓存结果和缓存标识，但结果已失效，强制缓存失败，使用协商缓存；</li>
<li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li>
</ol>
<p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 <code>Cache-Control</code> 的优先级更高。</p>
<h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><code>Expires</code> 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，再次请求时间小于该缓存值，直接使用缓存结果。</p>
<blockquote>
<p>到了 HTTP/1.1，<code>Expires</code> 已经被 <code>Cache-Control</code> 替代，原因：Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，但如果两者因某些原因发生误差，那么强制缓存则会直接失效。</p>
</blockquote>
<h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在 HTTP/1.1 中，<code>Cache-Control</code> 是最重要的规则，主要用于控制网页缓存，主要取值为：</p>
<ul>
<li><code>public</code>：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>
<li><code>private</code>：所有内容只有客户端可以缓存，默认为此值</li>
<li><code>no-cache</code>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>
<li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>
<li><code>max-age=xxx (xxx is numeric)</code>：缓存内容将在 xxx 秒后失效</li>
</ul>
<p>例如：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301003329024.png" srcset="/img/three2.gif" lazyload class title="expires 和 cache-control">

<ul>
<li>HTTP 响应报文中 expires 的时间值是一个绝对值，而 cache-control 的值是相对值；</li>
<li>无法确定客户端是否与服务端的时间同步的情况下，cache-control 比 expires 是更好的选择。</li>
</ul>


<p>上图中，状态码为灰色的请求代表使用了强制缓存，对应的 Size 值代表了则代表该缓存存放的位置，分别为：</p>
<ul>
<li><code>from memory cache</code>：内存缓存，代表使用内存中的缓存，先读取此项；</li>
<li><code>from disk cache</code>：硬盘缓存，代表使用硬盘中的缓存。</li>
</ul>
<p>硬盘缓存与内存缓存：</p>
<ol>
<li>内存缓存具有快速读取和时效性（进程关闭则内存清空）两个特点；</li>
<li>硬盘缓存是直接将缓存写入硬盘文件中，读取时需进行 I/O 操作，读取复杂，速度比内存缓存慢。</li>
</ol>
<p>在浏览器中，会在 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时只需直接从内存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache）。</p>
<h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要由两种情况：</p>
<ol>
<li><p>协商缓存生效，返回 304：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005038564.png" srcset="/img/three2.gif" lazyload class width="304"></li>
<li><p>协商缓存失效，返回 200 和请求结果：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005110494.png" srcset="/img/three2.gif" lazyload class title="协商缓存"></li>
</ol>
<p>同样，协商缓存的标识也是字啊响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified</code> / <code>If-Modified-Since</code> 和 <code>Etag</code> / <code>If-None-Match</code>，后者优先级更高。</p>
<h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code> 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间；</p>
<p><code>If-Modified-Since</code> 是客户端再次发起该请求时，携带上次请求返回的 <code>Last-Modified</code> 值，以此做对比决定是 200 还是 304；</p>
<h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p><code>Etag</code> 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）；</p>
<p><code>If-None-Match</code> 是客户端再次发起该请求时，携带上次请求返回的唯一标识 <code>Etag</code> 值，以此做判断。</p>
<h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>强制缓存优先于协商缓存进行，若协商缓存生效则直接使用缓存，若不生效则进行协商缓存（<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>），协商缓存由服务器决定是否使用缓存，若协商缓存失效，代表该请求的缓存失效，则重新获取请求结果再存入浏览器缓存中；生效则返回 304，继续使用缓存：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301010337843.png" srcset="/img/three2.gif" lazyload class title="浏览器缓存策略">

<h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><h4 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h4><p>CPU 与 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能。</p>
<ul>
<li>CPU（Center Processing Unit）：CPU 是计算机的大脑，负责处理各种不同的任务，过去大多数 CPU 是单芯片的，核心被安置再同一个芯片上，较新的 CPU 可以支持多核心，运算能力大大加强；</li>
<li>GPU（Graphics Processing Unit）：GPU 更擅长利用多核心同时处理单一的任务，最初被用来处理图像，这也是 GPU 可以更快、更流畅的渲染页面内容。</li>
</ul>
<h4 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h4><p>可以把计算机自下而上分为三层：硬件（Machine Hardware）、操作系统（Operating System）和应用（Application），有了操作系统的存在，上层应用可以使用操作系统提供的能力使用硬件资源而不是直接访问硬件资源。</p>
<h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>一个进程（Process）是应用正在运行的程序，而线程（Thread）是进程中更小的一部分；</p>
<ul>
<li>当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作；</li>
<li>操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，私有内存就会被释放；</li>
<li>还有比进程更小的存在：协程，是运行再线程中更小的单位。</li>
</ul>
<h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以使用 IPC（Inter Process Communcation），好处在于当一个进程给另一个进程发消息而并没有回应时，并不影响当前进程继续工作。</p>
<h4 id="浏览器架构-1"><a href="#浏览器架构-1" class="headerlink" title="浏览器架构"></a>浏览器架构</h4><p>借助进程和线程，浏览器可以被设计成但 单进程-多线程架构，或者利用 IPC 实现 多进程-多线程架构。</p>
<p>Chrome 就是采用了多进程架构，浏览器进程作为 Chrome 最核心的进程管理这其他进程，而 Renderer 则负责渲染不同的站点：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301160300551.png" srcset="/img/three2.gif" lazyload class title="Chorme 多进程">

<h5 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h5><ul>
<li><strong>浏览器进程（Browser process）</strong>：负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责不可见的功能，如网络请求、文件访问等，也负责其他进程的调度；</li>
<li><strong>渲染进程（Renderer process）</strong>：负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理；</li>
<li><strong>插件进程（Plugin process）</strong>：负责为浏览器提供各种额外的插件功能，如 flash；</li>
<li><strong>GPU 进程（GPU process）</strong>：负责提供成像的功能；</li>
<li>还有负责扩展进程、工具进程等的其他进程</li>
</ul>
<h5 id="多进程架构好处"><a href="#多进程架构好处" class="headerlink" title="多进程架构好处"></a>多进程架构好处</h5><p>当访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当在 Chrome 中打开多个页签同时访问三个站点时，如果其中一个无响应，同样可以正常使用其他的页签：</p>
<p>因为 Chrome 为每个站点均创建了独立的渲染进程，专门负责当前站点的渲染工作；若所有页面运行在同一个进程中，当有一个页面无响应时，则其他页面均无法使用。</p>
<p>借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。</p>
<p>但同样由于进程独享自己的私有内存，为了节省内存，Chrome 限制了最大进程数，取决于硬件的能力，且使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。</p>
<h5 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h5><p>Chrome 将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式实现，以解决多进程架构中的问题。</p>
<p>当 Chrome 运行在硬件强大的计算机上时，会将一个服务以多个进程的方式实现，提供稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p>
<h5 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h5><p>浏览器进程负责处理除了渲染外的大部分工作，包括以下线程：</p>
<ul>
<li>UI 线程负责绘制工具栏中的按钮、地址栏等；</li>
<li>网络线程负责从网络中获取数据；</li>
<li>存储线程负责文件等功能。</li>
</ul>
<h4 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h4><ol>
<li><p>输入处理：当在地址栏输入时，UI 线程会先判断输入的内容是要搜索的内容还是要访问一个站点；</p>
</li>
<li><p>访问开始：按下回车或开始访问时，UI 线程将借助网络线程访问站点资源，浏览器页签的标题会出现加载中的图标，同时网络线程会根据适当的网络协议，如 DNS lookup 和 TLS 为此次请求建立连接，当服务器返回给浏览器重定向请求时，网络线程会通知 UI 线程需要重定向，然后会以新的地址开始请求资源；</p>
</li>
<li><p>处理响应数据：当网络线程收到来自服务器的数据时，会试图从数据中的前面一些字节得到数据的类型（<code>Content-Type</code>），以试图了解数据的格式：</p>
<ul>
<li>当返回的数据类型时 HTML 时，会将数据传递给渲染进程做进一步的渲染工作；</li>
<li>数据类型时 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或下载工作；</li>
</ul>
<blockquote>
<p>注意：在开始渲染之前，网络进程会先检查数据的安全性，这也是浏览器保证安全的地方，如果返回的数据来自一些恶意的站点，网络进程会显示警告的页面；与此同时，Cross Origin Read Blocking（CORB）策略也会确保跨域的敏感数据不会被传递给渲染进程。</p>
</blockquote>
</li>
<li><p>渲染过程：当所有的检查结束后，网络进程确信浏览器可以访问该站点时，网络进程通知 UI 线程数据准备完毕，UI 线程根据当前站点找到一个渲染进程完成接下来的渲染工作；</p>
<blockquote>
<p>在访问开始时，UI 线程将请求地址传递给网络线程时，UI 线程就已经知道了要访问的站点，就会开始查找或启动一个渲染进程，这与网络进程下载数据是同时的，会减少渲染所需要的时间，提高效率。</p>
</blockquote>
</li>
<li><p>提交访问：浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过为了进程继续获取数据；此时地址栏显示出表明安全的图标，同时显示出站点的信息，访问历史中也会加入当前的站点信息；</p>
</li>
<li><p>加载完毕：当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面；当渲染进程结束渲染工作（页面及其中所有子页面结束加载，也就是 onLoad 事件触发后发送），会给浏览器进程发送消息，UI 线程则会隐藏页签标题上的加载图标，表明页面加载完毕。</p>
</li>
</ol>
<p>当输入另外一个地址时，浏览器进程会重复上面的过程，但在开始新的访问前，会确认当前站点是否关心 <code>beforeunload</code> 事件：可以提醒用户是否要访问新的站点或者关闭此页签，若用户拒绝则新的访问或关闭会被阻止。</p>
<p>如果一次访问是从一个渲染进程中发起的，如用户点击一个链接或者运行 JavaScript 代码 <code>location = &#39;xxx&#39;</code> 时，渲染进程会首先检查 <code>beforeunload</code>，然后再执行和浏览器进程初始化访问同样的操作。</p>
<h4 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h4><p><code>Service worker</code> 是一种可以 web 开发者控制缓存的技术，它的代码是运行在渲染进程中的。</p>
<p>当访问开始时，网络线程会根据域名检查是否有 Service worker 会处理当前地址的请求，若有，则 UI 线程会找到对应的渲染进程去执行 Service worker 的代码，而 Service worker 可以让开发者决定此请求从本地缓存还是从网络中获取数据。</p>
<h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>渲染进程负责所有发生在浏览器页签中的事情，在一个渲染进程中，主线程负责解析、编译或运行代码等工作，当使用 Worker 时，Worker 线程会负责运行一部分代码。合成线程和关栅线程也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。</p>
<p>渲染进程最重要的工作就是将 HTML、CSS 和 JavaScript 代码转换为一个可以与用户产生交互的页面。</p>
<h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><h5 id="DOM-的创建"><a href="#DOM-的创建" class="headerlink" title="DOM 的创建"></a>DOM 的创建</h5><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受 HTML 数据，主线程开始解析 HTML 文本字符串，并将其转化成 <strong>Document Object Model（DOM）</strong>。</p>
<p>当预加载扫描（Preload Scanner）在分析器分析 HTML 的过程中发现了类似 img 或 link 这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p>
<p>当 HTML 分析器发现 <code>script</code> 标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 JavaScript 代码（因为其中可能会操作 DOM 或 CSSOM）。</p>
<blockquote>
<p>如果 JavaScript 代码并不需要改变 DOM，可以为 <code>script</code> 标签添加 <code>async</code> 或 <code>defer</code> 属性从而达到异步加载这些资源而不阻塞 HTML 转化过程的目的。</p>
</blockquote>
<h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><p>主线程会解析样式并决定每个 DOM 元素的样式（Style calculation）。</p>
<h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>完成样式计算后，渲染进程已经知道了 DOM 的结构和每个节点的样式，还需要确定节点在页面上的位置。</p>
<p>布局（layout）时为元素指定几何信息的过程，主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的<strong>布局树（Layout tree）</strong>：</p>
<ul>
<li>布局树的结构与 DOM 树的结构非常类似，但只包含将会在页面中显示的元素；</li>
<li>元素样式设置为 <code>display: none</code> 时，不会出现在布局树中，但样式设置为 <code>visibility: hidden</code> 的元素会出现在布局树中；</li>
<li>一个包含内容的伪元素不会出现在 DOM 树中，但会出现在布局树中。</li>
</ul>
<h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><p>有了 DOM、样式和布局之后，还需要知道 <strong>绘制（Paint）</strong>的顺序（层叠上下文相关）。</p>
<p>在这个阶段，主线程遍历布局树并创建绘制记录：一系列由绘制步骤组成的流程。</p>
<h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><p>完成了上述的步骤，浏览器已经知道了文档结构、每一个元素的样式、几何信息以及绘制的顺序，将这些信息转化成屏幕上像素的过程叫做 <strong>光栅化</strong>，光栅化时图形学的范畴。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/9ed512afc63c664458faf1bd42247cc0.gif" srcset="/img/three2.gif" lazyload class title="传统做法">

<p>传统的做法是将可视区域的内容进行光栅化，随着用户滚动页面，不断的光栅化更多的区域；现代的浏览器有着更为复杂的过程：<strong>合成</strong>：</p>
<p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层来合成新的帧，动画则可以通过移动层来实现：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/ae1b6d19e8aeb45841f04bbfa72760dd.gif" srcset="/img/three2.gif" lazyload class title="合成">

<p><strong>层（Layer）</strong>：</p>
<p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对于开发者来说，当某一部分需要使用独立的层来渲染，可以使用 <code>will-change</code> 让浏览器创建层。</p>
<p><strong>栅格线程</strong>和<strong>合成线程</strong>：</p>
<p>当布局树和绘制顺序确定后，主线程会将这些信息提交给合成线程，合成线程会光栅化每个层。一个层包含的内容可能是一个完整的页面，也可能只是页面的一部分，所以合成线程将层拆分成许多块，并发送给栅格线程，栅格线程光栅化这些块并将它们存储再 GPU 缓存中。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/371b5fa654d59f0c8ccb2f4f0658c20a.png" srcset="/img/three2.gif" lazyload class title="栅格化">

<p>合成线程可以决定栅格线程光栅化的优先级，以此来确保用户能看到的部分优先光栅化；一个层也会包含多种块以支持类似缩放这样的功能，当块被光栅化后，合成线程会使用 <code>draw quads</code> 收集这些信息并创建合成帧（Compositor frame）。</p>
<ul>
<li><strong>Draw quads</strong>：存储在缓存中，包换类似块位置的信息，用于描述如何使用块合成页面；</li>
<li><strong>Compositor frame</strong>：用于存储表现页面一帧中包含哪些 Draw quads 的集合。</li>
</ul>
<p>然后一个合成帧被提交给浏览器进程，这时如果浏览器 UI 有变化，或者插件的 UI 有变化时，另一个合成帧就会被创建出来。每当有交互发生时，合成线程就会创建更多的合成帧然后通过 GPU 将新的部分渲染出来。</p>
<p>好处在于：其独立于主线程，合成线程不需要等待样式计算和 JavaScript 代码的运行。</p>
<h4 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h4><p>对于浏览器来说，输入事件意味着所有用户动作（如鼠标滚轮滚动或屏幕触摸等）。</p>
<p>当用户与页面发生交互时，浏览器进程首先接受到事件，但只关心事件发生位置，将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会找到事件发生的元素并触发事件监听器。</p>
<p><strong>合成线程对事件的处理</strong>：</p>
<p>当页面被合成线程合成过，合成线程会标记那些有事件监听的区域，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理；如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p>
<p><strong>事件代理引发的问题</strong>：</p>
<p>在事件代理中，利用事件冒泡，可以在目标元素的上层元素中监听事件，可以更高效的监听事件：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.target === area) &#123;<br>    event.preventDefault()<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>但从浏览器角度来看，此时整个页面都会标记成 “慢滚动” 区域，意味着页面中某些部分并不需要事件监听，但合成线程依然需要在每次交互发生后等待主线程处理事件，造成效率降低。</p>
<p>解决：可以在事件代理时传入 <code>passive: true</code> 选项参数，告诉渲染进程，依然需要将事件发送给主线程处理，但不需要等待：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-params">event</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (event.target === area) &#123;<br>    event.preventDefault()<br>  &#125;<br>&#125;, &#123; <span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span> &#125;)<br></code></pre></div></td></tr></table></figure>

<p><strong>浏览器动画事件优化</strong>：</p>
<p>类似 <code>touchmove</code> 这样的事件每秒向主线程发送 120 次可能会造成主程序执行时间过长而影响性能：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/6101cc07df5e744efb2a88208f1d1e52.png" srcset="/img/three2.gif" lazyload class title="img">

<p>为了减少发送给主线程的事件数量，Chrome 合并了连续的事件，类似：<code>wheel</code>、<code>mousewheel</code>、<code>mousemove</code>、<code>pointermove</code>、<code>touchmove</code> 等这样的事件会被延迟到下一次 <code>requestAnimationFrame</code> 前触发：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/53005a8114a736ca071a333946664ffd.png" srcset="/img/three2.gif" lazyload class title="img">

<p>而其他任何的离散时间，类似：<code>keydown</code>、<code>keyup</code>、<code>mouseup</code>、<code>touchstart</code>、<code>touchend</code> 等都会立即被发送给主线程处理。</p>
<h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><p>目前主流的浏览器有五个：Internet Explorer、FireFox、Safari、Chrome 和 Opera。</p>
<h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示请求的网络资源，一般为 HTML 文档，也可以是 PDF、图片或其他的类型，资源的位置由用户使用 UPI（统一资源标示符）指定。</p>
<h4 id="高层结构"><a href="#高层结构" class="headerlink" title="高层结构"></a>高层结构</h4><p>浏览器的主要组件为：</p>
<ul>
<li>用户界面：包括地址栏、前进/后退按钮、书签菜单等，除了浏览器主窗口显示的页面外，其他显示的各个部分都属于用户界面；</li>
<li>浏览器引擎：在用户界面和呈现引擎之间传送指令；</li>
<li>呈现引擎：负责显示请求的内容；</li>
<li>网络：用于网络调用，比如 HTTP 请求；</li>
<li>用户界面后端：用于绘制基本的窗口小部件，不如组合框和窗口；</li>
<li>JavaScript 解释器：用于解析和执行 JavaScript 代码；</li>
<li>数据存储：持久层</li>
</ul>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/layers.png" srcset="/img/three2.gif" lazyload class title="浏览器的主要组件">



<p>呈现引擎主流程（webkit 引擎）：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webkitflow.png" srcset="/img/three2.gif" lazyload class title="webkit 引擎">

<h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在硬件级别上，计算机内存由大量触发器组成，每个触发器包含几个晶导管，能够存储一个位；单个触发器可以通过唯一标识符寻址，可与进行读取与覆盖操作（可以把整个计算机内存看作是一个巨大的可读写的位数组）</p>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul>
<li>分配器：分配所需要的内存；</li>
<li>使用期：使用分配到的内存（读写）；</li>
<li>释放期：不需要时将其释放并归还</li>
</ul>
<p>内存分配 -&gt; 内存使用 -&gt; 内存释放</p>
<h5 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><blockquote>
<p>在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存；内存泄漏并非物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p>
</blockquote>
<p>如果内存不再需要时，没有经过生命周期的释放期，那么就存在内存泄漏。</p>
<p>简单来说：无用的内存还在占用，得不到释放和归还。</p>
<h4 id="JS-内存管理机制"><a href="#JS-内存管理机制" class="headerlink" title="JS 内存管理机制"></a>JS 内存管理机制</h4><p>JavaScript 是在创建变量时自动进行了分配内存，并在不使用它们时自动释放（垃圾回收）。</p>
<p>JS 不需要程序员手动分配内存，绝大部分情况下也不需要手动释放内存，只需要直接使用内存即可</p>
<ul>
<li>内存分配：JS 定义变量就会自动分配内存，无需了解过深；</li>
<li>内存使用：使用值的过程实际上是对分配内存进行读取和写入的操作；</li>
<li>内存回收：一般称为垃圾内存回收（Garbage Collection）。</li>
</ul>
<p>内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，那么就需要手动清理内存。</p>
<h5 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h5><p>最初级的垃圾收集算法，把 “对象是否不在需要” 简化定义为 “对象有没有其他对象引用到它”；如果没有引用指向该对象，对象将被垃圾回收机制回收。</p>
<p>ES6 中把引用分为强引用和弱引用：</p>
<ul>
<li>强引用才会有引用计数叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（前提是标记清除还没有执行）；</li>
<li>弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。</li>
</ul>
<h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p>当变量进入执行环境时标记为 “进入环境”，当变量离开执行环境时则标记为 “离开环境”；被标记为 “进入环境” 的变量不能被回收，因为正在被使用；标记为 “离开环境” 的变量则可以被回收。</p>
<p>环境可以理解为作用域，但全局作用域的变量只有在页面关闭时才会销毁。</p>
<h4 id="泄漏场景"><a href="#泄漏场景" class="headerlink" title="泄漏场景"></a>泄漏场景</h4><p><strong>意外的全局变量</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 在全局作用域下定义</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params">number</span>) </span>&#123;<br>  <span class="hljs-comment">// count 相当于 window.count = 2</span><br>  count = <span class="hljs-number">2</span><br>  <span class="hljs-keyword">return</span> count + number<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的计时器</strong>：</p>
<p>组件销毁时，<code>setInterval</code> 还是在运行的，里面涉及的内存都是无法回收的，需要在组件销毁时清除计时器：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      this.refreshInterval = setInterval(() =&gt; &#123;<br>        // 轮询获取数据<br>        this.refresh()<br>      &#125;, 2000)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      clearInterval(this.refreshInterval)<br>    &#125;,<br>    methods: &#123;<br>      refresh () &#123;<br>        // 获取一些数据<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的事件监听器</strong>：</p>
<p>组件销毁时，一些事件（如 resize）依然会在监听中，其涉及的内存无法回收，需要在组件销毁时移除相关的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  export default &#123;<br>    mounted () &#123;<br>      this.resize = () =&gt; &#123;<br>        // 这里做一些操作<br>      &#125;<br>      window.addEventListener(&#x27;resize&#x27;, this.resize)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      window.removeEventListener(&#x27;resize&#x27;, this.resize)<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的 ES6 Set</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>()<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span> &#125;<br>map.add(obj)<br><br><span class="hljs-comment">// 若不进行 delete 操作，则 obj 相关内存无法清除</span><br>map.delete(obj)<br>obj = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p>也可以使用 WeakSet，WeakSet 的成员是弱引用，内存回收不会考虑此引用是否存在。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">WeakSet</span>()<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span> &#125;<br>map.add(obj)<br><br>obj = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的 ES6 Map 键名</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> map = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>()<br><span class="hljs-keyword">let</span> key = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(<span class="hljs-number">5</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<br>map.set(key, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment">// 与 Set 同理，不进行 delete 操作则无法进行回收</span><br>map.delete(key)<br>key = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<p>也可以使用 WeakMap，与 WeakSet 同理。</p>
<p><strong>被遗忘的订阅发布事件监听器</strong>：</p>
<p>当组件销毁时，自定义事件依然在监听中，其涉及到的内存无法回收，需要在组件销毁时移除相关的事件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vue">&lt;template&gt;<br>	&lt;div @click=&quot;onClick&quot; /&gt;<br>&lt;/template&gt;<br><br>&lt;script&gt;<br>  import customEvent from &#x27;event&#x27;<br><br>  export default &#123;<br>    mounted () &#123;<br>      customEvent.on(&#x27;test&#x27;, data =&gt; &#123;<br>        // 一些逻辑<br>        console.log(data)<br>      &#125;)<br>    &#125;,<br>    beforeDestroy () &#123;<br>      customEvent.off(&#x27;test&#x27;)<br>    &#125;,<br>    methods: &#123;<br>      onClick () &#123;<br>        customEvent.emit(&#x27;test&#x27;, &#123; type: &#x27;click&#x27; &#125;)<br>      &#125;<br>    &#125;<br>  &#125;<br>&lt;/script&gt;<br></code></pre></div></td></tr></table></figure>

<p><strong>被遗忘的闭包</strong>：</p>
<p>闭包在带来便利的同时，有可能会带来内存的泄漏：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">closure</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> name = <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> name<br>      .split(<span class="hljs-string">&#x27;&#x27;</span>)<br>      .reverse()<br>      .join(<span class="hljs-string">&#x27;&#x27;</span>)<br>  &#125;<br>&#125;<br><span class="hljs-keyword">const</span> reverseName = closure()<br><span class="hljs-comment">// name 不是必须的，但还是占用了内存，也无法被回收</span><br></code></pre></div></td></tr></table></figure>

<p><strong>脱离 DOM 的引用</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.elements = &#123;<br>      <span class="hljs-attr">button</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#button&#x27;</span>),<br>      <span class="hljs-attr">div</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#div&#x27;</span>),<br>      <span class="hljs-attr">span</span>: <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">&#x27;#span&#x27;</span>)<br>    &#125;<br>  &#125;<br>  removeButton () &#123;<br>    <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-built_in">this</span>.elements.button)<br>    <span class="hljs-comment">// 需要手动释放内存</span><br>    <span class="hljs-comment">// this.elements.button = null</span><br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> a = <span class="hljs-keyword">new</span> Test()<br>a.removeButton()<br></code></pre></div></td></tr></table></figure>

<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能指标-RAIL"><a href="#性能指标-RAIL" class="headerlink" title="性能指标 RAIL"></a>性能指标 RAIL</h3><p>RAIL 是一个以用户为中心的性能模型，把用户的体验拆分成几个关键点，并制定了每一个的性能指标：</p>
<ul>
<li>Response</li>
<li>Animation</li>
<li>Idle</li>
<li>Load</li>
</ul>
<h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>用户的输入到响应的时间不超过 100ms，事件处理最好在 50ms 内完成。</p>
<p>优化方案：</p>
<ul>
<li>考虑到 idle task 的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations 等，不适用于 drag 和 scroll；</li>
<li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞；</li>
<li>超过 50ms 的响应，一定要提供反馈，比如倒计时、进度百分比等。</li>
</ul>
<blockquote>
<p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。</p>

</blockquote>
<h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>产生每一帧的时间不要超过 10ms，旨在视觉上的平滑，用户对于帧率变化感知很敏感。</p>
<p>优化方案：</p>
<ul>
<li>在一些高压节点上，比如动画，不要去挑战 CPU，尽可能的少做事；</li>
<li>在渲染性能上，针对不同的动画做一些特定优化。</li>
</ul>
<blockquote>
<p>动画不只是 UI 的视觉效果，以下行为都属于：</p>
<ul>
<li>视觉动画：如渐隐渐显，tweens，loading 等；</li>
<li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离；</li>
<li>拖拽，缩放等等。</li>
</ul>
</blockquote>
<h4 id="Idle"><a href="#Idle" class="headerlink" title="Idle"></a>Idle</h4><p>最大化空闲时间，以增大 50ms 内响应用户输入的几率。</p>
<p>优化方案：</p>
<ul>
<li>用空闲时间来完成一些延后的工作：<ul>
<li>比如先加载页面可见的部分，然后利用空闲时间加载剩余部分（可以使用 <code>requestIdleCallback API</code>）；</li>
</ul>
</li>
<li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间；</li>
<li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务。</li>
</ul>
<h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><p>根据设备网络等条件优化加载速度，在一个中配 3G 网络手机打开时间不超过 5s，对于第二次打开不超过 2s。</p>
<p>优化方案：</p>
<ul>
<li>在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 <a href="https://link.juejin.cn/?target=https://www.webpagetest.org/easy">WebPageTest</a> 来测试；</li>
<li>要考虑到丢包或者网络波动等情况导致比预期加载慢；</li>
<li>禁用渲染阻塞的资源，延后加载；</li>
<li>可以采用 lazy load，code-splitting 等其他优化手段，是第一次加载的资源更少</li>
</ul>
<h4 id="分析工具使用"><a href="#分析工具使用" class="headerlink" title="分析工具使用"></a>分析工具使用</h4><ul>
<li><a href="https://link.juejin.cn/?target=https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li>
<li><a href="https://link.juejin.cn/?target=https://web.dev/measure/">Lighthouse</a></li>
<li><a href="https://link.juejin.cn/?target=https://webpagetest.org/easy">WebPageTest</a></li>
</ul>
<h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul>
<li>聚焦用户</li>
<li>100ms 内响应用户的输入</li>
<li>10ms 内产生 1 帧，在滚动或者动画执行时</li>
<li>最大化主线程的空闲时间</li>
<li>5s 内让网页变得可交互</li>
</ul>
<h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><blockquote>
<p>资源来自文档：<a target="_blank" rel="noopener" href="https://alienzhou.com/projects/fe-performance-journey/">https://alienzhou.com/projects/fe-performance-journey/</a></p>
<p>雅虎性能优化35条规则：<a target="_blank" rel="noopener" href="https://github.com/creeperyang/blog/issues/1">https://github.com/creeperyang/blog/issues/1</a></p>
</blockquote>
<p>性能优化广义上包含前端优化和后端优化。后端优化的关注点更多是在增加资源利用率、降低资源成本以及提高稳定性上；前端性能优化会更直接与用户的体验相关。</p>
<h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="本地数据存储"><a href="#本地数据存储" class="headerlink" title="本地数据存储"></a>本地数据存储</h5><p>对于一些请求，可以直接在业务代码侧进行缓存处理，缓存方式包括：<code>localStorage</code>、<code>sessionStorage</code>、<code>indexedDB</code>；从前端视角看，这是一种本地存储，但从整个系统的维度来看，其实也是缓存链条上重要的一环，对于一些特殊的、轻量级的业务数据，可以考虑使用本次存储作为缓存。</p>
<h5 id="内存缓存-Memory"><a href="#内存缓存-Memory" class="headerlink" title="内存缓存(Memory)"></a>内存缓存(Memory)</h5><p>当访问一个页面及其子资源时，又是会出现一个资源被使用多次，如图标。由于该资源已经在内存中，再次请求没有必要，浏览器内存则是最近、最快的响应场所。</p>
<h5 id="Cache-API"><a href="#Cache-API" class="headerlink" title="Cache API"></a>Cache API</h5><p>在未命中内存缓存后，发送请求前会来到 Cache API 中，通常是和 Service Worker 配合使用的。</p>
<p>Service Worker 是一个后台运行的独立线程，可以在代码中启用：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;serviceWorker&#x27;</span> <span class="hljs-keyword">in</span> navigator) &#123;<br>  navigator.serviceWorker.register(<span class="hljs-string">&#x27;./sw.js&#x27;</span>).then(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-comment">// 注册成功</span><br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>之后处理一些 Service Worker 的生命周期时间，在其中设置请求拦截：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// sw.js</span><br>self.addEventListener(<span class="hljs-string">&#x27;fetch&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 如果有 cache 则直接返回，否则通过 fetch 请求</span><br>  e.respondWith(<br>    caches.match(e.request).then(<span class="hljs-function"><span class="hljs-params">cache</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">return</span> cache || fetch(e.request)<br>    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(err)<br>      <span class="hljs-keyword">return</span> fetch(e.request)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>以上会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。</p>
<p>与内存缓存不同，Cache API 的缓存可认为是 “永久性” 的。关闭浏览器或离开页面之后，下次访问仍可以使用。</p>
<blockquote>
<p>Service Worker 相关文章：<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903588691443725">https://juejin.cn/post/6844903588691443725</a></p>
</blockquote>
<h5 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h5><p>如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了，HTTP 缓存大致可以分为强缓存与协商缓存：</p>
<p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，一般就是来源于硬盘，也就是在 Chrome Devtools 上经常看到的 <code>disk cache</code>。</p>
<p>相关的响应头是 <code>Expires</code> 和 <code>Cache-Control</code>，具体可以查看之前的浏览器缓存策略。</p>
<h5 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h5><p>这是最后一个缓存检查，是 HTTP/2 的 Push 功能带来的，在你请求一个资源的同时，服务器可以为你推送一些其他相关的资源，以此来避免浏览器收到响应、解析到相应位置是才会请求所带来的延后。</p>
<p>HTTP/2 Push Cache 是比较底层的网络特性，与其他的缓存有很多不同：</p>
<ul>
<li>在匹配上时，并不会再额外检查资源是否过期；</li>
<li>存活时间很短（Chrome 中约为 5min 左右）；</li>
<li>只会被使用一次；</li>
<li>HTTP/2 链接断开将直接失效。</li>
</ul>
<h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><h5 id="避免多余重定向"><a href="#避免多余重定向" class="headerlink" title="避免多余重定向"></a>避免多余重定向</h5><p>重定向是一个比较常用的技术手段，分为 301 永久重定向和 302 临时重定向，需要贴合语义使用。</p>
<p>每次重定向都是由请求耗时的，要避免多余的重定向。</p>
<h5 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h5><p>访问远程服务时，不会直接使用服务的出口 IP，而是使用域名，所以请求需要进行域名解析。</p>
<p>DNS 服务本省是一个树状层级结构，其解析是一个递归与迭代的过程（github.com）：</p>
<ol>
<li>先检查本地 hosts 文件中是否有映射，有则使用；</li>
<li>查找本地 DNS 缓存，有则返回；</li>
<li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li>
<li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li>
<li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li>
<li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li>
</ol>
<p>要知道：</p>
<ul>
<li>DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li>
<li>在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的：</li>
</ul>
<p>DNS Prefetch 就是浏览器提供的一个 API，是 Resource Hint 的一部分，会预解析网页中可能之后会访问的域名。</p>
<h5 id="预先建立连接"><a href="#预先建立连接" class="headerlink" title="预先建立连接"></a>预先建立连接</h5><p>建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，都将会导致连接的耗时。</p>
<p>可以使用 Preconnect 告诉浏览器：之后有些资源会用到某个源（origin），然后预先建立连接。</p>
<p>根据规范，使用 Preconnect 时，浏览器做了如下处理：</p>
<ol>
<li>解析 Preconnect 的 url；</li>
<li>根据当前 link 元素中的属性进行 cors 的设置；</li>
<li>默认先将 credential 设为 true，如果 cors 位 Anonymous 并且存在跨域，则将 credential 设置为 false，随后进行连接。</li>
</ol>
<p>使用 preconnect 只需要将 <code>rel</code> 属性设为 <code>preconnect</code> 即可：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//agonilay.top&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 也可以设置 crossorigin --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preconnect&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//agonilay.top&quot;</span> <span class="hljs-attr">corssorigin</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h5><p>当实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p>
<p>对于静态资源，可以考虑通过 CDN 来降低时延。</p>
<blockquote>
<p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p>
</blockquote>
<p>发送请求的流程：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302172517397.png" srcset="/img/three2.gif" lazyload class title="发送请求流程">

<h4 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h4><p>主要针对于 NodeJS 讨论</p>
<h5 id="使用流进行响应"><a href="#使用流进行响应" class="headerlink" title="使用流进行响应"></a>使用流进行响应</h5><p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p>
<h5 id="业务聚合"><a href="#业务聚合" class="headerlink" title="业务聚合"></a>业务聚合</h5><p>使用 NodeJS 的 BFF 层来进行后端服务的聚合。</p>
<h5 id="避免代码问题"><a href="#避免代码问题" class="headerlink" title="避免代码问题"></a>避免代码问题</h5><ul>
<li><code>async</code> <code>await</code> 的不当使用导致并行请求被串行化了；</li>
<li>频繁地 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 大对象；</li>
<li>正则表达式的灾难性回溯；</li>
<li>闭包导致的内存泄漏；</li>
<li>CPU 密集型任务导致事件循环 delay 严重；</li>
<li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源。</li>
</ul>
<h4 id="页面解析与处理"><a href="#页面解析与处理" class="headerlink" title="页面解析与处理"></a>页面解析与处理</h4><p>此阶段浏览器需要处理的包括：</p>
<ul>
<li>页面 DOM 的解析；</li>
<li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li>
<li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li>
</ul>
<h5 id="注意资源在页面文档中的位置"><a href="#注意资源在页面文档中的位置" class="headerlink" title="注意资源在页面文档中的位置"></a>注意资源在页面文档中的位置</h5><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又会阻塞 JavaScript 的执行。</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302173153721.png" srcset="/img/three2.gif" lazyload class title="image-20220302173153721">

<p>所以这就是推荐把 CSS 样式表放在 <code>&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code>&lt;body&gt;</code> 的最后（即页面的尾部）的原因。</p>
<h5 id="使用-defer-和-async"><a href="#使用-defer-和-async" class="headerlink" title="使用 defer 和 async"></a>使用 defer 和 async</h5><p>可以使用 <code>defer</code> 或 <code>async</code> 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302173717303.png" srcset="/img/three2.gif" lazyload class title="image-20220302173717303">

<p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 <code>async</code>，例如统计脚本、监控脚本、广告脚本等，这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 <code>async</code> 可以有效避免这些非核心功能的加载影响页面解析速度。</p>
<h5 id="页面文档压缩"><a href="#页面文档压缩" class="headerlink" title="页面文档压缩"></a>页面文档压缩</h5><p>HTML 的文档大小也会极大影响响应体下载的时间，一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。</p>
<h4 id="页面静态资源"><a href="#页面静态资源" class="headerlink" title="页面静态资源"></a>页面静态资源</h4><h5 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h5><ol>
<li>减少不必要的请求：</li>
</ol>
<p>核心是尽量减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。</p>
<p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。</p>
<p>所以要减少不必要的请求：</p>
<ul>
<li>对于不需要使用的内容，不要请求；</li>
<li>对于可以延迟加载的内容，在需要使用之前再加载；</li>
<li>对于可以合并的资源，可以进行资源合并。</li>
</ul>
<ol start="2">
<li>减少包体大小</li>
</ol>
<p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好：</p>
<ul>
<li>使用适合当前资源的压缩技术；</li>
<li>删除响应包体中无关紧要的内容。</li>
</ul>
<ol start="3">
<li>降低应用资源时的消耗</li>
</ol>
<p>在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题；另外像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。</p>
<ol start="4">
<li>利用缓存</li>
</ol>
<h5 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h5><ol>
<li>代码拆分与按需加载：</li>
</ol>
<p>在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载；</p>
<p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 <a target="_blank" rel="noopener" href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a> 来告诉 webpack 去做代码拆分；如果不使用 webpack 之类的构建工具，也可以选择一个 AMD 模块加载器（例如 <a target="_blank" rel="noopener" href="https://requirejs.org/">RequireJS</a>）来实现前端运行时上的异步依赖加载。</p>
<ol start="2">
<li>代码合并</li>
</ol>
<p>在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会把依赖打包到一起的；但当使用其他一些工具时，就要注意打包。例如使用 <a target="_blank" rel="noopener" href="https://fis.baidu.com/fis3/docs/pack.html">FIS3</a> 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并；又或者使用 Gulp 这样的工具，也需要注意进行打包。</p>
<ol start="3">
<li>代码压缩</li>
</ol>
<p>JavaScript 代码压缩比较常见的做法就是使用 <a target="_blank" rel="noopener" href="http://lisperator.net/uglifyjs/">UglifyJS</a> 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。</p>
<p>在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 <a target="_blank" rel="noopener" href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a> 这样的功能插件。</p>
<p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p>
<ol start="4">
<li>Tree Shaking</li>
</ol>
<p>其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。</p>
<ol start="5">
<li>优化 polyfill 的使用</li>
</ol>
<p>前端技术的一大特点就是需要考虑兼容性，而 polyfill 用于在非兼容浏览器上也能使用新特性的 API。</p>
<p>但 polyfill 的使用也增加了代码体积，可以通过 <a target="_blank" rel="noopener" href="https://github.com/browserslist/browserslist">browserslist</a> 来帮忙；</p>
<p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 <a target="_blank" rel="noopener" href="https://youtu.be/reztLS3vomE?t=1254">Differential Serving</a> 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;main.mjs&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nomodule</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;legacy.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>这样，在能够处理 <code>module</code> 属性的浏览器（具有很多新特性）上就只需加载 <code>main.mjs</code>（不包含 polyfill）；而在老式浏览器下，则会加载 <code>legacy.js</code>（包含 polyfill）。</p>
<ol start="6">
<li>webpack</li>
</ol>
<p>webpack 现在已经成为很多前端应用的构建工具，但其中的无用包也不容小觑。</p>
<ol start="7">
<li>JS 的解析耗时</li>
</ol>
<p>一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的；删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p>
<ol start="8">
<li>避免 Long Task</li>
</ol>
<p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑，如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p>
<ol start="9">
<li>框架的使用与否</li>
</ol>
<p>并不是说不要使用框架/类库，只是希望不要拘泥于某个思维定式</p>
<h5 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h5><ol>
<li><p>关键 CSS：CRP（Critical Rendering Path，关键渲染路径） 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS，识别出当前业务中的关键 CSS，优先下载与解析它，将会更好地降低延迟：将关键 CSS 的内容通过 <code>&lt;style&gt;</code> 标签内联到 <code>&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS（骨架屏就是此思路的一个延展）</p>
</li>
<li><p>按需加载</p>
</li>
<li><p>合并文件</p>
</li>
<li><p>慎用 <code>@import</code>：CSS 提供了一个 <code>@import</code> 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p>
</li>
<li><p>压缩文件以及选择合适的兼容性</p>
</li>
<li><p>简化选择器</p>
</li>
<li><p>避免使用昂贵的属性：</p>
<ul>
<li>border-radius</li>
<li>box-shadow</li>
<li>opacity</li>
<li>transform</li>
<li>filter</li>
<li>position: fixed</li>
</ul>
</li>
<li><p>使用先进的布局方式：使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。 flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局，但 flex 有兼容性的要求（对于 IE）</p>
</li>
<li><p>利用缓存</p>
</li>
</ol>
<h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><ol>
<li>优化请求数：<ul>
<li>雪碧图（Sprite）；</li>
<li>懒加载（尽量只加载用户正在浏览或者即将要浏览到的图片）：<ul>
<li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li>
<li>设置合理的占位图，避免图片加载后的页面“抖动”。</li>
<li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup</li>
</ul>
</li>
<li>CSS 中图片懒加载：使用 <code>background-url</code> 属性设置，如果未使用到具体的元素，浏览器并不会去下载；</li>
<li>内联 base64：将将图片转为 base64 字符串，并将其内联到页面中返回，缺点在于相比使用二进制体积会增大 33% 且会在页面请求中串行进行（常用于首屏加载 CRP 或者骨架图上的一些小图标）</li>
</ul>
</li>
<li>减少图片大小：<ul>
<li>使用合适的图片格式：<ol>
<li>WebP 格式：在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式；</li>
<li>SVG 应对矢量图：在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错；</li>
<li>使用 video 替代 GIF：通过静音(muted)的 video 来代替 GIF，相同的效果下，GIF 比视频(MPEG-4)大 5~20 倍；</li>
<li>渐进式 JPEG：基线 JPEG (baseline JPEG) 会从上往下逐步呈现，而 <a target="_blank" rel="noopener" href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式 JPEG (progressive JPEG)</a> 则会从模糊到逐渐清晰，使人的感受上会更加平滑，但渐进式的解码速度会稍慢；</li>
</ol>
</li>
<li>图片质量的权衡：图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression），处理图片压缩可以使用 <a target="_blank" rel="noopener" href="https://github.com/imagemin/imagemin">imagemin</a> 这样的工具；</li>
<li>使用合适的大小和分辨率；</li>
<li>删除冗余的图片信息：可以使用像 <a target="_blank" rel="noopener" href="https://imageoptim.com/versions">imageOptim</a> 这样的工具来移除隐私与非关键的元信息；</li>
<li>SVG 压缩：<a target="_blank" rel="noopener" href="https://github.com/svg/svgo">SVGGO</a> 是一个可以集成到构建流中的 NodeJS 工具，可以进行 SVG 的优化；</li>
</ul>
</li>
<li>缓存</li>
</ol>
<h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>有些时候，内置的字体并不能满足需求，一般会使用 <code>@font-face</code> 来加载字体文件：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Samplefont&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/static/samplefont.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>),<br>    	 <span class="hljs-built_in">url</span>(<span class="hljs-string">/static/samplefont.woff</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>问题在于：在字体加载期间，浏览器页面是默认不展示文本内容的，也就是 FOIT（Flash of Invisible），会带来糟糕的用户体验。</p>
<ol>
<li><p>font-display：可以在 <code>@font-face</code> 中设置 <code>font-display: swap</code>，让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，先会使用默认的字体样式展示文本，加载完毕后再将文本的字体样式进行替换：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Samplefont&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">/static/samplefont.woff2</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>),<br>    	 <span class="hljs-built_in">url</span>(<span class="hljs-string">/static/samplefont.woff</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff&#x27;</span>);<br>  <span class="hljs-attribute">font-display</span>: swap;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>font-display 的取值包括 <code>auto|block|swap|fallback|optional</code>，不过有兼容性问题</p>
</li>
<li><p>内联字体：将字体文件转为 base64 的字符串，设置到 <code>@font-face</code> 里的 <code>src</code> 属性上，避免异步加载字体时的 FOIT 或 FOUT：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@font-face</span> &#123;<br>  <span class="hljs-attribute">font-family</span>: <span class="hljs-string">&#x27;Samplefont&#x27;</span>;<br>  <span class="hljs-attribute">src</span>: <span class="hljs-built_in">url</span>(<span class="hljs-string">&#x27;data:application/x-font-woff;charset=utf-8;base64...&#x27;</span>) <span class="hljs-built_in">format</span>(<span class="hljs-string">&#x27;woff2&#x27;</span>);<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>局限性：在一个 <code>@font-face</code> 中只能加载一种字体类型，也会将本可以并行请求的数据量变为串行；</p>
</li>
<li><p>使用 CSS Font Loading API：兼容性欠佳，可以使用 <a target="_blank" rel="noopener" href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a> 库；</p>
</li>
<li><p>FOFT：在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p>
</li>
</ol>
<h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><ol>
<li><p>使用合适的视频格式：不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4，除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。<br>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，但兼容性也较差；</p>
</li>
<li><p>视频压缩：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://handbrake.fr/">HandBrake</a></li>
<li><a target="_blank" rel="noopener" href="https://www.freemake.com/free_video_converter/">Freemake</a></li>
<li><a target="_blank" rel="noopener" href="http://www.selur.de/">Hybrid</a></li>
<li><a target="_blank" rel="noopener" href="https://sourceforge.net/projects/megui/">MeGUI</a></li>
</ul>
</li>
<li><p>移除不必要的音轨信息：在不需要声音的情况下，将 <code>&lt;video&gt;</code> 设置为 <code>muted</code>；</p>
</li>
<li><p>使用流：尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术；</p>
<blockquote>
<p>使用 HLS 技术，会包含一个 <code>.m3u8</code> 的索引文件和一系列包含播放内容的 <code>.ts</code> 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p>
</blockquote>
</li>
<li><p>移除不必要的视频：比如在小屏幕上，可以通过媒体查询来避免下载视频：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-keyword">@media</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">650px</span>) &#123;<br>  <span class="hljs-selector-id">#hero-video</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li>
</ol>
<h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><h5 id="强制同步布局"><a href="#强制同步布局" class="headerlink" title="强制同步布局"></a>强制同步布局</h5><ul>
<li>尝试使用 RAF（<code>requestAnimationFrame API</code>） 避免强制同步布局，将布局查询的操作放在 <code>requestAnimationFrame</code> 中；</li>
<li>批量化操作：批量化是计算机程序优化中的重要手段之一，对于元素布局的查询操作，可以将这些操作批量化存储下来，等到下一次 <code>requestAnimationFrame</code> 触发时一起执行</li>
</ul>
<h5 id="长列表优化"><a href="#长列表优化" class="headerlink" title="长列表优化"></a>长列表优化</h5><ol>
<li>实现 Virtual List：Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能；</li>
<li>原生的 Virtual Scroller：不建议在生产环境使用；</li>
</ol>
<h5 id="避免-JS-运行时间过长"><a href="#避免-JS-运行时间过长" class="headerlink" title="避免 JS 运行时间过长"></a>避免 JS 运行时间过长</h5><p>屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。</p>
<ol>
<li>任务分解：长时间的运行会导致渲染阻塞，那么把任务拆成一个个持续时间更短的小任务，分散到各个帧中执行；也可以使用浏览器 API <code>requestIdleCallback</code> 在浏览器空闲时间执行注册的回调函数；</li>
<li>延迟执行：<ol>
<li>懒执行，当需要时才去计算；</li>
<li>延后执行，即利用 <code>setTimeout</code>、<code>requestIdleCallback</code> 这样的方法把计算放到后续的事件循环或空闲时刻。</li>
</ol>
</li>
<li>并行计算：可以使用 Web Worker 启用并行程序；</li>
</ol>
<h5 id="善用-Composite"><a href="#善用-Composite" class="headerlink" title="善用 Composite"></a>善用 Composite</h5><p>当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。</p>
<p>合成层在性能优化上的优点在于：</p>
<ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint。</li>
</ul>
<h5 id="滚动事件的性能优化"><a href="#滚动事件的性能优化" class="headerlink" title="滚动事件的性能优化"></a>滚动事件的性能优化</h5><ul>
<li><a target="_blank" rel="noopener" href="https://github.com/lessfish/underscore-analysis/issues/22">节流(underscore)</a></li>
<li><a target="_blank" rel="noopener" href="https://github.com/lessfish/underscore-analysis/issues/21">防抖(debounce)</a></li>
</ul>
<h5 id="Passive-event-listeners"><a href="#Passive-event-listeners" class="headerlink" title="Passive event listeners"></a>Passive event listeners</h5><p>浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件，当添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费时间执行完你的回调，然后根据结果来判断是否需要滚动页面，就会导致性能问题。</p>
<p>所以需要告诉浏览器默认行为没有被禁用，而不用确认监听函数，就需要使用 <a target="_blank" rel="noopener" href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md">Passive event listeners</a>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;touchstart&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) </span>&#123;<br>    <span class="hljs-comment">// do something</span><br>&#125;, &#123;<span class="hljs-attr">passive</span>: <span class="hljs-literal">true</span>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>在监听函数的第三个参数中传入 <code>&#123; passive: true &#125;</code> 即可。</p>
<h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。</p>
<h5 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h5><h6 id="Resource-Hints"><a href="#Resource-Hints" class="headerlink" title="Resource Hints"></a>Resource Hints</h6><p><a target="_blank" rel="noopener" href="https://www.w3.org/TR/resource-hints/">Resource Hints</a> 是一种预加载相关的标准，它告诉浏览器哪些源下的资源 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。</p>
<p>Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender，此外，还有一个与 Resource Hints 类似的 Preload：</p>
<ul>
<li><p>Prefetch：资源预获取，as 属性用于制定资源的类型：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prefetch&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/prefetch.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>Prerender：预获取并预执行：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;prerender&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;//sample.com/nextpage.html&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li>
<li><p>Preload：立刻进行预获取并将结果放在内存里，不会影响页面 parse 与 load 事件的触发，直到再次遇到该资源的使用标签时，才会执行：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;./nextpage.js&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;script&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure></li>
</ul>
<h6 id="基于-JS-的预加载"><a href="#基于-JS-的预加载" class="headerlink" title="基于 JS 的预加载"></a>基于 JS 的预加载</h6><p>可以使用一些 JavaScript 中的功能来“巧妙”地进行预加载。</p>
<p>例如图片：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> img = <span class="hljs-keyword">new</span> Image()<br>img.src = <span class="hljs-string">&#x27;/static/img/prefetch.jpg&#x27;</span><br></code></pre></div></td></tr></table></figure>

<p>上述代码会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。</p>
<p>对于 JavaScript 和 CSS 可以动态添加 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）</p>
<h5 id="视频预加载"><a href="#视频预加载" class="headerlink" title="视频预加载"></a>视频预加载</h5><h6 id="为视频添加-preload-属性"><a href="#为视频添加-preload-属性" class="headerlink" title="为视频添加 preload 属性"></a>为视频添加 preload 属性</h6><p>使用 <code>preload</code> 属性可以让浏览器预加载相应的内容：</p>
<ul>
<li>none：不预加载视频</li>
<li>meta：载入元数据（时长、尺寸、文字轨道）</li>
<li>auto：预加载整个视频</li>
</ul>
<p>还可以设置 <code>poster</code> 属性来规定视频下载时或用户点击播放按钮前播放器上显示的图像。</p>
<p>推荐的方式是设置 <code>poster</code> 与 <code>preload: meta</code>，为用户提供一定的播放预览信息的同时避免过多的预加载流量；</p>
<h6 id="使用-Preload-Link"><a href="#使用-Preload-Link" class="headerlink" title="使用 Preload Link"></a>使用 Preload Link</h6><p>可以使用：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;preload&quot;</span> <span class="hljs-attr">as</span>=<span class="hljs-string">&quot;video&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/static/sample.mp4&quot;</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>进行资源的预加载</p>
<h6 id="使用-JS-进行自定义的-Buffer-操作"><a href="#使用-JS-进行自定义的-Buffer-操作" class="headerlink" title="使用 JS 进行自定义的 Buffer 操作"></a>使用 JS 进行自定义的 Buffer 操作</h6><p>可以通过 HTTP <code>Range</code> 请求头来获取开始的一小段视频数据，然后使用 <code>MediaSource</code> API 来进行视频媒体数据的暂存与播放（具体代码查看：<a target="_blank" rel="noopener" href="https://alienzhou.com/projects/fe-performance-journey/7-preload/#_2-%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89">https://alienzhou.com/projects/fe-performance-journey/7-preload/#_2-%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD）</a></p>
<h5 id="预加载的策略"><a href="#预加载的策略" class="headerlink" title="预加载的策略"></a>预加载的策略</h5><p>预加载一般都会面临一些矛盾：</p>
<ul>
<li>预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；</li>
<li>预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。</li>
</ul>
<h6 id="quicklink"><a href="#quicklink" class="headerlink" title="quicklink"></a>quicklink</h6><p><a target="_blank" rel="noopener" href="https://github.com/GoogleChromeLabs/quicklink">quicklink</a> 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式；核心就是：当链接进入到视口后，会对其进行预加载。</p>
<h6 id="Guess-js"><a href="#Guess-js" class="headerlink" title="Guess.js"></a>Guess.js</h6><p><a target="_blank" rel="noopener" href="https://github.com/guess-js/guess">Guess.js</a> 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。</p>
<h3 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h3><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>在页面的生命周期中，网页生成时至少会 <strong>渲染</strong> 一次，在用户访问的过程中，还会不断触发 <strong>重排(reflow)</strong> 和 **重绘(repaint)**，而重绘和重排都会影响性能。</p>
<p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p>
<h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>当 DOM 的变化影响了元素的集合信息（位置、尺寸和大小），浏览器需要重新计算元素的几何属性，以安放在页面的正确位置，此过程叫重排（也叫回流），也就是重新生成布局，重新排列元素。</p>
<p>触发条件：</p>
<ul>
<li>页面初始渲染，开销最大的一次渲染</li>
<li>添加删除可见的 DOM 元素</li>
<li>改变元素位置</li>
<li>改变元素尺寸，如：边距、填充、边框、宽度和高度等</li>
<li>改变元素内容，如：文字数量、图片大小等</li>
<li>改变元素字体大小</li>
<li>改变浏览器窗口尺寸，如：resize 事件发生时</li>
<li>激活 CSS 伪类</li>
<li>设置 style 属性的值</li>
<li>查询某些属性或调用某些方法，如：offsetWidth、offsetHeight、getComputedStyle()、currentStyle() 等</li>
</ul>
<p>常见的引起重排的属性和方法：</p>
<ul>
<li>width、height、margin、padding</li>
<li>display、border-width、border、position</li>
<li>overflow、font-size、vertical-align、min-height</li>
<li>clientWidth、clientWidth、clientTop、clientLeft</li>
<li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li>
<li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li>
<li>scrollIntoView()、scrollTo()、getComputedStyle()、getBoundingClientRect()、scrollIntoViewIfNeeded()</li>
</ul>
<p>影响范围：</p>
<p>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围 DOM 重新排列：</p>
<ul>
<li>全局范围：从根节点 html 开始对整个渲染树进行重新布局</li>
<li>局部范围：对渲染树的某一部分或某一个渲染对象进行重新布局</li>
</ul>
<h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。</p>
<p>常见的引起重绘的属性：</p>
<ul>
<li>color、border-style、visibility、background</li>
<li>background-size、background-image、background-position、background-reqeat</li>
<li>outline-color、outline、outline-style、outline-width</li>
<li>text-decoration、border-radius、box-shadow</li>
</ul>
<h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>减小重排范围：</p>
<ul>
<li>尽可能在低层级的 DOM 节点上触发重排，而不是全局范围；</li>
<li>尽量不要使用 table 布局，很小的改动都会造成整个 table 的重新布局，在必须要使用的情况下可以设置 <code>table-layout: auto</code> 或者 <code>table-layout: fixed</code> 使 table 一行一行的渲染来限制 reflow 的影响范围；</li>
</ul>
<p>减少重排次数：</p>
<ul>
<li>不要频繁的操作样式，要修改类名而不是修改样式；</li>
<li>DOM 的多个读操作（或者写操作）应该放在一起，不要混杂着使用；</li>
<li>使 DOM 离线，也就是不在当前的 DOM 树上做修改：<ul>
<li>使用 <code>display: none</code>，元素将不在 DOM 树中，在其中的操作也不会触发重绘重排，之后通过 <code>display</code> 属性显示，可以达到减少重绘重排次数的目的；另外，<code>visibility: hidden</code> 的元素只会触发重绘；</li>
<li>通过 <code>documentFragment</code> 创建一个 DOM 碎片进行批量操作，再添加到文档中，这样只会触发一次重排；</li>
<li>复制节点在副本上进行操作；</li>
</ul>
</li>
<li>使用 absolute 或 fixed 脱离文档流：使用绝对对位会使改元素单独成为渲染树中 body 的一个子元素，重排开销较小，不会给其他节点造成较大影响；</li>
<li>优化动画：<ul>
<li>可以将动画效果应用到 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上来减少对其他元素的影响；</li>
<li>启用 GPU 加速：包括 Canvas2D、布局合成、CSS3 转换(transitions)、CSS3 3D变换(transforms)、WebGL 和 视频(video)；</li>
</ul>
</li>
</ul>
<h4 id="查看页面渲染时间"><a href="#查看页面渲染时间" class="headerlink" title="查看页面渲染时间"></a>查看页面渲染时间</h4><p>打开开发者工具，点击 Performance 选项卡中左上角的小圆点，点击刷新页面会录制整个页面加载的时间的分配情况：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220303220841426.png" srcset="/img/three2.gif" lazyload class title="页面渲染时间">

<ul>
<li>蓝色：网络通信和HTML解析</li>
<li>黄色：JavaScript执行</li>
<li>紫色：样式计算和布局，即重排</li>
<li>绿色：重绘</li>
</ul>
<p>点击 Event Log：单独勾选 Loading 项会显示 html 和 css 的加载时间：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220303221208169.png" srcset="/img/three2.gif" lazyload class title="Event Log">

<h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>白屏时间指用户点击一个链接或打开浏览器输入 URL 地址后，从屏幕空白到显示第一个画面的时间。</p>
<blockquote>
<p>白屏时间的长短将会直接影响用户对该网站的第一印象。</p>
</blockquote>
<h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol>
<li>DNS Lookup：即浏览器从 DNS 服务器中进行域名查询；浏览器会先对页面进行域名解析，获取到服务器的 IP 地址后，进而和服务器进行通信；</li>
<li>建立 TCP 请求连接：基于 TCP/IP 协议，通过三次握手建立连接，并提供可靠的数据传输服务；</li>
<li>服务器端请求处理响应；</li>
<li>客户端下载解析渲染显示页面；</li>
</ol>
<h4 id="白屏性能优化"><a href="#白屏性能优化" class="headerlink" title="白屏性能优化"></a>白屏性能优化</h4><p>其实就是针对白屏过程，在每一个步骤做相应的性能优化措施</p>
<h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片加载面临的问题：</p>
<ol>
<li>启动页面时加载过多图片；</li>
<li>部分图片体积过大；</li>
</ol>
<h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol>
<li>判断图片是否是首屏内图片</li>
</ol>
<p>可以通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 viewport 内部：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> inViewport = <span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> rect = el.getBoundingClientRect()<br>  <span class="hljs-keyword">return</span> rect.top &gt; <span class="hljs-number">0</span><br>  	&amp;&amp; rect.bottom &lt; <span class="hljs-built_in">window</span>.innerHeight<br>	  &amp;&amp; rect.left &gt; <span class="hljs-number">0</span><br>  	&amp;&amp; rect.right &lt; <span class="hljs-built_in">window</span>.innerWidth<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>但上述方法的前提是元素插入到了 DOM 树中才可以进行判断，另一种方式：</p>
<p>使用 Vue 中的自定义指令 <code>v-img</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> promises = [] <span class="hljs-comment">// 用来存储优先加载的图片  </span><br>Vue.directive(<span class="hljs-string">&#x27;img&#x27;</span>, &#123;<br>  <span class="hljs-function"><span class="hljs-title">bind</span>(<span class="hljs-params">el, binding, vnode</span>)</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">const</span> &#123; defer &#125; = binding.value<br>    <span class="hljs-comment">// ...</span><br>    <span class="hljs-keyword">if</span> (!defer) &#123;<br>      promises.push(update(el, binding, vnode))<br>    &#125;<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">inserted</span>(<span class="hljs-params">el, binding, vnode</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; defer &#125; = binding.value<br>    <span class="hljs-keyword">if</span> (!defer) <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">if</span> (inViewport(el)) &#123;<br>      promises.push(update(el, binding, vnode))<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      Vue.nextTick(<span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-built_in">Promise</span>.all(promises)<br>          .then(<span class="hljs-function">() =&gt;</span> &#123;<br>          promises.length = <span class="hljs-number">0</span><br>          update(el, binding, vnode)<br>        &#125;).catch(<span class="hljs-function">() =&gt;</span> &#123;&#125;)<br>      &#125;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<ol start="2">
<li><p>图片体积过大，导致下载时间过长，可以在保证一定清晰度的情况下尽量使用体积较小的图片：</p>
<blockquote>
<p>一张 <code>100px * 100px</code> 像素的图片，其包含该 <code>100 * 100 = 10000</code> 个像素点，而每个像素点通过 <code>RGBA</code> 颜色值进行存储，<code>R\G\B\A</code> 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：<code>10000 * 4bytes = 40000bytes = 39KB</code>。</p>
</blockquote>
<ul>
<li>减少单位像素所需要的字节数</li>
<li>减少一张图片的总像素个数</li>
</ul>
</li>
</ol>
<h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ol>
<li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片；</li>
<li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li>
</ol>
<h3 id="动画性能"><a href="#动画性能" class="headerlink" title="动画性能"></a>动画性能</h3><h4 id="使用-CSS3-tranform"><a href="#使用-CSS3-tranform" class="headerlink" title="使用 CSS3 tranform"></a>使用 CSS3 tranform</h4><p>CSS3 的 tranform 可以旋转、缩放、倾斜，或者上传给定的元素，若属性的值不是 none，则会创建一个堆叠上下文。</p>
<p>示例：</p>
<figure class="highlight css"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs css"><span class="hljs-comment">/* 对应图1 */</span><br><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>; <span class="hljs-attribute">transition</span>: height <span class="hljs-number">1s</span> linear; &#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>; &#125; <br><br><span class="hljs-comment">/* 对应图2 */</span><br><span class="hljs-selector-tag">div</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>); <span class="hljs-attribute">transition</span>: transform <span class="hljs-number">1s</span> linear; &#125;<br><span class="hljs-selector-tag">div</span><span class="hljs-selector-pseudo">:hover</span> &#123; <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">1.0</span>); &#125;<br></code></pre></div></td></tr></table></figure>

<p>一个 height 从 100px 到 200px 的动画按如下流程图执行各种操作（橙色的比较耗时，绿色的比价快速）：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webp.webp" srcset="/img/three2.gif" lazyload class title="图1">

<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webp-16463188358882.webp" srcset="/img/three2.gif" lazyload class title="图2">

<p>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，而将位图加载到 GPU 内存中是相对耗时的操作，GPU 在如下方面很快：</p>
<ul>
<li>绘制位图到屏幕上</li>
<li>可不断的绘制相同的位图</li>
<li>将同一位图进行位移、旋转、缩放</li>
</ul>
<h4 id="层的引入"><a href="#层的引入" class="headerlink" title="层的引入"></a>层的引入</h4><p>以下会引起 Chrome 创建层：</p>
<ul>
<li>进行 3D 或者透视变换的 CSS 属性</li>
<li>使用硬件加速视频解码的 <code>&lt;video&gt;</code> 元素</li>
<li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的 <code>&lt;canvas&gt;</code> 元素</li>
<li>组合型插件（即 Flash）</li>
<li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li>
<li>具有硬件加速的 CSS 滤镜的元素</li>
<li>子元素中存在具有组合层的元素的元素（就是存在具有自己的层的子元素的元素）</li>
<li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（就是在组合层之上进行渲染的元素）</li>
</ul>
<p>提升为合成层的好处：</p>
<ol>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ol>
<p>提升合成层的方式：</p>
<ol>
<li>使用 CSS 的 will-change 属性；</li>
<li>使用一个 3D transform 属性：<code>transofrm: translateZ(0)</code>；</li>
</ol>
<h4 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h4><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能：</p>
<ol>
<li><code>window.requestAnimationFrame()</code>：可以将某些代码放到下一次重新渲染时执行；</li>
<li><code>window.requestIdleCallback()</code>：也可以用来调节重新渲染，指定只有在下一帧的末尾有空闲时间才会执行回调函数，否则就继续向下一个空闲时间推迟，第二个参数可以用来在设定的毫秒内未执行后强制执行。</li>
</ol>
<h3 id="渲染合成层"><a href="#渲染合成层" class="headerlink" title="渲染合成层"></a>渲染合成层</h3><h4 id="形成条件"><a href="#形成条件" class="headerlink" title="形成条件"></a>形成条件</h4><ul>
<li>3D 或透视变换(perspective transform) CSS 属性</li>
<li>使用加速视频解码的 <code>&lt;video&gt;</code> 元素 拥有 3D</li>
<li>(WebGL) 上下文或加速的 2D 上下文的 <code>&lt;canvas&gt;</code> 元素</li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li>
<li>拥有加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ul>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快<ul>
<li>仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU</li>
</ul>
</li>
<li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li>
<li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li>
</ul>
<blockquote>
<p>一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p>
</blockquote>
<h4 id="引发问题"><a href="#引发问题" class="headerlink" title="引发问题"></a>引发问题</h4><ol>
<li>合成层占用内存问题</li>
<li>层爆炸</li>
</ol>
<p>解决：让一些不需要成为合成层的元素回归到普通渲染层，也就是取消上面的形成条件。</p>
<h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>模块：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起，块的内部数据与实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信</p>
<p>进化过程：</p>
<ul>
<li>全局 function 模式：将不同的功能封装成不同的全局函数；<ul>
<li>缺点：污染全局命名空间，容易引起命名冲突或数据不安全；</li>
</ul>
</li>
<li>namespace 模式：在 function 模式下进行简单的对象封装，减少了全局变量，解决命名冲突；<ul>
<li>缺点：会暴露所有模块成员，内部状态可以被外部改写；</li>
</ul>
</li>
<li>IIFE 模式：匿名函数子调用（闭包），使数据私有化，只能通过暴露的方法操作其中的数据；</li>
<li>IIFE 模式增强：引入依赖，保证了模块的独立性且使得模块之间的依赖关系变得明显。</li>
</ul>
<p>好处：</p>
<ul>
<li>避免命名冲突（减少命名空间污染）</li>
<li>更好的分离，按需加载</li>
<li>高复用性和高维护性</li>
</ul>
<p>多个模块出现的问题：</p>
<ol>
<li>请求过多</li>
<li>依赖模糊</li>
<li>难以维护</li>
</ol>
<h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Node 应用有模块构成，采用 CommonJS 模块规范，每个文件就是一个模块，在一个文件里面定义的变量、函数、类都是私有的，对其他文件不可见。</p>
<p>在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p>
<h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul>
<li>所有代码都运行在模块作用域，不会污染全局作用域；</li>
<li>模块可以多次加载，但只会在第一次加载时运行一次，之后在加载会直接读取缓存结果；</li>
<li>模块加载的顺序，按照其在代码中出现的顺序</li>
</ul>
<h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 暴露模块</span><br><span class="hljs-built_in">module</span>.exports = &#123;&#125;<br><span class="hljs-built_in">exports</span>.xxx = value<br><br><span class="hljs-comment">// 引入模块</span><br><span class="hljs-built_in">require</span>(xxx)<br><span class="hljs-comment">// xxx：第三方模块则为模块名，自定义模块则为文件路径</span><br></code></pre></div></td></tr></table></figure>

<p>CommonJS 规范规定，每个模块内部，module 变量代表当前模块（值为一个对象），它的 exports 属性（即 module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p>
<p><code>require</code> 命令用于加载模块，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。</p>
<h5 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h5><p>输入的是被输出值的拷贝，一旦输出一个值，模块内部的变化就不会影响到这个值：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// lib.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-number">3</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">incCounter</span> (<span class="hljs-params"></span>) </span>&#123;<br>  counter++<br>&#125;<br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">counter</span>: counter,<br>  <span class="hljs-attr">incCounter</span>: incCounter<br>&#125;<br><br><span class="hljs-comment">// main.js</span><br><span class="hljs-keyword">var</span> counter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>).counter<br><span class="hljs-keyword">var</span> incCounter = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./lib&#x27;</span>).incCounter<br><span class="hljs-built_in">console</span>.log(counter) <span class="hljs-comment">// 3</span><br>incCounter()<br><span class="hljs-built_in">console</span>.log(counter) <span class="hljs-comment">// 3</span><br></code></pre></div></td></tr></table></figure>

<h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>CommonJS 规范加载模块是同步的，只有加载完成才可以执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。</p>
<p>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系，通常使用第三方库 <code>require.js</code>。</p>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义没有依赖的模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> 模块<br>&#125;)<br><span class="hljs-comment">// 定义有依赖的模块</span><br>define([module1, module2], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m1, m2</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> 模块<br>&#125;)<br><br><span class="hljs-comment">// 引入模块</span><br><span class="hljs-built_in">require</span>([module1, module2], <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m1, m2</span>) </span>&#123;<br>  使用模块<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载，CMD 规范整合了 CommonJS 和 AMD 的特点，通常使用第三方库 <code>sea.js</code>。</p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义没有依赖的模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>  <span class="hljs-built_in">exports</span>.xxx = value<br>  <span class="hljs-built_in">module</span>.exports = value<br>&#125;)<br><span class="hljs-comment">// 定义有依赖的模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">module</span></span>) </span>&#123;<br>  <span class="hljs-comment">// 引入依赖的模块（同步）</span><br>  <span class="hljs-keyword">var</span> module2 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module2&#x27;</span>)<br>  <span class="hljs-comment">// 引入依赖的模块（异步）</span><br>  <span class="hljs-built_in">require</span>.async(<span class="hljs-string">&#x27;./module3&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">m3</span>) </span>&#123;&#125;)<br>  <span class="hljs-comment">// 暴露模块</span><br>  <span class="hljs-built_in">exports</span>.xxx = value<br>&#125;)<br><br><span class="hljs-comment">// 引入模块</span><br>define(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-built_in">require</span></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> m1 = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./module1&#x27;</span>)<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，通常依赖第三方库：<code>babel</code>、<code>browserify</code>、<code>babel-preser-es2015</code>。</p>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 定义模块 math.js</span><br><span class="hljs-keyword">var</span> basicNum = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> add = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">a, b</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-keyword">export</span> &#123; basicNum, add &#125;<br><br><span class="hljs-comment">// 引用模块</span><br><span class="hljs-keyword">import</span> &#123; basicNum, add &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./math&#x27;</span><br><span class="hljs-comment">// ...</span><br></code></pre></div></td></tr></table></figure>

<h5 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h5><p>ES6 与 CommonJS 模块化的差异：</p>
<ol>
<li>CommonJS 输出的是一个值的拷贝，ES6 输出的是值的引用；</li>
<li>CommonJS 是运行时加载，ES6 是编译时输出接口；</li>
<li>ES6 模块是动态引用，不会缓存值；</li>
</ol>
<h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>可以理解为通过工具“摇”JS 文件，将其中用不到的代码“摇”掉，属于性能优化的范畴。</p>
<p>支持 tree-shaking 的构建工具有：Rollup、Webpack2、Closure compiler</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Tree-shaking 的本质是消除无用的 JS 代码，无用代码消除广泛存在于传统的编程语言编译器中，编译器可以判断出哪些代码根部不影响输出，然后消除这些代码，即为 DCE（dead code elmination）。</p>
<p>Tree-shaking 是 DCE 的一种新的实现，JavaScript 同传统的编程语言不同的是，JavaScript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件越小，整体执行时间更短，所以去除无用代码来减少文件体积，对 JavaScript 来说更有意义。</p>
<h5 id="DCE"><a href="#DCE" class="headerlink" title="DCE"></a>DCE</h5><p>Dead Code 的特征：</p>
<ol>
<li>代码不会被执行，不可到达</li>
<li>代码执行的结果不会被用到</li>
<li>代码只会影响死变量（只写不读）</li>
</ol>
<p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，JS 中是由代码压缩优化工具 uglify 完成。</p>
<h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>三大工具的 Tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。</p>
<p>其中 closure compiler 是效果最好的，但与日常的基于 node 的开发流很难兼容。</p>
<h3 id="Uglify-压缩-JS"><a href="#Uglify-压缩-JS" class="headerlink" title="Uglify 压缩 JS"></a>Uglify 压缩 JS</h3><h4 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h4><p>抽象语法树，AST（Abstract Syntax Tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都并表示源代码中的一种结构，抽象的原因是因为语法并不会表示出真实语法中出现的每个细节。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">foo = <span class="hljs-string">&#x27;hello AgoniLay&#x27;</span><br><span class="hljs-comment">/* AST：</span><br><span class="hljs-comment">		+------------+</span><br><span class="hljs-comment">		|  assign(=) |</span><br><span class="hljs-comment">		+------------+</span><br><span class="hljs-comment">			 /			\</span><br><span class="hljs-comment">  +-----+		 +----------------+</span><br><span class="hljs-comment">  | foo |		 | Hello AgoniLay |</span><br><span class="hljs-comment">  +-----+    +----------------+</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (foo === <span class="hljs-literal">true</span>) &#123;<br>  bar = <span class="hljs-string">&#x27;Hello AgoniLay&#x27;</span><br>  alert(bar)<br>&#125;<br><span class="hljs-comment">/* AST：</span><br><span class="hljs-comment">									+------+</span><br><span class="hljs-comment">									|  if  |</span><br><span class="hljs-comment">									+------+</span><br><span class="hljs-comment">								   / 	  \</span><br><span class="hljs-comment">			+------------+		+-----------+</span><br><span class="hljs-comment">  		| equal(===) |		|  if_body  |</span><br><span class="hljs-comment">			+------------+    +-----------+</span><br><span class="hljs-comment">				/      /					/				  \</span><br><span class="hljs-comment">  +-----+	 +------+ 	+-----------+  +---------+</span><br><span class="hljs-comment">  | foo |	 | true |		| assign(=) |	 | alert() |</span><br><span class="hljs-comment">  +-----+  +------+		+-----------+  +---------+</span><br><span class="hljs-comment">  										/				\							  \</span><br><span class="hljs-comment">  						  +-----+	 +----------------+   +-----+</span><br><span class="hljs-comment">  							| foo |	 | Hello AgoniLay |		| bar |</span><br><span class="hljs-comment">  							+-----+  +----------------+		+-----+</span><br><span class="hljs-comment">*/</span><br></code></pre></div></td></tr></table></figure>

<p>AST是源代码根据其语法结构，省略一些细节，抽象成树形表达。抽象语法树在计算机科学中有很多应用，比如编译器、IDE、压缩代码、格式化代码等。</p>
<h4 id="代码压缩原理"><a href="#代码压缩原理" class="headerlink" title="代码压缩原理"></a>代码压缩原理</h4><ol>
<li>将 code 转换成 AST；</li>
<li>将 AST 进行优化；</li>
<li>将优化后的 AST 再转化成 code。</li>
</ol>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220322145325311.png" srcset="/img/three2.gif" lazyload class title="代码压缩图解">

<p>使用 <code>uglify-js@2.x</code>  版本进行代码压缩示例：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// npm install uglify-js@2.x</span><br><span class="hljs-keyword">var</span> UglifyJS = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;uglify-js&#x27;</span>)<br><span class="hljs-comment">// 原始代码</span><br><span class="hljs-keyword">var</span> code = <span class="hljs-string">`</span><br><span class="hljs-string">var a</span><br><span class="hljs-string">var x = &#123; b: 123 &#125;</span><br><span class="hljs-string">a = 123</span><br><span class="hljs-string">delete x`</span><br><span class="hljs-comment">// 通过 UglifyJS 把代码解析为 AST</span><br><span class="hljs-keyword">var</span> ast = UglifyJS.parse(code)<br>ast.figure_out_scope()<br><span class="hljs-comment">// 转化为一颗更小的 AST 树</span><br><span class="hljs-keyword">var</span> compressor = UglifyJS.Compressor()<br>ast = ast.transform(compressor)<br><span class="hljs-comment">// 再把 AST 转化为代码</span><br>code = ast.print_to_string()<br><br><span class="hljs-built_in">console</span>.log(code) <span class="hljs-comment">// var a,x=&#123;b:123&#125;;a=123,delete x;</span><br></code></pre></div></td></tr></table></figure>

<h4 id="代码压缩规则"><a href="#代码压缩规则" class="headerlink" title="代码压缩规则"></a>代码压缩规则</h4><h5 id="表达式压缩"><a href="#表达式压缩" class="headerlink" title="表达式压缩"></a>表达式压缩</h5><p><strong>表达式预计算</strong>：</p>
<p>将可预先计算的表达式替换成其计算结果，同时要比较原来表达式以及生成后的结果的大小，取短值：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">var</span> val1 = <span class="hljs-number">1</span> + <span class="hljs-number">1</span><br><span class="hljs-keyword">var</span> val2 = <span class="hljs-number">1</span> / <span class="hljs-number">3</span><br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">var</span> val1 = <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> val2 = <span class="hljs-number">1</span> / <span class="hljs-number">3</span> <span class="hljs-comment">// 计算出来的值 0.333333333333~ 比 1/3 要长，所以不取预计算的结果</span><br></code></pre></div></td></tr></table></figure>

<p><strong>优化 true 和 false</strong>：</p>
<p>正常情况下会把：</p>
<ul>
<li><code>true</code> 变为 <code>!0</code>，节省 2 个字符；</li>
<li><code>false</code> 变为 <code>!1</code>，节省 3 个字符。</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">var</span> val1 = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> val2 = <span class="hljs-literal">false</span><br><span class="hljs-literal">true</span> == A<br><span class="hljs-literal">false</span> == A<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">var</span> val1 = !<span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> val2 = !<span class="hljs-number">1</span><br><span class="hljs-number">1</span> == A<br><span class="hljs-number">0</span> == A<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>在参与 <code>==</code> 或者 <code>!=</code> 计算时，可以把 <code>true</code> 变为 1，<code>false</code> 变为 0.</p>
</blockquote>
<p><strong>根据 &amp;&amp; || 短路特性压缩</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-literal">true</span> &amp;&amp; A()<br><span class="hljs-literal">false</span> &amp;&amp; A()<br><span class="hljs-literal">true</span> || A()<br><span class="hljs-literal">false</span> || A()<br><br><span class="hljs-comment">// 压缩后</span><br>A()	<span class="hljs-comment">// 返回 &amp;&amp; 后的值</span><br>!<span class="hljs-number">1</span>	<span class="hljs-comment">// 返回 &amp;&amp; 前的值</span><br>!<span class="hljs-number">0</span>	<span class="hljs-comment">// 返回 || 前的值</span><br>A()	<span class="hljs-comment">// 返回 &amp;&amp; 后的值</span><br></code></pre></div></td></tr></table></figure>

<h5 id="运算符缩短"><a href="#运算符缩短" class="headerlink" title="运算符缩短"></a>运算符缩短</h5><p><strong>!== === 缩短</strong>：</p>
<p>对于二元运算符 <code>===</code> 以及 <code>!==</code>，其两个操作数都是 string 类型或者布尔类型的，可以缩短成 <code>==</code> 以及 <code>!=</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-string">&#x27;object&#x27;</span> === <span class="hljs-keyword">typeof</span> A<br>(a, b, <span class="hljs-literal">true</span>) !== b <span class="hljs-keyword">instanceof</span> B<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-string">&#x27;object&#x27;</span> == <span class="hljs-keyword">typeof</span> A<br>(a, b, <span class="hljs-literal">true</span>) != b <span class="hljs-keyword">instanceof</span> B<br></code></pre></div></td></tr></table></figure>

<p><strong>赋值表达式缩短</strong>：</p>
<p>详细规则：</p>
<ol>
<li>必须是 <code>=</code> 赋值语句</li>
<li><code>=</code> 左侧只能是变量，不能是表达式等</li>
<li><code>=</code> 右侧必须为二元操作表达式，并且符号是 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&gt;&gt;&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&gt;&#39;, &#39;|&#39;, &#39;^&#39;, &#39;&amp;&#39;]</code> 中的元素</li>
<li><code>=</code> 右侧的二元表达式的第一个操作数必须跟 <code>=</code> 号左侧的变量一致</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br>a = a + b<br>c = c &gt;&gt;&gt; d<br>a = b + c<br><br><span class="hljs-comment">// 压缩后</span><br>a += b<br>c &gt;&gt;&gt;= d<br>a + b + c <span class="hljs-comment">// 无法进行赋值表达式压缩</span><br></code></pre></div></td></tr></table></figure>

<p><strong>! 的压缩</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br>!(a &gt;= b)<br>!!!a<br><br><span class="hljs-comment">// 压缩后</span><br>a &lt; b<br>!a<br></code></pre></div></td></tr></table></figure>

<h5 id="去除无用声明"><a href="#去除无用声明" class="headerlink" title="去除无用声明"></a>去除无用声明</h5><p><strong>去除重复的指示性字符串</strong>：</p>
<p>对于嵌套的作用域使用了同样的指示性字符串，子作用域可以省略：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params"></span>) </span>&#123;<br><span class="hljs-meta">  &#x27;use strict&#x27;</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span> (<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// &#x27;use strict&#x27; 可省略</span><br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>去除未使用的函数参数</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params">a, b<span class="hljs-comment">/*, c */</span></span>) </span>&#123; <span class="hljs-comment">// 此处 c 并未用到，可以去除</span><br>  b++<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>去除函数表达式冗余的函数名</strong>：</p>
<p>对于一个函数表达式，如果其函数体没有引用自身名字递归调用，那么此函数名可以去除，使之变为匿名函数：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span> (<span class="hljs-params"></span>) </span>&#123;<br>  A() <span class="hljs-comment">// 此处递归调用，无法省略函数名</span><br>&#125;)<br>(<span class="hljs-function"><span class="hljs-keyword">function</span> /* <span class="hljs-title">B</span> */ (<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">// 此处 B 函数名可以省略</span><br>  c++<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p><strong>去除没用的块</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">while</span> (f) &#123;<br>  &#123; A() &#125;<br>&#125;<br><span class="hljs-keyword">while</span> (f) &#123;<br>  &#123;&#125;<br>&#125;<br><span class="hljs-keyword">if</span> (A) &#123;<br>  B()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">while</span> (f)<br>  A()<br><span class="hljs-keyword">while</span> (f)<br>  ;<br><span class="hljs-keyword">if</span> (A)<br>  B()<br></code></pre></div></td></tr></table></figure>

<p><strong>去除未使用的 break</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">switch</span> (A) &#123;<br>  <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>    <span class="hljs-keyword">break</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>    <span class="hljs-comment">/* break */</span> <span class="hljs-comment">// 最后一项的 break 可以忽略，但如果带标签则不可忽略</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>去除没有引用的 label</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-attr">label1</span>: <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-attr">label2</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  <span class="hljs-keyword">break</span> label2<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br><span class="hljs-attr">label2</span>: <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>  <span class="hljs-keyword">break</span> label2<br></code></pre></div></td></tr></table></figure>

<p><strong>去除无用的 toString 函数调用</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br>(<span class="hljs-keyword">typeof</span> A).toString()<br>(<span class="hljs-string">&#x27;A&#x27;</span> + <span class="hljs-string">&#x27;B&#x27;</span>).toString()<br><span class="hljs-keyword">var</span> expr = <span class="hljs-string">&#x27;str&#x27;</span>.toString()<br><br><span class="hljs-comment">// 压缩后</span><br>(<span class="hljs-keyword">typeof</span> A)<br><span class="hljs-string">&#x27;AB&#x27;</span><br><span class="hljs-keyword">var</span> expr = <span class="hljs-string">&#x27;str&#x27;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="while-压缩"><a href="#while-压缩" class="headerlink" title="while 压缩"></a>while 压缩</h5><ul>
<li>去除根本不会执行的 while 循环；</li>
<li><code>while(true)</code> 变为 <code>for(;;)</code>，可以缩短 4 个字符</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">false</span>) &#123;<br>  A()<br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>  B()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">for</span> (;;)<br>  B()<br></code></pre></div></td></tr></table></figure>

<h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br>!cond ? yes() : no()<br><span class="hljs-literal">true</span> ? yes() : no()<br><br><span class="hljs-comment">// 压缩后</span><br>cond ? no() : yes()<br>yes()<br></code></pre></div></td></tr></table></figure>

<h5 id="语句块压缩"><a href="#语句块压缩" class="headerlink" title="语句块压缩"></a>语句块压缩</h5><p><strong>连续的表达式语句可以合并成一个逗号表达式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  B()<br>  C()<br>  d = <span class="hljs-number">1</span><br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  B(), C(), d = <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><strong>多个 var 声明可以压缩成一个</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">var</span> a<br><span class="hljs-keyword">var</span> b<br><span class="hljs-keyword">var</span> c<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">var</span> a, b, c<br></code></pre></div></td></tr></table></figure>

<p><strong>return 语句之后的非常量声明以及非函数声明语句可以去除</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  expr += <span class="hljs-number">1</span><br>  a = <span class="hljs-number">3</span><br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">B</span>(<span class="hljs-params"></span>) </span>&#123;&#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>  <span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>throw、break、continue 之后的语句也适用于此规则。</p>
</blockquote>
<p><strong>合并块末尾的 return 语句及其前面的多条表达式语句</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  B()<br>  C()<br>  <span class="hljs-keyword">return</span> D()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">A</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> B(), C(), D()<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="if-分支优化"><a href="#if-分支优化" class="headerlink" title="if 分支优化"></a>if 分支优化</h5><p><strong>去除没用的 if/else 分支</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<br>  A()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  B()<br>&#125;<br><span class="hljs-keyword">if</span> (<span class="hljs-literal">false</span>) &#123;<br>  C()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  D()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br>A()<br>D()<br></code></pre></div></td></tr></table></figure>

<p><strong>去除空的 if/else 分支</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  B()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br><span class="hljs-keyword">if</span> (C) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  D()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">if</span> (A)<br>  B()<br><span class="hljs-keyword">if</span> (!C)<br>  D()<br></code></pre></div></td></tr></table></figure>

<p><strong>尝试反转 if/else 分支</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (!C) &#123;<br>  A()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  B()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">if</span> (C)<br>  B()<br><span class="hljs-keyword">else</span><br>  A()<br></code></pre></div></td></tr></table></figure>

<p><strong>可合并情况</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  <span class="hljs-keyword">if</span> (B) &#123;<br>    C()<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">if</span> (A &amp;&amp; B)<br>  C()<br></code></pre></div></td></tr></table></figure>

<p><strong>如果 if 最后一个语句是跳出控制语句，则可以将 else 块的内容提到 else 外</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  B()<br>  <span class="hljs-keyword">return</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  C()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  B()<br>  <span class="hljs-keyword">return</span><br>&#125;<br>C()<br></code></pre></div></td></tr></table></figure>

<p><strong>如果 if/else 中都是只有一句 return 语句，可以进行合并</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  <span class="hljs-keyword">return</span> B()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  <span class="hljs-keyword">return</span> C()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br><span class="hljs-keyword">return</span> A ? B() : C()<br></code></pre></div></td></tr></table></figure>

<p><strong>如果if/else其中一个块为空，另一个块只有一条语句，则可以化成 || 或者 &amp;&amp; 的表达式</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 压缩前</span><br><span class="hljs-keyword">if</span> (A) &#123;<br>  B()<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>&#125;<br><span class="hljs-keyword">if</span> (C) &#123;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  D()<br>&#125;<br><br><span class="hljs-comment">// 压缩后</span><br>A &amp;&amp; B()<br>C || D()<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>源码可以参考此处：<a target="_blank" rel="noopener" href="http://rapheal.sinaapp.com/2014/05/22/uglifyjs-squeeze/">http://rapheal.sinaapp.com/2014/05/22/uglifyjs-squeeze/</a></p>
</blockquote>
<h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><h4 id="Babel-的处理流程"><a href="#Babel-的处理流程" class="headerlink" title="Babel 的处理流程"></a>Babel 的处理流程</h4><img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220322164012132.png" srcset="/img/three2.gif" lazyload class title="Babel 处理流程">

<p>源码解析（Parsing），包含两个步骤：</p>
<ul>
<li>词法解析（Lexical Analysis）：将字符串形式的代码转换为 Tokens（令牌，可以视作是一些词法片段组成的数组）；</li>
<li>语法解析（Syntactic Analysis）：解析器将 Tokens 转换为 AST。</li>
</ul>
<blockquote>
<p>AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST。</p>
</blockquote>
<p>接着进行转换（Transform），转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删改查，如语法转换、代码压缩。</p>
<p>最后阶段还是要把 AST 转换回字符串形式的 JavaScript，同时生成 Source Map</p>
<h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>Babel 的核心非常小，大部分功能都是通过插件扩展实现的。</p>
<h5 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h5><p><code>@babel/core</code> 就是微内核架构中的内核，对于 Babel 来说，此内核的任务是：</p>
<ul>
<li>加载和处理配置</li>
<li>加载插件</li>
<li>调用 <code>Parser</code> 进行语法解析，生成 AST</li>
<li>调用 <code>Traverser</code> 遍历 AST，并使用访问者模式应用插件对 AST 进行转换</li>
<li>生成代码，包括 SourceMap 转换和源代码生成</li>
</ul>
<h5 id="核心周边支撑"><a href="#核心周边支撑" class="headerlink" title="核心周边支撑"></a>核心周边支撑</h5><ul>
<li>Parser（<code>@babel/parser</code>）：将源代码解析为 AST；</li>
<li>Traverser（<code>@babel/traverse</code>）：实现了访问者模式；</li>
<li>Generator（<code>@babel/generator</code>）：将 AST 转换为源代码，支持 SourceMap</li>
</ul>
<h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul>
<li>loader：能转换各类资源，并处理成对应模块的加载器，loader 间可以串行使用；</li>
<li>chunk：code splitting  后的产物，也就是按需加载的分块，装载了不同的 module。</li>
</ul>
<h4 id="流程总览"><a href="#流程总览" class="headerlink" title="流程总览"></a>流程总览</h4><img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" srcset="/img/three2.gif" lazyload class title="webpack 流程总览"> 

<h4 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h4><p>Webpack 的插件机制依赖于一个核心的库，<strong>Tapable</strong>：是一个类似于 nodejs 的 EventEmitter 的库，主要是控制钩子函数的发布于订阅；Tapable 提供的 hook 机制比较全面，分为哦同步和异步两个大类（异步中又分为异步并行和异步单行），根据事件执行的终止条件，衍生出 Bail/Waterfall/Loop 类型。</p>
<h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h3><h4 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h4><p>Vue 源码是从 <code>_init</code> 初始化开始的，这个过程包括配置选项的合并，数据的检测代理，最后进行示例的挂载。</p>
<p>在示例挂载前还有一个重要的过程——数据的初始化（<code>initState(vm)</code>）：是对数据进行响应式设计的过程，针对 <code>props, nethods, data, computed, watch</code> 做数据的初始化处理，并将他们转换成响应式对象。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initState</span> (<span class="hljs-params">vm</span>) </span>&#123;<br>  vm._watchers = []<br>  <span class="hljs-keyword">var</span> opts = vm.$options<br>  <span class="hljs-comment">// 初始化 props</span><br>  <span class="hljs-keyword">if</span> (opts.props) &#123; initProps(vm, opts.props) &#125;<br>  <span class="hljs-comment">// 初始化 methods</span><br>  <span class="hljs-keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.method) &#125;<br>  <span class="hljs-comment">// 初始化 data</span><br>  <span class="hljs-keyword">if</span> (opts.data) &#123;<br>    initData(vm)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 如果没有定义 data，则创建一个空对象，并设置为响应式</span><br>    observe(vm._data = &#123;&#125;, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asROotData */</span>)<br>  &#125;<br>  <span class="hljs-comment">// 初始化 computed</span><br>  <span class="hljs-keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed) &#125;<br>  <span class="hljs-comment">// 初始化 watch</span><br>  <span class="hljs-keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;<br>    initWatch(vm, opts.watch)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><p>父组件通过属性的形式将数据传递给子组件，紫钻见通过 <code>props</code> 属性接收父组件传递的值：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 父组件</span><br><span class="hljs-comment">// &lt;child :test=&quot;test&quot;&gt;&lt;/child&gt;</span><br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">test</span>: <span class="hljs-string">&#x27;child&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;)<br><br><span class="hljs-comment">// 子组件</span><br>Vue.component(<span class="hljs-string">&#x27;child&#x27;</span>, &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">&#x27;&lt;div&gt;&#123;&#123; test &#125;&#125;&lt;/div&gt;&#x27;</span>,<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;test&#x27;</span>]<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>父组件优先进行模板编译得到一个 <code>render</code> 函数，在解析过程中遇到子组件的属性，<code>:test=&quot;test&quot;</code> 会被解析成 <code>&#123; attrs: &#123;test: test&#125; &#125;</code> 并作为子组件的 <code>render</code> 函数岑在：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">with</span> () &#123; ...c_(<span class="hljs-string">&#x27;child&#x27;</span>, &#123; <span class="hljs-attr">attr</span>: &#123; <span class="hljs-string">&#x27;test&#x27;</span>: test &#125; &#125;) &#125;<br></code></pre></div></td></tr></table></figure>

<p>render 解析 VNode 的过程遇到 child 这个子占位符节点，进入创建子组件 VNode 的过程：调用 <code>createComponent</code>，最终调用 <code>new Vnode</code> 去创建子 VNode，而对于 <code>props</code> 的处理，<code>extractPropsFromVNodeData</code> 会对 <code>attrs</code> 属性进行规范校验后，最后会把校验的结果以 <code>propsData</code> 属性的形式传入 VNode 构造器中。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建子组件过程</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComponent</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// props 校验</span><br>  <span class="hljs-keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)<br>  ...<br>  <span class="hljs-comment">// 创建子组件 vnode</span><br>  <span class="hljs-keyword">var</span> vnode = <span class="hljs-keyword">new</span> VNode(<br>    (<span class="hljs-string">&#x27;vue-component-&#x27;</span> + (Ctor.cid) + (name ? (<span class="hljs-string">&#x27;-&#x27;</span> + name) : <span class="hljs-string">&#x27;&#x27;</span>)),<br>    data, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, context,<br>    &#123; <span class="hljs-attr">Ctor</span>: Ctor, <span class="hljs-attr">propsData</span>: propsData, <span class="hljs-attr">listeners</span>: listeners, <span class="hljs-attr">tag</span>: tag, chilren, children &#125;,<br>    asyncFactory<br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="props-的命名规范"><a href="#props-的命名规范" class="headerlink" title="props 的命名规范"></a>props 的命名规范</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">extractPropsFromVNodeData</span> (<span class="hljs-params">data, Ctor, tag</span>) </span>&#123;<br>  <span class="hljs-comment">// Ctor 为子类构造器</span><br>  ...<br>  <span class="hljs-keyword">var</span> res = &#123;&#125;<br>  <span class="hljs-comment">// 子组件 props 选项</span><br>  <span class="hljs-keyword">var</span> propOptions = Ctor.options.props<br>  <span class="hljs-comment">// data.attrs 针对编译生成的 render 函数，data.props 针对用户自定义的 render 函数</span><br>  <span class="hljs-keyword">var</span> attrs = data.attrs<br>  <span class="hljs-keyword">var</span> props = data.props<br>  <span class="hljs-keyword">if</span> (isDef(attrs) || isDef(props)) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> propOptions) &#123;<br>      <span class="hljs-comment">// aB 形式转成 a-b</span><br>      <span class="hljs-keyword">var</span> altKey = <span class="hljs-function"><span class="hljs-title">hyphenate</span>(<span class="hljs-params">key</span>)</span><br>      &#123;<br>        <span class="hljs-keyword">var</span> keyInLowerCase = key.toLowerCase()<br>        <span class="hljs-keyword">if</span> (<br>          key !== keyInLowerCase &amp;&amp;<br>          attrs &amp;&amp; hasOwn(attrs, keyInLowerCase)<br>        ) &#123;<br>          <span class="hljs-comment">// 警告</span><br>          ...<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此在使用 DOM 中的模板时，cameCase（驼峰命名法）的 <code>props</code> 名需要使用其等价的 <code>kebab-case</code>（短横线分隔命名）代替。</p>
<h5 id="响应式数据-props"><a href="#响应式数据-props" class="headerlink" title="响应式数据 props"></a>响应式数据 props</h5><p>子组件处理 <code>props</code> 的过程，是发生在父组件 <code>_update</code> 阶段，这个阶段是 <code>Vnode</code> 生成真实节点的过程，期间会遇到子 Vnode，调用 <code>createComponent</code> 去实例化子组件。实例化子组件的过程又回到了 <code>_init</code> 初始化，经历选项的合并，针对 <code>props</code> 选项，最终会统一成 <code>&#123; props: &#123; test: &#123; type:null &#125;&#125;&#125;</code> 的写法，接着会调用 <code>initProps</code>：将组件的 <code>props</code> 数据设置为响应式数据。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initProps</span> (<span class="hljs-params">vm, propsOptions</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;<br>  <span class="hljs-keyword">var</span> loop = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">key</span>) </span>&#123;<br>    ...<br>    definePeactive(props, key, value, cb)<br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>      proxy(vm, <span class="hljs-string">&#x27;_props&#x27;</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 遍历 props，执行 loop 设置为响应式数据</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> propsOptions) loop(key)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>其中 <code>proxy(vm, &#39;_props&#39;, key)</code> 为 <code>props</code> 做了一层代理，用户通过 <code>vm.XXX</code> 可以代理访问到 <code>vm._props</code> 上的值。</p>
<h4 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h4><p><code>initMethod</code> 方法和响应式没有任何的关系，实现也相对简单，主要是保证 <code>methods</code> 方法定义必须是函数，且命名不能和 <code>props</code> 重复，最终会将定义的方法都挂载到根实例上:</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initMethods</span> (<span class="hljs-params">vm, methods</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> props = vm.$options.props<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> methods) &#123;<br>    &#123;<br>      <span class="hljs-comment">// method 必须为函数形式</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> methods[key] !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>      <span class="hljs-comment">// methods 方法名 不能和 props 重复</span><br>      <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>      <span class="hljs-comment">// 不能以 _ or $. 这些 Vue 保留标志开头</span><br>      <span class="hljs-keyword">if</span> ((key <span class="hljs-keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;<br>        <span class="hljs-comment">// ...</span><br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 直接挂载到示例的属性上，可以通过 vm[method] 访问</span><br>    vm[key] = <span class="hljs-keyword">typeof</span> methods[key] !== <span class="hljs-string">&#x27;function&#x27;</span> ? noop : bing(methods[key], vm)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><p>data 在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以 <code>initData</code> 方法会先执行拿到组件的 <code>data</code> 数据，并且会对对象每个属性的命名进行校验，保证不能和 <code>props, methods</code> 重复。</p>
<p>最后的核心方法是 <code>observe</code>，将数据对象标记为响应式对象，并对对象的每个属性进行响应式处理，同时 <code>proxy</code> 会对 data 做一层代理，直接通过 <code>vm.XXX</code> 可以failing访问到 <code>vm._data</code> 上挂载的对象属性。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initData</span> (<span class="hljs-params">vm</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> data = vm.$options.data<br>  <span class="hljs-comment">// 根实例时，data 是一个对象，子组件的 data 是一个函数，其中 getData 会调用函数返回 data 对象</span><br>  data = vm._data = <span class="hljs-keyword">typeof</span> data === <span class="hljs-string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125;<br>  <span class="hljs-keyword">var</span> keys = <span class="hljs-built_in">Object</span>.keys(data)<br>  <span class="hljs-keyword">var</span> props = vm.$options.props<br>  <span class="hljs-keyword">var</span> methods = vm.$options.methods<br>  <span class="hljs-keyword">var</span> i = keys.length<br>  <span class="hljs-keyword">while</span> (i--) &#123;<br>    <span class="hljs-keyword">var</span> key = keys[i]<br>    &#123;<br>      <span class="hljs-comment">// 命名不能和方法重复</span><br>      <span class="hljs-keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;<br>        warn()<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 命名不能与 props 重复</span><br>    <span class="hljs-keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;<br>      warn()<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isReserved(key)) &#123;<br>      <span class="hljs-comment">// 数据代理，用户可直接通过 vm 实例返回 data 数据</span><br>      proxy(vm, <span class="hljs-string">&#x27;_data&#x27;</span>, key)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// observe data</span><br>  observe(data, <span class="hljs-literal">true</span> <span class="hljs-comment">/* asRootData */</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>observe</code> 具体的行为是将数据对象添加一个不可枚举的属性 <code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写 <code>getter, setter</code> 方法，使得每个属性值都是响应式数据。</p>
<h4 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h4><p><code>initComputed</code> 是 <code>computed</code> 数据的初始化，不同之处在于：</p>
<ol>
<li><code>computed</code> 可以是对象，也可以是函数，对象必须有 <code>getter</code> 方法，所以需要进行验证；</li>
<li>针对 <code>computed</code> 每个属性，要创建一个监听的依赖，也就是需要实例化一个 watcher。</li>
</ol>
<p><code>initComputed</code> 也会将每个属性设置设置成响应式的数据，同样的，也会对 <code>computed</code> 的命名做检测，防止与 <code>props, data</code> 冲突。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initComputed</span> (<span class="hljs-params">vm, computed</span>) </span>&#123;<br>  ...<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> computed) &#123;<br>    <span class="hljs-keyword">var</span> userDef = computed[key]<br>    <span class="hljs-keyword">var</span> getter = <span class="hljs-keyword">typeof</span> userDef === <span class="hljs-string">&#x27;function&#x27;</span> ? userDef : userDef.get<br>    <span class="hljs-comment">// computed 属性为对象时，要保证有 getter 方法</span><br>    <span class="hljs-keyword">if</span> (getter === <span class="hljs-literal">null</span>) &#123;<br>      warn()<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!isSSR) &#123;<br>      <span class="hljs-comment">// 创建 computed watcher</span><br>      watchers[key] = <span class="hljs-keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!(key <span class="hljs-keyword">in</span> vm)) &#123;<br>      <span class="hljs-comment">// 设置为响应式数据</span><br>      defineComputed(vm, key, userDef)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 不能和 props, data 命名冲突</span><br>      <span class="hljs-keyword">if</span> (key <span class="hljs-keyword">in</span> vm.$data) &#123;<br>        warn()<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (vm.$options.props &amp;&amp; key <span class="hljs-keyword">in</span> vm.$options.props) &#123;<br>        warn()<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h4 id="极简响应式系统"><a href="#极简响应式系统" class="headerlink" title="极简响应式系统"></a>极简响应式系统</h4><h5 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h5><p>以 <code>MyVue</code> 作为类响应式框架。模拟 Vue 源码的实现思路，实例化 <code>MyVue</code> 时会传递一个选项配置，精简的代码只有一个 id 挂载元素和一个数据对象 data。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> MyVue(&#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">data</span>: &#123;<br>    <span class="hljs-attr">test</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>  &#125;<br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>myVue.js：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVue</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">options</span>) &#123;<br>    <span class="hljs-built_in">this</span>.options = options<br>    <span class="hljs-comment">// 数据的初始化</span><br>    <span class="hljs-built_in">this</span>.initData(options)<br>    <span class="hljs-keyword">let</span> el = <span class="hljs-built_in">this</span>.options.id<br>    <span class="hljs-comment">// 挂载实例</span><br>    <span class="hljs-built_in">this</span>.$mount(el)<br>  &#125;<br>  initData (options) &#123;<br>  &#125;<br>  $mount (el) &#123;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="设置响应式对象-Observer"><a href="#设置响应式对象-Observer" class="headerlink" title="设置响应式对象 - Observer"></a>设置响应式对象 - Observer</h5><p>引入一个 <code>Observer</code> 类，目的是将数据变成响应式对象，利用 <code>Object.defineProperty</code> 对数据的 <code>getter, setter</code> 方法进行改写。在数据读取 <code>getter</code> 阶段进行<strong>依赖的收集</strong>；在数据的修改 <code>setter</code> 阶段，进行<strong>依赖的更新</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVue</span> </span>&#123;<br>  initData (options) &#123;<br>    <span class="hljs-keyword">if</span> (!options.data) <span class="hljs-keyword">return</span><br>    <span class="hljs-built_in">this</span>.data = options.data<br>    <span class="hljs-comment">// 将数据重置 getter, setter 方法</span><br>    <span class="hljs-keyword">new</span> Observer(options.data)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// Observer 类的定义</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Observer</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">data</span>) &#123;<br>    <span class="hljs-built_in">this</span>.walk(data)<br>  &#125;<br>  walk (obj) &#123;<br>    <span class="hljs-keyword">const</span> keys = <span class="hljs-built_in">Object</span>.keys(obj)<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; keys.length; i++) &#123;<br>      <span class="hljs-comment">// Object.definedProperty 的处理逻辑</span><br>      defineReactive(obj, keys[i])<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="依赖本身-Watcher"><a href="#依赖本身-Watcher" class="headerlink" title="依赖本身 - Watcher"></a>依赖本身 - Watcher</h5><p>一个 <code>Watcher</code> 实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算作一个炫耀监听的依赖，<code>watcher</code> 中记录着这个依赖监听的状态，以及如何让更新操作的方法：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 监听的依赖</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  contructor (expOrFn, isRenderWatcher) &#123;<br>    <span class="hljs-built_in">this</span>.getter = expOrFn<br>    <span class="hljs-comment">// Watcher.property.get 的调用会进行状态的更新</span><br>    <span class="hljs-built_in">this</span>.get()<br>  &#125;<br>  get () &#123;&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>在渲染数据到真实 <code>DOM</code> 时可以创建 <code>watcher</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyVue</span> </span>&#123;<br>  $mount (el) &#123;<br>    <span class="hljs-comment">// 直接改写 innerHTML</span><br>    <span class="hljs-keyword">const</span> updateView = <span class="hljs-function"><span class="hljs-params">_</span> =&gt;</span> &#123;<br>      <span class="hljs-keyword">let</span> innerHtml = <span class="hljs-built_in">document</span>.querySelector(el).innerHTML<br>      <span class="hljs-keyword">let</span> key = innerHtml.match(<span class="hljs-regexp">/&#123;(\w+)&#125;/</span>)[<span class="hljs-number">1</span>]<br>      <span class="hljs-built_in">document</span>.querySelecter(el).innerHTML = <span class="hljs-built_in">this</span>.options.data[key]<br>    &#125;<br>    <span class="hljs-keyword">new</span> Watcher(updateView, <span class="hljs-literal">true</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h5 id="依赖管理-Dep"><a href="#依赖管理-Dep" class="headerlink" title="依赖管理 - Dep"></a>依赖管理 - Dep</h5><p><code>watcher</code> 理解为每个数据需要监听的依赖，那么 <code>Dep</code> 可以理解为对依赖的一种管理：将依赖进行收集，派发依赖进行更新：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">let</span> uid = <span class="hljs-number">0</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dep</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">this</span>.id = uid++<br>    <span class="hljs-built_in">this</span>.subs = []<br>  &#125;<br>  <span class="hljs-comment">// 依赖收集</span><br>  depend () &#123;<br>    <span class="hljs-keyword">if</span> (dep.target) &#123;<br>      <span class="hljs-comment">// Deptarget 是当前的 watcher，将当前的依赖推到 subs 中</span><br>      <span class="hljs-built_in">this</span>.subs.push(Dep.target)<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 派发更新</span><br>  notify () &#123;<br>    <span class="hljs-keyword">const</span> subs = <span class="hljs-built_in">this</span>.subs.slice()<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = subs.lenght; i &lt; l; i++) &#123;<br>      <span class="hljs-comment">// 遍历 dep 中的依赖，对每个依赖执行更新操作</span><br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br><br>Dep.target = <span class="hljs-literal">null</span><br></code></pre></div></td></tr></table></figure>

<h5 id="依赖管理过程-definedReactive"><a href="#依赖管理过程-definedReactive" class="headerlink" title="依赖管理过程 - definedReactive"></a>依赖管理过程 - definedReactive</h5><p><code>Observer</code> 实例化最终会调用 <code>definedReactive</code> 重写 <code>getter, setter</code> 方法。开始会实例化一个 <code>Dep</code>，也就是创建一个数据的依赖管理。在重写的 <code>getter</code> 方法中会进行依赖的收集，即调用 <code>dep.depend</code> 方法，在 <code>setter</code> 阶段，比较两个数不同后，会调用依赖的派发更新，即 <code>dep.notify</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">const</span> defineReactive = <span class="hljs-function">(<span class="hljs-params">obj, key</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep()<br>  <span class="hljs-keyword">const</span> property = <span class="hljs-built_in">Object</span>.getOwnPropertyDescriptor(obj)<br>  <span class="hljs-keyword">let</span> val = obj[key]<br>  <span class="hljs-keyword">if</span> (property &amp;&amp; property.configurable === <span class="hljs-literal">false</span>) <span class="hljs-keyword">return</span><br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    <span class="hljs-attr">configurable</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-attr">enumerable</span>: <span class="hljs-literal">true</span>,<br>    get () &#123;<br>      <span class="hljs-comment">// 做依赖的收集</span><br>      <span class="hljs-keyword">if</span> (Dep.target) &#123;<br>        dep.depend()<br>      &#125;<br>      <span class="hljs-keyword">return</span> val<br>    &#125;,<br>    set (newVal) &#123;<br>      <span class="hljs-keyword">if</span> (newVal === val) <span class="hljs-keyword">return</span><br>      <span class="hljs-comment">// 派发更新</span><br>      val = newVal<br>      dep.notify()<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>实例化 <code>Watcher</code> 时会将 <code>Dep.target</code> 设置为当前的 watcher，执行完状态更新函数之后，在将 <code>Dep.target</code> 置空：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Watcher</span> </span>&#123;<br>  <span class="hljs-title">constructor</span> (<span class="hljs-params">expOrFn, isRenderWatcher</span>) &#123;<br>    <span class="hljs-built_in">this</span>.getter = expOrFn<br>    <span class="hljs-built_in">this</span>.get()<br>  &#125;<br>  get () &#123;<br>    <span class="hljs-comment">// 当前执行的 watcher</span><br>    Dep.target = <span class="hljs-built_in">this</span><br>    <span class="hljs-built_in">this</span>.getter()<br>    Dep.target = <span class="hljs-literal">null</span><br>  &#125;<br>  update () &#123;<br>    <span class="hljs-built_in">this</span>.get()<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<h3 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>计算属性 computed，会根据所依赖的数据动态显示新的计算结果，且计算结果在 getter 执行后会被缓存起来，当所依赖的数据发生改变的时候，就会重新调用 getter 来计算最新的结果</p>
<p>computed 设计的初衷是为了使模板中的逻辑运算更简单，应用场景：</p>
<ul>
<li>重复使用数据或复杂及费时的运算；</li>
<li>需要的数据依赖于其他的数据。</li>
</ul>
<h5 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="headerlink" title="computed 和 methods 的区别"></a>computed 和 methods 的区别</h5><ol>
<li>computed 是基于响应性依赖来进行缓存的，只有当响应式依赖发生改变时才会重新求值；methods 方法中是每次调用，都会执行函数，且 methods 不是响应式的；</li>
<li>computed 中的成员可以指定一个函数作为只读属性，也可以定义 get/set 变成可读写属性，但是 methods 中不可行。</li>
</ol>
<p>缓存的存在避免了一些无谓的计算，提高了访问速度，优化了用户体验。</p>
<h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch 是对 data 的数据监听回调，当依赖的 data 的数据变化时，会执行回调。</p>
<p>使用场景：当在 data 中的某个数据发生变化时，需要进行一些操作，或者当需要在数据变化时执行异步或开销较大的操作时，使用 watch 来监听。</p>
<h5 id="普通监听和深度监听"><a href="#普通监听和深度监听" class="headerlink" title="普通监听和深度监听"></a>普通监听和深度监听</h5><p>watch 中有一个属性为 <code>deep</code>，含义是：是否深度监听某个对象的值，默认为 false。</p>
<blockquote>
<p>页面第一次加载默认不会触发 watch，可以添加 immediate 属性为 true 来使页面加载时先执行一次。</p>
</blockquote>
<h5 id="watch-和-computed-的区别"><a href="#watch-和-computed-的区别" class="headerlink" title="watch 和 computed 的区别"></a>watch 和 computed 的区别</h5><p>同：都是监听页面数据变化的；</p>
<p>异：</p>
<ul>
<li>computed 只有当依赖的数据变化时才会计算，当数据没有变化时，会读取缓存</li>
<li>watch 每次都需要执行函数，watch 更适合于数据变化的异步操作</li>
</ul>
<h4 id="computed-的基本原理及源码实现"><a href="#computed-的基本原理及源码实现" class="headerlink" title="computed 的基本原理及源码实现"></a>computed 的基本原理及源码实现</h4><p>// TODO:</p>
<h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>插槽允许以一种不同于严格的父子关系的方式组合组件，有普通插槽、具名插槽和作用域插槽。</p>
<h4 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h4><p>插槽将 <code>&lt;slot&gt;&lt;/slot&gt;</code> 作为子组件承载分发的载体。</p>
<h5 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h5><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> child = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div class=&quot;child&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span><br>&#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    child<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;app&quot;&gt;&lt;child&gt;test&lt;/child&gt;&lt;/div&gt;`</span><br>&#125;)<br><span class="hljs-comment">// 最终渲染结果</span><br><span class="hljs-comment">// &lt;div class=&quot;child&quot;&gt;test&lt;/div&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="组件挂载原理"><a href="#组件挂载原理" class="headerlink" title="组件挂载原理"></a>组件挂载原理</h5><p>组件渲染流程：</p>
<ol>
<li>从根实例入手进行实例的挂载，如果有手写的 <code>render</code> 函数，则直接进入 <code>$mount</code> 挂载流程；</li>
<li>只有 <code>template</code> 模板则需要对模板进行解析，分为将模板解析为 <code>AST</code> 树，以及根据不同平台生成执行代码；</li>
<li><code>$mount</code> 流程也分为两步：第一步是将 <code>render</code> 函数生成 <code>Vnode</code> 树，子组件会以 <code>vue-component-</code>  为 <code>tag</code> 标记，另一步是把 <code>Vnode</code> 渲染成真正的 DOM 节点；</li>
<li>创建真实节点过程中，如果遇到子的占位符组件会进行子组件的实例化过程，然后回到流程的第一步</li>
</ol>
<h5 id="父组件处理"><a href="#父组件处理" class="headerlink" title="父组件处理"></a>父组件处理</h5><p>父组件会优先于子组件进行实例的挂载，<code>createComponent</code> 执行了创建子占位节点 <code>Vnode</code> 的过程：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 创建子 Vnode 过程</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createComponent</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function"> Ctor, <span class="hljs-comment">// 子类构造器</span></span></span><br><span class="hljs-params"><span class="hljs-function"> data,</span></span><br><span class="hljs-params"><span class="hljs-function"> context, <span class="hljs-comment">// vm 实例</span></span></span><br><span class="hljs-params"><span class="hljs-function"> children, <span class="hljs-comment">// 父组件需要分发的内容</span></span></span><br><span class="hljs-params"><span class="hljs-function"> tag <span class="hljs-comment">// 子组件占位符</span></span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>	...<br>  <span class="hljs-comment">// 创建子 vnode，其中父保留的 children 属性会以选项的形式传递给 Vnode</span><br>  <span class="hljs-keyword">var</span> vnode = <span class="hljs-keyword">new</span> VNode(<br>    (<span class="hljs-string">&#x27;vue-component-&#x27;</span> + (Ctor.cid) + (name ? (<span class="hljs-string">&#x27;-&#x27;</span> + name) : <span class="hljs-string">&#x27;&#x27;</span>)),<br>    data, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, <span class="hljs-literal">undefined</span>, context,<br>    &#123; Ctor, propsData, listeners, tag, chilren &#125;,<br>    asyncFactory<br>  )<br>&#125;<br><span class="hljs-comment">// Vnode 构造器</span><br><span class="hljs-keyword">var</span> VNode = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">VNode</span> (<span class="hljs-params">tag, data, children, text, elm, context, componentOptions, asyncFactory</span>) </span>&#123;<br>  ...<br>  <span class="hljs-built_in">this</span>.coomponentOptions = componentOptions <span class="hljs-comment">// 子组件的选项相关</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>createComponent</code> 函数接收的第四个参数 <code>children</code> 就是父组件需要分发的内容。在创建 <code>Vnode</code> 的过程中，会将 <code>componentOptions</code> 配置传入 <code>Vnode</code> 构造器中。<strong>最终 <code>Vnode</code> 中父组件需要分发的内容以 <code>componentOptions</code> 属性的形式存在</strong>。</p>
<h5 id="子组件流程"><a href="#子组件流程" class="headerlink" title="子组件流程"></a>子组件流程</h5><p>父组件的最后一个阶段是将 <code>Vnode</code> 渲染为真正的 DOM 节点，在这个过程中遇到子 <code>Vnode</code> 会优先实例化子组件并进行一系列子组件的渲染流程。</p>
<p>子组件初始化会先调用 <code>init</code> 方法，子组件会嗲用 <code>initInternalComponent</code> 方法拿到父组件拥有的相关配置信息，并赋值给子组件自身的配置选项。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 子组件的初始化</span><br>Vue.prototype._init = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">options</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> (options &amp;&amp; options._isComponents) &#123;<br>    initInternalComponent(vm, options)<br>  &#125;<br>  initRender(vm)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initInternalComponent</span> (<span class="hljs-params">vm, options</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> opts = vm.$options = <span class="hljs-built_in">Object</span>.create(vm.constructor.options)<br>  <span class="hljs-keyword">var</span> parentVnode = options._parentVnode<br>  opts.parent = options.parent<br>  opts._parentVnode = parentVnode<br>  <span class="hljs-comment">// componentOptions 为子 vnode 记录的相关信息</span><br>  <span class="hljs-keyword">var</span> vnodeComponentOptions = parentVnode.componentOptions<br>  opts.propsData = vnodeComponentOptions.propsData<br>  opts._parentListeners = vnodeComponentOptions.listeners<br>  <span class="hljs-comment">// 父组件需要分发的内容赋值给子选项配置的 _renderChildren</span><br>  opts._renderChildren = vnodeComponentOptions.children<br>  opts._componentTag = vnodeComponentOptions.tag<br>  <span class="hljs-keyword">if</span> (options.render) &#123;<br>    opts.render = options.render<br>    opts.staticRenderFns = options.staticRenderFns<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>最终<strong>在子组件实例的配置中拿到了父组件保存的分发内容，记录在组件实例 <code>$options._renderChildren</code> 中</strong>。</p>
<p>然后是 <code>initRender</code> 阶段，在这个过程会<strong>将配置的 <code>_renderChildren</code> 属性做规范化处理，并将他赋值给子实例上的 <code>$slot</code> 属性</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initRender</span> (<span class="hljs-params">vm</span>) </span>&#123;<br>  ...<br>  vm.$solts = resolveSlots(options._renderChildren, renderContext) <span class="hljs-comment">// $slots 拿到了子占位符节点的 _renderChildren（即需要分发的内容），保留作为子实例的属性</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveSlots</span> (<span class="hljs-params">children, context</span>) </span>&#123;<br>  <span class="hljs-comment">// children 是父组件需要分发到子组件的 Vnode 节点，如果不存在，则没有分发内容</span><br>  <span class="hljs-keyword">if</span> (!children || !children.length) &#123;<br>    <span class="hljs-keyword">return</span> &#123;&#125;<br>  &#125;<br>  <span class="hljs-keyword">var</span> slots = &#123;&#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = children.length; i &lt; l; i++) &#123;<br>    <span class="hljs-keyword">var</span> child = children[i]<br>    <span class="hljs-keyword">var</span> data = child.data<br>    <span class="hljs-comment">// remove slot attribute if the node is resolved as a Vue slot node</span><br>    <span class="hljs-keyword">if</span> (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123;<br>      <span class="hljs-keyword">delete</span> data.attrs.slot<br>    &#125;<br>    <span class="hljs-comment">// named slots should only be respected if the vnode was rendered in the</span><br>    <span class="hljs-comment">// same context.</span><br>    <span class="hljs-comment">// 分支1为具名插槽的逻辑，放后分析</span><br>    <span class="hljs-keyword">if</span> ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != <span class="hljs-literal">null</span>) &#123;<br>      <span class="hljs-keyword">var</span> name = data.slot<br>      <span class="hljs-keyword">var</span> slot = (slots[name] || (slots[name] = []))<br>      <span class="hljs-keyword">if</span> (child.tag === <span class="hljs-string">&#x27;template&#x27;</span>) &#123;<br>        slot.push.apply(slot, child.children || [])<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        slot.push(child)<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 普通插槽的重点，核心逻辑是构造 &#123; default: [children] &#125; 对象返回</span><br>      (slots.default || (slots.default = [])).push(child)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> slots<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>普通插槽的核心在 <code>(slots.default || (slots.default = [])).push(child)</code>，即以数组的形式赋值给 <code>default</code> 属性，并以 <code>$slot</code> 属性的形式保存在子组件的实例中。</p>
<p>随后子组件也会走挂载的流程，同样会经历 <code>template</code> 模板到 <code>render</code> 函数，再到 <code>Vnode</code>，最后渲染真实 <code>DOM</code> 的过程。解析 <code>AST</code> 阶段，<code>slot</code> 标签和其他普通标签处理相同，<strong>不同之处在于 <code>AST</code> 生成 <code>render</code> 函数阶段，对 <code>slot</code> 标签的处理，会使用 <code>_t函数</code> 进行包裹</strong>。</p>
<p>子组件渲染的大致流程：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// ast 生成 render 函数</span><br><span class="hljs-keyword">var</span> code = geterate(ast, options)<br><span class="hljs-comment">// generate 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">generate</span>(<span class="hljs-params">ast, options</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> state = <span class="hljs-keyword">new</span> CodegenState(options)<br>  <span class="hljs-keyword">var</span> code = ast ? genElement(ast, state) : <span class="hljs-string">&#x27;c_(&quot;div&quot;)&#x27;</span><br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">render</span>: (<span class="hljs-string">&#x27;with (this) &#123; return &#x27;</span> + code <span class="hljs-string">&#x27;&#125;&#x27;</span>),<br>    <span class="hljs-attr">staticRenderFns</span>: state.staticRenderFnc<br>  &#125;<br>&#125;<br><span class="hljs-comment">// genElement 实现</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genElement</span> (<span class="hljs-params">el, state</span>) </span>&#123;<br>  <span class="hljs-comment">// 针对 slot 标签的处理走 ```genSlot``` 分支</span><br>  <span class="hljs-keyword">if</span> (el.tag === <span class="hljs-string">&#x27;slot&#x27;</span>) &#123;<br>    <span class="hljs-keyword">return</span> genSlot(el, state)<br>  &#125;<br>&#125;<br><span class="hljs-comment">// 核心 genSlot 原理</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">genSlot</span> (<span class="hljs-params">el, state</span>) </span>&#123;<br>  <span class="hljs-comment">// slotName 记录着插槽的唯一标志名，默认为 default</span><br>  <span class="hljs-keyword">var</span> slotName = el.slotName || <span class="hljs-string">&#x27;&quot;default&quot;&#x27;</span><br>  <span class="hljs-comment">// 如果子组件的插槽还有子元素，则会递归调执行子元素的创建过程</span><br>  <span class="hljs-keyword">var</span> children = genChildren(el, state)<br>  <span class="hljs-comment">// 通过 _t 函数包裹</span><br>  <span class="hljs-keyword">var</span> res = <span class="hljs-string">&#x27;_t(&#x27;</span> + slotName + (children ? <span class="hljs-string">&#x27;,&#x27;</span> + children : <span class="hljs-string">&#x27;&#x27;</span>)<br>  <span class="hljs-comment">// 具名插槽的其他处理</span><br>  ...<br>  <span class="hljs-keyword">return</span> res + <span class="hljs-string">&#x27;)&#x27;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>最终子组件的 render 函数为 <code>&quot;with (this) &#123; return _c(&#39;div&#39;, &#123; staticClass: &quot;child&quot; &#125;, [_t(&quot;defailt&quot;)], 2)&#125;&quot;</code>；</p>
<p>接下来是<strong>将子组件渲染为 <code>Vnode</code> 的过程，render 函数执行阶段会执行 <code>_t()</code> 函数，<code>_t</code> 函数是 <code>renderSlot</code> 函数简写，它会在 Vnode 树中进行分发内容的替换</strong>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// target._t = renderSlot</span><br><br><span class="hljs-comment">// render 函数渲染 Vnode 函数</span><br>Vue.prototype._render = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> _parentVnode = ref._parentVnode<br>  <span class="hljs-keyword">if</span> (_parentVnode) &#123;<br>    <span class="hljs-comment">// slot 的规范化处理并赋值给 $scopedSlots 属性</span><br>    vm.$scopedSlots = normalizeScopeSlots(<br>      _parentVnode.data.scopedSlots,<br>      vm.$slots, <span class="hljs-comment">//记录父组件的插槽内容</span><br>      vm.$scopedSlots<br>    )<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>拿到 <code>$scopedSlots</code> 属性后会执行真正的 <code>render</code> 函数，其中 <code>_t</code> 代码如下：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 渲染 slot 组件内容</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSlot</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">name,</span></span><br><span class="hljs-params"><span class="hljs-function"> fallback, <span class="hljs-comment">// slot 插槽后备内容</span></span></span><br><span class="hljs-params"><span class="hljs-function"> props, <span class="hljs-comment">// 子传给父的值(作用域插槽)</span></span></span><br><span class="hljs-params"><span class="hljs-function"> bindObject</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// scopedSlotFn 拿到父组件插槽的执行函数，默认 slotName 为 default</span><br>  <span class="hljs-keyword">var</span> scopedSlotFn = <span class="hljs-built_in">this</span>.$scopedSlots[name]<br>  <span class="hljs-keyword">var</span> nodes<br>  <span class="hljs-comment">// 具名插槽分支</span><br>  <span class="hljs-keyword">if</span> (scopedSlotFn) &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>		<span class="hljs-comment">// 如果父占位符组件没有插槽内容，this.$slots 不会有值，此时 vnode 节点为后备内容节点</span><br>    nodes = <span class="hljs-built_in">this</span>.$slots[name] || fallback<br>  &#125;<br>  <br>  <span class="hljs-keyword">var</span> target = props &amp;&amp; props.slot<br>  <span class="hljs-keyword">if</span> (target) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.$createElement(<span class="hljs-string">&#x27;template&#x27;</span>, &#123; <span class="hljs-attr">slot</span>: target &#125;, nodes)<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> nodes<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p><code>renderSlot</code> 执行过程会拿到父组件需要分发的内容，最终 <code>Vnode</code> 树将父元素的插槽替换掉子组件的 <code>slot</code> 组件，最后进行<strong>子组件真实节点的渲染</strong>。</p>
<h4 id="具有后备内容的插槽"><a href="#具有后备内容的插槽" class="headerlink" title="具有后备内容的插槽"></a>具有后备内容的插槽</h4><p>为一个插槽设置具体的后备内容，会在没有提供内容的时候被渲染：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> child = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div class=&quot;child&quot;&gt;&lt;slot&gt;后备内容&lt;/slot&gt;&lt;/div&gt;`</span><br>&#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    child<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`&lt;div id=&quot;app&quot;&gt;&lt;child&gt;&lt;/child&gt;&lt;/div&gt;`</span><br>&#125;)<br><span class="hljs-comment">// 父组件没有插槽内容，子的 slot 会渲染后备内容</span><br><span class="hljs-comment">// &lt;div class=&quot;child&quot;&gt;后备内容&lt;/div&gt;</span><br></code></pre></div></td></tr></table></figure>

<p>与普通插槽渲染流程的不同：</p>
<ol>
<li>父组件渲染该过程中没有需要分发的子节点，所以不再需要 <code>componentOptions.children</code> 属性来标记内容；</li>
<li>子组件也拿不到 <code>$slot</code> 属性的内容；</li>
<li>子组件的 <code>render</code> 函数最后在 <code>_t</code> 函数参数会携带第二个参数，该参数以数组的形式传入 <code>slot</code> 插槽的后备内容；</li>
<li>渲染子 <code>Vnode</code> 执行 <code>renderSlot(_t)</code> 函数时，第二个参数 fallback 有值，且 <code>this.$slots</code> 没值，<code>vnode</code> 会直接返回后备内容作为渲染对象。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSlot</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">name,</span></span><br><span class="hljs-params"><span class="hljs-function"> fallback, <span class="hljs-comment">// slot 插槽的后备内容</span></span></span><br><span class="hljs-params"><span class="hljs-function"> props, <span class="hljs-comment">// 子传给父的值(作用域插槽)</span></span></span><br><span class="hljs-params"><span class="hljs-function"> bindObject</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-keyword">if</span> () &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// fallback 为后备内容</span><br>    <span class="hljs-comment">// 如果父占位符组件没有插槽内容，this.$slots 不会有值，此时 vnode 节点为后备内容节点</span><br>    nodes = <span class="hljs-built_in">this</span>.$slots[name] || fallback<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<blockquote>
<p>父级模板里的所有内容都是在父级作用域中编译的；子模版的所有内容都是在子作用中编译的。</p>
</blockquote>
<h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>可以使用 <code>&lt;slot&gt;</code> 的 <code>name</code> 属性来灵活的使用插槽进行组件的开发：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> child = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;div class=&quot;child&quot;&gt;</span><br><span class="hljs-string">  	&lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">  	&lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span><br><span class="hljs-string">  &lt;/div&gt;`</span><br>&#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    child<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="hljs-string">  	&lt;child&gt;</span><br><span class="hljs-string">  		&lt;template v-slot:header&gt;</span><br><span class="hljs-string">  			&lt;span&gt;头部&lt;/span&gt;</span><br><span class="hljs-string">  		&lt;/template&gt;</span><br><span class="hljs-string">  		&lt;template v-slot:footer&gt;</span><br><span class="hljs-string">  			&lt;span&gt;底部&lt;/span&gt;</span><br><span class="hljs-string">  		&lt;/template&gt;</span><br><span class="hljs-string">  	&lt;/child&gt;</span><br><span class="hljs-string">  &lt;/div&gt;`</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<p>最终渲染结果：</p>
<figure class="highlight html"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>头部<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>底部<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></div></td></tr></table></figure>

<h5 id="模板编译的差别"><a href="#模板编译的差别" class="headerlink" title="模板编译的差别"></a>模板编译的差别</h5><p>父组件在编译 <code>AST</code> 阶段和普通节点的过程不同，具名插槽一般会在 <code>template</code> 模板中使用 <code>v-slot:</code> 来标注指定插槽，这一阶段会在编译阶段特殊处理，最终的 <code>AST</code> 树会写道 <code>scopedSlots</code> 用来记录具名插槽的内容：</p>
<figure class="highlight json"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs json">&#123;<br>  scopedSlots: &#123;<br>    footer: &#123; ... &#125;,<br>    header: &#123; ... &#125;<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">with</span> (<span class="hljs-built_in">this</span>) &#123;<br>  <span class="hljs-keyword">return</span> _c(<br>    <span class="hljs-string">&#x27;div&#x27;</span>,<br>    &#123; <span class="hljs-attr">attrs</span>: &#123; <span class="hljs-string">&#x27;id&#x27;</span>: <span class="hljs-string">&#x27;app&#x27;</span> &#125; &#125;,<br>    [_c(<span class="hljs-string">&#x27;child&#x27;</span>, &#123; <span class="hljs-attr">scopedSlots</span>: _u([<br>      &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;header&#x27;</span>, <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> [_c(<span class="hljs-string">&#x27;span&#x27;</span>, [_v(<span class="hljs-string">&#x27;头部&#x27;</span>)])]<br>      &#125;, <span class="hljs-attr">proxy</span>: <span class="hljs-literal">true</span> &#125;,<br>      &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&#x27;footer&#x27;</span>, <span class="hljs-attr">fn</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">return</span> [_c(<span class="hljs-string">&#x27;span&#x27;</span>, [_v(<span class="hljs-string">&#x27;底部&#x27;</span>)])]<br>      &#125;, <span class="hljs-attr">proxy</span>: <span class="hljs-literal">true</span> &#125;<br>    ])&#125;)],<br>    <span class="hljs-number">1</span><br>  )<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>父组件的插槽内容用 <code>_u</code> 函数封装成数组的形式，并赋值到 <code>scopedSlots</code> 属性中，而每一个插槽以对象形式描述，<code>key</code> 代表插槽名，<code>fn</code> 是一个返回执行结果的函数。</p>
<h5 id="父组件-vnode-生成阶段"><a href="#父组件-vnode-生成阶段" class="headerlink" title="父组件 vnode 生成阶段"></a>父组件 vnode 生成阶段</h5><p>照例进入父组件生成 <code>Vnode</code> 阶段，其中 <code>_u</code> 函数的原形是 <code>resolveScopedSlots</code>，其中一个参数就是插槽数组：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// vnode 生成阶段针对具名插槽的处理 _u (target._u = resolveScopedSlots)</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">resolveScopedSlots</span> (<span class="hljs-params">fns, res, hasDynamicKeys, contentHashKey</span>) </span>&#123;<br>  res = res || &#123; <span class="hljs-attr">$stable</span>: !hasDynamicKeys &#125;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; fns.length; i++) &#123;<br>    <span class="hljs-keyword">var</span> slot = fns[i]<br>    <span class="hljs-comment">// fn 是数组需要递归处理</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">Array</span>.isArray(slot)) &#123;<br>      resolveScopedSlots(slot, res, hasDynamicKeys)<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (slot) &#123;<br>      <span class="hljs-comment">// marker for reverse proxying v-slot without scope on this.$slots</span><br>      <span class="hljs-keyword">if</span> (slot.proxy) &#123; <span class="hljs-comment">// 针对 proxy 的处理</span><br>        slot.fn.proxy = <span class="hljs-literal">true</span><br>      &#125;<br>      <span class="hljs-comment">// 最终返回一个对象，对象以 slotname 作为属性，以 fn 作为值</span><br>      res[slot.key] = slot.fn<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">if</span> (contentHashKey) &#123;<br>    (res).$key = contentHashKey<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>最终父组件的 <code>vnode</code> 节点的 <code>data</code> 属性上多了 <code>scopedSlots</code> 数组。具名插槽和普通插槽实现上有明显的不同：</p>
<ul>
<li>普通插槽是以 <code>componentOptions.child</code> 的形式保留在父组件中；</li>
<li>具名插槽是以 <code>scopedSlots</code> 属性的形式存储到 <code>data</code> 属性中</li>
</ul>
<h5 id="子组件渲染-Vnode-过程"><a href="#子组件渲染-Vnode-过程" class="headerlink" title="子组件渲染 Vnode 过程"></a>子组件渲染 Vnode 过程</h5><p>子组件在解析成 <code>AST</code> 树阶段的不同，在于对 <code>slot</code> 标签的 <code>name</code> 属性的解析，而在 <code>render</code> 生成 <code>Vnode</code> 过程中，<code>slot</code> 的规范化处理针对具名插槽会进行特殊的处理：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">vm.$scopedSlots = normalizeScopedSlots(<br>  _parentVnode.data.scopedSlots, <span class="hljs-comment">// 此时的第一个参数会拿到父组件插槽相关的数据</span><br>  vm.$slots, <span class="hljs-comment">// 记录父组件的插槽内容</span><br>  vm.$scopedSlots<br>)<br></code></pre></div></td></tr></table></figure>

<p>最终子组件实例上的 <code>$scopedSlots</code> 属性会携带父组件插槽相关的内容。</p>
<h5 id="子组件渲染真实-DOM"><a href="#子组件渲染真实-DOM" class="headerlink" title="子组件渲染真实 DOM"></a>子组件渲染真实 DOM</h5><p>执行子 <code>render</code> 函数中的 <code>_t</code> 方法，最终的核心是执行 <code>nodes = scopedSlotFn(props)</code>，也就是执行 <code>function () &#123; return [_c(&#39;span&#39;, [_v(&#39;头部&#39;)])] &#125;</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 渲染 slot 组件内容</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">renderSlot</span> (<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">name,</span></span><br><span class="hljs-params"><span class="hljs-function"> fallback, <span class="hljs-comment">// slot 插槽后备内容</span></span></span><br><span class="hljs-params"><span class="hljs-function"> props, <span class="hljs-comment">// 子传给父的值(作用域插槽)</span></span></span><br><span class="hljs-params"><span class="hljs-function"> bindObject</span></span><br><span class="hljs-params"><span class="hljs-function"></span>) </span>&#123;<br>  <span class="hljs-comment">// scopedSlotFn 拿到父组件插槽的执行函数，默认 slotName 为 default</span><br>  <span class="hljs-keyword">var</span> scopedSlotFn = <span class="hljs-built_in">this</span>.$scopedSlots[name]<br>  <span class="hljs-keyword">var</span> nodes<br>  <span class="hljs-comment">// 针对具名插槽，特点是 $scopedSlots 有值</span><br>  <span class="hljs-keyword">if</span> (scopedSlotFn) &#123;<br>    props = props || &#123;&#125;<br>    <span class="hljs-keyword">if</span> (bindObject) &#123;<br>			<span class="hljs-keyword">if</span> (!isObject(bindObject)) &#123;<br>        warn()<br>      &#125;<br>      props = extend(extend(&#123;&#125;, bindObject), props)<br>    &#125;<br>    <span class="hljs-comment">// 执行时将子组件传递给父组件的值传入 fn</span><br>    nodes = scopedSlotFn(props) || fallback<br>  &#125;<br>  ...<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>至此子组件通过 <code>slotName</code> 找到了对应父组件的插槽内容。</p>
<h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>可以利用作用域插槽让父组件的插槽内容访问到子组件的数据，具体就是在子组件中以属性的方式记录在子组件中父组件通过 <code>v-slot:[name]=[props]</code> 的形式拿到子组件传递的值，子组件元素上的特性称为 <strong>插槽 Props</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">var</span> child = &#123;<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;div&gt;</span><br><span class="hljs-string">  	&lt;slot :user=&quot;user&quot;&gt;</span><br><span class="hljs-string">  	&lt;/slot&gt;</span><br><span class="hljs-string">  &lt;/div&gt;`</span>,<br>  data () &#123;<br>    <span class="hljs-keyword">return</span> &#123;<br>      <span class="hljs-attr">user</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;AgoniLay&#x27;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> vm = <span class="hljs-keyword">new</span> Vue(&#123;<br>  <span class="hljs-attr">el</span>: <span class="hljs-string">&#x27;#app&#x27;</span>,<br>  <span class="hljs-attr">components</span>: &#123;<br>    child<br>  &#125;,<br>  <span class="hljs-attr">template</span>: <span class="hljs-string">`</span><br><span class="hljs-string">  &lt;div id=&quot;app&quot;&gt;</span><br><span class="hljs-string">  	&lt;child&gt;</span><br><span class="hljs-string">  		&lt;template v-slot:default=&quot;slotProps&quot;&gt;</span><br><span class="hljs-string">  			&#123;&#123; slotProps.user.name &#125;&#125;</span><br><span class="hljs-string">  		&lt;/template&gt;</span><br><span class="hljs-string">  	&lt;/child&gt;</span><br><span class="hljs-string">  &lt;/div&gt;`</span><br>&#125;)<br></code></pre></div></td></tr></table></figure>

<h5 id="父组件编译阶段"><a href="#父组件编译阶段" class="headerlink" title="父组件编译阶段"></a>父组件编译阶段</h5><p>与具名插槽的用法基本相同，区别在于 <code>v-slot</code> 定义了一个 <code>插槽Props</code> 的名字，生成 <code>render</code> 函数阶段 <code>fn</code> 函数会携带 <code>props</code> 参数传入。</p>
<h5 id="子组件渲染"><a href="#子组件渲染" class="headerlink" title="子组件渲染"></a>子组件渲染</h5><p>在子组件编译阶段，<code>:user=&quot;user&quot;</code> 会以属性的形式解析，最终在 <code>render</code> 函数生成阶段以对象参数的形式传递 <code>_t</code> 函数。</p>
<p>子组件渲染 Vnode 阶段，会执行 <code>renderSlot</code> 函数，对于作用域插槽的处理，集中体现在函数传入的第三个参数 <code>props</code>。</p>
<h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>子父组件之间的通信完全可以通过事件 <code>$emit, $on</code> 的形式来完成，而增加一个 <code>插槽Props</code> 的原因：</p>
<blockquote>
<p>插槽 Props 允许将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的结果。</p>
</blockquote>
<h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的 DOM。</p>
<figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-comment">// 修改数据</span><br>vm.msg = <span class="hljs-string">&#x27;Hello&#x27;</span><br><span class="hljs-comment">// DOM 还没有更新</span><br>Vue.nextTick(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// DOM 更新了</span><br>&#125;)<br><br><span class="hljs-comment">// 作为一个 Promise 使用 (2.1.0 起新增)</span><br>Vue.nextTick()<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>	  <span class="hljs-comment">// DOM 更新了</span><br>	&#125;)<br></code></pre></div></td></tr></table></figure>

<h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">Promise</span> !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; inNative(<span class="hljs-built_in">Promise</span>)) &#123;<br>  <span class="hljs-keyword">const</span> p = <span class="hljs-built_in">Promise</span>.resolve()<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    p.then(flushCallbacks)<br>    <span class="hljs-keyword">if</span> (isIOS) <span class="hljs-built_in">setTimeout</span>(noop)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!isIE &amp;&amp; <span class="hljs-keyword">typeof</span> MutationObserver !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; (<br>  isNative(MutationObserver) ||<br>  MutationObserver.toString() === <span class="hljs-string">&#x27;[Object MutationObserverConstructor]&#x27;</span><br>)) &#123;<br>	<span class="hljs-keyword">let</span> counter = <span class="hljs-number">1</span><br>  <span class="hljs-keyword">const</span> observer = <span class="hljs-keyword">new</span> MutationObserver(flushCallbacks)<br>  <span class="hljs-keyword">const</span> textNode = <span class="hljs-built_in">document</span>.createTextNode(Stirng(counter))<br>  observer.observe(textNode, &#123;<br>    <span class="hljs-attr">characterData</span>: <span class="hljs-literal">true</span><br>  &#125;)<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    counter = (counter + <span class="hljs-number">1</span>) % <span class="hljs-number">2</span><br>    textNode.data = Stirng(counter)<br>  &#125;<br>  isUsingMicroTask = <span class="hljs-literal">true</span><br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> setImmediate !== <span class="hljs-string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;<br>  timerFunc = <span class="hljs-function">() =&gt;</span> &#123;<br>    setImmediate(flushCallbacks)<br>  &#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  timerFun = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(flushCallbacks, <span class="hljs-number">0</span>)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>

<p>首先进行条件判断:</p>
<ul>
<li>如果支持 Promise 就使用 <code>Promise</code>;</li>
<li>如果不支持则使用 <code>MutationObserver</code>，会在指定的 DOM 发生变化时被调用；</li>
<li>如果不支持则使用 <code>setImmediate</code>，但只有最新版 IE 和 node 支持；</li>
<li>均不支持则使用 <code>setTimeout</code>。</li>
</ul>
<h4 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h4><p>JS 是单线程，JS 里的任务分为两种：</p>
<ul>
<li>同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，阻塞；</li>
<li>异步任务（asynchronous）：不进入主线程，而进入”任务队列”（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li>
</ul>
<p>JS 任务又分为宏任务和微任务：</p>
<ul>
<li>宏任务（macrotask）：setTimeout、setInterval、setImmediate、I/O、UI rendering</li>
<li>微任务（microtask）：promise.then、process.nextTick、MutationObserver、queueMicrotask（开启一个微任务）</li>
</ul>
<p>宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面，浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前对页面进行重新渲染（task -&gt; 渲染 -&gt; task -&gt; …）</p>
<p>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，只要执行栈中没有其他的 JS 代码正在执行且每个宏任务执行完毕，微任务队列就会立即执行。</p>
<p>在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。</p>
<blockquote>
<p>使用微任务的时机：晚于当前本轮事件循环的 Call Stack（调用栈）中的代码（宏任务），遭遇事件处理函数和定时器的回调函数。</p>
<p>原因：</p>
<ul>
<li>减少操作中用户可感知到的延迟</li>
<li>确保任务顺序的一致性</li>
<li>批量操作的优化</li>
</ul>
</blockquote>
<p>执行流程：</p>
<img src="/2022/01/24/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220411013615619.png" srcset="/img/three2.gif" lazyload class title="JS 执行流程">

<p>故 nextTick 要优先调用 <code>Promise</code> 和 <code>MutationObserver</code> 等微任务，会在执行栈空闲时立即执行，响应速度会比 setTimeout 等更快，无需等渲染。</p>
<h1 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h1><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js"><br></code></pre></div></td></tr></table></figure>


            </div>
            <hr>
            <div>
              <div class="post-metas mb-3">
                
                
              </div>
              
                <p class="note note-warning">
                  
                    本博客所有文章除特别声明外，均为本人原创，转载请注明出处！
                  
                </p>
              
              
                <div class="post-prevnext">
                  <article class="post-prev col-6">
                    
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/10/Sass/">
                        <span class="hidden-mobile">Sass</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
              <!-- Comments -->
              <article class="comments" id="comments">
                
                  
                
                
  <div id="valine"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#valine', function() {
      Fluid.utils.createScript('https://cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', function() {
        var options = Object.assign(
          {"appId":"fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz","appKey":"k49y92c0BEE6zL2mCA2AUHKu","placeholder":"说点什么","path":"window.location.pathname","avatar":"monsterid","meta":["nick","mail","link"],"pageSize":10,"lang":"zh-CN","highlight":false,"recordIP":false,"serverURLs":"https://fmlk1v2u.lc-cn-n1-shared.com","emojiCDN":null,"emojiMaps":null,"enableQQ":false,"requiredFields":[]},
          {
            el: "#valine",
            path: window.location.pathname
          }
        )
        new Valine(options);
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


              </article>
            
          </article>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->

  <div class="col-lg-7 mx-auto nopadding-x-md">
    <div class="container custom post-custom mx-auto">
      <img src="/img/万事胜意.gif" class="rounded mx-auto d-block mt-5" style="width:150px; height:150px;"> <h5 style="text-align: center; margin-top: 1rem;">谢谢您的光临噢！！！</h5> 
    </div>
  </div>


    

    
      <a id="scroll-top-button" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
    

    
  </main>

  <footer class="text-center mt-5 py-3">
  <div class="footer-content">
     <span>张宝文</span> ❤ <span>郑佳丽</span>  
	<!--《添加网站运行时间 -->
<br/>

<span id="timeDate">载入天数...</span><span id="times">载入时分秒...</span>
<script>
var now = new Date(); 

function createtime() {
    //此处修改你的建站时间或者网站上线时间
    var grt = new Date('07/28/2020 17:53:14');
    now.setTime(now.getTime() + 250);
    days = (now - grt) / 1000 / 60 / 60 / 24;

    dnum = Math.floor(days);
    hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum);
    hnum = Math.floor(hours);
    if (String(hnum).length == 1) {
        hnum = "0" + hnum;
    }
    minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
    mnum = Math.floor(minutes);
    if (String(mnum).length == 1) {
        mnum = "0" + mnum;
    }
    seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
    snum = Math.round(seconds);
    if (String(snum).length == 1) {
        snum = "0" + snum;
    }
    document.getElementById("timeDate").innerHTML = " 本站已安全运行 " + dnum + " 天 ";
    document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
}
setInterval("createtime()", 250);
</script>

<!-- 添加网站运行时间》-->
  </div>
  
  <div class="statistics">
    
    

    
      
        <!-- 不蒜子统计PV -->
        <span id="busuanzi_container_site_pv" style="display: none">
            总访问量 
            <span id="busuanzi_value_site_pv"></span>
             次
          </span>
      
      
        <!-- 不蒜子统计UV -->
        <span id="busuanzi_container_site_uv" style="display: none">
            总访客数 
            <span id="busuanzi_value_site_uv"></span>
             人
          </span>
      
    
  </div>


  

  
</footer>


  <!-- SCRIPTS -->
  
  <script  src="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/nprogress@0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" ></script>
<script  src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.0/dist/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>

<!-- Plugins -->


  
    
      <script  src="/js/img-lazyload.js" ></script>
    
  



  



  <script  src="https://cdn.jsdelivr.net/npm/tocbot@4.12.3/dist/tocbot.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.5.7/dist/jquery.fancybox.min.js" ></script>



  <script  src="https://cdn.jsdelivr.net/npm/anchor-js@4.3.1/anchor.min.js" ></script>



  <script defer src="https://cdn.jsdelivr.net/npm/clipboard@2.0.8/dist/clipboard.min.js" ></script>



  <script  src="/js/local-search.js" ></script>



  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  <script  src="https://cdn.jsdelivr.net/npm/typed.js@2.0.12/lib/typed.min.js" ></script>
  <script src="https://sdk.jinrishici.com/v2/browser/jinrishici.js" charset="utf-8"></script>

  <script>
    function typing(id, title){
        var typed = new Typed('#' + id, {
            strings: [
              '  ',
              title + "&nbsp;",
            ],
            cursorChar: "❤",
            typeSpeed: 150,
            loop: false,
        });
        typed.stop();
        $(document).ready(function () {
            $(".typed-cursor").addClass("h2");
            typed.start();
        });
    }

    
        typing("subtitle", document.getElementById('subtitle').title)
    

  </script>













  
<script src="//cdn.jsdelivr.net/gh/bynotes/texiao/source/js/yinghua.js"></script>



<!-- 主题的启动项 保持在最底部 -->
<script  src="/js/boot.js" ></script>

<script async>window.onload=function(){var a=document.createElement('script'),b=document.getElementsByTagName('script')[0];a.type='text/javascript',a.async=!0,a.src='/sw-register.js?v='+Date.now(),b.parentNode.insertBefore(a,b)};</script></body></html>