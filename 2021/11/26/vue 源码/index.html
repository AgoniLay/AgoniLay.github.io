<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Vue 源码剖析 | AgoniLay的博客</title><meta name="keywords" content="源码,前端框架,vue"><meta name="author" content="AgoniLay"><meta name="copyright" content="AgoniLay"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="准备工作认识 FlowFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，了解 Flow 有利于阅读源码。 使用安装命令： 1npm install flow-bin -g  flow 初始化： 会在本目录下生成一个 .flowconfig 文件 1flow init  ![](vue 源码&#x2F;image-20211">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue 源码剖析">
<meta property="og:url" content="https://agonilay.github.io/2021/11/26/vue%20%E6%BA%90%E7%A0%81/index.html">
<meta property="og:site_name" content="AgoniLay的博客">
<meta property="og:description" content="准备工作认识 FlowFlow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，了解 Flow 有利于阅读源码。 使用安装命令： 1npm install flow-bin -g  flow 初始化： 会在本目录下生成一个 .flowconfig 文件 1flow init  ![](vue 源码&#x2F;image-20211">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://img2.baidu.com/it/u=4070430052,2876771977&fm=26&fmt=auto">
<meta property="article:published_time" content="2021-11-26T09:22:35.000Z">
<meta property="article:modified_time" content="2022-04-14T06:40:13.484Z">
<meta property="article:author" content="AgoniLay">
<meta property="article:tag" content="源码">
<meta property="article:tag" content="前端框架">
<meta property="article:tag" content="vue">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://img2.baidu.com/it/u=4070430052,2876771977&fm=26&fmt=auto"><link rel="shortcut icon" href="/img/zoro3.jpg"><link rel="canonical" href="https://agonilay.github.io/2021/11/26/vue%20%E6%BA%90%E7%A0%81/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//hm.baidu.com"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "https://hm.baidu.com/hm.js?050530911bbf514fb098003dafd2a51e";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Vue 源码剖析',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-04-14 14:40:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/zoro3.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">35</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">47</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://img2.baidu.com/it/u=4070430052,2876771977&amp;fm=26&amp;fmt=auto')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">AgoniLay的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> 清单</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 电影</span></a></li><li><a class="site-page child" href="/Gallery/"><i class="fa-fw fas fa-images"></i><span> 照片</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Vue 源码剖析</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-26T09:22:35.000Z" title="发表于 2021-11-26 17:22:35">2021-11-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-04-14T06:40:13.484Z" title="更新于 2022-04-14 14:40:13">2022-04-14</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%89%8D%E7%AB%AF/">前端</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">31.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>147分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Vue 源码剖析"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，了解 Flow 有利于阅读源码。</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install flow-bin -g</span><br></pre></td></tr></table></figure>

<p>flow 初始化：</p>
<p>会在本目录下生成一个 <code>.flowconfig</code> 文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow init</span><br></pre></td></tr></table></figure>

<p>![](vue 源码/image-20211112125710450.png)</p>
<p>在文件中加入：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow  */</span></span><br><span class="line">或</span><br><span class="line"><span class="comment">// @flow</span></span><br></pre></td></tr></table></figure>

<p>就会被 Flow 检查，否则会跳过</p>
<p>运行检查：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow check</span><br></pre></td></tr></table></figure>

<h3 id="为什么用-Flow"><a href="#为什么用-Flow" class="headerlink" title="为什么用 Flow"></a>为什么用 Flow</h3><p>JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。</p>
<blockquote>
<p>类型检查：就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。</p>
</blockquote>
<p>项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。</p>
<p>Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。</p>
<p>选择 Flow 的原因：因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。</p>
<h3 id="Flow-的工作方式"><a href="#Flow-的工作方式" class="headerlink" title="Flow 的工作方式"></a>Flow 的工作方式</h3><p>通常类型检查分为两种方式：</p>
<ul>
<li><strong>类型推断</strong>：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型；</li>
<li><strong>类型注释</strong>：事先注释好我们期待的类型，Flow 会基于这些注释来判断。</li>
</ul>
<h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。</p>
<p>Flow 不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的<strong>类型推断</strong>，Flow 最重要的特性之一。</p>
<p>示例：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split(<span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>随后在控制台执行 <code>flow check</code>：</p>
<p>![](vue 源码/image-20211112131100296.png)</p>
<p>Flow 检查后会报错，因为函数 split 期待的参数使字符串，而我们输入了数字。</p>
<h4 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h4><p>在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。</p>
<p>如下代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>Flow 检查时检查不出任何错误，因为 <code>+</code> 既可以用在字符串上，也可与用在数字上。</p>
<p>这种情况下，可以借助类型注释来指明期望的类型。</p>
<p>类型注释是以 <code>:</code> 开头，可以在函数参数，返回值，变量声明中使用。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;hello&#x27;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure>

<p>现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。</p>
<p>![](vue 源码/image-20211112131828406.png)</p>
<p>当传递的参数为两个数字时，则不会检查出错误。</p>
<h4 id="常见类型注释"><a href="#常见类型注释" class="headerlink" title="常见类型注释"></a>常见类型注释</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组类型注释的格式是 <code>Array&lt;T&gt;</code>，<code>T</code> 表示数组中每项的数据类型：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure>

<h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><p>类的类型注释，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。</p>
<blockquote>
<p>属性的类型中间用 <code>|</code> 做间隔，表示两种类型均可接受。</p>
</blockquote>
<p>对象的注释类型类似于类，需要指定对象属性的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>           <span class="comment">// x 是字符串</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span> | <span class="built_in">number</span>  <span class="comment">// y 可以是字符串或者数字</span></span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">    <span class="built_in">this</span>.z = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar: Bar = <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj: &#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;, d: Bar &#125; = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="attr">c</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">  <span class="attr">d</span>: <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="Null-Undefined"><a href="#Null-Undefined" class="headerlink" title="Null Undefined"></a>Null Undefined</h5><p>若想任意类型 <code>T</code>  可以为 <code>null</code> 或者 <code>undefined</code> ，只需要写成 <code>?T</code> 的格式即可：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">var</span> foo: ?<span class="built_in">string</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>也可以在类型中加入 <code>| void</code> 使其可以不传值（但也不可以为 <code>null</code> ，可以为<code>undefined</code>）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #flow */</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="Flow-在-Vue-js-源码中的应用"><a href="#Flow-在-Vue-js-源码中的应用" class="headerlink" title="Flow 在 Vue.js 源码中的应用"></a>Flow 在 Vue.js 源码中的应用</h3><p>在我们引用第三方库，或者自定义一些类型时，Flow 并不认识，因此在检查的时候会报错。因此，Flow 提出了一个 <code>libdef</code>  的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。</p>
<p>在 Vue.js 的主目录下由 <code>.flowconfig</code> 文件，它是 Flow 的配置文件。</p>
<blockquote>
<p>官方文档地址：<a target="_blank" rel="noopener" href="https://flow.org/en/docs/config">https://flow.org/en/docs/config</a> </p>
</blockquote>
<p>其中的 <code>[libs]</code> 部分用来描述包括指定库定义的目录，默认是名为 <code>flow-typed</code> 的目录。</p>
<p>Vue.js 源码中指定了 <code>flow</code> 目录，表示指定的库定义都在 flow 文件夹内，文件结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">├── compiler.js        # 编译相关</span><br><span class="line">├── component.js       # 组件数据结构</span><br><span class="line">├── global-api.js      # Global API 结构</span><br><span class="line">├── modules.js         # 第三方库定义</span><br><span class="line">├── options.js         # 选项相关</span><br><span class="line">├── ssr.js             # 服务端渲染相关</span><br><span class="line">├── vnode.js           # 虚拟 node 相关</span><br><span class="line">├── weex.js						 # weex 相关</span><br></pre></td></tr></table></figure>

<p>通过对 Flow 的认识，有助于阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 Flow 的工具还有如 TypeScript。</p>
<h2 id="Vue-js-源码目录设计"><a href="#Vue-js-源码目录设计" class="headerlink" title="Vue.js 源码目录设计"></a>Vue.js 源码目录设计</h2><p>Vue.js 的源码都在 src 目录下，其目录结构如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></table></figure>

<h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 AST 语法树，AST 语法树优化，代码生成等功能。</p>
<blockquote>
<p>编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。</p>
<p>编译是一项耗性能的工作，所以更推荐前者——离线编译。</p>
</blockquote>
<h3 id="core"><a href="#core" class="headerlink" title="core *"></a>core *</h3><p>core 目录包含了 Vue.js 的<strong>核心代码</strong>，包含内置组件、全局 API 封装、Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p>
<p><strong>这里的代码可谓是 Vue.js 的灵魂</strong>。</p>
<h3 id="platforms"><a href="#platforms" class="headerlink" title="platforms"></a>platforms</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platforms</span><br><span class="line">├── web				# 打包成运行在 Web 上的 Vue.js</span><br><span class="line">├── weex			# 打包成运行在 weex 上的 Vue.js</span><br></pre></td></tr></table></figure>

<p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 natvie 客户端上。</p>
<h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。</p>
<blockquote>
<p>注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。</p>
</blockquote>
<p>服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器上，最后将静态标记“混合”为客户端上完全交互的应用程序。</p>
<h3 id="sfc"><a href="#sfc" class="headerlink" title="sfc"></a>sfc</h3><p>通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件的编写组件。</p>
<p>这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。</p>
<h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从 Vue.js 的目录设计可以看到，作者把功能模块拆分成的非常清楚，相关的逻辑放在以恶搞独立的目录下维护，并且把复用的代码也抽成一个独立目录。</p>
<p>这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。</p>
<h2 id="Vue-js-源码构建"><a href="#Vue-js-源码构建" class="headerlink" title="Vue.js 源码构建"></a>Vue.js 源码构建</h2><p>Vue.js 源码时基于 Rollup 构建的，构建相关配置都子啊 scripts 目录下。</p>
<blockquote>
<p>Rollup：<a target="_blank" rel="noopener" href="https://rollupjs.org/guide/en/">https://rollupjs.org/guide/en/</a></p>
<p>和 Webpack 的区别：Webpack 较为强大，webpack 会把所有类型文件（包括图片等）统统编译成 JS 文件，而 Rollup 只编译 js 部分，所以 Rollup 更轻量，在编译代码时也较友好。</p>
</blockquote>
<h3 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h3><p>通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件——包描述文件，内容是一个标准的 JSON 对象。</p>
<p>通常会配置 <code>script</code> 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node scripts/build.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:ssr&quot;</span>: <span class="string">&quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:weex&quot;</span>: <span class="string">&quot;npm run build --weex&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面两条是在第一条命令的基础上，添加一些环境参数</p>
</blockquote>
<p>当在命令行运行 <code>npm run build</code> 时，实际上就会执行 <code>node scripts/builds.js</code>。</p>
<h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p><code>scripts/build.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> builds = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>).getAllBuilds()</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter builds via command line arg</span></span><br><span class="line"><span class="keyword">if</span> (process.argv[<span class="number">2</span>]) &#123;</span><br><span class="line">  <span class="keyword">const</span> filters = process.argv[<span class="number">2</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> filters.some(<span class="function"><span class="params">f</span> =&gt;</span> b.output.file.indexOf(f) &gt; -<span class="number">1</span> || b._name.indexOf(f) &gt; -<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// filter out weex builds by default</span></span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.output.file.indexOf(<span class="string">&#x27;week&#x27;</span>) === <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>先从配置文件读取配置，在通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。</p>
<p><code>scripts/config.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> build = &#123;</span><br><span class="line">  <span class="comment">// Runtime only (CommonJS). Used by bundlers .eg. Webpack&amp;Browserify</span></span><br><span class="line">  <span class="string">&#x27;web-runtime-cjs&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: resolve(<span class="string">&#x27;web/entry-runtime.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: resolve(<span class="string">&#x27;dist/vue.runtime.common.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span>,</span><br><span class="line">    <span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Runtime+complier development build (Browser)</span></span><br><span class="line">  <span class="string">&#x27;web-full-dev&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: resolve(<span class="string">&#x27;dist/vue.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    <span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entry-decoder&#x27;</span>&#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面列举了一些 Vue.js 构建的配置，对于单个的配置，它是遵循 Rollup 的构建规则的：</p>
<ul>
<li>entry：表示构建的入口 JS 文件地址；</li>
<li>dest：表示构建后的 JS 文件地址；</li>
<li>format：表示构建的格式：<ul>
<li>cjs：遵循 CommonJS 规范；</li>
<li>es：遵循 ES Module 规范；</li>
<li>umd：遵循 UMD 规范。</li>
</ul>
</li>
</ul>
<p><code>resolve()</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cosnt aliases = <span class="built_in">require</span>(<span class="string">&#x27;./alias&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>, p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先把 resolve 函数传入的参数 <code>p</code> 通过 <code>/</code> 做了分割成数组，然后取去租第一个元素设置为 <code>base</code>。<code>base</code> 并不是实际的路径，它的真实路径借助了别名的配置：</p>
<p><code>scripts/alisa.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">vue</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/web/entry-runtime-with-compiler&#x27;</span>),</span><br><span class="line">  <span class="attr">compiler</span>: path.resolve(__dirname, <span class="string">&#x27;../src/compiler&#x27;</span>),</span><br><span class="line">  <span class="attr">core</span>: path.resolve(__dirname, <span class="string">&#x27;../src/core&#x27;</span>),</span><br><span class="line">  <span class="attr">shared</span>: path.resolve(__dirname, <span class="string">&#x27;./src/shared&#x27;</span>),</span><br><span class="line">  <span class="attr">web</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/web&#x27;</span>),</span><br><span class="line">  <span class="attr">weex</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/weex&#x27;</span>),</span><br><span class="line">  <span class="attr">server</span>: path.resolve(__dirname, <span class="string">&#x27;../src/server&#x27;</span>),</span><br><span class="line">  <span class="attr">entries</span>: path.resolve(__dirname, <span class="string">&#x27;../src/entries&#x27;</span>),</span><br><span class="line">  <span class="attr">sfc</span>: path.resolve(__dirname, <span class="string">&#x27;../src/sfc&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>web</code> 对应的真实的路径是 <code>path.resolve(__dirname, &#39;../src/platforms/web&#39;)</code>，这个路径就找到了 Vue.js 源码的 web 目录。然后 <code>resolve</code> 函数通过 <code>path.resolve(aliases[base], p.slice(base.length + 1))</code> 找到了最终路径，也就是 Vue.js 源码 web 目录下的 <code>entry-runtime.js</code>。因此 <code>web-runtime-cjs</code> 配置对应的入口文件就找到了。它经过 Rollup 的构建打包后，最终在 dist 目录下生成 <code>vue.runtime.common.js</code>。</p>
<h3 id="Runtime-Only-VS-Runtime-Compiler"><a href="#Runtime-Only-VS-Runtime-Compiler" class="headerlink" title="Runtime Only VS Runtime+Compiler"></a>Runtime Only VS Runtime+Compiler</h3><p>通常，利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问用 Runtime Only 版本还是 Runtime+Comiler 版本，对比：</p>
<ul>
<li><p>Runtime Only：</p>
<p>在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。</p>
</li>
<li><p>Runtime+Compiler：</p>
<p>如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器的版本</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123; h1 &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况不需要</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>因为在 Vue.js 2.0 中，最终渲染都是通过 <code>render</code> 函数，如果写 <code>template</code> 属性，则需要编译成 <code>render</code> 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</p>
</li>
</ul>
<blockquote>
<p>很显然，Runtime+Compiler 的编译过程对性能会有一定损耗，所以通常更推荐使用 Runtime Only 的 Vue.js。</p>
</blockquote>
<h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>分析 Runtime+Compiler 构建出来的 Vue.js，入口文件：</p>
<p><code>src/platforms/web/entry-runtime-with-complier.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<p>当代码执行 <code>import Vue from &#39;vue&#39;</code> 时，就是从这个入口执行代码来初始化 Vue。</p>
<h3 id="Vue-的入口"><a href="#Vue-的入口" class="headerlink" title="Vue 的入口"></a>Vue 的入口</h3><p>在上面的入口 JS 的上方可以找到 <code>Vue</code> 的来源：<code>import Vue from &#39;./runtime/index&#39;</code> </p>
<p><code>src/platforms/web/runtime/index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;core/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<p>关键的代码就是 <code>import Vue from &#39;core/index&#39;</code>，之后的逻辑都是对 Vue 这个对象做一些扩展。</p>
<p><code>src/core/index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./instance/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">&#x27;./global-api/index&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">initGlobalAAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure>

<p>两处关键代码：</p>
<ul>
<li><code>import Vue from &#39;./instance/index&#39;</code> </li>
<li><code>initGlobalAPI(Vue)</code> </li>
</ul>
<h3 id="Vue-的定义"><a href="#Vue-的定义" class="headerlink" title="Vue 的定义"></a>Vue 的定义</h3><p><code>src/core/instance/index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)     </span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a costructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里就是 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，只能通过 <code>new Vue</code> 去实例化它。</p>
<blockquote>
<p><strong>不使用 ES6 的 Class 实现的原因</strong>：这里有很多 混入 的函数调用，并把 <code>Vue</code> 当参数传入，都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能将这些扩展分散到多个模块中去实现，而不是在一个模块中实现所有，这是使用 Class 难以实现的。</p>
<p>好处：方便代码的维护和管理。</p>
</blockquote>
<p><code>initGlobalAPI</code>：</p>
<p>Vue.js 在整个初始化的过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../config&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// config</span></span><br><span class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</span><br><span class="line">  configDef.get = <span class="function">() =&gt;</span> config</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    configDef.set = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      warn(<span class="string">&#x27;Do not replace the Vue.config object, set individual fields instead.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&#x27;config&#x27;</span>, configDef)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// exposed util methods</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on</span></span><br><span class="line">  <span class="comment">// them unless you are aware of the risk</span></span><br><span class="line">  Vue.util = &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Vue.set = set</span><br><span class="line">  Vue.delete = del</span><br><span class="line">  Vue.nextTick = nextTick</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.6 explicit observable API</span></span><br><span class="line">  Vue.observable = &lt;T&gt;(obj: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    observe(obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Vue.options = <span class="built_in">Object</span>,create(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.options[type + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;x multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">  extend(Vue.options.components, builtInComponents)</span><br><span class="line">  </span><br><span class="line">  initUse(Vue)</span><br><span class="line">  initMixin(Vue)</span><br><span class="line">  initExtend(Vue)</span><br><span class="line">  initAssetRegisters(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这是在 Vue 上扩展的一些全局方法的定义。</p>
<blockquote>
<p>注意：<code>Vue.util</code> 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。</p>
</blockquote>
<h1 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h1><p>Vue.js 一个核心思想是<strong>数据驱动</strong>。</p>
<p>数据驱动：是指视图是由数据驱动生成的，对视图的修改不会直接操作 DOM，而是通过修改数据。</p>
<p>相比于 jQuery 等前端库直接修改 DOM，==大大简化了代码量==；当交互复杂时，只关心数据的修改会让==代码的逻辑变得非常清晰==，因为 DOM 变成了数据的映射，所有的逻辑都是对数据的修改，而不用触碰 DOM，这样的==代码非常利于维护==。</p>
<p>在 Vue.js 中可以采用简洁的模板语法来声明式的将数据渲染为 DOM：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>这一部分主要是要弄清楚模板和数据如何渲染成最终的 DOM。</p>
<h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>先来分析 <code>new Vue</code> 背后发生了哪些事情。<code>new</code> 关键字在 JavaScript 中代表实例化是一个对象，而 <code>Vue</code> 实际上是一个类，类在 JavaScript 中是用 Function 来实现的。</p>
<p><code>src/core/instance/index.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码中可以看到 <code>Vue</code> 只能通过 new 关键字初始化，然后会调用 <code>this._init</code> 方法。</p>
<h3 id="this-init"><a href="#this-init" class="headerlink" title="this._init"></a>this._init</h3><p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  vm._uid = uid++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startTag, endTag</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    mark(StartTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm._isVue = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    initInteralComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  &#125;</span><br><span class="line">  vm._self = vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  initInjections(vm)</span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm)</span><br><span class="line">  callHook(vm)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Vue 初始化主要工作：合并配置选项 <code>options</code>、初始化生命周期、初始化事件中心、初始化渲染、初始化 data、props、computed、watcher 等等。</p>
<h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h2><p>Vue 中是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的。</p>
<blockquote>
<p><code>$mount</code> 方法在多个文件中都有定义，如：</p>
<ul>
<li><code>src/platform/web/entry-runtime-with-compiler.js</code> </li>
<li><code>src/platform/web/runtime/index.js</code> </li>
<li><code>src/platform/weex/runtime/index.js</code> </li>
</ul>
<p>因为 <code>$mount</code> 这个方法的实现是和平台、构建方式都相关的。</p>
</blockquote>
<h3 id="complier-mount"><a href="#complier-mount" class="headerlink" title="complier $mount"></a>complier $mount</h3><p>分析 complier 版本的 <code>$mount</code>：</p>
<p><code>src/platform/web/entry-runtime-with-compiler.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not fount or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)&#123;</span><br><span class="line">          warn(<span class="string">&#x27;invaid template option:&#x27;</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewLines,</span><br><span class="line">        shouldDecodeNewLinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.delimiters,</span><br><span class="line">        <span class="attr">comments</span>: options.comments</span><br><span class="line">      &#125;, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>过程分析：</p>
<ul>
<li><p>首先缓存了原型上的 <code>$mount</code> 方法，再重新定义该方法；</p>
</li>
<li><p>对 <code>el</code> 做了限制，Vue 不能挂载在 body、html 这样的根节点上；</p>
</li>
<li><p>如果没有定义 <code>render</code> 方法，就会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法；</p>
<blockquote>
<p>在 Vue 2.0 版本中，所有的 Vue 的组件的渲染最终都需要 <code>render</code> 方法，无论是用单文件 .vue 方式开发组件，还是写了 <code>el</code> 或者 <code>template</code> 属性，最终都会转换成 <code>render</code> 方法，这个过程是 Vue 的一个 “在线编译” 的过程，它是调用 <code>compileToFunctions</code> 方法实现的。</p>
</blockquote>
</li>
<li><p>最后调用原先原型上的 <code>$mount</code> 方法挂载。</p>
</li>
</ul>
<h3 id="prototype-mount"><a href="#prototype-mount" class="headerlink" title="prototype $mount"></a>prototype $mount</h3><p><code>src/platform/web/runtime/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原型上的 <code>$mount</code> 方法支持传入 2 个参数：</p>
<ul>
<li><code>el</code>：表示挂载的元素，可以是字符串，也可以是 DOM 对象；<ul>
<li>如果是字符串在浏览器环境下会调用 <code>query</code> 方法转换成 DOM 对象</li>
</ul>
</li>
<li>第二个参数和服务端渲染相关，在浏览器环境下不需要传第二个参数</li>
</ul>
<p>实际会去调用 <code>mountComponent</code> 方法。</p>
<h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent()"></a>mountComponent()</h3><p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el: ?Element,</span></span></span><br><span class="line"><span class="params"><span class="function">   hydrating?: booolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (processenv.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istannul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) || vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      </span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line">      </span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mount hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm.isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child componentd in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p><code>mountComponent</code> 的核心就是先实例化一个渲染 <code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 DOM。</p>
<p><code>Watcher</code> 在这里起到的两个作用：</p>
<ol>
<li>初始化时执行回调函数；</li>
<li>当 vm 实例中的检测是数据发生变化时执行回调函数。</li>
</ol>
<p>函数最后判断为根节点时设置 <code>vm._isMounted</code> 为 <code>true</code>，表示这个实例已经挂载了，同时执行 <code>mounted</code> 钩子函数。</p>
<blockquote>
<p>这里 <code>vm.$vnode</code> 表示 Vue 实例的父虚拟 Node，为 null 表示当前是根 Vue 的实例。</p>
</blockquote>
<h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>Vue 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。</p>
<p><code>src/core/instance/render.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    vm.$scoprdSlots = normalizeScopedSlots(</span><br><span class="line">      _parentVnode.data.scopedSlots,</span><br><span class="line">      vm.$slots,</span><br><span class="line">      vm.$scopedSlots</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder onde.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// there&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">    <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">    <span class="comment">// when parent component is patched.</span></span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="comment">// return error render result</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">    vnode = vnode[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Multiple root nodes returned from render function, Render function &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vonde = createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>最关键的是 <code>render </code> 方法的调用。</p>
<p>在平时的开发中手写 <code>render</code> 方法的场景比较少，而写的比较多的是 <code>template</code> 模板，在之前的 <code>mounted</code> 方法的实现中，会把 <code>template</code> 编译成 <code>render</code> 方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>render</code> 函数中的 <code>createElement</code> 方法就是 <code>vm.$createElement</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// normaliztion is always applied for the public version, used in </span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上， <code>vm.$createElement</code> 方法定义是在执行 <code>initRender</code> 方法的时候，除了该方法，还有一个 <code>vm._c</code> 方法，它是被模板编译成的 <code>render</code> 函数使用，而 <code>vm.$createElement</code> 是用户手写 <code>render </code>方法使用的，这两个方法支持的参数相同，且内部都调用了 <code>createElement</code> 方法。</p>
<blockquote>
<p><code>vm._render</code> 最终是通过执行 <code>createElement</code> 方法并返回的是 <code>vnode</code>，它是一个虚拟 Node。</p>
</blockquote>
<h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>在浏览器中将一个简单的 div 元素的属性全部遍历出来：</p>
<p>![DOM元素的属性](vue 源码/image-20211117132229078.png)</p>
<p>真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当进行频繁的去做 DOM 更新，会产生一定的性能问题。</p>
<p>而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。</p>
<p>在 Vue.js 中，Virtual DOM 是用一个叫 VNode 的 Class 去描述。</p>
<p><code>src/core/vdom/vnode.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line">	<span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  data: VNodeData | <span class="built_in">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  elm: Node | <span class="built_in">void</span>;</span><br><span class="line">  ns: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  context: Component | <span class="built_in">void</span>;</span><br><span class="line">  key: stirng | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="built_in">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="built_in">void</span>;</span><br><span class="line">  parent: VNode | <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: <span class="built_in">boolean</span>;</span><br><span class="line">	isStatic: <span class="built_in">boolean</span>;</span><br><span class="line">	isRootInsert: <span class="built_in">boolean</span>;</span><br><span class="line">  isComment: <span class="built_in">boolean</span>;</span><br><span class="line">  isCloned: <span class="built_in">boolean</span>;</span><br><span class="line">  isOnce: <span class="built_in">boolean</span>;</span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="built_in">void</span>;</span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  isAsyncPlaceholder: <span class="built_in">boolean</span>;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  fnContext: Component | <span class="built_in">void</span>;</span><br><span class="line">  fnOptions: ?ComponentOptions;</span><br><span class="line">	fnScopeId: ?stirng;</span><br><span class="line"></span><br><span class="line">	<span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = <span class="built_in">this</span>.text</span><br><span class="line">    <span class="built_in">this</span>.elm = <span class="built_in">this</span>.elm</span><br><span class="line">    <span class="built_in">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="built_in">this</span>.componentOptions = componentOptions</span><br><span class="line">	  <span class="built_in">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="built_in">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line">	<span class="comment">/* istanbul ignore next */</span></span><br><span class="line">	get child (): Component | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为其中包含了很多 Vue.js 的特性。</p>
<blockquote>
<p>Vue.js 中 Virtual DOM 借鉴了一个开源库 <a target="_blank" rel="noopener" href="https://github.com/snabbdom/snabbdom">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西。</p>
</blockquote>
<p>VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其他属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。</p>
<p>因为 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常 <strong>轻量</strong> 和 <strong>简单</strong> 的。</p>
<h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>Vue.js 利用 createElement 方法创建 VNode。</p>
<p><code>src/core/vdom/create-element.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrapper function for providing a more flexible interface</span></span><br><span class="line"><span class="comment">// without gettting yelled at by flow</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">creatElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  tag: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  data: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  children: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  normalizationType: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  alwaysNormalize: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，它允许传入的参数更加灵活，在处理之后，调用真正创建 VNode 的函数 <code>_createElement</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span> | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data?: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> children?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> normalizationType?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: <span class="built_in">any</span>).__ob__)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> creatEmptyVNode()</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">     ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-proimitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instend &#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">     ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vonde &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn) &amp;&amp; data.tag !== <span class="string">&#x27;component&#x27;</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The .native modifier for v-on only valid components but it was used on &lt;<span class="subst">$&#123;tag&#125;</span>&gt;`</span>,</span><br><span class="line">          context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponet(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Arra.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码参数分析：</p>
<p><code>_createElement</code> 方法有 5 个参数：</p>
<ul>
<li><code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；</li>
<li><code>tag</code> 表示标签，它可以是一个字符串，而也可以是一个 <code>Component</code>；</li>
<li><code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到定义</li>
<li><code>children</code> 表示当前 VNode 的子节点，是任意类型的，但之后会被规范为标准的 VNode 数组；</li>
<li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法就不同，主要参考 render 函数是编译生成还是用户手写的</li>
</ul>
<h3 id="children-的规范化"><a href="#children-的规范化" class="headerlink" title="children 的规范化"></a>children 的规范化</h3><p>Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型，所以需要对 <code>_createElement</code> 接收的 4 个参数 children 进行规范化：</p>
<p>根据 <code>normalizationType</code> 的不同，分别调用 <code>normalizeChildren(children)</code> 和 <code>simpleNormalizeChildren(children)</code> 方法。</p>
<p><code>src/core/vdom/helpers/normalzie-children.js</code>：</p>
<p><strong>simpleNormalizeChildren()</strong> </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrar.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>simpleNormalizeChildren</code> 方法的调用场景是 <code>render</code> 函数是编译生成的。</p>
<p>理论上编译生成的 <code>chiuldren</code> 都已经是 VNode 类型的，但会有一个例外，就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法将整个 <code>children</code> 数组打平。让它的深度只有一层。</p>
<p><strong>normalizeChildren()</strong> </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span> (<span class="params">children: <span class="built_in">any</span></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isPrimitive(children)</span><br><span class="line">  	? [createTextVNode(children)]</span><br><span class="line">		: <span class="built_in">Array</span>.isArray(children)</span><br><span class="line">			? normalizeArrayChildren(children)</span><br><span class="line">			: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>normalizeChildren</code> 方法的调用场景有两种：</p>
<ul>
<li><code>render</code> 函数是用户手写的，当 <code>children</code> 之后一个节点的时候，Vue.js 从接口层面允许用户把 <code>children</code> 写成基础类型来创建单个简单的文本节点，则调用 <code>creatTextVNode</code> 创建一个文本节点的 VNode；</li>
<li>当编译 <code>slot</code>、<code>v-for</code> 时会产生嵌套数组的情况，会调用 <code>normalizeArrayChildren</code> 方法。</li>
</ul>
<p><strong>normalizeArrayChildren()</strong> </p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeArrayChildren</span> (<span class="params">children: <span class="built_in">any</span>, nestedIndex?: <span class="built_in">string</span></span>): <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">let</span> i, c, lastIndex, last</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, i &lt; children.length; i++) &#123;</span><br><span class="line">    c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (inUndef(c) || <span class="keyword">typeof</span> c === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">    lastIndex = res.length - <span class="number">1</span></span><br><span class="line">    last = res[lastIndex]</span><br><span class="line">    <span class="comment">// nested</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c = normalizeArrayChildren(c, <span class="string">`<span class="subst">$&#123;nestedIndex || <span class="string">&#x27;&#x27;</span>&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="keyword">if</span> (isTextNode(c[<span class="number">0</span>]) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">          res[lastIndex] = createTextVNode(last.text + (c[<span class="number">0</span>]: <span class="built_in">any</span>).text)</span><br><span class="line">          c.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        res.push.apply(res, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="comment">// this is necessary for SSR bydration because text nodes are</span></span><br><span class="line">        <span class="comment">// essentialy merged when renderd to HTML strings</span></span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// convert primitive to vnode</span></span><br><span class="line">        res.push(createTextVNode(c))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(c) &amp;&amp; isTextNopde(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        res[lastIndex = createTextVNode(last.text + c.text)]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default key for nexted array children (likely generated by v-for)</span></span><br><span class="line">        <span class="keyword">if</span> (isTure(children.siVList) &amp;&amp;</span><br><span class="line">            isDef(c.tag) &amp;&amp;</span><br><span class="line">            isUndef(c.key) &amp;&amp;</span><br><span class="line">            isDef(nestedIndex)) &#123;</span><br><span class="line">          c.key = <span class="string">`__vlist<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.push(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>normalizeArrayChildren</code> 接收 2 个参数：</p>
<ul>
<li><code>children</code> 表示要进行规范的子节点；</li>
<li><code>nestedIndex</code> 表示嵌套的索引，因为单个 <code>child</code> 可能是一个数组类型。</li>
</ul>
<p>方法的主要逻辑就是 遍历 <code>children</code>，获得单个节点 <code>c</code>，然后对 <code>c</code> 的类型判断，如果是一个数组类型，则递归调用 <code>normalizeArrayChildren</code>；如果是基础类型，则通过 <code>createTextVNode</code> 方法转换成 VNode 类型；否则本来就是 VNode 类型。如果 <code>children</code> 是一个列表并且列表还存在嵌套的情况，则根据 <code>nestedIndex</code> 去更新它的 key。</p>
<p>其中还做了优化处理：</p>
<p>如果存在两个连续的 <code>text</code> 节点，则会合并为一个 <code>text</code> 节点。</p>
<h3 id="VNode-的创建"><a href="#VNode-的创建" class="headerlink" title="VNode 的创建"></a>VNode 的创建</h3><p>规范化 <code>children</code> 之后，接下来会去创建一个 VNode 的实例：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params">context, tag, data, children, normalizationType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;stirng&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.parsePlatformTagName(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>先对 <code>tag</code> 做判断：</p>
<ul>
<li>如果是 <code>string</code> 类型，则接着判断；<ul>
<li>如果是内置的一些节点，则直接创建一个普通 VNode；</li>
<li>如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 VNode；</li>
<li>否则创建一个未知的标签的 VNode；</li>
</ul>
</li>
<li>如果 <code>tag</code> 是 <code>Component</code> 类型，则直接调用 <code>createElement</code> 创建一个组件类型的 VNode 节点。</li>
</ul>
<h3 id="补充方法"><a href="#补充方法" class="headerlink" title="补充方法"></a>补充方法</h3><h4 id="判断类型方法"><a href="#判断类型方法" class="headerlink" title="判断类型方法"></a>判断类型方法</h4><p><code>src/shared/util.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inUndef</span> (<span class="params">v: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v === <span class="literal">undefined</span> || v === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isDef</span> (<span class="params">v: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if value is primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrimitive</span> (<span class="params">value: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> ||</span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;symbol&#x27;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createEmptyVNode"><a href="#createEmptyVNode" class="headerlink" title="createEmptyVNode"></a>createEmptyVNode</h4><p><code>src/core/vdom/vnode.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEmptyVNode = <span class="function">(<span class="params">text: stirng = <span class="string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> VNode()</span><br><span class="line">  node.text = text</span><br><span class="line">  node.isComment = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="createTextVNode"><a href="#createTextVNode" class="headerlink" title="createTextVNode"></a>createTextVNode</h4><p><code>src/core/vdom/vnode.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>Vue 的 <code>_update</code> 是实例的一个私有方法。</p>
<p>被调用的时机有 2 个：</p>
<ul>
<li>首次渲染</li>
<li>数据更新</li>
</ul>
<h3 id="update-1"><a href="#update-1" class="headerlink" title="_update"></a>_update</h3><p><code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM</p>
<p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Componment&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (!prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h3 id="patch"><a href="#patch" class="headerlink" title="__patch__"></a>__patch__</h3><p><code>_update</code> 的核心就是调用 <code>vm.__patch__</code> 方法，在不同平台（web 和 weex）上的定义是不一样的：</p>
<p><code>src/platforms/web/runtime/index.js</code></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platfomr patch method</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure>

<p>在 web 平台上，是否是服务器端渲染也会对这个方法产生影响。因为在服务器端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数 <code>noop</code>，而在浏览器端渲染中，它指向了 <code>patch</code> 方法。</p>
<p><code>src/platforms/web/runtime/patch.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web.runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules <span class="keyword">from</span> <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the directive module should be applied last, after all</span></span><br><span class="line"><span class="comment">// built-in modules have been applied.</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.concat(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure>

<p>该方法的定义是调用 <code>createPatchFunction</code> 方法的返回值，这里传入了一个对象，包含 <code>nodeOps</code> 参数和 <code>modules</code> 参数：</p>
<ul>
<li><code>nodeOps</code> 封装了一系列 DOM 操作的方法；</li>
<li><code>modules</code> 定义了一些模块的钩子函数的实现。</li>
</ul>
<h3 id="createPatchFunction"><a href="#createPatchFunction" class="headerlink" title="createPatchFunction"></a>createPatchFunction</h3><p>定义在 <code>src/core/vdom/patch.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hooks = [<span class="string">&#x27;create&#x27;</span>, <span class="string">&#x27;activate&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;remove&#x27;</span>, <span class="string">&#x27;destroy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;</span><br><span class="line">        cbs[hooks[i]].push(modules[j][hooks[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createPatchFunction</code> 内部定义了一系列辅助方法，最终返回了一个 <code>patch</code> 方法，这个方法就赋值给了 <code>vm._update</code> 函数里调用的 <code>vm.__patch__</code>。</p>
<blockquote>
<p>相关代码分散到各个目录，不在一个文件中定义的好处：</p>
<p><code>patch</code> 是平台相关的，在 Web 和 Weex 环境中把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 <code>nodeOps</code> 和 <code>modules</code>，它们的代码需要托管到 <code>src/platforms</code> 这个大目录下。</p>
<p>而不同平台的 <code>patch</code> 的主要逻辑部分是相同的，所以这部分公共的部分托管在 <code>core</code> 这个大目录下，差异化部分只需要通过参数来区别，这里用到了一个<strong>函数柯里化</strong>的技巧，通过 <code>createPatchFunction</code> 把差异化参数提前固化，这样不用每次都调用 <code>patch</code> 的时候都传递 <code>nodeOps</code> 和 <code>modules</code> 了。</p>
</blockquote>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2975c25e4d71"><strong>函数柯里化</strong></a>：（Currying），把接收多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的 add 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying 后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)					<span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)	<span class="comment">// 3</span></span><br></pre></td></tr></table></figure>

<p>好处：</p>
<ol>
<li>参数复用</li>
<li>提前确认</li>
<li>延迟运行</li>
</ol>
<p>性能：</p>
<ul>
<li>存取 arguments 对象通常要比存取命名参数要慢一点；</li>
<li>老版本的浏览器在 arguments.length 的实现上相当慢；</li>
<li>使用 fn.apply(…) 和 fn.call(…) 通常比直接调用 fn(…) 稍微慢点；</li>
<li>创建大量嵌套作用域和闭包函数会带来内存和速度上的花销。</li>
</ul>
</blockquote>
<ul>
<li><code>nodeOps</code> 表示对 “平台 DOM” 的一些操作方法；</li>
<li><code>modules</code> 表示平台的一些模块，它们会在整个 <code>patch</code> 过程的不同阶段执行相应的钩子函数。</li>
</ul>
<p>代码分析：</p>
<p><code>patch</code> 方法接收 4 个参数：</p>
<ul>
<li><code>oldVnode</code> 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；</li>
<li><code>vnode</code> 表示执行 <code>_render</code> 后返回的 VNode 的节点；</li>
<li><code>hydrating</code> 表示是否是服务端渲染；</li>
<li><code>removeOnly</code> 是给 <code>transition-group</code> 使用的。</li>
</ul>
<p>结合一个小例子：</p>
<p>index.html</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure>

<p>main.js</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="built_in">this</span>.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>在 <code>vm._update</code> 的方法里调用 <code>patch</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initial render</span></span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line"><span class="comment">//            ⇩</span></span><br><span class="line"><span class="comment">// 对应返回的 patch 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure>

<p>场景为首次渲染，所以在执行 <code>patch</code> 函数时，传入的参数情况：</p>
<ul>
<li> <code>vm.$el</code> 对应的是例子中 id 为 <code>app</code> 的 DOM 对象，也就是在 index.html 中写的 <code>&lt;div id=&quot;app&quot;&gt;</code>，<code>vm.$el</code> 的赋值是在之前的 <code>mountComponent</code> 函数做的；</li>
<li><code>vnode</code> 对应的是调用 <code>render</code> 函数的返回值；</li>
<li><code>hydrating</code> 在非服务端渲染的情况下为 false；</li>
<li><code>removeOnly</code> 为 false。</li>
</ul>
<p>回看 <code>patch</code> 执行的关键步骤：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldeVnode, vnode)) &#123;</span><br><span class="line">  <span class="comment">// patch existing root node</span></span><br><span class="line">  patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">   	<span class="comment">// mounting to a real element</span></span><br><span class="line">    <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">    <span class="comment">// a successful hydration.</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">      oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">      hydrating = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">        invokeInsertHook(vnode, insertVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVnode</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hyration and performing &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enther not server-rendered, or hydration failed.</span></span><br><span class="line">    <span class="comment">// create an empty node and replace it</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// replacing existing element</span></span><br><span class="line">  <span class="keyword">const</span> oldElm = oldValue.elm</span><br><span class="line">  <span class="keyword">const</span> parentELm = nodeOps.parentNode(oldELm)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create new node</span></span><br><span class="line">  createElm(</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">    <span class="comment">// leaving transition. Only happens when combining transtion +</span></span><br><span class="line">    <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">    oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">    nodeOps.nextSibling(oldElm)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中传入的 <code>oldValue</code> 实际上是一个 DOM container（DOM 容器），所以 <code>isRealELement</code> 为 true，接下来通过 <code>emptyNodeAt</code> 方法把 <code>oldVnode</code> 转换成 <code>VNode</code> 对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(nodeOps.tagName(elm).toLowerCase, &#123;&#125;, [], <span class="literal">undefined</span>, elm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再调用 <code>createElm</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creatingElmInVPre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentElm,</span></span></span><br><span class="line"><span class="params"><span class="function">  refElm,</span></span></span><br><span class="line"><span class="params"><span class="function">  nested,</span></span></span><br><span class="line"><span class="params"><span class="function">  ownerArray,</span></span></span><br><span class="line"><span class="params"><span class="function">  index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it&#x27;s used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it&#x27;s used as a n insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node no-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter back</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownELement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;unknown custom element: &lt;&#x27;</span> + tag + <span class="string">&#x27;&gt; - did you &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;register the component correctly? For recursive components, &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;make sure to provide the &quot;name&quot; option.&#x27;</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">    	? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">	    : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (process.en.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      createElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isCommon)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode,elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElm</code> 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。关键逻辑：</p>
<ul>
<li><code>createComponent</code> 方法目的是尝试创建子组件，组件篇章会详细展开分析，当前返回值为 false；</li>
<li>接下来判断 <code>vnode</code> 是否包含 <code>tag</code>，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；</li>
<li>再去调用平台 DOM 的操作去创建一个占位符元素</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vnode.elm = vnode.ns</span><br><span class="line">	? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">	: nodeOps.createElement(tag, vnode)</span><br></pre></td></tr></table></figure>

<ul>
<li>接下来调用 <code>createChildren</code> 方法去创建子元素：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      createElm(chidren[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(vnode.text)) &#123;</span><br><span class="line">    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(<span class="built_in">String</span>(vnode.text)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createChildren</code> 的逻辑很简单，遍历子虚拟节点，递归调用 <code>createElm</code>，这是一种常用的深度优先的遍历算法，遍历的过程中会把 <code>vnode.elm</code> 作为父容器的 DOM 节点占位符传入。</p>
<ul>
<li>接着再调用 <code>invokeCreateHooks</code> 方法执行所有的 create 的钩子并把 <code>vnode</code> push 到 <code>insertedVnodeQueue</code> 中：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ifDef(data)) &#123;</span><br><span class="line">  invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">    cbs.create[i](emptyNode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i.create)) i.create(emptyNode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>最后调用 <code>insert</code> 方法把 <code>DOM</code> 插入到父节点中，因为是递归调用，子元素会优先调用 <code>insert</code>，所以整个 <code>vnode</code> 树节点的插入顺序是 <strong>先子后父</strong>：</li>
</ul>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">insert(parentElm, vnode.elm, refElm)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(parent)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ref)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref.parentNode === parent) &#123;</span><br><span class="line">        nodeOps.insertBefore(parent, elm, ref)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nodeOps.appendChild(parent, elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>insert</code> 的逻辑：调用一些 <code>nodeOps</code> 把子节点插入到父节点中：</p>
<p><code>src/platforms/web/runtime/node-ops.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实就是调用原生 DOM 的 API 进行 DOM 操作。</p>
<p>在 <code>createELm</code> 过程中，如果 <code>vnode</code> 节点不包含 <code>tag</code>，则它又可能是一个注释或者纯文本节点，可以直接插到父元素中。</p>
<p>回看 <code>patch</code> 方法，首次渲染我们调用了 <code>createElm</code> 方法，传入的 <code>parentElm</code> 是 <code>lidVnode.elm</code> 的父元素，在例子中是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。</p>
<h3 id="patch-执行流程分析"><a href="#patch-执行流程分析" class="headerlink" title="patch 执行流程分析"></a>patch 执行流程分析</h3><p>在 vue.esm.js 源文件的 <code>patch</code> 方法定义下打一个 <code>debugger</code> 调试：</p>
<p>![image-20211118170756105](vue 源码/image-20211118170756105.png)</p>
<p>进行单步调试，可以看到 <code>vnode</code> 有值， <code>oldVnode</code> 是 id 为 <code>app</code> 的 div：</p>
<p>![image-20211118171208901](vue 源码/image-20211118171208901.png)</p>
<p>继续进行单步调试，可以看到 <code>isRealElement</code> 为 <code>true</code>：</p>
<p>![image-20211118171628548](vue 源码/image-20211118171628548.png)</p>
<p>之后执行 <code>emptyNodeAt(oldVnode)</code> 方法，<code>oldVnode</code> 成为 <code>VNode</code> 节点：</p>
<p>![image-20211118172049107](vue 源码/image-20211118172049107.png)</p>
<p>之后进入 <code>createElm</code> 方法调试：</p>
<p>![image-20211118172301881](vue 源码/image-20211118172301881.png)</p>
<p>向下执行，生成当前元素的占位符 <code>vnode.elm</code>，<code>setScope</code> 是 CSS 作用域相关的：</p>
<p>![image-20211118172400799](vue 源码/image-20211118172400799.png)</p>
<p>进入 <code>createChildren</code> 方法：</p>
<p>![image-20211118172723914](vue 源码/image-20211118172723914.png)</p>
<p>再进入 <code>createElm</code> 方法：</p>
<p>![image-20211118172827056](vue 源码/image-20211118172827056.png)</p>
<p>此时已没有子节点，故 <code>children</code>、<code>tag</code> 均为 <code>undefined</code>：</p>
<p>![image-20211118173120807](vue 源码/image-20211118173120807.png)</p>
<p>判断是注释节点还是文本节点，此处为 <code>Hello AgoniLay!</code> 文本：</p>
<p>![image-20211118173308852](vue 源码/image-20211118173308852.png)</p>
<p>执行完 <code>nodeOps.createTextNode</code> 方法之后，<code>vnode.elm</code> 已转换成 DOM 文本节点：</p>
<p>![image-20211118173439630](vue 源码/image-20211118173439630.png)</p>
<p>之后调用 <code>insert</code> 方法插入，继续前进，<code>createChild</code> 执行结束：</p>
<p>![image-20211118173654013](vue 源码/image-20211118173654013.png)</p>
<p>之后执行 <code>insert</code> 方法，插入 DOM 节点，可以看到此时已渲染至浏览器页面：</p>
<p>![image-20211118173935912](vue 源码/image-20211118173935912.png)</p>
<p>此时查看 body，发现此时有两个 id 为 <code>app</code> 的 div：</p>
<p>![image-20211118174103119](vue 源码/image-20211118174103119.png)</p>
<p>继续执行代码，向前调试，回到了 <code>patch</code> 执行：</p>
<p>![image-20211118174235569](vue 源码/image-20211118174235569.png)</p>
<p><code>removeVnodes</code> 方法执行结束过后，再次查看 body，旧 div 已被销毁：</p>
<p>![image-20211118174400121](vue 源码/image-20211118174400121.png)</p>
<p>此时，<code>patch</code> 基本执行结束，渲染成功。</p>
<h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>Vue.js 另一个核心思想是<strong>组件化</strong>。</p>
<p>所谓组件化，就是把页面拆分成多个组件（component），每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。</p>
<p>组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p>
<p>接下来用 Vue-cli 初始化的代码为例，来分析 Vue 组件初始化的过程：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">	<span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这里的 h 是 createElement 方法</span></span><br><span class="line">  render h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>和之前分析相同的都是通过 <code>render</code> 函数去渲染，但这次通过 <code>createElement</code> 传的参数是一个组件而不是一个原生的标签。</p>
<h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h2><p>在分析 <code>createElement</code> 的实现时，它最终会调用 <code>_createElement</code> 方法，其中会对参数 <code>tag</code> 进行判断，如果是一个普通的 html 标签，则会实例化一个普通的 VNode 节点，否则会通过 <code>createComponent</code> 方法创建一个组件 VNode。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> Ctor</span><br><span class="line">  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">    <span class="comment">// platform built-in elements</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      consfig.parsePlatformTagNmae(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;component&#x27;</span>, tag))) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">    <span class="comment">// check at runtime because it may get assigned a namespace then its</span></span><br><span class="line">    <span class="comment">// parent normalizes children</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = createComponent(tag, data, context, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处传入的一个 App 对象，本质上是一个 <code>Component</code> 类型，则会走 else 逻辑，直接通过 <code>createComponent</code> 方法来创建 <code>vnode</code>。</p>
<p><code>src/core/vdom/create-component.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  data: VNodeData | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  tag?: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(Ctor)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// plain options object: trurn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if at this stage it&#x27;s not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">/// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Ctor === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      warn(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resloveAsyncComponent(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">      <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">      <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line">	<span class="comment">// component constructor creation</span></span><br><span class="line">  resolveConstructorOptions(Ctor)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data.model)) &#123;</span><br><span class="line">    transfromModel(Ctor.options, data)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//fucntional component</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createFunctionalComponent((Ctor, propsData, data, context, children))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead og DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.on</span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processd during parent component patch</span></span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (istrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    <span class="comment">// abstract components do not keep anything</span></span><br><span class="line">		<span class="comment">// other than props &amp; listeners &amp; slot</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// work around flow</span></span><br><span class="line">    <span class="keyword">const</span> slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">  installComponentHooks(data)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Weex specific: invoke recycle-list optimized @render function for</span></span><br><span class="line">  <span class="comment">// extractiong cell-slot template.</span></span><br><span class="line">  <span class="comment">// https://github.com/Hanks10100/weex-native-directive/tree/master/component</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderRecyclableComponentTemplate(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个代码中，针对组件渲染这个 case 主要就 3 个关键步骤：</p>
<ul>
<li>构造子类构造函数；</li>
<li>安装组件钩子函数；</li>
<li>实例化 <code>vnode</code> 。</li>
</ul>
<h3 id="构造子类钩子函数"><a href="#构造子类钩子函数" class="headerlink" title="构造子类钩子函数"></a>构造子类钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain options object: turn it into a construtor</span></span><br><span class="line"><span class="comment">// 普通选项对象：将其转换为一个构造器</span></span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">  Ctor = baseCtor.extend(Ctor) <span class="comment">// 此处为关键方法 extend</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>App.vue</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;.components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>export</code> 是一个对象，所以 <code>createComponent</code> 里的代码逻辑会执行到 <code>baseCtor.extend(Ctor)</code>，在这里 <code>baseCtor</code> 实际上就是 Vue，这个定义是在最开始初始化 Vue 的阶段：</p>
<p><code>src/core/global-api/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  <span class="comment">// 这用于识别“基本”构造函数</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里定义的是 <code>Vue.options</code>，但在 <code>createComponent</code> 取的是 <code>context.$options</code>，这在 Vue 原型上的 <code>_init</code> 函数中有定义：</p>
<p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstuctorOptions(vm.constructor),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就把 Vue 上的一些 <code>option</code> 扩展到了 <code>vm.$options</code> 上，所以就能通过 <code>vm.$options._base</code> 拿到 Vue 这个构造函数了。</p>
<blockquote>
<p><code>mergeOptions</code> 的功能是把 Vue 构造函数上的 <code>options</code> 和用户传入的 <code>options</code> 做一层合并，到 <code>vm.$options</code> 上。</p>
</blockquote>
<h4 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h4><p><code>src/core/global-api/extend.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class inheritance  ---  类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> Super = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> SuperId = Super.id</span><br><span class="line">  <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> name = extendOptions.name || Super.options.name</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; name) &#123;</span><br><span class="line">    validateComponentName(name)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._init(options)</span><br><span class="line">  &#125;</span><br><span class="line">  Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">  Sub.prototype.constructor = Sub</span><br><span class="line">  Sub.cid = cid++</span><br><span class="line">  Sub.options = mergeOptions(</span><br><span class="line">    Super.options,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  Sub[<span class="string">&#x27;super&#x27;</span>] = Super</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">  <span class="comment">// the Vue instances at extension time , on the extended prototype. This</span></span><br><span class="line">  <span class="comment">// avoid Object.defineProperty calls for each instance created.</span></span><br><span class="line">  <span class="comment">// 在扩展时在 Vue 实例上定义扩展原型上的 proxy getters</span></span><br><span class="line">  <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">    initProps(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">    initComputed(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">  <span class="comment">// 允许之后使用 扩展/混入/插件</span></span><br><span class="line">  Sub.extend = Super.extend</span><br><span class="line">  Sub.mixin = Super.mixin</span><br><span class="line">  Sub.use = Super.use</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">  <span class="comment">// can have their private assets too.</span></span><br><span class="line">  <span class="comment">// 创建资源寄存器，这样扩展的类也可以拥有其私有的资源</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">    Sub[<span class="keyword">type</span>] = Super[<span class="keyword">type</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">  <span class="comment">// 使其能够递归自我查找</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    Sub.option.components[name] = Sub</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">  <span class="comment">// later at instantiation we can check if Super&#x27;s options have</span></span><br><span class="line">  <span class="comment">// been updated.</span></span><br><span class="line">  <span class="comment">// 在扩展时保留对 Super 选项引用。稍后在实例化时，我们可以检查 Suoer 选项是否已经更新</span></span><br><span class="line">  Sub.superOptions = Super.options</span><br><span class="line">  Sub.extendOptions = extendOptions</span><br><span class="line">  Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cache constructor</span></span><br><span class="line">  <span class="comment">// 缓存构造函数</span></span><br><span class="line">  cachedCtors[SuperId] = Sub</span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Vue.extend</code> 的作用：</p>
<ul>
<li>构造一个 <code>Vue</code> 的子类，通过原型继承的方式把一个纯对象转换成一个继承于 <code>Vue</code> 的构造器 <code>Sub</code> 并返回，然后对 <code>Sub</code> 这个对象本身扩展了一些属性，如扩展 <code>options</code>、添加全局 API 等；</li>
<li>并对配置中的 <code>props</code> 和 <code>computed</code> 做了初始化工作；</li>
<li>最后对 <code>Sub</code> 这个构造函数做了缓存，避免多次执行 <code>Vue.extend</code> 的时候对同一个子组件重复构造。</li>
</ul>
<p>当去实例化 <code>Sub</code> 的时候，就会执行 <code>this._init</code> 逻辑再次走到 <code>Vue</code> 实例的初始化逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="安装组件钩子函数"><a href="#安装组件钩子函数" class="headerlink" title="安装组件钩子函数"></a>安装组件钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">installComponentHooks(data)</span><br></pre></td></tr></table></figure>

<p>Vue 在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p>
<h4 id="installComponentHooks"><a href="#installComponentHooks" class="headerlink" title="installComponentHooks"></a>installComponentHooks</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline hooks to be invoked on component VNodes during patch</span></span><br><span class="line"><span class="keyword">const</span> componetVNodeHooks = &#123;</span><br><span class="line">  init (vnode: VNodeWithData, <span class="attr">hydrating</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.componentInstance &amp;&amp;</span><br><span class="line">        !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">        vnode.data.keepAlive</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: <span class="built_in">any</span> = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponetInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedCOmponentVNode) &#123;</span><br><span class="line">		<span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    updateChildComponent(</span><br><span class="line">      child,</span><br><span class="line">      options.propsData, 	<span class="comment">// updated props</span></span><br><span class="line">      options.listeners, 	<span class="comment">// updated listeners</span></span><br><span class="line">      vnode, 						 	<span class="comment">// new parent vnode</span></span><br><span class="line">      options.children 	 	<span class="comment">// new children</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">        <span class="comment">// vue-router#1212</span></span><br><span class="line">        <span class="comment">// During updates, a kept-alive component&#x27;s child components may</span></span><br><span class="line">        <span class="comment">// change, so directly walking the tree here may call activated hooks</span></span><br><span class="line">        <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></span><br><span class="line">        <span class="comment">// be processed after whole patch process ended.</span></span><br><span class="line">        queueActivatedComponent(componentInstance)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  destory (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class="line">        componentInstance.$destroy()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hooksToMerge = <span class="built_in">Object</span>.keys(componentVNodeHooks) <span class="comment">// [&#x27;init&#x27;, &#x27;prepatch&#x27;, &#x27;insert&#x27;, &#x27;destory&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span> (<span class="params">data: VnodeData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hooksToMerge[i]</span><br><span class="line">    <span class="keyword">const</span> existing = hooks[key]</span><br><span class="line">    <span class="keyword">const</span> toMerge = componentVNodeHooks[key]</span><br><span class="line">    <span class="comment">// 判断 是否相同 || 已经合并</span></span><br><span class="line">    <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数。</p>
<h4 id="mergeHook"><a href="#mergeHook" class="headerlink" title="mergeHook"></a>mergeHook</h4><p>合并策略：在合并过程中，如果某个时机的钩子已经存在 <code>data.hook</code> 中，那么通过执行 <code>mergeHook</code> 函数做合并，就是在最终执行的时候，依次执行这两个钩子函数即可。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params">f1: <span class="built_in">any</span>, f2: <span class="built_in">any</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> merged = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// flow complains about extra args which is why we use any</span></span><br><span class="line">    f1(a, b)</span><br><span class="line">    f2(a, b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 做缓存，提高效率</span></span><br><span class="line">  merged._merged = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="实例化-VNode"><a href="#实例化-VNode" class="headerlink" title="实例化 VNode"></a>实例化 VNode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	Ctor, data, context, children, tag</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后通过 <code>new VNode</code> 实例化一个 <code>vnode</code>并返回。</p>
<blockquote>
<p>注意：和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>chldren</code> 的，这点很关键。</p>
</blockquote>
<h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在 <code>vue.esm.js</code> 中在执行 <code>createComponent</code> 方法之前打一个 <code>debugger</code> 断点：</p>
<p>![image-20211119125713362](vue 源码/image-20211119125713362.png)</p>
<p>浏览器中执行代码，进到 <code>createComponent</code> 方法内执行，此时 <code>Ctor</code> 结构如下图所示：</p>
<p>![image-20211119125841531](vue 源码/image-20211119125841531.png)</p>
<p>向后执行，进入 <code>extend</code> 方法内：</p>
<p>![image-20211119130003696](vue 源码/image-20211119130003696.png)</p>
<p>进行一系列原型继承，方法合并之后返回 <code>Sub</code>，继续执行，退出到 <code>createComponent</code> 方法中：</p>
<p>![image-20211119130317549](vue 源码/image-20211119130317549.png)</p>
<p>一直执行到 <code>installComponentHooks(data)</code> 方法，执行前 <code>data</code> 中只有一个 <code>on</code>：</p>
<p>![image-20211119130507167](vue 源码/image-20211119130507167.png)</p>
<p>执行完成 <code>installComponentHooks</code> 方法过后，<code>data</code> 上添加了 <code>hook</code>：</p>
<p>![image-20211119130638202](vue 源码/image-20211119130638202.png)</p>
<p>继续执行，创建 <code>VNode</code>并返回，<code>createComponent</code> 执行结束：</p>
<p>![image-20211119130901213](vue 源码/image-20211119130901213.png)</p>
<p>![image-20211119131005730](vue 源码/image-20211119131005730.png)</p>
<p>![image-20211119131034122](vue 源码/image-20211119131034122.png) </p>
<h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><p>当通过 <code>createComponent</code> 创建了组件 VNode，接下来会走到 <code>vm._update</code>，执行 <code>vm.__patch__</code> 去把 VNode 转换成真正的 DOM 节点。</p>
<p>patch 的过程会调用 <code>createElm</code> 创建元素节点：</p>
<p><code>src/core/vdom/patch.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vnode, insertedVnodeQueue, parentElm, refElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> nested, ownerArray, index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">	<span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="createComponent-1"><a href="#createComponent-1" class="headerlink" title="createComponent"></a>createComponent</h3><p>只看关键的逻辑，这里会判断 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值，如果为 <code>true</code> 则直接结束，那么接下来看一下 <code>createComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hok) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should&#x27;ve created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode&#x27;s elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>creatComponent</code> 函数中，首先对 <code>vnode.data</code> 做了一些判断：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = vnode.data</span><br><span class="line"><span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">    i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果 <code>vnode</code> 是一个组件 VNode，那么条件满足，得到 <code>i</code> 就是 <code>init</code> 钩子函数，上一节在创建 VNode 的时候合并钩子函数中就包含 <code>init</code> 钩子函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">vnode: Vnode, hydrating: <span class="built_in">boolean</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vnode.componentInstance &amp;&amp;</span><br><span class="line">    !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">    vnode.data.keepAlive</span><br><span class="line">  ) &#123;</span><br><span class="line">		<span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">    <span class="keyword">const</span> mouted: <span class="built_in">any</span> = vnode <span class="comment">// work around flow</span></span><br><span class="line">    componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">      vnode,</span><br><span class="line">      activeInstance</span><br><span class="line">    )</span><br><span class="line">    child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先不考虑 keep-alive 的情况，它是通过 <code>createComponentInstanceForVnode</code> 创建一个 Vue 的实例，然后调用 <code>$mount</code> 方法挂载子组件：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="comment">// we known it&#x27;s MountedComponentVNode but flow doesn&#x27;t</span></span></span></span><br><span class="line"><span class="params"><span class="function">	vnode: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// activeInstance is lisfecycle state</span></span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check inline-template render functions</span></span><br><span class="line">  <span class="keyword">const</span> inlineTemplate = vnode.data.inlineTemplate</span><br><span class="line">  <span class="keyword">if</span> (isDef(inlineTemplate)) &#123;</span><br><span class="line">    options.render = inlineTemplate.render</span><br><span class="line">    options.staticRenderFns = inlineTemplate.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createComponentInstanceForVnode</code> 构造函数的一个内部组件的参数，然后执行 <code>new vnode.componentOptions.Ctor(options)</code>。这里的 <code>vnode.componentOptions.Ctor</code> 对应的就是子组件的构造函数，相当于之前的 <code>new Sub(options)</code>，这里的参数：</p>
<ul>
<li><code>_isComponent</code> 为 <code>true</code> 表示它是一个组件；</li>
<li><code>parent</code> 表示当前激活的组件实例</li>
</ul>
<p>接着进行子组件的实例化，执行实例的 <code>_init</code> 方法：</p>
<p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveCOnstructorOPtions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先是合并 <code>options</code> 的过程有变化，<code>_isComponent</code> 为 true，执行 <code>initInternalComponent</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// doing this because it&#x27;s faster than dynamic dnumeration.</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = vnodeComponentOptions.tag</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中较为重要的是：</p>
<ul>
<li><code>opts.parent = options.parent</code>；</li>
<li><code>opts._parentVnode = parentVnode</code>。</li>
</ul>
<p>是将之前通过 <code>createComponentInstanceForVnode</code> 函数传入的几个参数合并到内部的选项 <code>$options</code> 里。</p>
<p><code>_init</code> 函数最后执行代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于组件实例化是不传 el 的，因此组件是自己接管了 $mount 的过程，回到组件 <code>init</code> 的过程，<code>componentVNodeHooks</code> 的 <code>init</code> 钩子函数，在完成实例化的 <code>_init</code> 后，接着执行 <code>child.$mount(hydrating ? vnode.elm : undefined, hydrating)</code>：</p>
<p>这里 <code>hyrating</code> 为 true 一般为服务器端渲染，所以这里相当于执行 <code>child.$mount(undefined, false)</code>，它最终会调用 <code>mountComponent</code> 方法，进而执行 <code>vm._render()</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">Vnode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set parent vnode. this allows render function to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>_parentVnode</code> 就是当前组件的父 VNode，而 <code>render</code> 函数生成的 <code>vnode</code> 的 <code>parent</code> 指向了 <code>_parentVnode</code>，也就是 <code>vm.$vnode</code>，成父子关系。</p>
<p>执行完 <code>vm._render</code> 生成 VNode 后，接下来执行 <code>vm._update</code> 去渲染 VNode：</p>
<p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> activeInstance: <span class="built_in">any</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// update in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>vm._vnode = vnode</code> 中的 <code>vnode</code> 是通过 <code>vm._render()</code> 返回的组件渲染 VNode；</p>
</li>
<li><p><code>vm._vnode</code> 和 <code>vm.$vnode</code> 的关系就是一种父子关系，即：<code>vm._vnode.parent = vm.$vnode</code>；</p>
</li>
<li><p><code>activeInstance</code> 的作用就是保持当前上下文的 Vue 实例，是 <code>lifecycle</code> 模块的全局变量。</p>
<blockquote>
<p>JavaScript 是一个单线程，Vue 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 Vue 实例是什么，并把它作为子组件的父 Vue 实例。</p>
</blockquote>
</li>
</ul>
<p>对子组件的实例化过程会先调用 <code>initInternalComponent(vm, options)</code> 合并 <code>options</code>，把 <code>parent</code> 存储在 <code>vm.$options</code> 中，在 <code>$mount</code> 之前会调用 <code>initLifecycle(vm)</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// locale first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>vm.$parent</code> 就是用来保留当前 <code>vm</code> 的父实例，并通过 <code>parent.$children.push(vm)</code> 将当前 <code>vm</code> 存储到父实例的 <code>$children</code> 中。</p>
<p>在 <code>vm._update</code> 的过程中，把当前的 <code>vm</code> 赋值给 <code>activeInstance</code>，同时通过 <code>const prevActiveInstance = activeInstance</code> 用 <code>prevActiveInstance</code> 保留上一次的 <code>activeInstance</code>。当一个 <code>vm</code> 实例完成了它的所有子树的 patch 或者 update 过程后，<code>activeInstance</code> 会回到它的父实例。</p>
<p>再回到 <code>_update</code>，最后调用 <code>__patch__</code> 渲染 VNode：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    inInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElm</code> 负责渲染成 DOM，这里只传了 2 个参数，所以对应的 <code>parentElm</code> 是 <code>undefined</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vnode,</span></span></span><br><span class="line"><span class="params"><span class="function"> insertedVnodeQueue,</span></span></span><br><span class="line"><span class="params"><span class="function"> parentElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> refElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> nested,</span></span></span><br><span class="line"><span class="params"><span class="function"> ownerArray,</span></span></span><br><span class="line"><span class="params"><span class="function"> index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">	</span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag =vnode.tag</span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">    	? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">    	: nodeOps.createELement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode,insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, cnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里传入的 <code>vnode</code> 是组件渲染的 <code>vnode</code>，也就是 <code>vm._vnode</code>，如果组件的根节点是个普通元素，那么 <code>vm._vnode</code> 也是普通的 <code>vnode</code>，这里 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值是 false，然后创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 <code>createElm</code>，遍历过程中遇到 VNode 是一个组件的 VNode，则重复本节的过程，通过一个递归的方式完整地构建了整个组件树。</p>
<p>这时传入的 <code>parentElm</code> 是空，所以在 <code>createComponent</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在完成组件的整个 <code>patch</code> 过程后，最后执行 <code>insert(parentElm, vnode.elm, refElm)</code> 完成组件的 DOM 插入，如果组件 <code>patch</code> 的过程中又创建了子组件，那么 DOM 的插入顺序是<strong>先子后父</strong>。</p>
<h2 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h2><p><code>new Vue</code> 的过程通常有 2 种场景：</p>
<ol>
<li>一种是外部代码主动调用 <code>new Vue(options)</code> 的方式实例化一个 Vue 对象；</li>
<li>另一种是组件过程中内部通过调用 <code>new Vue(options)</code> 实例化子组件。</li>
</ol>
<p>以上两种都会执行实例的 <code>_init(options)</code> 方法，它首先会执行一个 <code>mergeOptions</code> 的逻辑：</p>
<p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal compnent instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merhing is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到不同场景对于 <code>options</code> 的合并逻辑是不一样的，并且传入的 <code>options</code> 值也有非常大的不同。</p>
<p>示例代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childComp = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">   	<span class="built_in">console</span>.log(<span class="string">&#x27;child created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child mounted&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(childComp)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h3 id="外部调用场景"><a href="#外部调用场景" class="headerlink" title="外部调用场景"></a>外部调用场景</h3><p>当执行 <code>new Vue</code> 时，执行 <code>this._init(options)</code> 时就会执行如下逻辑去合并 <code>options</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>这里通过调用 <code>mergeOptions</code> 方法来合并，实际上就是吧 <code>resloveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，现在认为 <code>resolveConstructorOptions</code> 简单返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>：</p>
<p><code>src/core/global-api/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">  extend(Vue.options.components, buildInComponents)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象；</p>
<p>然后遍历 <code>ASSET_TYPE</code>；</p>
<p><code>src/shared/constants.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPE = &#123;</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历 <code>ASSETS_TYPE</code> 后的代码相当于：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.options.components = &#123;&#125;</span><br><span class="line">Vue.options.directives = &#123;&#125;</span><br><span class="line">Vue.options.filters = &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>接着执行 <code>Vue.options._base = Vue</code>；</p>
<p>最后通过 <code>extend(Vue.options.components, builtInComponets)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，Vue 的内置组件有：</p>
<ul>
<li><code>&lt;keep-alive&gt;</code> </li>
<li><code>&lt;transition&gt;</code> </li>
<li><code>&lt;transition-group&gt;</code> </li>
</ul>
<p>再看 <code>mergeOptions</code> 这个函数</p>
<p><code>src/core/util/options.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two option objects into a new one.</span></span><br><span class="line"><span class="comment"> * Core utility used in both instantiation and inheritance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  child: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  vm?: Component</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    checkComponents(child)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    child = child.options</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  normalizeProps(child, vm)</span><br><span class="line">  normalizeInject(child, vm)</span><br><span class="line">  normalizeDirectives(child)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Apply extends and mixins on the child options,</span></span><br><span class="line">  <span class="comment">// but only if it is a raw options object that isn&#x27;t</span></span><br><span class="line">  <span class="comment">// the result of auother mergeOptions call.</span></span><br><span class="line">  <span class="comment">// Only merged options has the _base property.</span></span><br><span class="line">  <span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.mixin[i], vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>mergeOptions</code> 主要功能就是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回：</p>
<ul>
<li>先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上；</li>
<li>然后遍历 <code>parent</code>，调用 <code>mergeField</code>；</li>
<li>再遍历 <code>child</code>，如果 key 不在 <code>parent</code> 的自身属性上，则同样调用 <code>mergeField</code>。</li>
</ul>
<p><code>mergeField</code> 函数对不同的 <code>key</code> 有着不同的合并策略：</p>
<ul>
<li><p>对于生命周期函数：</p>
<p><code>src/core/util/options.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	parentVal?: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  childVal?: <span class="built_in">Function</span> | <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line">	<span class="keyword">const</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">    	? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">				? childVal</span><br><span class="line">				: [childVal]</span><br><span class="line">		: parentVal</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">    ? dedupeHooks(res)</span><br><span class="line">    : res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupeHooks</span> (<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, i &lt; hooks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(hooks[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      res.push(hooks[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>LIFECYCLE_HOOKS</code> 定义在 <code>src/shared/constants.js</code> 中：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">&#x27;beforeCreate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;created&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeMount&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mounted&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeUpdate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;updated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeDestroy&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;destroyed&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;activated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deactivated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;errorCaptured&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>这里定义了 Vue.js 的所有钩子函数名称，所以对于钩子函数，他们的合并策略都是 <code>mergeHook</code> 函数：</p>
<p>使用了一个多层 3 元运算符：</p>
<ul>
<li>如果不存在 <code>childVal</code>，就返回 <code>parentVal</code>；</li>
<li>否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；</li>
<li>否则返回 <code>childVal</code> 的数组。</li>
</ul>
</li>
</ul>
<p>回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p>
<p>通过执行 <code>mergeField</code> 函数，把合并后的结果保存到 <code>options</code> 对象中，最终返回。</p>
<p>执行完如下合并后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>vm.$options</code> 的值大概如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">created</span>: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">directive</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">filters</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">_base</span>: <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件场景"><a href="#组件场景" class="headerlink" title="组件场景"></a>组件场景</h3><p>组件的构造函数是通过 <code>Vue.extend</code> 继承自 <code>Vue</code> 的；</p>
<p><code>src/core/global-api/extend.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class inheritance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Sub.options = mergeOptions(</span><br><span class="line">    Super.options,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">  <span class="comment">// later at instantiation we can check if Super&#x27;s options have</span></span><br><span class="line">  <span class="comment">// been updated.</span></span><br><span class="line">  Sub.superOptions = Super.options</span><br><span class="line">  Sub.extendOptions = extendOptions</span><br><span class="line">  Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>extendOptions</code> 对应的就是前面定义的组件对象，它会和 <code>Vue.options</code> 合并到 <code>Sub.options</code> 中。</p>
<p>再来看一下子组件的初始化过程：</p>
<p><code>src/core/vdom/create-component.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForValue</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	vnode: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里的 <code>vnode.componentOptions.Ctor</code> 就是执行那个 <code>Vue.extend</code> 的返回值 <code>Sub</code>，所以执行 <code>new vnode.componentOptions.Ctor(options)</code>，接着执行 <code>this._init(options)</code>，因为 <code>options._isComponent</code> 为 true，那么合并 <code>options</code> 的过程走到了 <code>initInternalComponent(vm, options)</code> 逻辑。</p>
<p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// doing this because it&#x27;s faster than dunamic enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = nodeComponentOptions.tag</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 代码分析：</p>
<ul>
<li>首先执行 <code>const opts = vm.$options = Object.create(vm.constructor.options)</code>；</li>
<li>这里的 <code>vm.constructor</code> 就是子组件的构造函数 <code>Sub</code>，相当于 <code>vm.$options = Object.create(Sub.options)</code>；</li>
<li>接下来把实例化子组件传入的子组件父 VNode 实例 <code>parentVnode</code>、子组件的父 Vue 实例 <code>parent</code> 保存到 <code>vm.$options</code> 中；</li>
<li>另外还保留了 <code>parentVnode</code> 配置中的其他属性。</li>
</ul>
<p>因此执行完如下合并后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initInternalComponent(vm, options)</span><br></pre></td></tr></table></figure>

<p><code>vm.$options</code> 的值差不多是：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = &#123;</span><br><span class="line">  <span class="attr">parent</span>: Vue <span class="comment">/* 父 Vue 实例 */</span>,</span><br><span class="line">  <span class="attr">propsData</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">_componentTag</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">_parentVnode</span>: VNode <span class="comment">/* 父 VNode 实例 */</span>,</span><br><span class="line">  <span class="attr">_renderChildren</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">directives</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">filters</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">_base</span>: <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_Ctor</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">created</span>: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;child created&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">mounted</span>: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">mounted</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;child mounted&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对于 <code>options</code> 的两种合并方式中，子组件初始化过程通过 <code>initInternalComponent</code> 方式要比外部初始化 Vue 通过 <code>mergeOptions</code> 的过程要快，合并完的结果保留在 <code>vm.$options</code> 中。</p>
</blockquote>
<h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程，在这过程中会运行一些叫做生命周期的钩子函数：</p>
<p>![img](vue 源码/lifecycle.png)</p>
<p>源码中最终执行生命周期的函数都是调用 <code>callHook</code> 方法：</p>
<p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm: Component, hook: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$optons[hook]</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span></span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>callHook</code> 逻辑分析：</p>
<p>根据传入的字符串 <code>hook</code>，去拿到 <code>vm.$options[hook]</code> 对应的回调函数数组，然后遍历执行，执行时把 <code>vm</code> 作为函数执行的上下文</p>
<p><code>callHook</code> 函数的功能就是调用某个生命周期钩子注册的所有回调函数。</p>
<h3 id="beforeCreate-amp-created"><a href="#beforeCreate-amp-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h3><p><code>beforeCreate</code> 和 <code>create</code> 都是在实例化 <code>Vue</code> 的阶段，在 <code>_init</code> 方法中执行。</p>
<p><code>src/core/instance/init.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性：</p>
<ul>
<li><code>beforeCreate</code> 的钩子函数中不能获取到 <code>props</code>、<code>data</code> 中定义的值，而又不能调用 <code>methods</code> 中定义的函数；</li>
<li>在这两个钩子函数执行的时候，并没有渲染 DOM，所以也不能够访问 DOM；</li>
<li>一般在组件加载的时候需要和后端有交互，则放在这两个钩子中均可；</li>
<li>如果是需要访问 <code>props</code>、<code>data</code> 等数据的话，就需要使用 <code>created</code> 钩子函数。</li>
</ul>
<blockquote>
<p>vue-router 和 vuex 都混合了 <code>beforeCreate</code> 钩子函数。</p>
</blockquote>
<h3 id="beforeMount-amp-mounted"><a href="#beforeMount-amp-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h3><p><code>beforeMount</code> 钩子函数发生在 DOM 挂载之前，调用时机是在 <code>mountComponent</code> 函数中。</p>
<p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    call(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在执行 <code>vm._render()</code> 函数渲染 VNode 之前，执行了 <code>beforeMounted</code> 钩子函数，在执行完 <code>vm._update()</code> 把 VNode patch 到真实 DOM 后，执行 <code>mounted</code> 钩子。</p>
<p>这里对 <code>mounted</code> 钩子函数执行有一个判断逻辑，<code>vm.$vnode</code> 如果为 <code>null</code>，则表明这不是依次组件的初始化过程，而是通过外部 <code>new Vue()</code> 初始化过程。</p>
<p>对于组件，<code>mounted</code> 的时机略有不同：</p>
<p>组件的 VNode patch 到 DOM 后，会执行 <code>invokeInsertHook</code> 函数，把 <code>insertedVnodeQueue</code> 里保存的钩子函数依次执行一遍。</p>
<p><code>src/core/vdom/patch.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay insert hook for component root nodes, invoke them after the</span></span><br><span class="line">  <span class="comment">// element is really inserted</span></span><br><span class="line">  <span class="keyword">if</span> (isTure(initial) &amp;&amp; inDef(vnode.parent)) &#123;</span><br><span class="line">    vnode.parent.data.pendingInsert = queue</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">      queue[i].data.hook.insert(queue[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>invodeInsertHook</code> 函数会执行定义在 <code>componentVNodeHooks</code> 中的 <code>insert</code> 这个钩子函数。</p>
<p><code>src/core/vdom/create-component.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>每个子组件都是在这个钩子函数中执行 <code>mounted</code> 钩子函数，且 <code>insertVnodeQueue</code> 的添加顺序是先子后父，所以对于同步渲染的子组件而言，<code>mounted</code> 钩子函数的执行顺序也是 <strong>先子后父</strong>。</p>
<h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p><code>beforeUpdate</code> 和 <code>updated</code> 的钩子函数执行时机都应该是在数据更新的时候。</p>
<p><code>beforeUpdate</code> 的执行时机是在渲染 Watcher 的 <code>before</code> 函数中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>会判断，在组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。</p>
<p><code>update</code> 的执行时机是在 <code>flushSchedulerQueue</code> 函数调用的时候。</p>
<p><code>src/core/observer/scheduler.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取到 updatedQueue</span></span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[i]</span><br><span class="line">    <span class="keyword">const</span> vm = watcher.vm</span><br><span class="line">    <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm.isDestroyed) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>updatedQueue</code> 是更新了的 <code>watcher</code> 数组，在 <code>callUpdatedHooks</code> 函数中，它对这些数组做遍历，只有满足当前 <code>watcher</code> 为 <code>vm._watcher</code> 以及组件已经 <code>mounted</code> 且未 <code>destroyed</code> 这三个条件，才会执行 <code>updated</code> 钩子函数。</p>
<p>在组件 mount 的过程中，会实例化一个渲染的 <code>Watcher</code> 去监听 <code>vm</code> 上的数据变化重新渲染，这发生在 <code>mountComponent</code> 函数执行的时候：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 简写</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在实例化 <code>Watcher</code> 的过程中，在它的构造函数里会判断 <code>isRenderWatcher</code>，接着把当前 <code>watcher</code> 的实例赋值给 <code>vm._watcher</code>。</p>
<p><code>src/core/observer/watcher.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">   vm: Component,</span></span><br><span class="line"><span class="params">   expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   options?: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">   isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同时，还把当前 <code>watcher</code> 实例 push 到 <code>vm._watchers</code> 中，<code>vm._watcher</code> 是专门用来监听 <code>vm</code> 上数据变化然后重新渲染的，所以它是一个渲染相关的 <code>watcher</code>，因此在 <code>callUpdatedHook</code> 函数中，只有 <code>vm._watcher</code> 的回调执行完毕后，才会执行 <code>updated</code> 钩子函数。</p>
<h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p><code>beforeDestroy</code> 和 <code>destroy</code> 钩子函数的执行时机在组件销毁的阶段，最终会调用 <code>$destroy</code> 方法：</p>
<p><code>src/core/instance/lifecycle.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="line">  <span class="comment">// ... 此处进行销毁操作</span></span><br><span class="line">  vm.isDestroyed = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// incoke destroy hooks on current rendered tree</span></span><br><span class="line">  vm.__patch__(vm._vnode, <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// fire destroyed hook</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">  <span class="comment">// turn off all instance listeners</span></span><br><span class="line">  vm.$off()</span><br><span class="line">  <span class="comment">// remove __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// release circular reference (#6759)</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode) &#123;</span><br><span class="line">    vm.$vnode.parent = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>beforeDestroy</code> 钩子函数的执行时机是在 <code>$destroy</code> 函数执行最开始的地方，接着执行了一些列的销毁操作：</p>
<ul>
<li>从 <code>parent</code> 的 <code>$children</code> 中删掉自身；</li>
<li>删除 <code>watcher</code>；</li>
<li>当前渲染的 VNode 执行销毁钩子函数等</li>
</ul>
<p>执行完毕后再调用 <code>destroyed</code> 钩子函数。</p>
<p>在 <code>$destroy</code> 的执行过程中，它又会执行 <code>vm.__patch__(vm.vnode, null)</code> 触发它子组件的销毁钩子函数，进行一层层的递归调用，所以 <code>destroyed</code> 钩子函数执行顺序是 <strong>先子后父</strong>，和 <code>mounted</code> 过程一样。</p>
<blockquote>
<p><code>beforeDestroy</code> 的调用顺序是 <strong>先父后子</strong>，<code>destroyed</code> 的调用顺序是 <strong>先子后父</strong>。</p>
</blockquote>
<h3 id="activated-amp-deactivated"><a href="#activated-amp-deactivated" class="headerlink" title="activated &amp; deactivated"></a>activated &amp; deactivated</h3><p><code>activated</code> 和 <code>deactivated</code> 钩子函数是专门为 <code>keep-alive</code> 组件定制的钩子。</p>
<blockquote>
<ul>
<li>在 <code>created</code> 钩子函数中可以访问到数据；</li>
<li>在 <code>mounted</code> 钩子函数中可以访问到 DOM；</li>
<li>在 <code>destroyed</code> 钩子函数中可以做一些定时器销毁工作…</li>
</ul>
</blockquote>
<h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>在 Vue.js 中，除了内置的组件 <code>keep-alive</code>、<code>transition</code>、<code>transition-group</code> 等，其他用户自定义组件在使用前必须注册，否则会报错：</p>
<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Unkown custom element: &lt;xxx&gt; - did you register the component correctly? For recursive components, make sure to provide the &quot;name&quot; option.&#x27;</span></span><br></pre></td></tr></table></figure>

<p>![image-20211123145637885](vue 源码/image-20211123145637885.png)</p>
<p>Vue.js 提供了 2 种组件注册的方式：全局注册 和 局部注册。</p>
<h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>要注册一个全局组件，可以使用 <code>Vue.component(tagName, options)</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>Vue.component</code> 的定义过程发生在初始化 Vue 的全局函数的时候：</p>
<p><code>src/core/global-api/assets.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ASSET_TYPES &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/constants&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isplainObject, validateComponentName &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create asset registration methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[<span class="keyword">type</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    	id: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      definition: <span class="built_in">Function</span> | <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>,options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>][id]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="keyword">type</span> === <span class="string">&#x27;component&#x27;</span>) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;component&#x27;</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = <span class="built_in">this</span>.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;directive&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>][id] = definition</span><br><span class="line">        <span class="keyword">return</span> definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>函数首先遍历 <code>ASSET_TYPES</code>，得到 <code>type</code> 后挂载到 Vue 上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>也就是 Vue 初始化了 3 个全局函数，并且当 <code>type</code> 是 <code>component</code> 且 <code>definition</code> 是一个对象的话，通过 <code>this.$options._base.extend</code>（即 <code>Vue.extend</code>）将这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + &#39;s&#39;][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sub.options = mergeOptions(</span><br><span class="line">  Super.options,</span><br><span class="line">  extendOptions</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在继承中，会把 <code>Vue.options</code> 合并到 <code>Sub.options</code>，也就是组件的 <code>options</code> 上，然后在组件的实例化阶段，执行 <code>mergeOptions</code> 逻辑，把 <code>Sub.options.components</code> 合并到 <code>vm.$options.components</code> 上。</p>
<p>然后在创建 <code>vnode</code> 的过程中，会执行 <code>_createElement</code> 方法：</p>
<p><code>src/core/vdom/create-element.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span> | Class&lt;Component&gt; | Funciton | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data?: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> children?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> normalizationType?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;component&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      	tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolveAsset</code> 的定义：</p>
<p><code>src/core/utils/options.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve an asset.</span></span><br><span class="line"><span class="comment"> * This function is used because child instances need access</span></span><br><span class="line"><span class="comment"> * to assets defined in its ancestor chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsset</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">options: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">type</span>: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> id: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> warnMissing?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore is */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> assets = options[<span class="keyword">type</span>]</span><br><span class="line">  <span class="comment">// check local registration variations first</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, id)) <span class="keyword">return</span> assets[id]</span><br><span class="line">  <span class="keyword">const</span> camelizedId = camelize(id)</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line">  <span class="keyword">const</span> PascalCaseId = capitalize(camelizedId)</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, PascalCaseId)) <span class="keyword">return</span> assets[PascalCaseId]</span><br><span class="line">  <span class="comment">// fallback to prototype chain</span></span><br><span class="line">  <span class="keyword">const</span> res = assets[id] || assets[camelizedId] || assets[PascalCaseId]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warnMissing &amp;&amp; !res) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;Failed to resolve &#x27;</span> + <span class="keyword">type</span>.slice(<span class="number">0</span>, -<span class="number">1</span>) + <span class="string">&#x27;: &#x27;</span> + id,</span><br><span class="line">      options</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li>先通过 <code>const assets = options[type]</code> 拿到 <code>assets</code>；</li>
<li>然后尝试拿 <code>assets[id]</code>：<ol>
<li>先直接使用 <code>id</code> 拿；</li>
<li>若不存在，把 <code>id</code> 变成驼峰的形式再拿；</li>
<li>还不存在，则在驼峰的基础上把首字母变成大写的形式再拿；</li>
<li>还拿不到，则报错。</li>
</ol>
</li>
</ol>
<blockquote>
<p>也就是说，在使用 <code>Vue.component(id, definition)</code> 全局注册组件时，id 可以是连字符、小驼峰或大驼峰。</p>
</blockquote>
<p>在 <code>resolveAsset(context.$options, &#39;components&#39;, tag)</code> 调用中，也就相当于拿 <code>vm.$options.component[tag]</code>，取到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p>
<h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>Vue.js 也支持局部注册，在一个组件内部使用 <code>components</code> 选项做组件的局部注册：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在组件的实例化阶段有一个合并 <code>option</code> 的逻辑，就是把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p>
<blockquote>
<p>局部组件的不同在于：只有该类型的组件才可以访问局部注册的子组件，而全局注册时扩展到 <code>Vue.options</code> 下。</p>
</blockquote>
<h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步的能力：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 reuqire 语法告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">  <span class="comment">// 这些块将通过 Ajax 请求自动下载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>Vue 注册的组件不再是一个对象，而是一个工厂函数，函数有 <code>resolve</code> 和 <code>reject</code> 两个参数，内部调用了 <code>setTimeOut</code> 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址，最终通过执行 <code>resolve</code> 方法，参数就是异步组件对象。</p>
<h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>组件的定义并不是一个普通对象，所以不会执行 <code>Vue.extend</code> 的逻辑变为一个组件的构造函数，但依旧执行 <code>createComponent</code> 函数：</p>
<p><code>src/core/vdom/create-component.js</code> 中：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">Ctor: Class&lt;component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> children: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(Ctor)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._bases</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asuncFactory, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">      <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">      <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时传入的 <code>Ctor</code> 是一个函数，不会执行 <code>Vue.extend</code> 逻辑，因此 <code>cid</code> 是 <code>undefined</code>，进入异步组件创建逻辑，首先执行 <code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</code> 方法：</p>
<p><code>src/core/vdom/helpers/resolve-async-component.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	factory: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.errorComp</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> owner = currrntRenderingInstance</span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// already pending</span></span><br><span class="line">    factory.owners.push(owner)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingCamp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.owners.push(owner)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; !isDef(factory.owners)) &#123;</span><br><span class="line">    <span class="keyword">const</span> owners = factory.owners = [owner]</span><br><span class="line">    <span class="keyword">let</span> sync = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> timerLoading = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> timerTimeout = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    ;(owner: <span class="built_in">any</span>).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="function">() =&gt;</span> remove(owners, owner))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = owners.length; i &lt; l; i++) &#123;</span><br><span class="line">        (owner[i]: <span class="built_in">any</span>).$forceUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">          timerLoading = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">          timerTimeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// cache resolved</span></span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="comment">// invoke callbacks only if this is not a synchronous resolve</span></span><br><span class="line">      <span class="comment">// (async resolves are shimmed as synchronous during SSR)</span></span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed to resolve async component: <span class="subst">$&#123;<span class="built_in">String</span>(factory)&#125;</span>`</span> +</span><br><span class="line">        (reason ? <span class="string">`\nReason: <span class="subst">$&#123;reason&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">        factory.error = <span class="literal">true</span></span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> res = factory(resolve, reject)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// return in case resolved synchronously</span></span><br><span class="line">    <span class="keyword">return</span> factory.loading</span><br><span class="line">    	? factory.loadingComp</span><br><span class="line">    	: factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>resolveAsyncComponent</code> 函数逻辑较为复杂，实际处理了 3 种异步组件的创建方式：</p>
<ul>
<li><p>普通函数（工厂函数）异步组件；</p>
</li>
<li><p><code>Promise</code> 异步组件；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 该 `import` 函数返回一个 `Promise` 对象</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li>
<li><p>高级异步组件。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 -- 应当是一个 Promise</span></span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./MyComp.vue&#x27;</span>),</span><br><span class="line">	<span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">  <span class="attr">loading</span>: LoasingComp,</span><br><span class="line">  <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">  <span class="attr">error</span>: ErrorComp,</span><br><span class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 最长等待时间。超出时间则渲染组件错误。默认：Infinity</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, AsyncComp)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="普通函数异步组件"><a href="#普通函数异步组件" class="headerlink" title="普通函数异步组件"></a>普通函数异步组件</h3><p>实际加载中，定义了 <code>forceRender</code>、<code>resolve</code> 和<code>inject</code> 函数，这里 <code>resolve</code> 和 <code>reject</code> 函数用 <code>once</code> 函数做了一层包装：</p>
<p><code>src/shared/util.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensure a function is called only once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn: <span class="built_in">Function</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>. <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：传入一个函数，并返回一个新函数，巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次。</p>
<p>接着执行 <code>const res = factory(resolve, reject)</code> 逻辑，即执行组件的工厂函数，同时把 <code>resolve</code> 和 <code>reject</code> 函数作为参数传入，组件的工厂函数通常会先发送请求去加载异步组件的 JS 文件，拿到组件定义的对象 <code>res</code> 后，执行 <code>resolve(res)</code> 逻辑，会先执行 <code>factory.resolved = ensureCtor(res, baseCtor)</code>：</p>
<figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCtor</span> (<span class="params">comp: <span class="built_in">any</span>, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    comp.__esModule ||</span><br><span class="line">    (hasSymbol &amp;&amp; comp[<span class="built_in">Symbol</span>.toStringTag] === <span class="string">&#x27;Moudule&#x27;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    comp = comp.default</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isObject(comp)</span><br><span class="line">		? base.extend(comp)</span><br><span class="line">  	: comp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>ensureCtor</code> 的目的是为了保证能找到异步组件 JS 定义的组件对象，并且如果是一个普通对象，则调用 <code>Vue.extend</code> 把它转换成一个组件的构造函数。</p>
<p><code>resolve</code> 的逻辑最后判断了 <code>sunc</code>，为 <code>false</code> 则会执行 <code>forceRender</code> 函数：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = owners.length; i &lt; l; i++) &#123;</span><br><span class="line">    (owners[i]: <span class="built_in">any</span>).$forceUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">    owners.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">      timerLoading = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">      timerTimeout = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>遍历 <code>factory.owners</code>；</li>
<li>拿到每一个调用异步组件的实例 <code>vm</code>；</li>
<li>执行 <code>vm.$forceUpdate()</code> 方法。</li>
</ul>
<p><code>src/core/instance.lifecycle.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.updata()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：调用渲染 <code>watcher</code> 的 <code>update</code> 方法，让渲染 <code>watcher</code> 对应的回调函数执行，也就是触发了组件的重新渲染。</p>
<h3 id="Promise-异步组件"><a href="#Promise-异步组件" class="headerlink" title="Promise 异步组件"></a>Promise 异步组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 该 `import` 函数返回一个 `Promise` 对象。</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>webpack 2+ 支持了异步加载的语法糖：<code>() =&gt; import(&#39;./my-async-component&#39;)</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回的值就是 <code>import(&#39;./my-async-component&#39;)</code> 的返回值，是一个 <code>Promise</code> 对象。</p>
<p>接着进入 if 条件判断 <code>isObject(res)</code> 和 <code>isPromise(res)</code>，条件满足，执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isPromise(res)) &#123;</span><br><span class="line">    <span class="comment">// () =&gt; Promise</span></span><br><span class="line">    <span class="keyword">if</span> (imUndef(factory.resolved)) &#123;</span><br><span class="line">      res.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当组件异步加载成功后，执行 <code>resolve</code>，加载失败则执行 <code>reject</code>，这样就非常巧妙地实现了配合 webpack 2+ 的异步加载组件方式（<code>Promise</code>）加载异步组件。</p>
<h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><p>由于异步加载组件需要加载 JS，有一定网络延时，而且有加载失败的情况，所以需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。</p>
<p>Vue.js 2.3+ 支持了一种高级异步组件的方式，它通过一个简单的对象配置，搞定 loading 组件和 error 组件的渲染时机：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件。应当是一个 Promise</span></span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./MyComp.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">  <span class="attr">loading</span>: LoadingComp,</span><br><span class="line">  <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">  <span class="attr">error</span>: ErrorComp,</span><br><span class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, AsyncComp)</span><br></pre></td></tr></table></figure>

<p>高级一部组件的初始化逻辑和普通异步组件一样，也是执行 <code>resolveAsyncComponent</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回值就是定义的组件对象，满足 <code>isObject(res)</code> 和 <code>isPromise(res.component)</code>，接着执行 <code>res.component.then(resolve, reject)</code>，当异步组件加载成功后，执行 <code>resolve</code>，失败执行 <code>reject</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPromise(res.component)) &#123;</span><br><span class="line">  res.component.then(resolve, reject)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为异步组件加载是一个异步过程，所以接着执行以下逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params">factory, baseCtor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(res.error)) &#123;</span><br><span class="line">    factory.errorComp = ensureCtor(res.error, baseCtor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(res.loading)) &#123;</span><br><span class="line">    factory.loadingComp = ensureCtor(res.loading, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (res.delay === <span class="number">0</span>) &#123;</span><br><span class="line">      factory.loading = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeLoading = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timerLoading = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(factory.resolved) &amp;&amp; inUndef(factory.error)) &#123;</span><br><span class="line">          factory.loading = <span class="literal">true</span></span><br><span class="line">          forceRender(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, res.delay || <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(res.timeout)) &#123;</span><br><span class="line">    timerTimeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timerTmeout = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (inUndef(factory.resolved)) &#123;</span><br><span class="line">        reject(</span><br><span class="line">          process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">          	? <span class="string">`timeout (<span class="subst">$&#123;res.timeout&#125;</span>ms)`</span></span><br><span class="line">          	: <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, res.timeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>先判断 <code>res.error</code> 是否定义了 <code>error</code> 组件，有则赋值给 <code>factory.errorComp</code>；</li>
<li>接着判断 <code>res.loading</code> 是否定义了 <code>loading</code> 组件，有则赋值给 <code>factory.loadingComp</code>；</li>
<li>如果设置了 <code>res.delay</code> 且为 0，则设置 <code>factory.loading = true</code>，否则延时 <code>delay</code> 的时间执行；</li>
<li>最后判断 <code>res.timeout</code>，若配置了，则在 <code>res,timeout</code> 时间后没成功加载组件执行 <code>reject</code>。</li>
</ul>
<p>在 <code>resolveAsyncComponent</code> 最后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> factory.loading</span><br><span class="line">	? factory.loadingComp</span><br><span class="line">	: factory.resolved</span><br></pre></td></tr></table></figure>

<p>如果 <code>delay</code> 为 0，则直接渲染 loading 组件，否则延时 <code>delay</code> 执行 <code>forceRender</code>，那么在一次执行到 <code>resolveAsyncComponent</code>。</p>
<h4 id="加载失败-reject"><a href="#加载失败-reject" class="headerlink" title="加载失败 reject"></a>加载失败 reject</h4><p>当异步组件加载失败，会执行 <code>reject</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">    <span class="string">`Failed to resolve async component: <span class="subst">$&#123;Stirng(factory)&#125;</span>`</span> +</span><br><span class="line">    (reason ? <span class="string">`\nReason: <span class="subst">$&#123;reason&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">    factory.error = <span class="literal">true</span></span><br><span class="line">    forceRender()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>这时候会把 <code>factory.error</code> 设置为 <code>true</code>，同时执行 <code>forceRender()</code> 再次执行到 <code>resolveAsyncComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory.errorComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时会直接返回 <code>factory.errorComp</code>，直接渲染 error 组件。</p>
<h4 id="加载成功-resolve"><a href="#加载成功-resolve" class="headerlink" title="加载成功 resolve"></a>加载成功 resolve</h4><p>当异步组件加载失败，会执行 <code>resolve</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">  <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">    forceRender()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>首先把加载结果缓存到 <code>factory.resolved</code> 中，此时 <code>sync</code> 已经为 false，则执行 <code>forceRender()</code> 再次执行到 <code>resolvedAsyncComponent</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory.resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时直接返回 <code>factory.resolved</code>，渲染成功加载的组件。</p>
<h4 id="加载中-loading"><a href="#加载中-loading" class="headerlink" title="加载中 loading"></a>加载中 loading</h4><p>如果异步组件加载中并未返回，此时会执行以下逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123;</span><br><span class="line">  <span class="keyword">return</span> dactory.loadingComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时返回 <code>factory.loadingComp</code>，渲染 loading 组件。</p>
<h4 id="加载超时-timeout"><a href="#加载超时-timeout" class="headerlink" title="加载超时 timeout"></a>加载超时 timeout</h4><p>若加载超时，则走到了 <code>reject</code> 逻辑，之后同加载失败，渲染 error 组件。</p>
<blockquote>
<p>异步组件实现的本质是两次（或三次）渲染，先渲染成注释节点，当组件加载成功后，再通过 forceRender 重新渲染。</p>
</blockquote>
<h3 id="异步组件-patch"><a href="#异步组件-patch" class="headerlink" title="异步组件 patch"></a>异步组件 patch</h3><p>回看 <code>createComponent</code> 逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ctor = resolveAsyncComponent(asyncFactory, baseCtor)</span><br><span class="line"><span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">    asyncFactory,</span><br><span class="line">    data,</span><br><span class="line">    context,</span><br><span class="line">    children,</span><br><span class="line">    tag</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果是首次执行 <code>resolveAsyncComponent</code>，除非使用高级异步组件 <code>0 delay</code> 去创建了一个 loading 组件，否则返回是 <code>undefined</code>，接着通过 <code>createAsyncPlaceholder</code> 创建一个注释节点作为占位符：</p>
<p><code>src/core/vdom/helpers/resolve-async-components.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAsyncPlaceholder</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">	factory: Funciton,</span></span></span><br><span class="line"><span class="params"><span class="function">   data: VnodeData,</span></span></span><br><span class="line"><span class="params"><span class="function">   context: Compnent,</span></span></span><br><span class="line"><span class="params"><span class="function">   children: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">   tag: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line"> 	<span class="keyword">const</span> node = createEmptyVNode()</span><br><span class="line">  node.asyncFactory = factory</span><br><span class="line">  node.asyncMeta = &#123; data, context, children, tag &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是创建了一个占位的注释 VNode，同时把 <code>asyncFactory</code> 和 <code>asyncMeta</code> 赋值给当前 <code>vnode</code>。</p>
<p>当执行 <code>forceRender</code> 时，会触发组件的重新渲染，将会再一次执行 <code>resolveAsyncComponent</code>，此时就会根据情况返回 loading、error 或 成功加载的异步组件，返回值不为 <code>undefined</code>，因此就走正常的组件 <code>render</code>、<code>patch</code> 过程，与第一次渲染流程不一样。</p>
<h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p>前端开发最重要的 2 个工作：</p>
<ul>
<li>把数据渲染到页面</li>
<li>处理用户交互</li>
</ul>
<h2 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h2><p>Vue.js 实现响应式的核心是利用了 ES5 的 <code>Object.defineProperty</code>，这也是 Vue.js 不能兼容 IE8 及以下浏览器的原因。</p>
<h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote>
<p>MDN 文档：<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p>
</blockquote>
<p><code>Object.defineProperty</code> 方法会直接再一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure>

<ul>
<li><code>obj</code>：要在其上定义属性的对象；</li>
<li><code>props</code>：要定义或修改的属性的名称；</li>
<li><code>descriptor</code>：将被定义或修改的属性描述符。</li>
</ul>
<p>其中 <code>descriptor</code> 是核心，它有很多可选键值：</p>
<ul>
<li><code>get</code>：是一个给属性提供的 getter 方法，访问该属性时会触发 getter 方法；</li>
<li><code>set</code>：是一个给属性提供的 setter 方法，对该属性做修改时会触发 setter 方法。</li>
</ul>
<p>一旦对象拥有了 getter 和 setter，我们就可以简单地把这个对象称为<strong>响应式对象</strong>。</p>
<h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p>在 Vue 的初始化阶段，<code>_init</code> 方法执行时，会执行 <code>initState(vm)</code> 方法：</p>
<p><code>src/core/instance/state.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>watcher</code> 等属性做初始化操作。</p>
<h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propsKeys = []</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObsering(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">				warn(</span><br><span class="line">          <span class="string">`&quot;<span class="subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +</span><br><span class="line">            <span class="string">`values. Prop being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static props are already proxied on the component&#x27;s prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>props</code> 的初始化主要过程就是：遍历定义的 <code>props</code> 配置。</p>
<ol>
<li>调用 <code>defineReactive</code> 方法把每个 <code>prop</code> 对应的值变成响应式，可以通过 <code>vm._props.xxx</code> 访问到定义 <code>props</code> 中对应的属性；</li>
<li>通过 <code>proxy</code> 把 <code>vm._props.xxx</code> 的访问代理到 <code>vm.xxx</code> 上。</li>
</ol>
<h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  	? getData(data, vm)</span><br><span class="line">  	: data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPLainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`data functions should return an object:\n`</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>data</code> 的初始化主要过程：</p>
<ol>
<li>对定义的 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上；</li>
<li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式，可以通过 <code>vm._data.xxx</code> 访问到定义 <code>data</code> 返回函数中对应的属性。</li>
</ol>
<h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>代理：作用就是把 <code>props</code> 和 <code>data</code> 上的属性代理到 <code>vm</code> 实例上。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  set noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: <span class="built_in">string</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现原理：通过 <code>Object.defineProperty</code> 把 <code>target[sourceKey][key]</code> 的读写变成了对 <code>target[key]</code> 的读写。</p>
<h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><code>observe</code> 的功能就是用来监测数据的变化</p>
<p><code>src/core/observer/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: <span class="built_in">any</span>, asRootData: <span class="built_in">boolean</span></span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="built_in">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasWon(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !serverRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：给非 VNode 的对象类型数据添加一个 <code>Observer</code>：</p>
<ul>
<li>如果已经添加过则直接返回；</li>
<li>否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。</li>
</ul>
<h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>Observer</code> 是一个类，作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attacted to each observed</span></span><br><span class="line"><span class="comment"> * object. ONce attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object&#x27;s property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: <span class="built_in">number</span>; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCOunt = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li><p>首先实例化 <code>Dep</code> 对象；</p>
</li>
<li><p>通过执行 <code>dep</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上；</p>
<p><code>src/core/util/lang.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: <span class="built_in">Object</span>, key: <span class="built_in">string</span>, val: <span class="built_in">any</span>, enumerable?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>def</code> 函数是一个 <code>Object.defineProperty</code> 的封装。</p>
</li>
<li><p>对 <code>value</code> 做判断：</p>
<ul>
<li>数组：调用 <code>observeArray</code> 方法，遍历数组再次调用 <code>observe</code> 方法；</li>
<li>纯对象：调用 <code>walk</code> 方法，遍历对象的 key 调用 <code>defineReactive</code> 方法。</li>
</ul>
</li>
</ul>
<h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter</p>
<p><code>src/core/observer/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> customSetter?: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> shallow?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; argument.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ol>
<li>初始化 <code>Dep</code> 对象的实例；</li>
<li>拿到 <code>obj</code> 的属性描述符；</li>
<li>然后对子对象递归调用 <code>observe</code> 方法；</li>
<li>利用 <code>Object.defineProperty</code> 给 <code>obj</code> 的属性 <code>key</code> 添加 getter 和 setter。</li>
</ol>
<h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>响应式对象 getter 相关的逻辑就是做 <strong>依赖收集</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">definedReactive</span> (<span class="params">obj, key, val,customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键点：</p>
<ol>
<li><code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 的实例；</li>
<li>通过 <code>dep.depend()</code> 做依赖收集，其中对 <code>childOb</code> 做判断。</li>
</ol>
<h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p><code>Dep</code> 是整个 getter 依赖收集的核心</p>
<p><code>src/core/observer/dep.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> Watcher <span class="keyword">from</span> <span class="string">&#x27;./watcher&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can hace multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: Watcher;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Dep</code> 是一个 Class，定义了一些属性和方法，其中关键的是有一个静态属性 <code>target</code>，是一个全局唯一 <code>Watcher</code>，它的自身属性 <code>subs</code> 是一个 <code>Watcher</code> 的数组。</p>
<blockquote>
<p><code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的。</p>
</blockquote>
<h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Wathcer</span> </span>&#123;</span><br><span class="line">  <span class="attr">vm</span>: Component;</span><br><span class="line">  expression: <span class="built_in">string</span>;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  deep: <span class="built_in">boolean</span>;</span><br><span class="line">  user: <span class="built_in">boolean</span>;</span><br><span class="line">  lazy: <span class="built_in">boolean</span>;</span><br><span class="line">  sync: <span class="built_in">boolean</span>;</span><br><span class="line">  dirty: <span class="built_in">boolean</span>;</span><br><span class="line">  active: <span class="built_in">boolean</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: <span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">   vm: Component,</span></span><br><span class="line"><span class="params">   expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   options?: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">   isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="built_in">this</span>.before = !!options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.computed <span class="comment">// for computed watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = []</span><br><span class="line">    <span class="built_in">this</span>.newDeps = []</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">`Watcher only accepts simple dot-delimited paths. `</span> +</span><br><span class="line">          <span class="string">`For full control, use a function instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="built_in">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="built_in">this</span>.depIds</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Watcher</code> 是一个 Class，其中定义了一些和 <code>Dep</code> 相关的属性：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.deps = []</span><br><span class="line"><span class="built_in">this</span>.newDeps = []</span><br><span class="line"><span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure>

<ul>
<li><code>this.deps</code> 和 <code>this.newDeps</code> 表示 <code>Watcher</code> 实例特有的 <code>Dep</code> 实例的数组；</li>
<li><code>this.depIds</code> 和 <code>this.newDepIds</code> 分别代表 <code>this.deps</code> 和 <code>this.newDeps</code> 的 <code>id</code> Set；<ul>
<li>Set 是 ES6 的数据结构，实现在 <code>src/core/util/env.js</code> 中</li>
</ul>
</li>
<li>还定义了一些原型的方法，和依赖收集相关的包括<code>get</code>、<code>addDep</code>、<code>cleanupDeps</code> 方法。</li>
</ul>
<h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><p>Vue 的 mount 过程是通过 <code>mountComponent</code> 函数：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>当实例化一个渲染 <code>watcher</code> 时，首先进入 <code>watcher</code> 的构造函数逻辑，然后会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，首先执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushTarget(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep .target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈；</p>
<p>接着执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br></pre></td></tr></table></figure>

<p><code>this.getter</code> 对应就是 <code>updateComponent</code> 函数，实际上就是在执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._update(vm._render(), hydrating)</span><br></pre></td></tr></table></figure>

<p>先执行 <code>vm._render()</code> 方法，生成渲染 VNode，并访问 <code>vm</code> 上的数据，此时触发了数据对象的 getter。</p>
<p>每个对象值的 getter 都持有一个 <code>dep</code>，在触发 getter 时会调用 <code>dep.depend()</code> 方法，执行 <code>Dep.target.addDep(this)</code>。</p>
<p>此时 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code>，执行到 <code>addDep</code> 方法：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDep</span> (<span class="params">dep: Dep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.has(id)</span><br><span class="line">    <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>addDep</code> 方法中执行一些判断（保证统一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，然后执行 <code>this.subs.push(sub)</code>，将当前的 <code>watcher</code> 订阅到此数据持有的 <code>dep</code> 的 <code>subs</code> 中。</p>
<p>所以 <code>vm._render()</code> 过程中，会触发所有数据的 getter，也就是完成了一个依赖收集的过程。</p>
<p>还有后续逻辑处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">  traverse(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>递归去访问 <code>value</code> 触发所有子项的 <code>getter</code>；</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">popTarget()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line">Dep.target = targetStack.pop()</span><br></pre></td></tr></table></figure>

<p>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，最后执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.cleanupDeps()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="built_in">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> 	<span class="keyword">let</span> tmp = <span class="built_in">this</span>.depIds</span><br><span class="line">  <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds</span><br><span class="line">  <span class="built_in">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="built_in">this</span>.newDepIds.clear()</span><br><span class="line">  tmp = <span class="built_in">this</span>.deps</span><br><span class="line">  <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps</span><br><span class="line">  <span class="built_in">this</span>.newDeps = tmp</span><br><span class="line">  <span class="built_in">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为 Vue 是数据驱动的，所以每次数据变化都会重新 render，<code>vm._render()</code> 方法就会再次执行，并再次触发数据的 getters，所以 <code>Watcher</code> 在构造函数中会初始化 2 个 <code>Dep</code> 实例数组：</p>
<ul>
<li><code>newDeps</code> 表示新添加的 <code>Dep</code> 实例数组；</li>
<li>而 <code>deps</code> 表示上一次添加的 <code>Dep</code> 实例数组。</li>
</ul>
<p>在执行 <code>cleanupDeps</code> 函数时：</p>
<ol>
<li>首先会遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Watcher</code> 的订阅；</li>
<li>然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换；</li>
<li>将 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</li>
</ol>
<h2 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h2><p>setter 负责 <strong>派发更新</strong>。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val, customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;peoduction&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑中有 2 个关键点：</p>
<ul>
<li><code>childOb = !shallow &amp;&amp; observe(newVal)</code>：<code>shallow</code> 为 false 的情况下，会对新设置的值变成一个响应式对象；</li>
<li><code>dep.notify()</code>：通知所有的订阅者。</li>
</ul>
<h3 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h3><p>当在组件中对响应的数据做了修改，就会触发 setter 的逻辑，最后调用 <code>dep.notify()</code> 方法，它是 <code>Dep</code> 的一个实例方法：</p>
<h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h4><p><code>src/core/observer/dep.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subsriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not runnning async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      sub.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑：遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法：</p>
<h4 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update"></a>watcher.update</h4><p><code>src/core/observer/watcher.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于 <code>Watcher</code> 的不同状态，会执行不同的逻辑：</p>
<p>一般组件数据更新会走到最后一个分支，执行 <code>queueWatcher(this)</code> </p>
<h4 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h4><p><code>src/core/observer/scheduler.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: <span class="built_in">number</span>]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with deplicate IDs will be skipped unless it&#x27;s</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushingm splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i --</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此处引入了队列：并不会每次数据改变都触发 <code>watcher</code> 的回调，而是这些 <code>watcher</code> 先添加到一个队列里，然后在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。</p>
<ul>
<li><code>has</code> 对象保证同一个 <code>Watcher</code> 只添加一次；</li>
<li>通过 <code>waiting</code> 保证对 <code>nextTick(flushSchedulerQueue)</code> 的调用逻辑只有一次（异步执行）。</li>
</ul>
<h4 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h4><p><code>src/core/observer/scheduler.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow()</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">// 		created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">// 		user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span></span><br><span class="line">  <span class="comment">// 		its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dex child, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; has[id] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">            	? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">	            : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line">  </span><br><span class="line">  resetSchledulerState()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">&#x27;flush&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关键逻辑分析：</p>
<p><strong>队列排序</strong>：</p>
<p><code>queue.sort((a, b) =&gt; a.id - b.id)</code> 对队列做了升序排序，可以确保：</p>
<ol>
<li>组件的更新由父到子；</li>
<li>用户的自定义 <code>watcher</code> 要优先于渲染 <code>watcher</code> 执行；</li>
<li>如果一个组件在父组件的 <code>watcher</code> 期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，父组件的 <code>watcher</code> 先执行。</li>
</ol>
<p><strong>队列遍历</strong>：</p>
<p>在对 <code>queue</code> 排序后，接着对它进行遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。</p>
<p>遍历中每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，然后再次执行到 <code>queueWatcher</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushingm splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i --</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时 <code>flushing</code> 为 true，执行到 else 中的逻辑，然后从后往前找到第一个待插入 <code>watcher</code> 的 id 比当前队列中 <code>watcher</code> 的 id 大的位置，因此 <code>queue</code> 的长度发生了变化。</p>
<p><strong>状态恢复</strong>：</p>
<p>就是执行 <code>resetSchedulerState</code> 函数：</p>
<p><code>src/core/observer/scheduler.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: <span class="built_in">number</span>]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: <span class="built_in">number</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler&#x27;s state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queu.length = activatedChildren.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码逻辑就是把这些控制流程状态的变量恢复到初始值，把 <code>watcher</code> 队列清空。</p>
<h4 id="watcher-run"><a href="#watcher-run" class="headerlink" title="watcher.run"></a>watcher.run</h4><p><code>src/core/observer/watcher.js</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="built_in">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the values is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mounted.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="built_in">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">          incokeWithErrorHandling(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>run</code> 函数逻辑：</p>
<ul>
<li>先通过 <code>this.get()</code> 得到当前的值，然后做判断；</li>
<li>若满足 新旧值不等、新值是对象类型、<code>deep</code> 模式 任意一个条件，则执行 <code>watcher</code> 的回调。</li>
</ul>
<p>对于渲染 <code>watcher</code> 来说，在执行 <code>this.get()</code> 方法求值时会执行 <code>getter</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(). hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这就是修改组件相关的响应式数据时，会触发组件重新渲染的原因，接着就会重新执行 <code>patch</code> 的过程。</p>
<h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p><code>nextTick</code> 是 Vue 的一个核心实现</p>
<h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>JS 执行是单线程的，基于事件循环：</p>
<ol>
<li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；</li>
<li>主线程之外，还存在一个 “任务队列”（task queue）。只要异步任务有了运行结果，就在任务队列中放置一个事件；</li>
<li>一旦 执行栈 中的所有同步任务执行完毕，系统就会读取 “任务队列”，结束该任务等待状态，进入执行栈，开始执行；</li>
<li>主线程不断重复第三步。</li>
</ol>
<p>主线程的执行过程就是一个 tick，而所有的一部结果都是通过 “任务队列” 来调度。消息队列中存放的是一个个的任务（task：分为 macro task 和 micro task）：</p>
<ul>
<li>macro task<ul>
<li>setTimeout、MessageChannel、postMessage、setImmediate；</li>
</ul>
</li>
<li>micro task<ul>
<li>MutationObserver、Promise.then</li>
</ul>
</li>
</ul>
<h3 id="Vue-的实现"><a href="#Vue-的实现" class="headerlink" title="Vue 的实现"></a>Vue 的实现</h3><p>在 Vue 2.5+ 后，<code>nextTick</code> 的实现单独有一个 JS 文件来维护：</p>
<p><code>src/core/util/next-tick.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>对外暴露了nextTick 函数：</p>
<p>把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>timerFunc</code>，在下一个 tick 执行 <code>flushCallbacks</code>；</p>
<p><code>flushCallbacks</code> 中对 <code>callbacks</code> 遍历，然后执行相应的回调函数。</p>
<blockquote>
<p>使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因：</p>
<p>保证在同一个 tick 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而是把这些异步任务都压成一个同步任务，在一个 tick 执行完毕。</p>
</blockquote>
<p><code>nextTick</code> 函数最后：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    _resolve = resolve</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>nextTick</code> 不传 <code>cb</code> 参数的时候，提供一个 Promise 化的调用：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextTick().then(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<p>当 <code>_resolve</code> 函数执行，就会跳到 <code>then</code> 的逻辑中。</p>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。</p>
<p>Vue.js 提供了 2 种调用 <code>nextTick</code> 的方式：</p>
<ul>
<li>全局 API <code>Vue.nextTick</code>；</li>
<li>实例上 <code>vm.$nextTick()</code>。</li>
</ul>
<h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于使用 <code>Object.defineProperty</code> 实现响应式的对象，添加新属性时无法触发 setter：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// vm.b 是非响应式的</span></span><br><span class="line">vm.b = <span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>Vue 为了解决这个问题，定义了一个全局 API <code>Vue.set</code> 方法，它在 <code>erc/core/global-api/index.js</code> 中初始化：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set = set</span><br></pre></td></tr></table></figure>

<p><code>set</code> 方法定义在 <code>src/core/observer/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Object</span>, key: <span class="built_in">any</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      (isUndef(target) || isPrimitive(target))</span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: <span class="built_in">any</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: <span class="built_in">any</span>).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.def.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p><code>set</code> 方法接收 3 个参数：</p>
<ul>
<li><code>target</code> 可能是数组或者普通对象；</li>
<li><code>key</code> 代表数组的下标或者对象的键值；</li>
<li><code>val</code> 代表添加的值。</li>
</ul>
<p>首先判断如果 <code>target</code> 是数组且 <code>key</code> 为合法下标，则通过 <code>splice</code> 添加进数组然后返回；</p>
<p>接着判断 <code>key</code> 是否已经存在于 <code>target</code> 中，若存在则直接赋值返回；</p>
<p>否则获取到 <code>target.__ob__</code> 并赋值给 <code>ob</code>（表示 <code>Observer</code> 的一个实例），若不存在则直接赋值并返回；</p>
<p>最后通过 <code>defineReactive(ob.value, key, val)</code> 把新添加的属性变成响应式对象；</p>
<p>再通过 <code>ob.dep.notify()</code> 手动地触发依赖通知。</p>
<h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>Vue 也不能检测到以下变动的数组：</p>
<ul>
<li>利用索引直接设置一个项时；</li>
<li>修改数组的长度时。</li>
</ul>
<p>在通过 <code>observe</code> 方法去观察对象的时候会实例化 <code>Observer</code>，在它的构造函数中时专门对数组做了处理：</p>
<p><code>src/core/observer/index.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: <span class="built_in">number</span>; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先获取 <code>augment</code>，<code>hasProto</code> 用与判断对象中是否存在 <code>__proto__</code>，如果存在则 <code>augment</code> 指向 <code>protoAugment</code>，否则指向 <code>copyAugment</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment a target Object or Array by intercepting</span></span><br><span class="line"><span class="comment"> * the prototype chain using __proto__</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment a target Object or a Array defining</span></span><br><span class="line"><span class="comment"> * hidden properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: <span class="built_in">Object</span>, src: <span class="built_in">Object</span>, keys: <span class="built_in">Array</span>&lt;<span class="built_in">String</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>protoAugment</code> 方法是直接把 <code>target.__proto__</code> 原型直接修改为 <code>src</code>；</li>
<li><code>copyAugment</code> 方法是遍历 keys，通过 <code>def</code>（也就是 <code>Object.defineProperty</code>） 去定义自身的属性值</li>
</ul>
<p>对于大部分现代浏览器都会走到 <code>protoAugment</code>，就把 <code>value</code> 的原型指向了 <code>arrayMethods</code>。</p>
<p><code>src/core/observer/array.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPath = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPath.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>arrayMethods</code> 首先继承了 <code>Array</code>，然后对数组中所有能改变数组自身的方法进行重写：</p>
<ul>
<li>重写后的方法会先执行本身原有的逻辑；</li>
<li>并对能增加数组长度的 3 个方法 <code>push、unshift、splice</code> 方法做了判断，获取到插入的值，将新添加的值变成一个响应式对象；</li>
<li>并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知。</li>
</ul>
<h2 id="计算属性-VS-侦听属性"><a href="#计算属性-VS-侦听属性" class="headerlink" title="计算属性 VS 侦听属性"></a>计算属性 VS 侦听属性</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性的初始化是发生在 Vue 实例初始化阶段的 <code>initState</code> 函数中，执行了 <code>if(opts.computed) initComputed(vm, opts.computed)</code>。</p>
<h4 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h4><p><code>src/core/instance/state.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// computed-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// computed prototype. We only need to defined computed properties define</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a props.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.methods &amp;&amp; key <span class="keyword">in</span> vm.$options.methods) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a method.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>首先创建 <code>vm._computedWatchers</code> 为一个空对象；</li>
<li>接着对 <code>computed</code> 对象做遍历，拿到计算属性的每一个 <code>userDef</code>；</li>
<li>尝试获取这个 <code>userDef</code> 对应的 <code>getter</code> 函数，拿不到则在开发环境下报警告；</li>
<li>为每一个 <code>getter</code> 创建一个 <code>wathcer</code>（一个 <code>computed watcher</code>）；</li>
<li>最后判断 <code>key</code> 是否是 <code>vm</code> 实例的属性：<ul>
<li>不是：调用 <code>defineComputed(vm, key, userDef)</code>；</li>
<li>是：判断是否对应的 <code>key</code> 是否已经被 <code>data、props、methods</code> 所占用，是则在开发环境下报相应的警告。</li>
</ul>
</li>
</ul>
<h4 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a>defineComputed</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  userDef: <span class="built_in">Object</span> | <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">    	? createComputedGetter(key)</span><br><span class="line">    	: createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">    	? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">    		? createComputedGetter(key)</span><br><span class="line">    		: createGetterInvoker(userDef.get)</span><br><span class="line">    	: noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">     sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>利用 <code>Object.defineProperty</code> 给计算属性对应的 <code>key</code> 值添加 getter 和 setter；</p>
<blockquote>
<p>setter 通常是计算属性是一个对象且拥有 <code>set</code> 方法的时候才有，否则是一个空函数。</p>
</blockquote>
<p>最终 getter 对应的是 <code>createComputedGetter(key)</code> 的返回值；</p>
<h4 id="createComputedGetter"><a href="#createComputedGetter" class="headerlink" title="createComputedGetter"></a>createComputedGetter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createComputedGetter</code> 返回一个函数 <code>computedGetter</code>，就是计算属性对应的 getter。</p>
<p>计算属性的初始化过程结束。</p>
<h4 id="computed-watcher"><a href="#computed-watcher" class="headerlink" title="computed watcher"></a>computed watcher</h4><p>分析一下 <code>computed watcher</code> 和普通的 <code>watcher</code> 有什么区别。</p>
<p>当初始化 <code>comupted watcher</code> 时，构造函数部分逻辑略有不同：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">  	? <span class="literal">undefined</span></span><br><span class="line">	  : <span class="built_in">this</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当 <code>render</code> 函数执行访问到该计算属性时，则触发计算属性的 <code>getter</code>，会拿到计算属性对应的 <code>watcher</code>，然后执行 <code>watcher.depend()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="built_in">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时，<code>this.deps[i].depend()</code> 相当于渲染 <code>watcher</code> 订阅了这个 <code>computed watcher</code> 的变化。</p>
<p>再执行 <code>watcher.evaluate()</code> 去求值：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate and return the value if the watcher.</span></span><br><span class="line"><span class="comment"> * This only gets called for computed property watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">  <span class="built_in">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一旦对计算属性依赖的数据做修改，则会触发 setter 过程，通知所有订阅它变化的 <code>watcher</code> 更新，执行 <code>watcher.update()</code> 方法：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscriber interface.</span></span><br><span class="line"><span class="comment"> * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际上有 2 种模式，lazy 和 active，看 <code>watcher.run()</code>：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scheduler job interface.</span></span><br><span class="line"><span class="comment"> * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="built_in">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mytated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="built_in">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">        invokeWithErrorHanding(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>run</code> 中会重新计算，然后对比新旧值，如果变化了则执行回调函数，也就是 <code>this.dep.notify()</code>，触发渲染 <code>watcher</code> 重新渲染。</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>侦听属性的初始化同样是发生在 Vue 实例初始化阶段的 <code>initState</code> 函数中，在 <code>computed</code> 初始化之后，执行：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">  initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h4><p><code>src/core/instance/state.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>,; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>就遍历 <code>watch</code> 对象，拿到每一个 <code>handler</code>，如果 <code>handler</code> 是一个数组，则遍历这个数组，调用 <code>createWatcher</code> 方法，否则直接调用 <code>createWatcher</code>。</p>
<h4 id="createWatcher"><a href="#createWatcher" class="headerlink" title="createWatcher"></a>createWatcher</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  handler: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">     options = handler</span><br><span class="line">     handler = handler.handler</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">     handler = vm[handler]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>首先对 <code>handler</code> 的类型做判断，拿到最终的回调函数，最后调用 <code>vm.$watch(expOrFn, handler, options)</code> 函数，<code>$watch</code> 是 Vue 原型上的方法，在执行 <code>stateMixin</code> 时定义。</p>
<h4 id="watch-1"><a href="#watch-1" class="headerlink" title="$watch"></a>$watch</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">    pushTarget()</span><br><span class="line">    invokeWithErrorHandling(cb, vm, [watcher.value], vm, info)</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<ul>
<li>首先判断 <code>cb</code> 如果是一个对象，则调用 <code>createWatcher</code> 方法，这是因为 <code>$watch</code> 方法是用户可以直接调用的，可以传递一个对象，也可以传递函数；</li>
<li>接着执行 <code>const watcher = new Watcher(vm, expOrFn, cb, options)</code> 实例化一个 <code>watcher</code>，这里是一个 <code>user watcher</code>，因为 <code>options.user = true</code>；</li>
<li>若设置了 <code>immediate</code> 为 true，则直接会执行回调函数 <code>cb</code>；</li>
<li>最后返回 <code>unwatchFn</code> 方法，调用 <code>teardown</code> 方法移除这个 <code>watcher</code>。</li>
</ul>
<h3 id="Watcher-Options"><a href="#Watcher-Options" class="headerlink" title="Watcher Options"></a>Watcher Options</h3><p><code>Watcher</code> 支持了不同的类型，<code>Watcher</code> 的构造函数对 <code>options</code> 做了处理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line">  <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">  <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">  <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">  <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可见 <code>watcher</code> 一共 4 种类型</p>
<h4 id="deep-watcher"><a href="#deep-watcher" class="headerlink" title="deep watcher"></a>deep watcher</h4><p>通常想对一个对象做深度观生产线的测时，需要设置 <code>deep</code> 属性为 true；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">	a: &#123;</span><br><span class="line">		deep: true,</span><br><span class="line">		handler (newVal) &#123;</span><br><span class="line">			console.log(newVal)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样就创建了一个 <code>deep watcher</code> 了，在 <code>watcher</code> 执行 <code>get</code> 求值的过程中有一段逻辑：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在对 watch 的表达式或者函数求值后，会调用 <code>traverse</code> 函数；</p>
<p><code>src/core/observer.traverse.js</code>：</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _Set <span class="keyword">as</span> <span class="built_in">Set</span>, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; SimpleSet &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VNode <span class="keyword">from</span> <span class="string">&#x27;../vdom/vnode&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursively traverse an object to evoke all converted</span></span><br><span class="line"><span class="comment"> * getters, so that every nested property inside the object</span></span><br><span class="line"><span class="comment"> * is collected as a &quot;deep&quot; dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects)</span><br><span class="line">  seenObjects.clear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: <span class="built_in">any</span>, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码分析：</p>
<p>对一个对象做深层递归遍历，因为遍历过程中就是对一个子对象的访问，触发所有的 hetter，收集依赖，订阅它们变化的 <code>watcher</code>；</p>
<p>遍历过程中会把子响应式对象通过它们的 <code>dep id</code> 记录到 <code>seenObjects</code>，避免重复访问。</p>
<h4 id="user-watcher"><a href="#user-watcher" class="headerlink" title="user watcher"></a>user watcher</h4><p>通过 <code>vm.$watch</code> 创建的 <code>watcher</code> 是一个 <code>user watcher</code>，功能就是在对 <code>watcher</code> 求值以及在执行回调函数的时候，会处理一下错误：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">    handlerError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">    invokeWithErrorHandling(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>handleError</code> 是一个错误捕获并且暴露给用户的一个利器。</p>
<h4 id="lazy-watcher"><a href="#lazy-watcher" class="headerlink" title="lazy watcher"></a>lazy watcher</h4><p>就是为计算属性量身定制的，具体可以看前面计算属性中的分析。</p>
<h4 id="sync-watcher"><a href="#sync-watcher" class="headerlink" title="sync watcher"></a>sync watcher</h4><p>当响应式数据发生变化后，触发了 <code>watcher.update()</code>，只是把这个 <code>watcher</code> 推送到了一个队列中，在 <code>nextTick</code> 后才会真正执行 <code>watcher</code> 的回调函数。</p>
<p>当设置了 <code>sync</code> 为 true，就可以在当前 <code>Tick</code> 中同步执行 <code>watcher</code> 的回调函数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>只有当需要 watch 的值的变化到执行 <code>watcher</code> 的回调函数是一个同步过程的时候才会去设置该属性为 <code>true</code>。</p>
</blockquote>
<h2 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h2></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">AgoniLay</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://agonilay.github.io/2021/11/26/vue%20%E6%BA%90%E7%A0%81/">https://agonilay.github.io/2021/11/26/vue%20%E6%BA%90%E7%A0%81/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://agonilay.github.io" target="_blank">AgoniLay的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%BA%90%E7%A0%81/">源码</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6/">前端框架</a><a class="post-meta__tags" href="/tags/vue/">vue</a></div><div class="post_share"><div class="social-share" data-image="https://img2.baidu.com/it/u=4070430052,2876771977&amp;fm=26&amp;fmt=auto" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="wechat"/></a><div class="post-qr-code-desc">wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="alipay"/></a><div class="post-qr-code-desc">alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/29/SpringBoot-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://img1.baidu.com/it/u=1244635425,3010427070&amp;fm=26&amp;fmt=auto" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SpringBoot 复习笔记</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/26/React/"><img class="next-cover" src="https://img1.baidu.com/it/u=2721501999,167662473&amp;fm=26&amp;fmt=auto" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">React</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/08/14/vue%E7%AC%94%E8%AE%B0/" title="vue笔记"><img class="cover" src="https://img0.baidu.com/it/u=2459854756,3883213966&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-14</div><div class="title">vue笔记</div></div></a></div><div><a href="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/" title="axios 源码实现"><img class="cover" src="https://img1.baidu.com/it/u=760748498,104452322&fm=15&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-08</div><div class="title">axios 源码实现</div></div></a></div><div><a href="/2021/11/26/React/" title="React"><img class="cover" src="https://img1.baidu.com/it/u=2721501999,167662473&fm=26&fmt=auto" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-11-26</div><div class="title">React</div></div></a></div><div><a href="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/" title="前端综合复习笔记"><img class="cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fwww.xuekebaba.com%2Fuploads%2F202004%2F24%2F200424103930895.jpeg&refer=http%3A%2F%2Fwww.xuekebaba.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1652630370&t=7aa679493e509726dbb151dd49072ebe" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-08-28</div><div class="title">前端综合复习笔记</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.</span> <span class="toc-text">准备工作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A4%E8%AF%86-Flow"><span class="toc-number">1.1.</span> <span class="toc-text">认识 Flow</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">1.1.1.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%94%A8-Flow"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么用 Flow</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">1.1.3.</span> <span class="toc-text">Flow 的工作方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%8E%A8%E6%96%AD"><span class="toc-number">1.1.3.1.</span> <span class="toc-text">类型推断</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.3.2.</span> <span class="toc-text">类型注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%B1%BB%E5%9E%8B%E6%B3%A8%E9%87%8A"><span class="toc-number">1.1.3.3.</span> <span class="toc-text">常见类型注释</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.1.3.3.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.1.3.3.2.</span> <span class="toc-text">类和对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Null-Undefined"><span class="toc-number">1.1.3.3.3.</span> <span class="toc-text">Null Undefined</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flow-%E5%9C%A8-Vue-js-%E6%BA%90%E7%A0%81%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.1.4.</span> <span class="toc-text">Flow 在 Vue.js 源码中的应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-js-%E6%BA%90%E7%A0%81%E7%9B%AE%E5%BD%95%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.2.</span> <span class="toc-text">Vue.js 源码目录设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#compiler"><span class="toc-number">1.2.1.</span> <span class="toc-text">compiler</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#core"><span class="toc-number">1.2.2.</span> <span class="toc-text">core *</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#platforms"><span class="toc-number">1.2.3.</span> <span class="toc-text">platforms</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#server"><span class="toc-number">1.2.4.</span> <span class="toc-text">server</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sfc"><span class="toc-number">1.2.5.</span> <span class="toc-text">sfc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#shared"><span class="toc-number">1.2.6.</span> <span class="toc-text">shared</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-number">1.2.7.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Vue-js-%E6%BA%90%E7%A0%81%E6%9E%84%E5%BB%BA"><span class="toc-number">1.3.</span> <span class="toc-text">Vue.js 源码构建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%84%9A%E6%9C%AC"><span class="toc-number">1.3.1.</span> <span class="toc-text">构建脚本</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E8%BF%87%E7%A8%8B"><span class="toc-number">1.3.2.</span> <span class="toc-text">构建过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Runtime-Only-VS-Runtime-Compiler"><span class="toc-number">1.3.3.</span> <span class="toc-text">Runtime Only VS Runtime+Compiler</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%8E%E5%85%A5%E5%8F%A3%E5%BC%80%E5%A7%8B"><span class="toc-number">1.4.</span> <span class="toc-text">从入口开始</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%9A%84%E5%85%A5%E5%8F%A3"><span class="toc-number">1.4.1.</span> <span class="toc-text">Vue 的入口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.4.2.</span> <span class="toc-text">Vue 的定义</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A9%B1%E5%8A%A8"><span class="toc-number">2.</span> <span class="toc-text">数据驱动</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#new-Vue"><span class="toc-number">2.1.</span> <span class="toc-text">new Vue</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this-init"><span class="toc-number">2.1.1.</span> <span class="toc-text">this._init</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mount"><span class="toc-number">2.2.</span> <span class="toc-text">$mount</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#complier-mount"><span class="toc-number">2.2.1.</span> <span class="toc-text">complier $mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#prototype-mount"><span class="toc-number">2.2.2.</span> <span class="toc-text">prototype $mount</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mountComponent"><span class="toc-number">2.2.3.</span> <span class="toc-text">mountComponent()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#render"><span class="toc-number">2.3.</span> <span class="toc-text">render</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Virtual-DOM"><span class="toc-number">2.4.</span> <span class="toc-text">Virtual DOM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#createElement"><span class="toc-number">2.5.</span> <span class="toc-text">createElement</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#children-%E7%9A%84%E8%A7%84%E8%8C%83%E5%8C%96"><span class="toc-number">2.5.1.</span> <span class="toc-text">children 的规范化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VNode-%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">2.5.2.</span> <span class="toc-text">VNode 的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.3.</span> <span class="toc-text">补充方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E7%B1%BB%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.5.3.1.</span> <span class="toc-text">判断类型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createEmptyVNode"><span class="toc-number">2.5.3.2.</span> <span class="toc-text">createEmptyVNode</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createTextVNode"><span class="toc-number">2.5.3.3.</span> <span class="toc-text">createTextVNode</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#update"><span class="toc-number">2.6.</span> <span class="toc-text">update</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#update-1"><span class="toc-number">2.6.1.</span> <span class="toc-text">_update</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch"><span class="toc-number">2.6.2.</span> <span class="toc-text">__patch__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#createPatchFunction"><span class="toc-number">2.6.3.</span> <span class="toc-text">createPatchFunction</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#patch-%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">2.6.4.</span> <span class="toc-text">patch 执行流程分析</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%8C%96"><span class="toc-number">3.</span> <span class="toc-text">组件化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#createComponent"><span class="toc-number">3.1.</span> <span class="toc-text">createComponent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%AD%90%E7%B1%BB%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">构造子类钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Vue-extend"><span class="toc-number">3.1.1.1.</span> <span class="toc-text">Vue.extend</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%89%E8%A3%85%E7%BB%84%E4%BB%B6%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">安装组件钩子函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#installComponentHooks"><span class="toc-number">3.1.2.1.</span> <span class="toc-text">installComponentHooks</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mergeHook"><span class="toc-number">3.1.2.2.</span> <span class="toc-text">mergeHook</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8C%96-VNode"><span class="toc-number">3.1.3.</span> <span class="toc-text">实例化 VNode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">3.1.4.</span> <span class="toc-text">流程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#patch-1"><span class="toc-number">3.2.</span> <span class="toc-text">patch</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#createComponent-1"><span class="toc-number">3.2.1.</span> <span class="toc-text">createComponent</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%88%E5%B9%B6%E9%85%8D%E7%BD%AE"><span class="toc-number">3.3.</span> <span class="toc-text">合并配置</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E8%B0%83%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.1.</span> <span class="toc-text">外部调用场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E5%9C%BA%E6%99%AF"><span class="toc-number">3.3.2.</span> <span class="toc-text">组件场景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">3.4.</span> <span class="toc-text">生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeCreate-amp-created"><span class="toc-number">3.4.1.</span> <span class="toc-text">beforeCreate &amp; created</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeMount-amp-mounted"><span class="toc-number">3.4.2.</span> <span class="toc-text">beforeMount &amp; mounted</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeUpdate-amp-updated"><span class="toc-number">3.4.3.</span> <span class="toc-text">beforeUpdate &amp; updated</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#beforeDestroy-amp-destroyed"><span class="toc-number">3.4.4.</span> <span class="toc-text">beforeDestroy &amp; destroyed</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#activated-amp-deactivated"><span class="toc-number">3.4.5.</span> <span class="toc-text">activated &amp; deactivated</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%B3%A8%E5%86%8C"><span class="toc-number">3.5.</span> <span class="toc-text">组件注册</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E6%B3%A8%E5%86%8C"><span class="toc-number">3.5.1.</span> <span class="toc-text">全局注册</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E6%B3%A8%E5%86%8C"><span class="toc-number">3.5.2.</span> <span class="toc-text">局部注册</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">3.6.</span> <span class="toc-text">异步组件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.6.1.</span> <span class="toc-text">源码实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">3.6.2.</span> <span class="toc-text">普通函数异步组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">3.6.3.</span> <span class="toc-text">Promise 异步组件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6"><span class="toc-number">3.6.4.</span> <span class="toc-text">高级异步组件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E5%A4%B1%E8%B4%A5-reject"><span class="toc-number">3.6.4.1.</span> <span class="toc-text">加载失败 reject</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E6%88%90%E5%8A%9F-resolve"><span class="toc-number">3.6.4.2.</span> <span class="toc-text">加载成功 resolve</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E4%B8%AD-loading"><span class="toc-number">3.6.4.3.</span> <span class="toc-text">加载中 loading</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8A%A0%E8%BD%BD%E8%B6%85%E6%97%B6-timeout"><span class="toc-number">3.6.4.4.</span> <span class="toc-text">加载超时 timeout</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5%E7%BB%84%E4%BB%B6-patch"><span class="toc-number">3.6.5.</span> <span class="toc-text">异步组件 patch</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86"><span class="toc-number">4.</span> <span class="toc-text">响应式原理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%8D%E5%BA%94%E5%BC%8F%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.1.</span> <span class="toc-text">响应式对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-defineProperty"><span class="toc-number">4.1.1.</span> <span class="toc-text">Object.defineProperty</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#initState"><span class="toc-number">4.1.2.</span> <span class="toc-text">initState</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#initProps"><span class="toc-number">4.1.2.1.</span> <span class="toc-text">initProps</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#initData"><span class="toc-number">4.1.2.2.</span> <span class="toc-text">initData</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#proxy"><span class="toc-number">4.1.3.</span> <span class="toc-text">proxy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#observe"><span class="toc-number">4.1.4.</span> <span class="toc-text">observe</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Observer"><span class="toc-number">4.1.5.</span> <span class="toc-text">Observer</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defineReactive"><span class="toc-number">4.1.6.</span> <span class="toc-text">defineReactive</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86"><span class="toc-number">4.2.</span> <span class="toc-text">依赖收集</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Dep"><span class="toc-number">4.2.1.</span> <span class="toc-text">Dep</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher"><span class="toc-number">4.2.2.</span> <span class="toc-text">Watcher</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90"><span class="toc-number">4.2.3.</span> <span class="toc-text">过程分析</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B4%BE%E5%8F%91%E6%9B%B4%E6%96%B0"><span class="toc-number">4.3.</span> <span class="toc-text">派发更新</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E7%A8%8B%E5%88%86%E6%9E%90-1"><span class="toc-number">4.3.1.</span> <span class="toc-text">过程分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dep-notify"><span class="toc-number">4.3.1.1.</span> <span class="toc-text">dep.notify</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watcher-update"><span class="toc-number">4.3.1.2.</span> <span class="toc-text">watcher.update</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#queueWatcher"><span class="toc-number">4.3.1.3.</span> <span class="toc-text">queueWatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#flushSchedulerQueue"><span class="toc-number">4.3.1.4.</span> <span class="toc-text">flushSchedulerQueue</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watcher-run"><span class="toc-number">4.3.1.5.</span> <span class="toc-text">watcher.run</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nextTick"><span class="toc-number">4.4.</span> <span class="toc-text">nextTick</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS-%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">4.4.1.</span> <span class="toc-text">JS 运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Vue-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-number">4.4.2.</span> <span class="toc-text">Vue 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%BB%E7%BB%93-1"><span class="toc-number">4.4.3.</span> <span class="toc-text">总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">4.5.</span> <span class="toc-text">检测变化的注意事项</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1"><span class="toc-number">4.5.1.</span> <span class="toc-text">对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84-1"><span class="toc-number">4.5.2.</span> <span class="toc-text">数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%B1%9E%E6%80%A7-VS-%E4%BE%A6%E5%90%AC%E5%B1%9E%E6%80%A7"><span class="toc-number">4.6.</span> <span class="toc-text">计算属性 VS 侦听属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#computed"><span class="toc-number">4.6.1.</span> <span class="toc-text">computed</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#initComputed"><span class="toc-number">4.6.1.1.</span> <span class="toc-text">initComputed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#defineComputed"><span class="toc-number">4.6.1.2.</span> <span class="toc-text">defineComputed</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createComputedGetter"><span class="toc-number">4.6.1.3.</span> <span class="toc-text">createComputedGetter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#computed-watcher"><span class="toc-number">4.6.1.4.</span> <span class="toc-text">computed watcher</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#watch"><span class="toc-number">4.6.2.</span> <span class="toc-text">watch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#initWatch"><span class="toc-number">4.6.2.1.</span> <span class="toc-text">initWatch</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#createWatcher"><span class="toc-number">4.6.2.2.</span> <span class="toc-text">createWatcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#watch-1"><span class="toc-number">4.6.2.3.</span> <span class="toc-text">$watch</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Watcher-Options"><span class="toc-number">4.6.3.</span> <span class="toc-text">Watcher Options</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#deep-watcher"><span class="toc-number">4.6.3.1.</span> <span class="toc-text">deep watcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#user-watcher"><span class="toc-number">4.6.3.2.</span> <span class="toc-text">user watcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lazy-watcher"><span class="toc-number">4.6.3.3.</span> <span class="toc-text">lazy watcher</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#sync-watcher"><span class="toc-number">4.6.3.4.</span> <span class="toc-text">sync watcher</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%84%E4%BB%B6%E6%9B%B4%E6%96%B0"><span class="toc-number">4.7.</span> <span class="toc-text">组件更新</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://img2.baidu.com/it/u=4070430052,2876771977&amp;fm=26&amp;fmt=auto')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By AgoniLay</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: 'fMlK1v2U3cjKJBIaYGEUd6iH-gzGzoHsz',
      appKey: 'k49y92c0BEE6zL2mCA2AUHKu',
      avatar: 'monsterid',
      serverURLs: 'https://fmlk1v2u.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/fireworks.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>