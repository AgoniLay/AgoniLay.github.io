<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>面经总结</title>
      <link href="/2022/04/20/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/20/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="JS-相关"><a href="#JS-相关" class="headerlink" title="JS 相关"></a>JS 相关</h1><h2 id="原型及原型链"><a href="#原型及原型链" class="headerlink" title="原型及原型链"></a>原型及原型链</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Person.prototype.name = <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">  Person.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="comment">// JS 在创建对象的时候，都有一个 __proto__ 的内置属性，用于指向创建它的构造函数的原型对象</span></span><br><span class="line"><span class="comment">// 每个对象都有 __proto__ 属性，但是只有函数对象才有 prototype 属性</span></span><br><span class="line"><span class="comment">// 对象 person1 有一个 __proto__ 属性，创建它的构造函数是 Person，构造函数的原型对象是 Person.prototype</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.__proto__ == Person.prototype) <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 所有函数对象的 __proto__ 都指向 Function.prototype</span></span><br><span class="line"><span class="built_in">String</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="/2022/04/20/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/640.jpeg" class title="prototype"><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="原型继承"><a href="#原型继承" class="headerlink" title="原型继承"></a>原型继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Parent&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;Child&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将子类的原型对象指向父类的实例</span></span><br><span class="line">Child.prototype = <span class="keyword">new</span> Person()</span><br></pre></td></tr></table></figure><p>优点：继承了父类的模板，又继承了父类的原型对象；</p><p>缺点：无法实现多继承；创建子类时，无法向父类构造函数传参数。</p><h3 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 用 call 来改变 Parent 构造函数内的指向</span></span><br><span class="line">  Parent.call(<span class="built_in">this</span>, <span class="string">&#x27;child&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：解决了原型继承中子类实例共享父类引用对象的问题，实现多继承，创建子类实例时，可以向父类传递参数；</p><p>缺点：构造继承只能继承父类的实例属性和方法，不能继承父类原型的属性和方法。</p><h3 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h3><p>组合继承就是将原型链继承和构造函数继承组合在一起：</p><ul><li>使用原型链继承来保证子类能继承到父类原型中的属性和方法；</li><li>使用构造函数继承来保证子类能继承到父类的实例属性和方法。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.sex = sex</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br></pre></td></tr></table></figure><h3 id="class-继承"><a href="#class-继承" class="headerlink" title="class 继承"></a>class 继承</h3><p>依靠 class 中的 extends 和 super：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  getName () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> <span class="keyword">extends</span> <span class="title">Parent</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name)</span><br><span class="line">    <span class="built_in">this</span>.sex = <span class="string">&#x27;boy&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, sex</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.sex = sex</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 关键</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = Parent.prototype</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F()</span><br></pre></td></tr></table></figure><p>封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span> (<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(parent.prototype)</span><br><span class="line">  prototype.constructor = child</span><br><span class="line">  child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prototype(child, parent)</span><br></pre></td></tr></table></figure><p>优点：高效率，只调用一次 Parent 构造函数，避免了在 <code>Parent.prototype</code> 上创建不必要的属性，同时原型链还可以保持不变，因此也可以正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。</p><p><strong>寄生式组合式继承式最为理想的继承方式</strong>。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/04/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<blockquote><p>程序设计  = 数据结构 + 算法；数据 = 符号</p></blockquote><ul><li>数据：指可以输入到计算机中并且能够被计算机识别和处理的符号；</li><li>数据元素：数据的基本单位，也成为节点或者记录；</li><li>数据对象：相同特性的数据元素的集合，是一个数据的子集；</li><li>数据项：独立含义的数据的最小单位</li></ul><p>数据的目的是存储，存储的目的是：后期再利用</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS正则表达式</title>
      <link href="/2022/04/15/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/04/15/JS%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><p>用于匹配规律规则的表达式，通常被用来检索、替换那些符合某个模式（规则的文本）。</p><h2 id="构建"><a href="#构建" class="headerlink" title="构建"></a>构建</h2><p>字面量创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/正则表达式/</span>修饰符</span><br></pre></td></tr></table></figure><p>构造函数创建：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&#x27;正则表达式&#x27;</span>, <span class="string">&#x27;修饰符&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><ul><li><code>i</code>：ignoreCase，匹配忽视大小写；</li><li><code>m</code>：multiline，多行匹配；</li><li><code>g</code>：global，全局匹配。</li></ul><h2 id="属性方法"><a href="#属性方法" class="headerlink" title="属性方法"></a>属性方法</h2><h3 id="exec"><a href="#exec" class="headerlink" title="exec()"></a>exec()</h3><p>匹配字符串和正则表达式：</p><ul><li><p>匹配成功：返回一个数组</p><p><code>[匹配内容, index: 匹配的起始位置, input: 要匹配的字符串, group: undefined]</code></p></li><li><p>匹配失败：返回 null</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello AgoniLay hello&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str))</span><br><span class="line"><span class="comment">// [&#x27;hello&#x27;, index: 0, input: &#x27;hello AgoniLay hello&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><h3 id="test"><a href="#test" class="headerlink" title="test()"></a>test()</h3><p>测试待检测的字符串是否能匹配到，匹配到返回 <code>true</code>，否则返回 false。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello AgoniLay hello&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(str)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h3 id="compile"><a href="#compile" class="headerlink" title="compile()"></a>compile()</h3><p>可以编译指定的正则表达式，编译之后的正则表达式执行速度将会提升（在多次被调用时效果会较为明显）.</p><h3 id="lastIndex"><a href="#lastIndex" class="headerlink" title="lastIndex"></a>lastIndex</h3><p>未设置全局匹配时，返回值均为 0；</p><p>设置全局匹配后，匹配到对应字符 lastIndex 指向该字符的结束位置，在执行 exec 返回 null 时 lastIndex 归零；</p><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><table><thead><tr><th align="center">字符</th><th align="center">匹配</th></tr></thead><tbody><tr><td align="center">字母和数字字符</td><td align="center">自身</td></tr><tr><td align="center">\o</td><td align="center">Null 字符</td></tr><tr><td align="center">\t</td><td align="center">制表符 Tab</td></tr><tr><td align="center">\n</td><td align="center">换行符</td></tr><tr><td align="center">\v</td><td align="center">垂直制表符</td></tr><tr><td align="center">\f</td><td align="center">换页符</td></tr><tr><td align="center">\r</td><td align="center">回车符</td></tr></tbody></table><table><thead><tr><th align="center">字符类</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配 换行符\n 和 回车符\r 之外的任何单个字符，等效于 <code>[^\n\r]</code></td></tr><tr><td align="center">\d</td><td align="center">匹配一个数字字符，等效于 <code>[0-9]</code></td></tr><tr><td align="center">\D</td><td align="center"><code>[^0-9]</code></td></tr><tr><td align="center">\w</td><td align="center">匹配包括下划线的任何单个字符，等效于 <code>[a-zA-Z0-9]</code></td></tr><tr><td align="center">\W</td><td align="center"><code>[^a-zA-Z0-9]</code></td></tr><tr><td align="center">\s</td><td align="center">匹配任何 Unicode 空白字符，包括空格、制表符、换页符和换行符，等效于 <code>[\f\t\n\r]</code></td></tr><tr><td align="center">\S</td><td align="center"><code>[^\f\t\n\r]</code></td></tr></tbody></table><ul><li><code>[]</code>：匹配其中的某一个字符；</li><li><code>^</code>：<ol><li>反义字符：<code>[^abc]</code>；匹配除了 abc 之外的字符；</li><li>边界符：表示匹配开始的字符；</li></ol></li><li><code>$</code>：表示匹配结束位置的字符；<ul><li><code>^</code> 和 <code>$</code>  共同使用表示精确匹配，只有匹配的字符完全相同才匹配成功；</li></ul></li></ul><table><thead><tr><th align="center">字符</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">*</td><td align="center">≥ 0 次</td></tr><tr><td align="center">+</td><td align="center">≥ 1 次</td></tr><tr><td align="center">?</td><td align="center">0 或 1 次</td></tr><tr><td align="center">{n}</td><td align="center">n 次</td></tr><tr><td align="center">{n,}</td><td align="center">≥ n 次</td></tr><tr><td align="center">{n, m}</td><td align="center">n 到 m 次</td></tr></tbody></table><ul><li>贪婪模式：默认为贪婪模式，尽可能匹配更多的</li><li>非贪婪模式：尽可能匹配少的，在数量前加 <code>?</code> 改变为非贪婪模式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;1234567&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d&#123;3,6&#125;/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str)) <span class="comment">// [&#x27;123456&#x27;, index: 0, input: &#x27;1234567&#x27;, groups: undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/\d&#123;3,6&#125;?/g</span></span><br><span class="line"><span class="built_in">console</span>.log(reg2.exec(str)) <span class="comment">// [&#x27;123&#x27;, index: 0, input: &#x27;1234567&#x27;, groups: undefined]</span></span><br></pre></td></tr></table></figure><h3 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h3><p>使用 <code>|</code> 来进行选择，找到组内的某一个就返回</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/html|css|js/</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(<span class="string">&#x27;abchtmlcss&#x27;</span>)) <span class="comment">// html</span></span><br></pre></td></tr></table></figure><h3 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h3><p>使用 <code>()</code> 来进行分组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/aaa/</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/(a)&#123;3&#125;/</span></span><br><span class="line"><span class="comment">// reg1 和 reg2 效果相同</span></span><br></pre></td></tr></table></figure><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>捕获使用 <code>RegExp.$</code> 来捕获分组内的内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> date = <span class="string">&#x27;2022-04-15&#x27;</span></span><br><span class="line"></span><br><span class="line">reg.test(date)</span><br><span class="line"><span class="comment">// 捕获之前要先 test/exec</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$1) <span class="comment">// 2021</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$2) <span class="comment">// 04</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">RegExp</span>.$3) <span class="comment">// 15</span></span><br></pre></td></tr></table></figure><p>将捕获的内容进行使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/(\w&#123;3&#125;) is \1/</span> <span class="comment">// \1 表示捕获第一个分组内的内容</span></span><br><span class="line"><span class="built_in">console</span>.log(reg.test(<span class="string">&#x27;aaa is aaa&#x27;</span>)) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h2 id="String-方法"><a href="#String-方法" class="headerlink" title="String 方法"></a>String 方法</h2><h3 id="search"><a href="#search" class="headerlink" title="search()"></a>search()</h3><p>和 exec() 类似，有则返回第一次出现的索引，否则返回 -1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/[hello]/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(reg.exec(str)) <span class="comment">// [&#x27;h&#x27;, index: 0, input: &#x27;hello&#x27;, groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.search(reg)) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><h3 id="match"><a href="#match" class="headerlink" title="match()"></a>match()</h3><p>不加全局匹配时和 exec 一样，加了之后以数组形式返回查找到的所有的字符。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello agonilay hello&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg1 = <span class="regexp">/hello/</span></span><br><span class="line"><span class="keyword">var</span> reg2 = <span class="regexp">/hello/g</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg1)) <span class="comment">// [&#x27;hello&#x27;, index: 0, input: &#x27;hello agonilay hello&#x27;, groups: undefined]</span></span><br><span class="line"><span class="built_in">console</span>.log(str.match(reg2)) <span class="comment">// [&#x27;hello&#x27;, &#x27;hello&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p>按照指定规则切割字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;agoni123lay456sun789x&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/\d+/</span></span><br><span class="line"><span class="built_in">console</span>.log(str.split(reg)) <span class="comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;, &#x27;sun&#x27;, &#x27;x&#x27;]</span></span><br></pre></td></tr></table></figure><h3 id="replace"><a href="#replace" class="headerlink" title="replace()"></a>replace()</h3><p>替换满足正则表达式的内容，全局模式替换所有匹配的，非全局模式只替换第一个。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;hello123 hello world hello agoni456&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/hello/g</span></span><br><span class="line"><span class="keyword">var</span> result = str.replace(reg, <span class="string">&#x27;Lay&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result) <span class="comment">// Lay123 Lay world Lay agoni456</span></span><br><span class="line"><span class="built_in">console</span>.log(res) <span class="comment">// hello123 hello world hello agoni456</span></span><br></pre></td></tr></table></figure><h2 id="前瞻表达式"><a href="#前瞻表达式" class="headerlink" title="前瞻表达式"></a>前瞻表达式</h2><p><code>(?=exp)</code> 正向前瞻，匹配后面满足表达式 <code>exp</code> 的位置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&#x27;Hello, Hi, Hi.&#x27;</span></span><br><span class="line"><span class="keyword">var</span> reg = <span class="regexp">/H(?=i)/g</span></span><br><span class="line"><span class="keyword">var</span> newStr = str.replace(reg, <span class="string">&#x27;Agon&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// Hello, Agoni, Agoni.</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写JS相关</title>
      <link href="/2022/04/15/%E6%89%8B%E5%86%99JS%E7%9B%B8%E5%85%B3/"/>
      <url>/2022/04/15/%E6%89%8B%E5%86%99JS%E7%9B%B8%E5%85%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="数据类型判断"><a href="#数据类型判断" class="headerlink" title="数据类型判断"></a>数据类型判断</h2><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><ul><li>instanceof 是用来判断 A 是否是 B 的实例，是则返回 true，否则返回 false；</li><li>instanceof 运算符用来测试一个对象在其原型链上是否存在一个构造函数的 prototype 属性；</li><li>不能检测基本数据类型；</li><li>实现：遍历左边变量的原型链，直到找到右边变量的 prototype，如果没找到则返回 false。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span> (<span class="params">l, r</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = r.prototype</span><br><span class="line">  l = l.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l == o) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    l = l.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myInstanceof</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="built_in">Object</span>.getPrototypeOf(left)</span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    <span class="keyword">if</span> (proto === prototype) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    proto = <span class="built_in">Object</span>.getPrototypeOf(proto)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><h3 id="数组扁平化"><a href="#数组扁平化" class="headerlink" title="数组扁平化"></a>数组扁平化</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFlat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> prev.concat(<span class="built_in">Array</span>.isArray(curr) ? myFlat(curr) : curr)</span><br><span class="line">  &#125;, [])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES6 扩展运算符和 some 方法实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myFlat</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (arr.some(<span class="function"><span class="params">item</span> =&gt;</span> <span class="built_in">Array</span>.isArray(item))) &#123;</span><br><span class="line">    arr = [].concat(...arr)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><p>ES6 Set：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(<span class="built_in">this</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对象属性唯一：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = <span class="built_in">this</span>.length; i &lt; length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[<span class="built_in">this</span>[i]]) &#123;</span><br><span class="line">      res.push(<span class="built_in">this</span>[i])</span><br><span class="line">      obj[<span class="built_in">this</span>[i]] = <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sort + 相邻元素比较：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = <span class="built_in">this</span>.sort()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] === arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">      arr.splice(i , <span class="number">1</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      i++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="快速排列"><a href="#快速排列" class="headerlink" title="快速排列"></a>快速排列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fastSort = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length &lt;= <span class="number">1</span>) <span class="keyword">return</span> arr</span><br><span class="line">  <span class="keyword">var</span> middleIndex = <span class="built_in">Math</span>.floor(arr.length / <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">var</span> middle = arr.splice(middleIndex, <span class="number">1</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> [left, right] = [[], []]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> item = arr[i]</span><br><span class="line">    item &lt; middle ? left.push(item) : right.push(item)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fastSort(left).concat([middle], fastSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="params">nums</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> len = nums.length,</span><br><span class="line">      result = [],</span><br><span class="line">      visited = <span class="keyword">new</span> <span class="built_in">Array</span>(len).fill(<span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">const</span> dfs = <span class="function">(<span class="params">path = []</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (path.length === len) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.push([...path])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="comment">// 有重复数字做判断</span></span><br><span class="line">      <span class="keyword">if</span> (visited[i] || (i &amp;&amp; nums[i] === nums[i - <span class="number">1</span>] &amp;&amp; !visited[i - <span class="number">1</span>])) <span class="keyword">continue</span></span><br><span class="line">      path.push(nums[i])</span><br><span class="line">      visited[i] = <span class="literal">true</span></span><br><span class="line">      dfs(path)</span><br><span class="line">      visited[i] = <span class="literal">false</span></span><br><span class="line">      path.pop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 有重复数字需排序</span></span><br><span class="line">  nums.sort()</span><br><span class="line">  dfs()</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="this-指向"><a href="#this-指向" class="headerlink" title="this 指向"></a>this 指向</h2><h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><ul><li>第一个参数为 null 或者 undefined 时，this 指向全局对象，值为原始值的指向该原始值的自动包装对象；</li><li>为了避免函数名与上下文的属性发生冲突，使用 Symbol 类型作为唯一值；</li><li>将函数作为传入的上下文属性执行；</li><li>函数执行完成后删除该属性；</li><li>返回执行结果。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cxt = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 新建一个唯一的 Symbol 变量避免重复</span></span><br><span class="line">  <span class="keyword">let</span> func = <span class="built_in">Symbol</span>()</span><br><span class="line">  cxt[func] = <span class="built_in">this</span></span><br><span class="line">  args = args ? args : []</span><br><span class="line">  <span class="comment">// 以对象调用形式调用 func，此时 this 指向 cxt，也就是需要绑定的 this 指向</span></span><br><span class="line">  <span class="keyword">const</span> res = args.length &gt; <span class="number">0</span> ? cxt[func](...args) : cxt[func]()</span><br><span class="line">  <span class="comment">// 删除该方法，不然会对传入对象造成污染</span></span><br><span class="line">  <span class="keyword">delete</span> cxt[func]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><ul><li>大部分与 call 相同，只是不需要再额外处理参数列表；</li><li>第二个参数可以不传，但类型必须是数组或者类数组。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, args = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> cxt = context || <span class="built_in">window</span></span><br><span class="line">  <span class="comment">// 新建一个唯一的 Symbol 变量避免重复</span></span><br><span class="line">  <span class="keyword">let</span> func = <span class="built_in">Symbol</span>()</span><br><span class="line">  cxt[func] = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 以对象调用形式调用 func，此时 this 指向 cxt 也就是传入的需要绑定的 this 指向</span></span><br><span class="line">  <span class="keyword">const</span> res = args.length ? cxt[func](...args) : cxt[func]()</span><br><span class="line">  <span class="comment">// 删除该方法，不然会对传入对象造成污染</span></span><br><span class="line">  <span class="keyword">delete</span> cxt[func]</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><ul><li>bind() 除了 this 外，还可以传入多个参数；</li><li>bind 创建的新函数可能传入多个参数；</li><li>新函数可能被当作构造函数使用；</li><li>函数可能有返回值。</li></ul><p>实现：</p><ul><li>bind 方法不会立即执行，需要返回一个待执行的函数（闭包）；</li><li>实现作用域绑定（apply）；</li><li>参数传递（apply 的数组传参）；</li><li>当作为构造函数时，进行原型继承。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新建一变量赋值为 this 表示当前函数</span></span><br><span class="line">  <span class="keyword">const</span> fn = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// 判断有没有传参进来，若为空则赋值 []</span></span><br><span class="line">  args  = args ? args : []</span><br><span class="line">  <span class="comment">// 返回一个 newFn 函数，在里面调用 fn</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">newFn</span> (<span class="params">...newFnArgs</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> <span class="keyword">instanceof</span> newFn) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> fn(...args, ...newFnArgs)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(context, [...args, ...newFnArgs])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h3 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = obj.name</span><br><span class="line">  <span class="built_in">this</span>.age = obj.age</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> Person(&#123; <span class="attr">anme</span>: <span class="string">&#x27;AgoniLay&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person1</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, obj)</span><br><span class="line">  <span class="built_in">this</span>.sex = obj.sex</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这一步是继承的关键</span></span><br><span class="line">Person1.prototype = <span class="built_in">Object</span>.create(Person.prototype)</span><br><span class="line">Person1.prorotype.constructor = Person1</span><br><span class="line"></span><br><span class="line">Person1.prototype.play = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> Person1(&#123; <span class="attr">name</span>: <span class="string">&#x27;agoni&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>, <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h3 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name=<span class="string">&#x27;agoni&#x27;</span>, age=<span class="string">&#x27;18&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span> <span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span> eat food`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name=<span class="string">&#x27;ren&#x27;</span>, age=<span class="string">&#x27;19&#x27;</span></span>) &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age)</span><br><span class="line">  &#125;</span><br><span class="line">  eat () &#123;</span><br><span class="line">    <span class="built_in">super</span>.eat()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> womanObj = <span class="keyword">new</span> Woman(<span class="string">&#x27;AgoniLay&#x27;</span>)</span><br><span class="line">womanObj.eat()</span><br></pre></td></tr></table></figure><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><ul><li>一个继承自 <code>Foo.prototype</code> 的新对象被创建；</li><li>使用指定的参数调用构造函数 Foo，并将 this 绑定到新创建的对象。new Foo 等同于 new Foo()，也就是没有指定参数列表；</li><li>有构造函数返回的对象就是 new 表达式的结果，如果构造函数没有显式返回一个对象，则使用步骤1 创建的对象；</li><li>一般情况下，构造函数不返回值，但是用户可以选择主动返回对象，来覆盖正常的对象创建步骤。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNew</span> (<span class="params">ctor, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> ctor !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="string">&#x27;myNew function the first param must be a function&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> newObj = <span class="built_in">Object</span>.create(ctor.prototype) <span class="comment">// 创建一个继承自 ctor.prototype 的新对象</span></span><br><span class="line">  <span class="keyword">var</span> ctorReturnResult = ctor.apply(newObj, args) <span class="comment">// 将构造函数 ctor 的 this 绑定到 newObj 中</span></span><br><span class="line">  <span class="keyword">var</span> isObject = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&#x27;object&#x27;</span> &amp;&amp; ctorReturnResult !== <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> isFunction = <span class="keyword">typeof</span> ctorReturnResult === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (isObject || isFunction) &#123;</span><br><span class="line">    <span class="keyword">return</span> ctorReturnResult</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> newObj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = myNew(Foo)</span><br></pre></td></tr></table></figure><h2 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h2><h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>Object.create() 会将参数对象作为一个新创建的空对象的原型，并返回这个空对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简略版</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myCreate</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 新声明一个函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">C</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 将函数的原型指向 obj</span></span><br><span class="line">  C.prototype = obj</span><br><span class="line">  <span class="comment">// 返回这个函数的实例化对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 官方版</span></span><br><span class="line"><span class="built_in">Object</span>.create = <span class="function"><span class="keyword">function</span> (<span class="params">proto, propertiesObject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> proto !== <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> proto !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;Object prototype may only be an Object: &#x27;</span> + proto)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (proto === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> propertiesObject !== <span class="string">&#x27;undefined&#x27;</span>) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>()</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = proto</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h3><p>Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象，返回目标对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.myAssign = <span class="function"><span class="keyword">function</span> (<span class="params">target, ...source</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (target == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> net = <span class="built_in">Object</span>(target)</span><br><span class="line">  source.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">          net[key] = obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> net</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><h4 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> copyObj = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(obj))</span><br></pre></td></tr></table></figure><p>问题：</p><ol><li>undefined、function 类型的 key 会丢失；</li><li>时间对象会变成字符串格式；</li><li>RegExp 定义的对象会变成 {}；</li><li>NaN 类型会变成 null；</li><li>无法处理循环引用的问题。</li></ol><h4 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h4><p>可以使用 WeakMap 来解决循环引用的问题。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span> (<span class="params">obj, hash = <span class="keyword">new</span> <span class="built_in">WeakMap</span>()</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj !== <span class="string">&#x27;object&#x27;</span>) <span class="keyword">return</span> obj</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">RegExp</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(obj)</span><br><span class="line">  <span class="keyword">if</span> (hash.has(obj)) &#123;</span><br><span class="line">    <span class="keyword">return</span> hash.get(obj)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> constr = <span class="keyword">new</span> obj.constructor()</span><br><span class="line">  hash.set(obj, constr)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">      constr[key] = deepClone(obj[key], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> symbolObj = <span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = symbolObj.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (obj.hasOwnProperty(symbolObj[i])) &#123;</span><br><span class="line">      constr[symbolObj[i]] = deepClone(obj[symbolObj[i]], hash)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> constr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><ul><li>Promise 本质是一个状态机，且状态只能为以下三种：Pending（等待态）、Fulfilled（执行态）、Rejected（拒绝态），状态的变更是单向的，只能从 Pending -&gt; Fulfilled 或 Pending -&gt; Rejected，状态变更不可逆；</li><li>then 需要支持链式调用。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  callbacks = []</span><br><span class="line">  state = <span class="string">&#x27;pending&#x27;</span></span><br><span class="line">  value = <span class="literal">null</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">fn</span>) &#123;</span><br><span class="line">    fn(<span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>), <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  then (onFulfilled, onRejected) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>._handle(&#123;</span><br><span class="line">        <span class="attr">onFulfilled</span>: onFulfilled || <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">onRejected</span>: onRejected || <span class="literal">null</span>,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  _handle (callback) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.callbacks.push(callback)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> cb = <span class="built_in">this</span>.state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      cb = <span class="built_in">this</span>.state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject</span><br><span class="line">      cb(<span class="built_in">this</span>.value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> net = cb(<span class="built_in">this</span>.value)</span><br><span class="line">    cb = <span class="built_in">this</span>.state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject</span><br><span class="line">    cb(net)</span><br><span class="line">  &#125;</span><br><span class="line">  _resolve (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> value === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">      <span class="keyword">var</span> then = value.then</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        then.call(value, <span class="built_in">this</span>._resolve.bind(<span class="built_in">this</span>). <span class="built_in">this</span>._reject.bind(<span class="built_in">this</span>))</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="built_in">this</span>._handle(callback))</span><br><span class="line">  &#125;</span><br><span class="line">  _reject (error) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.value = error</span><br><span class="line">    <span class="built_in">this</span>.callbacks.forEach(<span class="function"><span class="params">callback</span> =&gt;</span> <span class="built_in">this</span>._handle(callback))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h3><p>可以将任何值转成值为 value状态是 fulfilled 的 Promise，但如果传入的值本身是 Promise 则会原样返回它。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value &amp;&amp; (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">    <span class="keyword">let</span> then = value.then</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> then(resolve))</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reject"><a href="#reject" class="headerlink" title="reject"></a>reject</h3><p>和 Promise.resolve() 类似，Promise.reject() 会实例化一个 rejected 状态的 Promise。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject(reason))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="all"><a href="#all" class="headerlink" title="all"></a>all</h3><ul><li>传入的所有 Promise 都是 fulfilled，则返回由他们组成的状态为 fulfilled 的新 Promise；</li><li>只要有一个 Promise 是 rejected，则返回 rejected 状态的新 Promise，且它的值是第一个 rejected 的 Promise 的值；</li><li>只要有一个 Promise 是 pending，则返回一个 pending 状态的新 Promise。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>, result = [], len = promiseArr.length</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">Array</span>.isArray(promiseArr)) &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">&#x27;arguments must be an array&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    promiseArr.forEach(<span class="function">(<span class="params">p, i</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        index++</span><br><span class="line">        result[i] = res</span><br><span class="line">        <span class="keyword">if</span> (index === len) &#123;</span><br><span class="line">          resolve(result)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="race"><a href="#race" class="headerlink" title="race"></a>race</h3><p>Promise 会返回一个由所有可迭代实例中第一个 fulfilled 或 rejected 的实例包装后的新实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">promiseArr</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    promiseArr.forEach(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(p).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(res)</span><br><span class="line">      &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Ajax"><a href="#Ajax" class="headerlink" title="Ajax"></a>Ajax</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span> (<span class="params">url, method, body, headers</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> req = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">    req.open(method, url)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">      req.setRequsetHeader(key, headers[key])</span><br><span class="line">    &#125;</span><br><span class="line">    req.onreadystatechange(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (req.readystate == <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (req.status &gt;= <span class="string">&#x27;200&#x27;</span> &amp;&amp; req.status &lt;= <span class="number">300</span>) &#123;</span><br><span class="line">          resolve(req.responseText)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          reject(req)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    req.send(body)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防抖-节流"><a href="#防抖-节流" class="headerlink" title="防抖 节流"></a>防抖 节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><p>连续触发在最后一次执行方法，场景：输入框匹配。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> debounce = <span class="function">(<span class="params">fn, delay = <span class="number">1000</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3><p>在一定时间内只触发一次，场景：长列表滚动节流。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> throbble = <span class="function">(<span class="params">fn, delay = <span class="number">1000</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> ((nowTime - lastTime) &gt; delay) &#123;</span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">      lastTime = nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fnLen = fn.length</span><br><span class="line">  <span class="keyword">let</span> argLen = args.length</span><br><span class="line">  <span class="keyword">if</span> (fnLen &gt; argLen) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...arg2s</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> curry(fn, ...args, ...arg2s)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> fn(...args)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span> </span><br><span class="line">  judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">    args.length &gt;= fn.length</span><br><span class="line">    ? fn(...args)</span><br><span class="line">    : <span class="function">(<span class="params">...arg</span>) =&gt;</span> judge(...args, ...arg)</span><br></pre></td></tr></table></figure><h2 id="闭包相关"><a href="#闭包相关" class="headerlink" title="闭包相关"></a>闭包相关</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">  (<span class="function"><span class="keyword">function</span> (<span class="params">i</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(i), <span class="number">1000</span> * i)</span><br><span class="line">  &#125;)(i)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>sleep 函数的作用是让线程休眠，等到指定时间再重新唤起</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span> (<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">while</span> ((<span class="built_in">Date</span>.now() - start &lt; delay) &#123;</span><br><span class="line">    <span class="keyword">continue</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="正则相关"><a href="#正则相关" class="headerlink" title="正则相关"></a>正则相关</h2><h3 id="切分千分位"><a href="#切分千分位" class="headerlink" title="切分千分位"></a>切分千分位</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有小数点</span></span><br><span class="line"><span class="keyword">let</span> num1 = <span class="string">&#x27;1567421311&#x27;</span></span><br><span class="line">num1.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+$)/g</span>, <span class="string">&#x27;$1,&#x27;</span>) <span class="comment">// 1,567,421,311</span></span><br><span class="line"><span class="comment">// 有小数点</span></span><br><span class="line"><span class="keyword">let</span> num2 = <span class="string">&#x27;23165348.54454&#x27;</span></span><br><span class="line">num2.replace(<span class="regexp">/(\d)(?=(\d&#123;3&#125;)+\.)/g</span>, <span class="string">&#x27;$1,&#x27;</span>) <span class="comment">// 23,165,348.54454</span></span><br></pre></td></tr></table></figure><h3 id="解析-URL-Params-为对象"><a href="#解析-URL-Params-为对象" class="headerlink" title="解析 URL Params 为对象"></a>解析 URL Params 为对象</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseParams</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> paramsStr = <span class="regexp">/.+\?(.+)$/</span>.exec(url)[<span class="number">1</span>]</span><br><span class="line">  <span class="keyword">const</span> paramsArr = paramsStr.split(<span class="string">&#x27;&amp;&#x27;</span>)</span><br><span class="line">  <span class="keyword">let</span> paramsObj = &#123;&#125;</span><br><span class="line">  paramsArr.forEach(<span class="function"><span class="params">param</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/=/</span>.test(param)) &#123;</span><br><span class="line">      <span class="keyword">let</span> [key, val] = param.split(<span class="string">&#x27;=&#x27;</span>)</span><br><span class="line">      val = <span class="built_in">decodeURIComponent</span>(val)</span><br><span class="line">      val = <span class="regexp">/^\d+$/</span>.test(val) ? <span class="built_in">parseFloat</span>(val) : val</span><br><span class="line">      <span class="keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123;</span><br><span class="line">        paramsObj[key] = [].concat(paramsObj[key], val)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        paramsObj[key] = val</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      paramsObj[param] = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> paramsObj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="模板引擎实现"><a href="#模板引擎实现" class="headerlink" title="模板引擎实现"></a>模板引擎实现</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span> (<span class="params">template, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> reg = <span class="regexp">/\&#123;\&#123;(\w+)\&#125;\&#125;/</span></span><br><span class="line">  <span class="keyword">if</span> (reg.test(template)) &#123;</span><br><span class="line">    <span class="keyword">const</span> name = reg.exec(template)[<span class="number">1</span>]</span><br><span class="line">    template = template.replace(reg, data[name])</span><br><span class="line">    <span class="keyword">return</span> render(template, data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> template</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="转驼峰命名"><a href="#转驼峰命名" class="headerlink" title="转驼峰命名"></a>转驼峰命名</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!s) <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  <span class="keyword">if</span> (s[<span class="number">0</span>] === <span class="string">&#x27;-&#x27;</span>) s = s.slice(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> s.replace(<span class="regexp">/-\w/g</span>, <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.slice(<span class="number">1</span>).toUpperCase()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="图片懒加载"><a href="#图片懒加载" class="headerlink" title="图片懒加载"></a>图片懒加载</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> imgList = [...document.querySelectorAll(<span class="string">&#x27;img&#x27;</span>)]</span><br><span class="line"><span class="keyword">let</span> length = imgList.length</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imgLazyLoad = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> deleteIndexList = []</span><br><span class="line">    imgList.forEach(<span class="function">(<span class="params">img, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> rect = img.getBoundingClientRect()</span><br><span class="line">      <span class="keyword">if</span> (rect.top &lt; <span class="built_in">window</span>.innerHeight) &#123;</span><br><span class="line">        img.src = img.dataset.src</span><br><span class="line">        deleteIndexList.push(index)</span><br><span class="line">        count++</span><br><span class="line">        <span class="keyword">if</span> (count === length) &#123;</span><br><span class="line">          <span class="built_in">document</span>.removeEventListeners(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    imgList = imgList.filter(<span class="function">(<span class="params">img, index</span>) =&gt;</span> !deleteIndexList.includes(index))</span><br><span class="line">  &#125;)()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处最好开始防抖处理</span></span><br><span class="line"><span class="built_in">document</span>.addEventListeners(<span class="string">&#x27;scroll&#x27;</span>, imgLazyLoad)</span><br></pre></td></tr></table></figure><h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.events = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  on (event, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[event]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[event] = []</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.events[event].push(fn)</span><br><span class="line">  &#125;</span><br><span class="line">  once (event, fn) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      fn(...args)</span><br><span class="line">      <span class="built_in">this</span>.off(event, temp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.on(event, temp)</span><br><span class="line">  &#125;</span><br><span class="line">  emit (event, ...args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.events[event]) &#123;</span><br><span class="line">      <span class="built_in">this</span>.events[event].forEach(<span class="function"><span class="params">callback</span> =&gt;</span> callback(...args))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  off (event, fn) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.events[event]) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>.events[event] = <span class="built_in">this</span>.events[event].filter(<span class="function"><span class="params">item</span> =&gt;</span> item !== fn)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observerd</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.state = <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">    <span class="built_in">this</span>.observers = []</span><br><span class="line">  &#125;</span><br><span class="line">  setObserver (observer) &#123;</span><br><span class="line">    <span class="built_in">this</span>.observers.push(observer)</span><br><span class="line">  &#125;</span><br><span class="line">  setState (newState) &#123;</span><br><span class="line">    <span class="built_in">this</span>.state = newState</span><br><span class="line">    <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="params">observer</span> =&gt;</span> observer.update(<span class="built_in">this</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">name</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  update (observerd) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(observerd.state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub = <span class="keyword">new</span> Observerd(<span class="string">&#x27;灯&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> mm = <span class="keyword">new</span> Observer(<span class="string">&#x27;小明&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> hh = <span class="keyword">new</span> Observer(<span class="string">&#x27;小黄&#x27;</span>)</span><br><span class="line"></span><br><span class="line">sub.setObserver(mm)</span><br><span class="line">sub.setObserver(hh)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JS </tag>
            
            <tag> 手写 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试八股</title>
      <link href="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/"/>
      <url>/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-和-HTTPS"><a href="#HTTP-和-HTTPS" class="headerlink" title="HTTP 和 HTTPS"></a>HTTP 和 HTTPS</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ul><li>HTTP：是一个客户端和服务器端请求和应答的标准（TCP），用于从 WWW 服务器传输超文本到本地服务器的超文本传输协议；</li><li>HTTPS：是以安全为目标的 HTTP 通道，即 HTTP 下加入 SSL 层进行加密，作用是：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</li></ul><h3 id="区别以及优缺点"><a href="#区别以及优缺点" class="headerlink" title="区别以及优缺点"></a>区别以及优缺点</h3><ul><li>HTTP 是超文本传输协议，信息是明文传输，HTTPS 要比 HTTP 协议安全，https 是具有安全性的 ssl 的加密传输协议，可以防止数据在传输过程中被窃取、改变，确保数据的完整性；</li><li>http 协议的默认端口是 80，https 是 443；</li><li>http 的连接比较简单，是无状态的；https 握手阶段比较费时，会使页面加载时间延长 50%，增加 10% ~ 20% 的耗电；</li><li>https 缓存没有 http 高效，会增加数据开销；</li><li>https 协议需要 ca 证书，费用较高，功能越强大的证书费用越高；</li><li>SSL 证书需要绑定 IP，不能在同一个 IP 上绑定多个域名，IPv4 资源支持不了这种消耗；</li></ul><h3 id="HTTPS-工作原理"><a href="#HTTPS-工作原理" class="headerlink" title="HTTPS 工作原理"></a>HTTPS 工作原理</h3><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<strong>建立 ssl 链接</strong>；</li><li>web 服务器接收到客户端的请求后，会<strong>将网站的证书（包含公钥）传输给客户端</strong>；</li><li>客户端和 web 服务器端开始<strong>协商 SSL 链接的安全等级</strong>，也就是加密等级；</li><li>客户端浏览器通过双方协商一致的安全等级，<strong>建立会话密钥</strong>，然后通过网站的公钥来加密会话密钥，并传送给网站；</li><li>web 服务器<strong>通过自己的私钥解密出会话密钥</strong>；</li><li>web 服务器<strong>通过会话密钥加密与客户端之间的通信</strong>。</li></ol><h2 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h2><h3 id="TCP-三次握手"><a href="#TCP-三次握手" class="headerlink" title="TCP 三次握手"></a>TCP 三次握手</h3><ol><li>第一次握手：建立连接时，客户端发送 <code>SYN</code> 包（SYN = j）到服务器，并进入 <code>SYN_SENT</code> 状态，等待服务器确认（SYN：同步序列编号，Synchronize Sequence Numbers）；</li><li>第二次握手：服务器收到 <code>SYN</code> 包并确认客户端的 <code>SYN</code>（ACK = j + 1），同时也发送一个自己的 <code>SYN</code> 包（SYN = k），即 SYN + ACK 包，此时服务器进入 <code>SYN_RECV</code>；</li><li>第三次握手：客户端收到服务器的 <code>SYN + ACK</code> 包，向服务器发送确认包 <code>ACK</code>（ACK = k + 1），此包发送完毕，客户端和服务器进入 <code>ESTABLISHED</code>（TCP 连接成功）状态，完成三次握手。</li></ol><blockquote><p>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p></blockquote><h3 id="TCP-四次挥手"><a href="#TCP-四次挥手" class="headerlink" title="TCP 四次挥手"></a>TCP 四次挥手</h3><ol><li><strong>客户端进程发出连接释放报文</strong>，并且停止发送数据。释放数据报文首部，FIN = 1，其序列号为 seq = u（的等于之前已经传送过来的数据的最后一个字节的序号加 1），此时，<strong>客户端进入 FIN-WAIT-1(终止等待 1)状态</strong>；</li><li><strong>服务器收到连接释放报文，发出确认报文</strong>，ACK = 1，ack = u + 1，并且带上自己的序列号 seq = v，此时，<strong>服务端就进入了 CLOSE-WAIT(关闭等待)状态</strong>；</li><li>客户端收到服务器的确认请求后，此时，<strong>客户端就进入 FIN-WAIT-2(终止等待 2)状态</strong>，等待服务器发送连接释放报文；</li><li><strong>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</strong>，FIN = 1，ack = u + 1，由于在半关闭状态，服务器可能又发送了一部分数据，此时的序列号是 seq = w，此时，<strong>服务器就进入了 LAST-ACK(最后确认)状态</strong>，等待客户端的确认；</li><li><strong>客户端收到服务器的连接释放报文后，必须发出确认</strong>，ACK = 1，ack = w + 1，自己的序列号是 seq = u + 1，此时，<strong>客户端就进入了 TIME-WAIT(时间等待)状态</strong>，此时 TCP 连接还没有释放，必须经过 2**MSL(最长报文段寿命)的时间后，<strong>当客户端撤销相应的 TCB 后，才进入 CLOSED 状态</strong>；</li><li>服务器只要收到了客户端发出的确认，<strong>立即进入 CLOSED 状态</strong>。同样，撤销 TCB 后，就结束了这次的 TCP 连接，服务器结束 TCP 连接要比客户端稍早一些。</li></ol><h3 id="保证数据包传输的有序可靠"><a href="#保证数据包传输的有序可靠" class="headerlink" title="保证数据包传输的有序可靠"></a>保证数据包传输的有序可靠</h3><p>对字节流分段并进行编号然后 <code>通过 ACK 回复</code> 和 <code>超时重发</code> 两个机制来保证：</p><ul><li>为了保证数据包的可靠传递，发送方必须把已发送的数据包留在缓存区；</li><li>并为每个已发送的数据包启动一个超时定时器；</li><li>如在定时器超时之前收到了对方的应答信息，则释放改数据包占用的缓冲区；</li><li>否则，重传改数据包，直到收到应答或重传次数超过规定的最大次数为止；</li><li>接收方收到数据包后，先进行 CRC 校验，如果正确则把数据交给上层协议，然后给发送方发送一个累计应答包，表明该数据已接收到，如果接收方正好也有数据要发，则应答包可以放在数据包中稍带过去。</li></ul><h3 id="TCP-和-UDP-的区别"><a href="#TCP-和-UDP-的区别" class="headerlink" title="TCP 和 UDP 的区别"></a>TCP 和 UDP 的区别</h3><ol><li>TCP 是面向<strong>链接</strong>的，而 UDP 是面向无连接的；</li><li>TCP 仅支持 <strong>单播传输</strong>，UDP 提供了单播，多播，广播的功能；</li><li>TCP 的三次握手保证了连接的<strong>可靠性</strong>；UDP 是无连接的、不可靠的一种数据传输协议，首先不可靠体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收；</li><li>UDP 的<strong>头部开销</strong>比 TCP 的更小，数据<strong>传输速率更高，实时性更好</strong>。</li></ol><h3 id="HTTP-请求跨域问题"><a href="#HTTP-请求跨域问题" class="headerlink" title="HTTP 请求跨域问题"></a>HTTP 请求跨域问题</h3><h4 id="跨域的原理"><a href="#跨域的原理" class="headerlink" title="跨域的原理"></a>跨域的原理</h4><p>跨域，是指浏览器不能执行其他网址的脚本，是由浏览器的同源策略造成的；</p><p>同源策略，是浏览器对 JavaScript 实施的安全限制，只要协议、域名、端口有任何一个不同，就被当作是不同的域；</p><p>跨域原理，即通过各种方式，避开浏览器的安全限制。</p><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>JSONP：</p><p>ajax 受同源策略影响，不允许进行跨域请求，而 script 标签 src 属性中的链接却可以访问跨域的 js 脚本，利用这个特性，服务端不再返回 JSON 格式的数据，而是返回一段调用某个函数的 js 代码，在 src 中进行了调用，从而实现跨域。</p><ol><li>去创建一个 script 标签</li><li>script 的 src 属性设置接口地址</li><li>接口参数必须要携带一个自定义函数名，否则后台无法返回数据</li><li>通过定义函数名去接受返回的数据</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 动态创建 script</span></span><br><span class="line"><span class="keyword">var</span> script = <span class="built_in">document</span>.createElement(<span class="string">&quot;script&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getData</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 script 的 src 属性，并设置请求地址</span></span><br><span class="line">script.src = <span class="string">&quot;http://localhost:3000/?callback=getData&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 让 srcipt 生效</span></span><br><span class="line"><span class="built_in">document</span>.body.appendChild(script);</span><br></pre></td></tr></table></figure><p>缺点：JSON 只支持 get，因为 script 标签只能使用 get 请求；JSONP 需要后端配合返回指定格式的数据。</p><p>document.domain：</p><p>基本域名相同 子域名不同</p><p>window.name：</p><p>利用在一个浏览器窗口内，载入所有的域名都是共享一个 window.name</p><p>CORS：</p><p>CORS（Cross-origin resourse sharing）跨域资源共享服务器设置对 CORS 的支持原理：服务器设置 Accesss-Control-Allow-Origin HTTP 响应头之后，浏览器将会允许跨域请求。</p><p>proxy 代理：</p><p>目前常用的方式，通过服务器设置代理</p><p>window.postMessage()：</p><p>利用 H5 新特性 <code>window.postMessage()</code> </p><h2 id="Cookie-sessionStorage-localStorage"><a href="#Cookie-sessionStorage-localStorage" class="headerlink" title="Cookie sessionStorage localStorage"></a>Cookie sessionStorage localStorage</h2><p>相同点：</p><ul><li>均存储在客户端</li></ul><p>不同点：</p><ul><li>cookie 数据大小不能超过 4K；sessionStorage 和 localStorage 的存储比 cookie 大得多，可以达到 5M+；</li><li>cookie 的设置的过期时间之前一直有效；localStorage 永久储存，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage 数据在当前浏览器窗口关闭后自动删除；</li><li>cookie 的数据会自动传递到服务器；sessionStorage 和 localStorage 数据保存在本地</li></ul><h2 id="粘包问题分析与对策"><a href="#粘包问题分析与对策" class="headerlink" title="粘包问题分析与对策"></a>粘包问题分析与对策</h2><p>TCP 粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接受缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><h3 id="出现原因"><a href="#出现原因" class="headerlink" title="出现原因"></a>出现原因</h3><p>在流传输中出现，UDP 不会出现粘包，因为它有消息边界。</p><p>粘包情况有两种，一种是 <strong>粘在一起的包都是完整的数据包</strong>，另一种是 <strong>粘在一起的包有不完整的包</strong>。</p><h3 id="避免措施"><a href="#避免措施" class="headerlink" title="避免措施"></a>避免措施</h3><ol><li>对于发送方引起的粘包现象，用户可以通过编程设置来避免，<strong>TCP 提供了强制数据立即传送的操作指令 push</strong>，TCP 软件收到改操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满；<ul><li>虽然可以避免发送方引起的粘包，但关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用</li></ul></li><li>对于接收方引起的粘包现象，则可通过优化程序设计、精简接收进程工作量、<strong>提高接收进程优先级</strong>等措施，使其即使接收数据，从而尽量避免出现粘包现象；<ul><li>只能减少出现粘包的可能性，并不能完全避免粘包</li></ul></li><li>由接收方控制，将一包数据按结构字段，认为控制分多次接收，然后合并，通过这种手段来避免粘包。<strong>分包多发</strong>。<ul><li>虽然避免了粘包，但应用程序的效率较低，对实时应用的场合不适合。</li></ul></li></ol><blockquote><p>周全的对策：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开，高效可行。</p></blockquote><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="输入-URL-到页面加载"><a href="#输入-URL-到页面加载" class="headerlink" title="输入 URL 到页面加载"></a>输入 URL 到页面加载</h3><ol><li>在浏览器地址栏输入 URL；</li><li>查找缓存：浏览器先查看浏览器缓存-系统缓存-路由缓存中是否有该地址页面，如果有则直接显示页面内容，如果没有则进行下一步；<ul><li>浏览器缓存：浏览器会记录 DNS 一段时间；</li><li>操作系统缓存：如果在浏览器缓存中不包含这个记录，则会使系统调用操作系统，获取操作系统的记录（保存最近的 DNS 查询缓存）；</li><li>路由器缓存：如果上述两个步骤均不能成功获取 DNS 记录，继续 搜索路由器缓存；</li><li>ISP 缓存：若上述均失败，继续向 ISP 搜索。</li></ul></li><li>DNS 域名解析：浏览器向 DNS 服务器发起请求，解析该 URL 中的域名对应的 IP 地址，<strong>DNS 服务器是基于 UDP 的，因此会用到 UDP 协议</strong>；</li><li>建立 TCP 连接：解析出 IP 地址后，根据 IP 地址和默认 80 端口，和服务器建立 TCP 连接；</li><li>发起 HTTP 请求：浏览器发起读取文件的 HTTP 请求，该 i 请求作为 TCP 三次握手的第三次数据发送给服务器；</li><li>服务器响应请求并返回结果：服务器对浏览器请求做出响应，并把对应的 html 文件发送给服务器</li><li>关闭 TCP 连接：通过四次挥手释放 TCP 连接</li><li>浏览器渲染：客户端（浏览器）解析 HTML 内容并渲染出来，浏览器接收到数据包后进行解析：<ul><li>构建 DOM 树：词法分析然后解析成 DOM 树，是由 DOM 元素及属性节点组成，树的根是 document 对象；</li><li>构建 CSS 规则树：生成 CSS 规则树（CSSOM）；</li><li>构建 render 树：Web 浏览器将 DOM 和 CSSOM 结合，病候检出渲染树（render tree）；</li><li>布局（Layout）：计算出每个节点在屏幕中的位置；</li><li>绘制（Painting）：即遍历 render 树，并使用 UI 后端层绘制每个节点。</li></ul></li><li>JS 引擎解析过程：调用 JS 引擎执行 JS 代码：<ul><li>创建 window 对象：window 对象也叫全局变量环境，当页面产生时就被创建，所有的全局变量和函数都属于 window 的属性和方法，DOM 树也会映射在 window 的 document 对象上；当关闭网页或者浏览器时，全局执行环境会被销毁；</li><li>加载文件：JS 引擎分析它的语法和词法是否合法，合法则进入预编译；</li><li>预编译：浏览器会寻找全局变量声明，把它作为 window 的属性加入到 window 对象中，并赋值为 <code>undefined</code>；寻找全局函数声明，作为 window 的方法加入到 window 对象中，将函数体赋值给它（匿名函数是不参与预编译的，它是变量）；</li><li>解释执行：执行到变量就赋值，若变量未定义，在 ES5 严格模式下此变量会变成 window 的一个属性，也就是成为全局变量；函数执行，就将函数的环境推入一个环境的栈中，执行完成后弹出，交回控制权；</li></ul></li></ol><h3 id="重绘与重排"><a href="#重绘与重排" class="headerlink" title="重绘与重排"></a>重绘与重排</h3><ul><li>重排/回流（Reflow）：当 DOM 的变化影响了元素的几何信息，浏览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，即重排；表现为重新生成布局，重新排列元素；</li><li>重绘（Repaint）：当一个元素的外观发生改变，但没有影响布局，重新把元素外观绘制出来的过程，叫重绘；表现为元素的外观被改变。</li></ul><blockquote><p>重绘不一定会出现重排，但重排一定会重绘！</p></blockquote><p>重排和重绘的代价是高昂的，会破坏用户体验，让 UI 展示非常迟缓，相比之下重排的性能影响更大，两者无法避免的情况下一般选择代价更小的重绘。</p><h4 id="触发条件"><a href="#触发条件" class="headerlink" title="触发条件"></a>触发条件</h4><ul><li>添加、删除、更新 DOM 节点；</li><li>通过 <code>display: none</code> 隐藏一个 DOM 节点，触发重排和重绘；</li><li>通过 <code>visibility: hidden</code> 隐藏一个 DOM 节点，只触发重绘；</li><li>移动或者给页面中的 DOM 节点添加动画；</li><li>添加一个样式表，调整样式属性；</li><li>用户行为：调整窗口大小、改变字号、滚动等。</li></ul><h4 id="避免"><a href="#避免" class="headerlink" title="避免"></a>避免</h4><ol><li><p><strong>集中改变样式</strong>，不要一条一条多次修改 DOM 中的样式；</p></li><li><p>不要把 DOM 节点的属性放在循环里当成循环里的变量；</p></li><li><p>为动画的 HTML 元件使用 fixed 或 absolute 的 position，那么修改他们的 CSS 是不会触发整个页面的 reflow 的；</p></li><li><p>不要使用 table 布局，很小的改动会造成整个 table 的重新布局；</p></li><li><p>尽量只修改 <code>position: absolute</code> 或 <code>fixed</code> 的元素，影响较小；</p></li><li><p>动画开启 GPU 加速，translate 使用 3D 变化；</p></li><li><p>提升为合成层：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他层；</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><p>提升合成层的最好方式是使用 CSS 的 <code>will-change</code> 属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#demo</span> &#123;</span><br><span class="line">  will-change: transform;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="304"><a href="#304" class="headerlink" title="304"></a>304</h3><ul><li>浏览器请求资源时首先命中资源的 Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过 Cache-control: max-age 指定最大生命周期，状态仍返回 200，但不会请求数据；</li><li>强缓存失效，进入协商缓存阶段，首先验证 ETagETag 可以保证每一个资源是唯一的，资源变化都会导致 ETag 变化，服务器根据客户端上送的 If-No 该资源的最后 ne-Match 值来判断是否命中缓存；</li><li>协商缓存 LastModify/If-Modify-Since 阶段，客户端第一次请求资源时，服务器返回的 header 中会加上 Last-Modify，Last-Modify 标识该资源的最后修改时间，再次请求该资源时，request 的请求头中会包含 If-Modify-Since，为缓存之前返回的 Last-Modify，服务器收到 If-Modify-Since 后，根据资源的最后修改时间判断是否命中缓存。</li></ul><h3 id="强制缓存-协商缓存"><a href="#强制缓存-协商缓存" class="headerlink" title="强制缓存 协商缓存"></a>强制缓存 协商缓存</h3><p>浏览器与服务器通信的方式为应答模式，即是：浏览器发起 HTTP 请求 - 服务器响应该请求。</p><p>浏览器第一次向服务器发起请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220412153039501.png" class title="第一次发起 HTTP 请求"><ul><li>浏览器每次发起请求，都会<strong>先在浏览器缓存中查找该请求的结果以及缓存标识</strong>；</li><li>浏览器每次拿到返回的请求结果都会<strong>将该结果和缓存标识存入浏览器缓存中</strong>。</li></ul><p>强制缓存：</p><p>就是<strong>向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程</strong>。当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 Cache-Control 优先级更高。</p><p>强制缓存的情况主要有三种：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（与首次发请求一致）；</li><li>存在该缓存结果和缓存标识，但已失效，强制缓存失效，则使用协商缓存；</li><li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li></ol><p>协商缓存：</p><p>就是<strong>强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</strong>。协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，字段包括：<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>，其中 Etag/If-None-Match 的优先级更高。</p><p>情况有两种：</p><ol><li>协商缓存生效，返回 304；</li><li>协商缓存失效，重新发起请求，返回 200 和请求结果。</li></ol><h3 id="进程-线程-协程"><a href="#进程-线程-协程" class="headerlink" title="进程 线程 协程"></a>进程 线程 协程</h3><p>进程：是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位，是应用程序运行的载体。</p><p>线程：是程序执行中一个单一的顺序控制流程，是程序执行流的最小单元，是处理器调度和分派的基本单位。一个进程可以有一个或多个线程，各个线程之间共享程序的内存空间。</p><ul><li>一个标准的线程由线程 ID、当前指令指针(PC)、寄存器和堆栈组成；</li><li>进程由内存空间(代码、数据、进程空间、打开的文件)和一个或多个线程组成</li></ul><p>协程（Coroutines）：是一种基于线程之上，但又比线程更加轻量级的存在。</p><p>进程和线程的区别：</p><ol><li>调度：线程作为调度和分配的基本单位，进程作为拥有资源的基本单位；</li><li>并发性：进程之间可以并发执行，同一个进程的多个线程之间也可以并发执行；</li><li>拥有资源：进程拥有资源，线程不拥有系统资源，但可以访问隶属于进程的资源；</li><li>系统开销：创建或撤销进程比线程的开销大，因为系统都要为之分配和回收资源；多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率较差；</li></ol><p>联系：</p><ul><li>一个线程只能属于一个进程，而一个进程可以有一个或多个线程；</li><li>资源分配给进程，同一进程的所有线程共享该进程的所有资源；</li><li>处理机分给线程，即真正在处理机上运行的是线程；</li><li>线程在执行过程中，需要协作同步，不同进程的线程间要利用消息通信的办法实现同步。</li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="HTML5-语义化"><a href="#HTML5-语义化" class="headerlink" title="HTML5 语义化"></a>HTML5 语义化</h3><p>HTML5 的语义化指的是<strong>合理正确的使用语义化的标签来创建页面结构</strong>。</p><p>语义化标签包括：</p><ul><li>header、nav、main、article、section、aside、footer</li></ul><p>优点：</p><ul><li>在没 CSS 样式的情况下，页面整体也会呈现很好的结构效果；</li><li>代码结构清晰，易于阅读；</li><li>利于开发和维护，方便其他设备解析（如屏幕阅读器），根据语义渲染网页；</li><li>有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重。</li></ul><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="CSS-选择器及优先级"><a href="#CSS-选择器及优先级" class="headerlink" title="CSS 选择器及优先级"></a>CSS 选择器及优先级</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><p>id 选择器 <code>#</code>、类选择器 <code>.</code>、属性选择器 <code>[a=&quot;b&quot;]</code>、伪类选择器 <code>:</code>、标签选择器 <code>div h1...</code>、相邻选择器 <code>+</code>、子选择器 <code>&gt;</code>、后代选择器 <code>(空格)</code>、通配符选择器 <code>*</code>。</p><h4 id="优先级"><a href="#优先级" class="headerlink" title="优先级"></a>优先级</h4><ul><li><code>!important</code></li><li>内联样式（1000）</li><li>ID 选择器（0100）</li><li>类选择器/属性选择器/伪类选择器（0010）</li><li>元素选择器/伪元素选择器（0001）</li><li>关系选择器/通配符选择器（0000）</li></ul><p>带 important 标记的样式属性优先级最高；样式表的来源相同时：</p><p><code>!important</code> &gt; 行内样式 &gt; ID 选择器 &gt; 类选择器 &gt; 标签选择器 &gt; 通配符选择器 &gt; 继承 &gt; 浏览器默认属性</p><h3 id="position"><a href="#position" class="headerlink" title="position"></a>position</h3><p><strong>固定定位 fixed</strong>：元素的位置相对于浏览器窗口是固定位置，即使窗口滚动也不会移动；fixed 定位使元素的位置与文档流无关，因此不占据空间，fixed 定位的元素和其他元素重叠；</p><p><strong>相对定位 relative</strong>：如果一个元素相对定位，它将依旧出现在所在的位置上，可以通过设置垂直水平距离让此元素相对于原先的位置进行移动，但元素仍占据原先的空间，会覆盖其他元素；</p><p><strong>绝对定位 absolute</strong>：绝对定位的元素的位置相对于最近的已定位父元素，若无已定位的父元素，则位置相对于 body，absolute 定位使元素的位置与文档流无关，因此不占据空间，absolute 定位的元素和其他元素重叠；</p><p><strong>粘性定位 sticky</strong>：元素先按照普通文档流定位，相对于该元素在流中的 flow root（BFC）和 containing block（最近的块级祖先元素）定位，在跨越特定阈值前为相对定位，之后为固定定位；</p><p><strong>默认定位 static</strong>：默认值。没有定位，元素出现在正常的流中，忽略 top、bottom、left、right 以及 z-index 声明。</p><p>也可以设置为 <code>inherit</code>：来从父元素继承 position 属性的值。</p><h3 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h3><p>box-sizing 规定两个并排的带边框的框：</p><ul><li><strong>content-box</strong>：宽度和高度分别应用到元素的内容框，在宽度和高度之外绘制元素的内边距和边框【标准盒模型】；</li><li><strong>border-box</strong>：为元素设定的宽度和高度决定了元素的边框盒【IE 盒模型/怪异盒模型】；</li><li>inherit：继承父元素的 box-sizing 值</li></ul><h3 id="CSS-盒模型"><a href="#CSS-盒模型" class="headerlink" title="CSS 盒模型"></a>CSS 盒模型</h3><p>CSS 盒模型本质上是一个盒子，包括：边距、边框、填充盒实际内容；CSS 中的盒模型包括 IE 盒模型和标准 W3C 盒模型。</p><ul><li>在标准的盒模型中，width 指 <code>content</code> 部分的宽度；</li><li>在 IE 盒模型中，width 表示 <code>content + padding + border</code> 三个部分的宽度。</li></ul><p>总宽度都是 <code>width + margin(左右)</code>，高度同理。</p><p>可通过 <code>box-sizing</code> 进行设置，根据计算宽高的区域可以分为：</p><ul><li><code>content-box</code>：W3C 标准盒模型</li><li><code>border-box</code>：IE 盒模型</li><li><code>padding-box</code>：FireFox 曾支持</li><li><code>margin-box</code>：浏览器未实现</li></ul><blockquote><p>理论上是有四种盒模型，但目前 W3C 和 MDN 规范中均只支持 <code>content-box</code> 与 <code>border-box</code>。</p></blockquote><h3 id="BFC-块级格式上下文"><a href="#BFC-块级格式上下文" class="headerlink" title="BFC(块级格式上下文)"></a>BFC(块级格式上下文)</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>BFC（Block Formatting Context），块级格式上下文，是 CSS 布局的一个概念，是一个独立的渲染区域，规定了内部 box 如何布局，并且这个区域的子元素不会影响到外面的元素，其中比较重要的布局规则有：</p><ul><li>内部 box 垂直放置；</li><li>计算 BFC 的高度的时候，浮动元素也参与计算。</li></ul><h4 id="原理布局规则"><a href="#原理布局规则" class="headerlink" title="原理布局规则"></a>原理布局规则</h4><ul><li>内部的 Box 会在垂直方向，一个一个的放置；</li><li>Box 垂直方向的距离由 margin 决定，属于同一个 BFC 的两个相邻 Box 的 margin 会发生重叠；</li><li>每个元素的 margin box 的左边，与包含块 border box 的左边相接触（对于默认的从左往右排列的格式）；</li><li>BFC 的区域不会与 float box 重叠；</li><li>BFC 是一个独立容器，容器里的子元素不会影响到外面的元素；</li><li>计算 BFC 高度时，浮动元素也参与计算；</li><li>元素的类型和 display 属性，决定了这个 Box 的类型，不同类型的 Box 会参与不同的 <code>Formatting Context</code>。</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ul><li>根元素，即 HTML 元素</li><li>float 的值不为 none</li><li>position 为 absolute 或 fixed</li><li>display 的值为 inline-block、table-cell、table-caption</li><li>overflow 的值不为 visible</li></ul><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4><ul><li>去除边距重叠现象；</li><li>清除浮动（让父元素的高度包含子浮动元素）；</li><li>避免某元素被浮动元素覆盖；</li><li>避免多列布局由于宽度计算四舍五入而自动换行。</li></ul><h3 id="水平垂直居中"><a href="#水平垂直居中" class="headerlink" title="水平垂直居中"></a>水平垂直居中</h3><h4 id="水平居中"><a href="#水平居中" class="headerlink" title="水平居中"></a>水平居中</h4><ul><li>对于行内元素：<code>text-align: center;</code> </li><li>对于确定宽度的块级元素：<ul><li><code>margin: 0 auto;</code> </li><li><code>position: absolute; margin-left: (父width - 子width) / 2;</code>，需要父元素 <code>position: relative;</code> </li></ul></li><li>对于宽度未知的块级元素：<ul><li><code>display: table; margin: 0 auto;</code> </li><li><code>display: inline-block; text-align: center;</code> </li><li><code>position: absolute; left: 50%; transform: translateX(-50%);</code> </li><li><code>display: flex; justify-content: center;</code> </li></ul></li></ul><h4 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h4><ol><li><code>inline-height: height;</code> 适合纯文字类；</li><li>通过设置父容器相对定位，子元素设置绝对定位，标签通过 margin 实现自适应居中；</li><li>弹性布局 flex：父级设置 <code>display: flex;</code>，子级设置 margin 为 auto 实现自适应居中；</li><li>父级设置相对定位，子级设置绝对定位，并且通过位移 transform 实现；</li><li>利用 table 布局，子级设置 <code>vertical-align: middle;</code>，使用的前提条件：内联元素以及 display 值为 table-cell 的元素</li></ol><h3 id="隐藏页面中元素"><a href="#隐藏页面中元素" class="headerlink" title="隐藏页面中元素"></a>隐藏页面中元素</h3><ol><li><code>opacity: 0</code>，元素变透明，即隐藏，不会改变页面布局，且绑定的一些事件仍然可以触发（如点击事件）；</li><li><code>visibility: hidden</code>，同样不会改变页面布局，但无法触发已绑定的事件，隐藏对应元素，在文档布局中仍保留原来的空间；</li><li><code>display: none</code>，会改变页面布局，在文档布局中不再分配空间（重排重绘）</li></ol><h3 id="用-CSS-画三角"><a href="#用-CSS-画三角" class="headerlink" title="用 CSS 画三角"></a>用 CSS 画三角</h3><p><strong>盒子宽高均为零，三面边框均透明</strong>。</p><p>利用伪元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>:after &#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot; &quot;</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid pink;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接边框：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#css</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">16px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">16px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="0-5px-边框"><a href="#0-5px-边框" class="headerlink" title="0.5px 边框"></a>0.5px 边框</h3><p>方案一：缩小</p><p>利用缩小使得视觉上变为 0.5px：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: <span class="number">#000</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">transform</span>: <span class="built_in">scaleY</span>(<span class="number">0.5</span>);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：兼容性较好，可以设置圆角，<strong>推荐使用</strong>。</p><p>方案二：线性渐变</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.border-half</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">position</span>: absolute;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">1px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: <span class="built_in">linear-gradient</span>(to bottom, <span class="number">#000</span>, transparent);</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;border-half&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>优点：适合设置一条边框，无法展示圆角。</p><p>方案三：阴影</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h3><h4 id="Flex-布局"><a href="#Flex-布局" class="headerlink" title="Flex 布局"></a>Flex 布局</h4><p>Flex 是 Flexible Box 的缩写，意为“弹性布局”，用来为盒模型提供最大的灵活性，指定 <code>display: flex</code> 即可。</p><p>容器属性：</p><ul><li>flex-direction：决定主轴的方向(即子 item 的排列方法)，取值：<ul><li>row | row-reverse | column | column-reverse</li></ul></li><li>flex-wrap：决定换行规则，取值：<ul><li>nowrap | wrap | wrap-reverse</li></ul></li><li>flex-flow：flex-direction 和 flex-wrap 的简写形式；</li><li>justify-content：水平主轴对齐方式；</li><li>align-items：竖直轴线方向对齐方式；</li><li>align-content：元素排列大于一行时 align-items 需换成 align-content；</li></ul><p>元素属性：</p><ul><li>order：定义项目的排列顺序，默认为 0，越小越靠前；</li><li>flex-grow：定义项目的放大比例，即使存在空间，也不会放大；</li><li>flex-shrink：定义项目的缩小比例，当空间不足的情况下会等比例的缩小，0 为不缩小；</li><li>flex-basis：定义了在分配多余的空间项目所占的空间；</li><li>flex：flex-grow、flex-shrink 和 flex-basis 的简写，默认值为 <code>0 1 auto</code>；</li><li>align-self：允许单个项目于其他项目不同的对齐方式，可覆盖；</li><li>align-items：默认值为 auto，表示继承父元素的 align-items 值。</li></ul><h4 id="Rem-布局"><a href="#Rem-布局" class="headerlink" title="Rem 布局"></a>Rem 布局</h4><p>Rem 相对于根（html）的 font-size 大小来计算，就是一个相对比例（如：<code>font-size: 10px</code>，那么），rem 布局的本质是等比缩放，一般是基于宽度。</p><p>优点：可以快速使用移动端布局，字体，图片高度；</p><p>缺点：</p><ol><li>目前 IE 不支持，对 pc 页面来讲使用次数不多；</li><li>数据量大：所有的图片、盒子都需要给一个准确的值，才能保证不同机型的适配；</li><li>在响应式布局中，必须通过 js 来动态控制根元素 font-size 的大小，且必须将改变 font-size 的代码放在 css 样式之前。</li></ol><h4 id="百分比布局"><a href="#百分比布局" class="headerlink" title="百分比布局"></a>百分比布局</h4><p>通过百分比单位 <code>%</code> 来实现响应式的效果，可以使得浏览器中的组件的宽高随着浏览器的变化而变化。</p><ul><li>height 相对于 height；</li><li>width 相对于 width；</li><li>padding、bording、margin 等不论是垂直还是水平方向都相对于直接父元素的 width；</li><li>除了 border-radius 外，translate、background-szie 等都相对于自身。</li></ul><p>缺点：计算困难，可能使布局问题复杂</p><h4 id="浮动布局"><a href="#浮动布局" class="headerlink" title="浮动布局"></a>浮动布局</h4><p>当元素浮动以后可以向左或向右移动，直到它的边缘碰到包含它的框或者另外一个浮动元素的边框为止；元素浮动后会脱离正常的文档流，所以文档的普通流中的框就会变得好像浮动元素不存在一样。</p><p>优点：</p><ul><li>在图文混排的时候可以很好的实现文字环绕图片；</li><li>当元素浮动起来后，它有着块级元素的一些性质，如设置宽高；</li></ul><p>缺点：会造成父级元素高度塌陷，需要进行清除浮动。</p><h3 id="圣杯布局-双飞翼布局"><a href="#圣杯布局-双飞翼布局" class="headerlink" title="圣杯布局 双飞翼布局"></a>圣杯布局 双飞翼布局</h3><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><p>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span>我是头部<span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span>我是尾部<span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hiddle;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220416103735470.png" class title="圣杯布局"><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>HTML：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle_child&quot;</span>&gt;</span>我是中<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span>我是左<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span>我是右<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">header</span>, <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">48px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: purple;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content</span> &#123;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.middle_child</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">80px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用-rem-或-viewport-进行移动端适配"><a href="#使用-rem-或-viewport-进行移动端适配" class="headerlink" title="使用 rem 或 viewport 进行移动端适配"></a>使用 rem 或 viewport 进行移动端适配</h3><h4 id="rem-适配原理"><a href="#rem-适配原理" class="headerlink" title="rem 适配原理"></a>rem 适配原理</h4><p>改变了一个元素在不同设备上占据的 css 像素的个数。</p><p>优点：没有破坏完美视口</p><p>缺点：px 转换 rem 较为复杂</p><h4 id="viewport-适配原理"><a href="#viewport-适配原理" class="headerlink" title="viewport 适配原理"></a>viewport 适配原理</h4><p>每一个元素在不同设备上占据的 css 像素的个数是一样的，但 css 像素和物理像素的比例是不一样的。</p><p>优点：在设计图上所取量的大小即为可以设置的像素大小（所量及所设）</p><p>缺点：破坏完美视口</p><h3 id="清除浮动"><a href="#清除浮动" class="headerlink" title="清除浮动"></a>清除浮动</h3><ol><li><p>添加额外标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加额外标签并添加 clear 属性 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以添加一个 br 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>父级添加 overflow 属性，或者设置高度；</p></li><li><p>建立伪类选择器清除浮动：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 在 css 中添加 :after 伪元素 */</span></span><br><span class="line"><span class="selector-class">.parent</span>:after &#123;</span><br><span class="line">  content: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="CSS-中可以继承的属性"><a href="#CSS-中可以继承的属性" class="headerlink" title="CSS 中可以继承的属性"></a>CSS 中可以继承的属性</h3><ol><li>字体系列属性：<ul><li>font-family、font-weight、font-size、font-style</li></ul></li><li>文本系列：<ul><li>text-indent、text-align、line-height</li><li>word-spacing、letter-spacing</li><li>text-transform、color</li></ul></li><li>元素可见性：visibility</li><li>列表布局属性：<ul><li>list-style、list-style-image、list-style-type 等</li></ul></li><li>光标属性：cursor</li></ol><h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>媒体查询是 CSS3 开始加入的功能，可以进行响应式适配展示，由两部分组成：</p><ul><li>一个可选的媒体类型（如 screen、print）等；</li><li>零个或多个媒体功能限定表达式（如 <code>max-width: 500px</code>、<code>orientation: landscape</code>）等</li></ul><p>最终这两部分会被解析为 true 或 false，进而确定该媒体查询关联的样式是否生效。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> <span class="keyword">not</span>|<span class="keyword">only</span> mediatype <span class="keyword">and</span> (mediafeature <span class="keyword">and</span>|<span class="keyword">or</span>|<span class="keyword">not</span> mediafeature) &#123;</span><br><span class="line">  CSS-<span class="selector-tag">Code</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键词定义：</p><ul><li><code>not</code>：用于否定媒体查询，将解析后的媒体查询结反转；若出现在逗号分隔的查询列表中，将仅否定应用了该查询的特定查询；使用 not 必需指定媒体类型；</li><li><code>only</code>：仅在整个查询匹配时才用于应用样式，对于防止版本低的浏览器应用所选样式很有用；</li><li><code>,</code>：用于将多个媒体查询合并为一个规则，各自分开处理，类似于逻辑或 or；</li><li><code>and</code>：用于将多个媒体查询规则组合成单条媒体查询，类似于逻辑与；</li></ul><p>媒体类型（Media Types）：描述设备的一般类型</p><ul><li><code>all</code>：用于所有设备</li><li><code>print</code>：用于打印机和打印预览</li><li><code>screen</code>：用于电脑屏幕、平板电脑、智能手机等</li><li><code>speech</code>：用于屏幕阅读器等发声设备</li><li>其他已废弃（aural、braille、embossed、handheld、projection、tty、tv）</li></ul><p>媒体功能：</p><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>color</td><td>每一组彩色原件的个数，非彩色设备则值为 0</td></tr><tr><td>min-color</td><td>每一组彩色原件的最小个数</td></tr><tr><td>max-color</td><td>每一组彩色原件的最大个数</td></tr><tr><td>color-index</td><td>彩色查询表中的条目数，没有使用则为 0</td></tr><tr><td>min-color-index</td><td>彩色查询表中的最大条目数</td></tr><tr><td>max-color-index</td><td>彩色查询表中的最大条目数</td></tr><tr><td>device-aspect-ratio</td><td>屏幕可见区域宽高比</td></tr><tr><td>device-height</td><td>屏幕可见区域高度</td></tr><tr><td>device-width</td><td>屏幕可见区域最大宽度</td></tr><tr><td>min-device-aspect-ratio</td><td>屏幕可见区域最小宽高比</td></tr><tr><td>min-device-height</td><td>屏幕可见区域最小高度</td></tr><tr><td>min-device-width</td><td>屏幕可见区域最小宽度</td></tr><tr><td>max-device-aspect-ratio</td><td>屏幕可见区域最大宽高比</td></tr><tr><td>max-device-height</td><td>屏幕可见区域最大高度</td></tr><tr><td>max-device-width</td><td>屏幕可见区域最大宽度</td></tr><tr><td>aspect-ratio</td><td>页面可见区域宽高比</td></tr><tr><td>height</td><td>页面可见区域高度</td></tr><tr><td>width</td><td>页面可见区域宽度</td></tr><tr><td>max-aspect-ratio</td><td>页面可见区域最大宽高比</td></tr><tr><td>max-height</td><td>页面可见区域最大高度</td></tr><tr><td>max-width</td><td>页面可见区域最大宽度</td></tr><tr><td>min-aspect-ratio</td><td>页面可见区域最小宽高比</td></tr><tr><td>min-height</td><td>页面可见区域最小高度</td></tr><tr><td>min-width</td><td>页面可见区域最小宽度</td></tr><tr><td>max-resolution</td><td>设备的最大分辨率</td></tr><tr><td>min-resolution</td><td>设备的最小分辨率</td></tr><tr><td>resolution</td><td>设备的分辨率，单位为 dpi、dpcm</td></tr><tr><td>max-monochrome</td><td>在一个单色框架缓冲区中每像素包含的最大单色元件个数</td></tr><tr><td>min-monochrome</td><td>在一个单色框架缓冲区中每像素包含的最小单色元件个数</td></tr><tr><td>monochrome</td><td>在一个单色框架缓冲区中每像素包含的单色元件个数，若非单色设备则值为 0</td></tr><tr><td>orientation</td><td>页面可见区域高度是否大于或者等于宽度</td></tr><tr><td>grid</td><td>查询输出设备是否使用栅格或点阵</td></tr><tr><td>scan</td><td>电视类设备的扫描工序</td></tr></tbody></table><h2 id="JS-TS-ES6"><a href="#JS-TS-ES6" class="headerlink" title="JS TS ES6"></a>JS TS ES6</h2><h3 id="JS-的-8-种数据类型"><a href="#JS-的-8-种数据类型" class="headerlink" title="JS 的 8 种数据类型"></a>JS 的 8 种数据类型</h3><p>包含值类型(基本对象类型)和引用类型(复杂对象类型)</p><p>基本类型：在内存中占据固定大小，保存在栈内存中</p><ul><li>Number（数字类型）</li><li>String（字符串类型）</li><li>Boolean（布尔类型）</li><li>null（空）</li><li>undefined（未定义）</li><li>Symbol（符号类型，ES6）</li><li>bigInt（ES10）</li></ul><p>引用类型：引用类型的值是对象，保存在堆内存中，栈内存存储的是对象的变量标识符以及对象在堆内存中的存储地址</p><ul><li>Object（对象）</li><li>Function（函数）</li><li>Array（数组）</li><li>Date（日期）</li><li>RegExp（正则表达式）</li><li>特殊的包装类型：String、Number、Boolean</li><li>单体内置对象：Global、Math 等</li><li>Map（字典，ES6）</li><li>Set（集合，ES6）</li></ul><h4 id="Object"><a href="#Object" class="headerlink" title="Object"></a>Object</h4><p>判断空对象方法：</p><ul><li><p><code>JSON.stringify(obj) === &#39;&#123;&#125;&#39;</code> </p></li><li><p><code>Object.keys(obj).length == 0</code> </p></li><li><p><code>Object.getWonPropertyNames(obj).length == 0</code> </p></li><li><p>jQuery 中的 <code>$.isEmptyObject(obj)</code> 方法</p></li><li><p>```js<br>var result = function (obj) {<br>  for (let key in obj) {</p><pre><code>return false</code></pre><p>  }<br>  return true<br>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### Symbol</span><br><span class="line"></span><br><span class="line">Symbol 指的是独一无二的值，每个通过 `Symbol()` 生成的值都是唯一的。</span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line">let var_symbol = Symbol();</span><br><span class="line">let other_symbol = Symbol();</span><br><span class="line">console.log(var_symbol === other_symbol); // false</span><br><span class="line">console.log(typeof var_symbol); // symbol</span><br><span class="line">console.log(var_symbol.constructor === Symbol); // true</span><br></pre></td></tr></table></figure></li></ul><p>可以用 <code>Symbol.for(key)</code> 创建相等的变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> var_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> other_symbol = <span class="built_in">Symbol</span>.for(<span class="string">&quot;symbol&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(var_symbol === other_symbol); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol.for(key)</code> 会根据给定的建 key(字符串)，来存运行时的 symbol 注册表中找到对应的 symbol，如找到则返回，未找到则新建一个与该键相关联的 symbol 返回，并放入全局 symbol 注册表中。</p><p>应用场景：</p><ol><li>使用 Symbol 来作为对象属性名（key）</li><li>使用 Symbol 来替代常量</li><li>使用 Symbol 定义类的私有属性/方法</li></ol><p>Object.getOwnPropertySymbols() 方法返回一个数组，包含给定对象所有自有的 Symbol 值的属性（包括不可枚举的 Symbol 值属性）。</p><h4 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h4><p>BigInt 是一种数字类型的数据，可以表示任意精度格式的整数。</p><p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于 2 的 1024 次方的数值，JavaScript 无法表示，会返回 <code>Infinity/-Infinity</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 超过 53 个二进制位的数值，无法保持精度</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 超过 2 的 1024 次方的数值，无法表示</span></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">1024</span>); <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure><p>ES10 引入了一种新的数据类型 BigInt 来解决这个问题，只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示，为了与 Number 进行区分，BigInt 类型的数据必须添加后缀 <code>n</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12</span>; <span class="comment">// 普通 Number</span></span><br><span class="line"><span class="number">12n</span>; <span class="comment">// BigInt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// BigInt 的运算</span></span><br><span class="line"><span class="number">1n</span> + <span class="number">2n</span>; <span class="comment">// 3n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Number 类型进行运算</span></span><br><span class="line"><span class="number">1</span> + <span class="number">1n</span>; <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure><p>BigInt 与普通整数时两种值，它们之间并不相等：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">12n</span> === <span class="number">12</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>由于 BigInt 与 Number 完全属于两种类型，并且不会进行隐式转换，所以没有办法进行混合运算。想要运算的话，必须将两种数据类型转换为同一种后，方可进行计算：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">BigInt</span>(number);</span><br><span class="line"><span class="built_in">Number</span>(bigint);</span><br></pre></td></tr></table></figure><p>typeof 运算符对于 BigInt 类型的数据返回 <code>bigint</code> 字符串；BigInt 并不是一个构造函数，不能使用 new 来创建实例；创建一个 BigInt 时，参数必须为整数，否则会报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">12n</span>; <span class="comment">// &#x27;bigint&#x27;</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">BigInt</span>(); <span class="comment">// Uncaught TypeError</span></span><br><span class="line"><span class="built_in">BigInt</span>(<span class="number">1.2</span>); <span class="comment">// Uncaught RangeError</span></span><br></pre></td></tr></table></figure><h4 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h4><p>Set 是 ES6 引入的一种叫做集合（是由一堆无序的、相关联的，且不重复的内存结构）的数据结构。</p><p>Set 就像一个数组，但是仅包含唯一项，Set 对象是值的集合，可以按照插入的顺序迭代它的元素。Set 中的元素只会出现一次，即 Set 中的元素是唯一的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> setTest = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">0</span>, -<span class="number">0</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="literal">Infinity</span>, <span class="literal">null</span>])</span><br><span class="line"><span class="built_in">console</span>.log(setTest) <span class="comment">// Set &#123; 0, Infinity, null, undefined, NaN &#125;</span></span><br></pre></td></tr></table></figure><ul><li>虽然 NaN !== NaN，但是在 Set 集合内只会存在一个；</li><li>undefine、null、Infinity 也只能各自存在一个。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 属性</span></span><br><span class="line">set.size <span class="comment">// 返回集合中所包含元素的数量</span></span><br><span class="line"><span class="comment">// 操作方法</span></span><br><span class="line">set.add(value) <span class="comment">// 向 set 中添加元素</span></span><br><span class="line">set.delete(value) <span class="comment">// 删除 set 中对应元素</span></span><br><span class="line">set.has(value) <span class="comment">// 判断值在集合中是否存在，返回 true 或 false</span></span><br><span class="line">set.clear() <span class="comment">// 移除集合中所有的向</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 遍历进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Set]&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4><p>Map 是一组键值对的结构，具有极快的查找速度。</p><p>初始化 Map 需要一个二维数组，或者直接初始化一个空 Map：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="comment">//属性</span></span><br><span class="line">map.size <span class="comment">// 返回映射中的元素数</span></span><br><span class="line"><span class="comment">// 方法</span></span><br><span class="line">map.set(<span class="string">&#x27;key&#x27;</span>, <span class="string">&#x27;value&#x27;</span>) <span class="comment">// 添加新的 key-value</span></span><br><span class="line">map.has(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 判断是否存在 key，返回 true 或 false</span></span><br><span class="line">map.get(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 返回 key 对应的 value 值</span></span><br><span class="line">map.delete(<span class="string">&#x27;key&#x27;</span>) <span class="comment">// 删除 key</span></span><br><span class="line">map.clear() <span class="comment">// 移除 map 中所有的键值对</span></span><br><span class="line"><span class="comment">// 遍历方法</span></span><br><span class="line">set.keys() <span class="comment">// 返回一个包含集合中所有键的迭代器</span></span><br><span class="line">set.values() <span class="comment">// 返回一个包含集合中所有值的迭代器</span></span><br><span class="line">set.entries() <span class="comment">// 返回一个包含集合中所有键值对的迭代器</span></span><br><span class="line">set.forEach() <span class="comment">// 对映射中每个元素进行操作，无返回值</span></span><br><span class="line">set.valueOf() <span class="comment">// 返回指定对象的原始值</span></span><br><span class="line">set.toString() <span class="comment">// &#x27;[object Map]&#x27;</span></span><br></pre></td></tr></table></figure><p>一个 key 只能对应一个 value，多次对一个 key 放入 value，后面的将会覆盖前面的值。</p><p><strong>Object 和 Map 的区别</strong>：</p><p>相同点：都是以 key-value 的形式对数据进行存储</p><p>不同点：</p><table><thead><tr><th>不同点</th><th>Object</th><th>Map</th></tr></thead><tbody><tr><td>key 的数据类型范围</td><td>number、string、symbol</td><td>所有已有的数据类型均可以</td></tr><tr><td>key 的顺序</td><td>Object.keys() 获取到的顺序是：数字(升序)-&gt;string(symbol)(创建的顺序)</td><td>声明的顺序</td></tr><tr><td>创建方式</td><td><code>new Object()</code>、<code>&#123;&#125;</code>、<code>Object.create(&#123;&#125;)</code></td><td><code>new Map()</code></td></tr><tr><td>取值</td><td>通过 <code>.</code> 或 <code>[]</code></td><td><code>map.get()</code></td></tr><tr><td>判断是否存在属性</td><td><code>&#39;key&#39; in obj</code></td><td><code>map.has(key)</code></td></tr><tr><td>设置属性的方式</td><td><code>obj[&#39;key&#39;] = value</code>、<code>obj.key = value</code></td><td><code>map.set(&#39;key&#39;, value)</code></td></tr><tr><td>删除 key 的方式</td><td><code>delete obj.key</code></td><td><code>map.delete(&#39;key&#39;)</code><br><code>map.clear()</code></td></tr><tr><td>获取长度</td><td>通过 <code>Object.keys(obj)</code> 返回一个数组，通过获取数组的长度来获取 size</td><td><code>map.size</code></td></tr><tr><td>JSON 操作</td><td>支持 JSON.stringify 和 JSON.parse 的操作</td><td>不支持</td></tr><tr><td>this 指向不同</td><td>指向访问的 obj</td><td>取决于操作函数的调用者</td></tr><tr><td>Iterating(迭代)</td><td>不可以</td><td>可以</td></tr></tbody></table><blockquote><p>判断是否可以迭代的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [][<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Set</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="keyword">new</span> <span class="built_in">Map</span>()[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;function&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>[<span class="built_in">Symbol</span>.iterator] <span class="comment">// &#x27;undefined&#x27;</span></span><br></pre></td></tr></table></figure></blockquote><p><strong>性能对比</strong>：</p><p>插入性能：</p><p>向 Object 和 Map 中插入新键值对的消耗大致相当，<strong>涉及到大量的插入操作时，Map 的性能更佳</strong>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initObj</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    obj[<span class="string">&#x27;name&#x27;</span> + i] = i</span><br><span class="line">    <span class="comment">// obj[i] = i</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMap</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">let</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">1000000</span>; i++) &#123;</span><br><span class="line">    map.set(<span class="string">&#x27;name&#x27;</span> + i, i)</span><br><span class="line">    <span class="comment">// map.set(i, i)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> end = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="keyword">return</span> end - start</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`object set spend <span class="subst">$&#123;initObj()&#125;</span>,map set spend <span class="subst">$&#123;initMap()&#125;</span>`</span>)</span><br></pre></td></tr></table></figure><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151220692.png" class title="map&amp;obj插入大量字符串键"><blockquote><p>但当设置的键为整数值时，object 的性能要比 map 好一些。</p><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/image-20220425151330371.png" class title="map&amp;obj插入大量整数键"></blockquote><p>查找性能：</p><p>从大型 Object 和 Map 中查找键值对的性能差异很小；若<strong>只有少量键值对，则 Object 有时速度更快</strong>；在把 Object 当数组使用时，浏览器引擎进行了优化，在内存中使用了更高效的布局。</p><p>当<strong>键不为整数时，Map 的性能要略优于 Object</strong>.</p><p>删除性能：</p><p>对于大多数浏览器引擎来说，Map 的 delete 操作都比插入和查找更快，<strong>代码中涉及大量删除操作时，应选择 Map 使用</strong>；同样，若键为整数则 Object 略优。</p><p>内存占用：</p><p>存储单个键值对所占用的内存数量都会随着键的数量线性增加，给定固定大小的内存，<strong>Map 大约可以比 Object 多存储 50% 的键值对</strong>。</p><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>为了便于操作基本类型的值，JavaScript 引入了三个特殊的引用类型 boolean、number、string 的包装类。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(a.name) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">234</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> +b) <span class="comment">// number</span></span><br></pre></td></tr></table></figure><p>基本类型可以添加属性，访问不报错但返回 undefined：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">123</span></span><br><span class="line">a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="comment">// 这一步，系统知道 a 是个常量，所以包装类创建了一个 Number 类型的实例，同时为此实例添加了 name 属性</span></span><br><span class="line"><span class="comment">// 之后又迅速销毁了这个实例</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>)</span><br><span class="line">  a.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line">  <span class="keyword">delete</span> a</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a.name)</span><br><span class="line"><span class="comment">// 系统看到又错了，包装类自动又创建了一个 Number 类型的实例</span></span><br><span class="line"><span class="comment">// 但此实例并没有 name 属性，所以返回 undefined</span></span><br></pre></td></tr></table></figure><h3 id="数据类型检测方案"><a href="#数据类型检测方案" class="headerlink" title="数据类型检测方案"></a>数据类型检测方案</h3><h4 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span>              <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span>           <span class="comment">// boolean</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">&#x27;mc&#x27;</span>           <span class="comment">// string</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>         <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">console</span>.log()  <span class="comment">// function</span></span><br><span class="line"><span class="keyword">typeof</span> []             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125;             <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span>           <span class="comment">// object</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span>      <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>优点：可以快速区分基本数据类型</p><p>缺点：无法区分 Object、Array 和 null，均返回 object</p><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="keyword">instanceof</span> <span class="built_in">Number</span>                <span class="comment">// false</span></span><br><span class="line"><span class="literal">true</span> <span class="keyword">instanceof</span> <span class="built_in">Boolean</span>            <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;str&#x27;</span> <span class="keyword">instanceof</span> <span class="built_in">String</span>            <span class="comment">// false</span></span><br><span class="line">[] <span class="keyword">instanceof</span> <span class="built_in">Array</span>                <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">&#123;&#125; <span class="keyword">instanceof</span> <span class="built_in">Object</span>               <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>优点：能够区分 Array、Object 和 Function，适用于判断自定义的类实例对象</p><p>缺点：不能判断 NUmber、Boolean、String 基本数据类型</p><h4 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> toString = <span class="built_in">Object</span>.prototype.toString;</span><br><span class="line">toString.call(<span class="number">1</span>)              <span class="comment">// [object Number]</span></span><br><span class="line">toString.call(<span class="literal">true</span>)           <span class="comment">// [object Boolean]</span></span><br><span class="line">toString.call(<span class="string">&quot;mc&quot;</span>)           <span class="comment">// [object String]</span></span><br><span class="line">toString.call([])             <span class="comment">// [object Array]</span></span><br><span class="line">toString.call(&#123;&#125;)             <span class="comment">// [object Object]</span></span><br><span class="line">toString.call(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;) <span class="comment">// [object Function]</span></span><br><span class="line">toString.call(<span class="literal">undefined</span>)      <span class="comment">// [object Undefined]</span></span><br><span class="line">toString.call(<span class="literal">null</span>)           <span class="comment">// [object Null]</span></span><br></pre></td></tr></table></figure><p>优点：精准判断数据类型</p><p>缺点：较前两种方法写法较为繁琐不易于记忆，可以进行封装后使用</p><h4 id="var-let-const"><a href="#var-let-const" class="headerlink" title="var let const"></a>var let const</h4><p>ES6 之前创建变量使用 var，之后创建变量用的是 let/const</p><p>区别：</p><ol><li><p>var 定义的变量，没有块的概念，可以跨块访问，不能跨函数访问；<br>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问；<br>const 用来定义常量，使用时必须初始化（即创建时必须赋值），只能在块作用域里访问，且不能修改；</p></li><li><p>var 可以先使用，后声明，因为存在变量提升，let/const 必须先声明后使用；</p></li><li><p>var 允许在相同作用域内重复声明同一个变量，但 let/const 不允许；</p></li><li><p>在全局上下文中，基于 let 声明的全局变量与全局对象（window）没有任何关系，var 声明的会有映射关系；</p></li><li><p>会产生暂时性死区：</p><p>暂时性死区是浏览器的 bug：检测一个未被声明的变量类型时，不会报错，而会返回 undefined</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="comment">// ---------------</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b) <span class="comment">// Uncaught SyntaxError: Identifier &#x27;b&#x27; has already been declared</span></span><br><span class="line"><span class="keyword">let</span> b</span><br></pre></td></tr></table></figure></li><li><p>let/const/function 会把当前所在的大括号（除函数之外）作为一个全新的块级上下文。</p></li></ol><h3 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h3><ul><li><p>join()：以指定的字符串连接起来，变成字符串，通常和 String 中的 split 连用；</p><ul><li>参数为指定的字符串，默认为 <code>,</code>；</li></ul></li><li><p>slice()：按传入的下标截取数组；</p><ul><li>参数1：开始截取的位置即下标；</li><li>参数2：可选，若不传则默认截取到末尾，若传入则截取到该下标的前一位；</li><li>传入负数则从数组的末尾往前数；</li><li>返回值：返回按指定下标截取后的数组，不会影响前数组；</li></ul></li><li><p>splice()：删除或添加数组元素；</p><ul><li>参数1：开始删除的位置即下标；</li><li>参数2：可选，删除元素个数，不传则默认删到最后；</li><li>参数3,4,5…：添加的元素；</li><li>返回值：返回删除后的数据，<strong>会改变原数组</strong>；</li></ul></li><li><p>pop()：移除数组的最后一项，返回删除的项，<strong>会改变原数组</strong>；</p></li><li><p>push()：在数组末尾添加项数，返回添加后的数组长度，<strong>会改变原数组</strong>；</p></li><li><p>shift()：删除数组中的第一项，返回删除的项，<strong>会改变原数组</strong>；</p></li><li><p>unshift()：像数组的最前面添加项，返回新的数组长度，<strong>会改变原数组</strong>；</p></li><li><p>sort()：按一定规则排序，返回新数组，<strong>会改变原数组</strong>；</p><ul><li>参数接受一个函数；</li></ul></li><li><p>reverse()：数组反转，返回新数组，<strong>会改变原数组</strong>；</p></li><li><p>concat()：将两个数组连接，返回新数组，不会改变原数组；</p></li><li><p>indexOf()：查找一个数组中是否存在某个值，存在返回下标，不存在返回 -1；</p><ul><li>默认从首位开始查询；</li><li>只能匹配第一次出现的位置；</li><li>参数1：要查找的值；</li><li>参数2：可选，传入指定的下标，指定从哪个位置开始查询；</li></ul></li><li><p>lastIndexOf()：从末尾开始倒着查询；</p></li><li><p>every()：检测数组的每一项是否都符合条件，符合返回 true，若有一项不符合则停止检测返回 false；</p><ul><li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li><li>不会改变原数组；</li></ul></li><li><p>some()：检测数组中是否存在符合指定条件的项，若有则停止检测返回 true，否则返回 false；</p><ul><li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li><li>不会改变原数组；</li></ul></li><li><p>filter()：过滤，检测数组，返回符合条件的内容，没有则返回空数组；</p><ul><li>参数传入一个函数，该函数有三个参数分别为 当前项、当前项的下标、检测的数组；</li><li>不会改变原数组；</li></ul></li><li><p>map()：映射，返回一个新的数组，新数组中的元素是原数组调用函数后处理过的值；</p></li><li><p>reduce()：对数组的每一个元素指定一个函数（正序执行），将其结果汇总为单个返回值；</p><ul><li><p>接收一个函数参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">prev, curr, index, arr</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;, init)</span><br></pre></td></tr></table></figure><ul><li>prev：必需，累计器累计回调的返回值；表示上一次调用回调时的返回值，或者是初始值；</li><li>curr：必需，表示当前正在处理的数组元素；</li><li>index：可选，表示当前正在处理的元素的索引，提供 init 初始值则起始索引为 0，否则起始索引为 1；</li><li>arr：可选，表示原数组；</li><li>init：可选，表示初始值。</li></ul></li></ul></li></ul><p>以下为 ES6 新增：</p><ul><li>includes()：检测数组是否存在某个值，存在为 true，否则为 false；<ul><li>参数1：传入的指定值；</li><li>参数2：可选，表示搜索的起始位置，默认为 0，若为负数则倒着数；</li><li>若传入的值为整数，且大于数组的长度则返回 false；</li><li>若闯入的值为负数，且超过数组长度则从 0 开始查询；</li></ul></li><li>Array.of()：将一组值转为数组；<ul><li>如果没有传入参数则返回一个空数组 <code>[]</code>；</li><li>可以代替 Array() 和 new Array() 去创建和声明一个新数组；</li></ul></li><li>fill()：使用定值去填充一个数组，数组中的元素会被全部抹除；<ul><li>参数1：要替换为的值；</li><li>还可以接收参数2 和参数3，指定填充的起始位置和结束位置（前包后不包）；</li></ul></li><li>copyWithin()：将数组中指定的成员项，复制到其他位置（会覆盖原来的成员），返回新数组，<strong>会改变原数组</strong>；<ul><li>参数1：指定从哪个位置开始替换数据；</li><li>参数2：可选，默认从 0 开始复制，传入则从指定位置开始复制，为负则从尾部数；</li><li>参数3：可选，默认复制到最后，若传入则为复制的结束位置，为负则从尾部数；</li></ul></li><li>find()：用来找出第一个符合条件的成员；<ul><li>参数是一个回调函数，依次查询每一项，直到查询到第一个符合条件的成员，并返回该项的值，若不存在则返回 undefined；</li></ul></li><li>findIndex()：类似于 find()，但返回的是符合条件的项的位置即下标，均不满足则返回 -1；</li><li>entries()：键值对的遍历；</li><li>keys()：键名遍历；</li><li>values()：键值遍历。</li></ul><h3 id="JS-垃圾回收机制"><a href="#JS-垃圾回收机制" class="headerlink" title="JS 垃圾回收机制"></a>JS 垃圾回收机制</h3><p>如果存在大量不被释放的内存（堆/栈/上下文），页面性能会变得很慢；当某些代码操作不能被合理释放，就会造成内存泄漏。</p><p>浏览器垃圾回收机制/内存回收机制：</p><ol><li>标记清除</li><li>谷歌浏览器：查找引用</li><li>IE 浏览器：引用计数法</li></ol><p>优化手段：</p><ol><li>堆内存：fn = null【null：空指针对象】</li><li>栈内存：将上下文中被外部占用的堆取消掉即可</li></ol><p>内存泄漏：</p><ul><li>全局变量</li><li>闭包</li><li>DOM 元素的引用</li><li>定时器</li></ul><h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="headerlink" title="作用域和作用域链"></a>作用域和作用域链</h3><p>创建函数的时候，已经声明了当前函数的作用域 -&gt; 当前创建函数所处的上下文。如果是在全局下创建的函数就是 <code>[[scope]]:EC(G)</code>，函数执行的时候，形成一个全新的私有上下文 <code>EC(FN)</code>，供字符串代码执行（进栈执行）。</p><p>定义：作用域就是变量与函数的可访问范围，由当前环境与上层环境的一系列变量对象组成</p><ol><li>全局作用域：代码在程序的任何地方都能被访问，window 对象的内置属性都拥有全局作用域；</li><li>函数作用域：在固定的代码片段才能被访问</li></ol><p>作用：作用域的最大用处就是 <strong>隔离变量</strong>，不同作用域下同名变量不会有冲突。</p><p>一般情况下，变量到创建该变量的函数的作用域中取值。但如果没有查询到，就会向上级作用域去查，直到查到全局作用域，这一个查找过程所构成的链条就叫做作用域链。</p><h3 id="闭包：保存-保护"><a href="#闭包：保存-保护" class="headerlink" title="闭包：保存/保护"></a>闭包：保存/保护</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>函数执行时形成的私有上下文 <code>EC(FN)</code>，正常情况下，代码执行完会出栈然后释放；但是特殊情况下，如果当前私有上下文中的数据被上下文以外的事物占用了，则上下文不会出栈释放，从而形成不会被销毁的上下文。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>保护：划分一个独立的代码执行区域，在这个区域中有自己私有变量存储的空间，保护自己的私有变量不受外界干扰；</li><li>保存：如果当前上下文不被释放，则存储的私有变量也不会被释放，可以供其下级上下文中调取使用，相当于把一些值保存起来了；</li></ol><p>把函数执行形成私有上下文，来保护和保存私有变量机制称为闭包。</p><blockquote><p>闭包是指有权访问另一个函数作用域中的变量的函数。</p></blockquote><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>内部函数可以访问定义它们外部函数的参数和变量，设计私有的方法和变量，避免全局变量的污染；</li><li>函数嵌套函数；</li><li>本质是将函数内部和外部连接起来，优点是可以读取函数内部的变量，让这些变量的值始终保存在内存中，不会在函数被调用之后自动清除。</li></ol><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><ol><li>模仿块级作用域</li><li>保护外部函数的变量，能够访问函数定义时所在的词法作用域（阻止其被回收）</li><li>封装私有化变量</li><li>创建模块</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>会导致函数的变量一致保存在内存中，过多的闭包会导致内存泄漏。</p><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><ol><li>作为普通函数执行时，<code>this</code> 指向 <code>window</code>；</li><li>当函数作为对象的方法被调用时，<code>this</code> 就会指向该对象；</li><li>构造器调用，this 指向返回的这个对象；</li><li>箭头函数的 this 绑定看的是 this 所在函数定义在哪个对象下，就绑定哪个对象，如果有嵌套的情况，则 this 绑定到最近的一层对象上；</li><li>基于 Function.prototype 上的 apply、call 和 bind 调用模式，可以显示指定调用函数的 this 指向。</li></ol><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数的特点：</p><ol><li>箭头函数均为匿名函数；</li><li>箭头函数不能用于构造函数，不能使用 new；</li><li>箭头函数中的 this 指向不同：<ul><li>在普通函数中，this 总是指向调用它的对象，用作构造函数则指向创建的对象实例；</li><li>但箭头函数本身不会创建 this，但会<strong>在声明时捕获其所在上下文的 this 供自己使用，且一旦捕获无法改变</strong>。</li></ul></li><li>箭头函数不能 generator 函数，不能使用 yeild 关键字；</li><li>箭头函数不具有 prototype 原型对象；</li><li>不具有 new.target 和 super。</li></ol><h3 id="原型-原型链"><a href="#原型-原型链" class="headerlink" title="原型 原型链"></a>原型 原型链</h3><p>原型关系：</p><ul><li>每个 class 都有显示原型 prototype</li><li>每个实例都有隐式原型 __proto__</li><li>实例的 __proto__ 指向对应 class 的 prototype</li></ul><p>原型：在 JS 中，每当定义一个对象（函数也是对象）时，对象中都会包含一些预定义的属性。其中每个函数对象都有一个<code>prototype</code> 属性，这个属性指向函数的原型对象。</p><p>原型链：函数的原型链对象 constructor 默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针 __proto**，该指针是指向上一层的原型对象，而上一层的原型对象的结构以此类推。因此可以利用 <code>__proto__</code>一直指向 Object 的原型对象上，而 Object 的原型对象用<code>Object.prototype.__proto__ = null</code> 表示原型链顶端，如此形成了 js 的原型链继承；</p><p>特点：JavaScript 对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><ol><li>创建一个空的新对象；</li><li>设置原型，将对象的原型 <code>__proto__</code> 设置为函数的 <code>prototype</code> 对象；</li><li>让函数的 this 指向这个对象，执行构造函数的代码（添加属性）；</li><li>判断函数的返回类型，若是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象；</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo =  <span class="keyword">new</span> Foo(<span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> fn () &#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  obj.__proto__ = Foo.prototype</span><br><span class="line">  Foo.call(obj, <span class="string">&#x27;Agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>JS 是单线程的，为了防止一个函数执行时间过长而阻塞后面的代码，所以会先将同步代码压入执行栈中，一次执行，将异步代码突入异步队列，异步队列又分为宏任务队列和微任务队列，微任务队列优先于宏任务队列。</p><p>JS 运行的环境一般为浏览器或者 Node，在浏览器环境中，有 JS 引擎线程和渲染线程，且两个线程互斥。 Node 环境中，只有 JS 线程。 不同环境执行机制有差异，不同任务进入不同 Event Queue 队列。 当主程结束，先执行准备好微任务，然后再执行准备好的宏任务，一个轮询结束。</p><h4 id="浏览器中的事件循环"><a href="#浏览器中的事件循环" class="headerlink" title="浏览器中的事件循环"></a>浏览器中的事件循环</h4><p>先执行栈中的内容，栈中的内容执行后执行微任务，微任务清空后再执行宏任务，先取出一个宏任务，再去执行微任务，然后取宏任务清微任务不停循环。</p><p>EventLoop 是由 JS 的宿主环境（浏览器）来实现的；</p><ol><li>函数入栈，当 Stack 中执行到异步任务时，就将它丢给 WebAPIs，接着执行同步任务，直到 Stack 为空；</li><li>此期间 WebAPIs 完成这个事件，把回调函数放入队列中等待执行；</li><li>执行栈为空时，Event Loop 把微任务队列执行清空；</li><li>微任务队列清空后，进入宏任务队列，取对列的第一项任务放入 Stack（栈）中执行，执行完成后，查看微任务队列是否有任务，有则执行清空，然后重复此步骤，直至清空所有的任务。</li></ol><p>浏览器中的任务源（task）：</p><h5 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h5><p>页面中大部分任务都是在主线程上执行的，包括：</p><ul><li>渲染事件（DOM、计算布局、绘制）</li><li>用户交互事件（鼠标点击、滚动页面、放大缩小等）</li><li>JavaScript 脚本执行事件</li><li>网络请求完成、文件读写完成事件</li></ul><p>ajax、setTimeout、setInterval、setTmmediate(只兼容 IE)、script、requestAnimationFrame、messageChannel、UI渲染、一些浏览器 API</p><h5 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h5><p>微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后、当前宏任务结束之前。</p><ul><li>微任务和宏任务是绑定的，每个宏任务在执行时，会创建自己的微任务队列；</li><li>微任务的执行时长会影响到当前宏任务的时长；</li><li>在一个宏任务中分别创建一个用于回调的宏任务和微任务，无论如何微任务都早于宏任务执行。</li></ul><p>then、queueMicrotask(基于 then)、mutationObserver(浏览器提供)、messageChannel 、mutationObserve</p><h4 id="Node-中的事件循环"><a href="#Node-中的事件循环" class="headerlink" title="Node 中的事件循环"></a>Node 中的事件循环</h4><p>Node 是基于 V8 引擎的运行在服务端的 <code>JavaScript</code> 运行环境，在处理高并发、I/O 密集（文件操作、网络操作、数据库操作等）场景有明显的优势。</p><p>由于服务目的和环境不同，其事件循环还要处理一些 I/O，所以 Node 的 Event Loop 与浏览器的是不太一样：</p><ol><li>timers：计时器，执行 setTimeout 和 setInterval 的回调；</li><li>pending callbacks：执行延迟到下一个循环迭代的 I/O 回调；</li><li>idle，prepare：队列的移动，仅系统内部使用；</li><li>poll 轮询：检索新的 I/O 事件，执行与 I/O 相关的回调；</li><li>check：执行 Immediate 的回调；</li><li>close callbacks：执行 close 事件的 callback ，一些关闭的回调函数，如：<code>socket.on(&#39;close&#39;, ...)</code> </li></ol><h3 id="setTimeout-Promise-Async-Await"><a href="#setTimeout-Promise-Async-Await" class="headerlink" title="setTimeout Promise Async/Await"></a>setTimeout Promise Async/Await</h3><p>setTimeout：</p><p>setTimeout 的回调函数放入宏任务队列中，等到执行栈清空后执行；</p><p>Promise：</p><p>Promise 本身是同步的立即执行函数，当在 executor 中执行 resolve 或者 reject 是，此时是异步操作，会先执行 then/catch 等，当主栈完成后，才会去调用 resolve/reject 的 中存放的方法执行。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> promise1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1&#x27;</span>)</span><br><span class="line">  resolve()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;promise1 end&#x27;</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;promise2&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;settimeout&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出顺序：</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">promise1</span></span><br><span class="line"><span class="comment">promise1 end</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">promise2</span></span><br><span class="line"><span class="comment">settimeout</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>async/awiat：</p><p>async 函数返回一个 Promise 对象，当函数执行时，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 start&#x27;</span>)</span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;async1 end&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>(<span class="string">&#x27;async2&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script start&#x27;</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;script end&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出顺序：</span></span><br><span class="line"><span class="comment">script start</span></span><br><span class="line"><span class="comment">async1 start</span></span><br><span class="line"><span class="comment">async2</span></span><br><span class="line"><span class="comment">script end</span></span><br><span class="line"><span class="comment">async1 end</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>async/await 通过同步的方式实现异步的原理：</p><p>async/awiat 就是一个自执行的 generate 函数，利用 generate 函数的特性把异步的代码写成同步的形式，第一个请求的返回值作为后一个请求的参数，其中每一个参数都是一个 promise 对象。</p><h3 id="节流-防抖"><a href="#节流-防抖" class="headerlink" title="节流/防抖"></a>节流/防抖</h3><p>节流：<strong>事件触发后，规定时间内，事件处理函数不能再次被调用</strong>；也就是在规定的时间内，函数只能被调用一次，且是最先被触发调用的那次；</p><p>防抖：<strong>多次触发事件，事件触发函数只能执行一次，并且是在触发结束时执行</strong>；即当一个事件被触发准备执行事件函数前，会等待一定的时间，如果没有再次被触发，那么就执行，如果被触发，则本次作废，重新从新触发的时间开始计算，并再次等待，直到能最终执行。</p><p>使用场景：</p><ol><li>节流：滚动加载更多、搜索框的搜索联想功能、高频点击、表单重复提交…</li><li>搜索框搜索输入，并在输入完成后自动搜索、手机号，邮箱验证输入检测、窗口大小 resize 变化后再重新渲染。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 节流函数 一个函数执行一次之后，只有大于设定的执行周期才会执行第二次.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被节流的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次函数触发的时间</span></span><br><span class="line">  <span class="keyword">var</span> lastTime = <span class="number">0</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 记录当前函数触发的时间</span></span><br><span class="line">    <span class="keyword">var</span> nowTime = <span class="built_in">Date</span>.now()</span><br><span class="line">    <span class="keyword">if</span> (nowTime - lastTime &gt; delay) &#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.call(<span class="built_in">this</span>, ...args)</span><br><span class="line">      <span class="comment">// 同步执行结束时间</span></span><br><span class="line">      lastTime = nowTime</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.onscroll = throttle(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;scroll 事件被触发了&#x27;</span>, <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 防抖函数 一个需要频繁触发的函数，再规定时间内，只让最后一次生效</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>fn 要被防抖的函数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param </span>delay 规定的时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">debounce</span> (<span class="params">fn, delay</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 记录上一次的延时器</span></span><br><span class="line">  <span class="keyword">var</span> timer = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 清除上一次的延时器</span></span><br><span class="line">    <span class="built_in">clearTimeout</span>(timer)</span><br><span class="line">    <span class="comment">// 重新设置新的延时器</span></span><br><span class="line">    timer = <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// 修正 this 指向问题</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    &#125;, delay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用：</span></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).onclick = debounce(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;按钮被点击了&#x27;</span> + <span class="built_in">Date</span>.now())</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure><h3 id="和"><a href="#和" class="headerlink" title="== 和 ==="></a>== 和 ===</h3><p>对于基本数据类型而言，== 和 === 是有区别的：</p><ul><li>不同类型间比较，== 只比较转化成同一类型后的值是否相等；</li><li>=== 如果类型和数值有一项不同，就是不等</li></ul><p>对于引用数据类型来说，== 和 === 是没有区别的；</p><p>对于引用类型和基本数据类型比较：</p><ul><li>== 会将引用数据类型转化为基本数据类型，进行值比较；</li><li>=== 结果为 false</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="number">0</span> === -<span class="number">0</span>    <span class="comment">// true</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="number">42</span>  <span class="comment">// true -- 字符串转数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="number">42</span> <span class="comment">// false</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> == <span class="literal">true</span> <span class="comment">// false -- 字符串与布尔值分别转化成数字进行比较</span></span><br><span class="line"><span class="string">&#x27;42&#x27;</span> === <span class="literal">true</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">undefined</span>  <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span>       <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">false</span>      <span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == [<span class="number">42</span>]<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === [<span class="number">42</span>]<span class="comment">// false</span></span><br><span class="line"><span class="number">42</span> == <span class="built_in">Object</span>(a)<span class="comment">// true</span></span><br><span class="line"><span class="number">42</span> === <span class="built_in">Object</span>(a)<span class="comment">// false</span></span><br></pre></td></tr></table></figure><h3 id="事件冒泡捕获"><a href="#事件冒泡捕获" class="headerlink" title="事件冒泡捕获"></a>事件冒泡捕获</h3><p>不支持冒泡的事件：</p><ul><li>UI 事件：load、unload、resize、abort、error</li><li>焦点事件：blur、focus</li><li>鼠标事件：mouseleave、mouseenter</li></ul><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h3><p>概念：视图模型双向绑定，是 <code>Model-View-ViewModel</code> 的缩写，也就是将 MVC 中的 Controller 演变成 ViewModel。</p><ul><li>Model 层代表数据模型</li><li>View 代表 UI 组件</li><li>ViewModel 是 View 和 Model 层的桥梁，数据会绑定到 ViewModel 层并自动将数据渲染到页面中，视图变化时会通知 ViewModel 层更新数据；</li></ul><p>以前是操作 DOM 结构更新视图，现在是<strong>数据驱动视图</strong>。</p><p>优点：</p><ol><li><strong>低耦合</strong>：View 可以独立于 Model 变化和修改，一个 Model 可以绑定到不同的 View 上，当 View 变化时 Model 可以不变化，反之也一样；</li><li><strong>可重用性</strong>：可以把一些视图逻辑放在一个 Model 里，让很多的 View 重用这段视图逻辑；</li><li><strong>独立开发</strong>：开发人员可以专注于业务逻辑和数据的开发（ViewModel），设计人员可以专注于页面设计。</li><li><strong>可测试</strong>。</li></ol><h3 id="Vue-底层原理"><a href="#Vue-底层原理" class="headerlink" title="Vue 底层原理"></a>Vue 底层原理</h3><p>vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过 Object.definedProperty() 来劫持各个属性的 setter 和 getter，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 是一个典型的 MVVM 框架，Model 只是普通的 JavaScript 对象，修改它则 View 会自动更新，这种设计让状态管理变得非常简单而直观。</p><p><code>Observer</code>（数据监听器）：Observer 的核心时通过 Object.defineProperty() 来监听数据的变动，这个函数内部可以定义 setter 和 getter，每当数据发生变化，就会触发 setter，此时 Observer 通知订阅者，也就是 Watcher；</p><p><code>Watcher</code>（订阅者）：Watcher 订阅者作为 Observer 和 Complie 之间通信的桥梁：</p><ol><li>在自身实例化时往属性订阅器（dep）中添加自己</li><li>自身必须有一个 update 方法</li><li>待属性变动 dep.notice() 通知时，能调用自身的 update() 方法，并触发 Compile 中绑定的回调</li></ol><p><code>Compile</code>（指令解析器）：Compile 主要做的事情是解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听函数的订阅者，一旦数据有变动，收到通知就更新视图。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>每个 Vue 实例在创建时都会经过一系列的初始化过程，vue 的生命周期钩子，就是说达到某一阶段或条件时去触发的函数，目的就是为了完成一些动作或者事件：</p><ul><li>create 阶段：vue 实例被创建<ul><li><code>beforeCreate</code>：创建前，此时 data 和 methods 中的数据还没有初始化；</li><li><code>created</code>：创建完毕，data 中有值，但还未挂载；</li></ul></li><li>mount 阶段：vue 实例被挂载到真实 DOM 节点<ul><li><code>beforeMount</code>：可以发起服务器请求去请求数据；</li><li><code>mounted</code>：此时可以操作 DOM；</li></ul></li><li>update 阶段：当 vue 实例里面的 data 数据变化时，触发组件的重新渲染<ul><li><code>beforeUpdate</code>：更新前；</li><li><code>updated</code>：更新后；</li></ul></li><li>destroy 阶段：vue 实例被销毁<ul><li><code>beforeDestroy</code>：实例被销毁前，此时可以手动销毁一些方法；</li><li><code>destroyed</code>：销毁后。</li></ul></li></ul><p>组件生命周期：</p><p>父组件 beforeCreate -&gt; 父组件 created -&gt; 父组件 beforeMount -&gt; 子组件 beforeCreate -&gt; 子组件 created -&gt; 子组件 beforeMount -&gt; 子组件 mounted -&gt; 父组件 mounted -&gt; 父组件 beforeDestroy -&gt; 子组件 beforeDestroy -&gt; 子组件 detroyed -&gt;  父组件 detroyed</p><p>父组件更新：父组件 beforeUpdate -&gt; 父组件 updated</p><p>子组件更新：父组件 beforeUpdate -&gt; 子组件 beforeUpdate -&gt; 子组件 updated -&gt; 父组件 updated</p><h3 id="computed-watch"><a href="#computed-watch" class="headerlink" title="computed watch"></a>computed watch</h3><p>既能用 computed 实现又可以用 watch 监听来实现的功能，推荐使用 computed：</p><ul><li>computed 计算属性是用来声明式的描述一个值依赖了其他的值，当所依赖的值或者变量改变时，计算属性就会跟着改变；</li><li>watch 监听的是已经在 data 中定义的变量，当该变量变化时，会触发 watch 中的方法。</li></ul><p>watch 监听属性：是一个对象，键是需要观察的属性，值是对应回调函数，主要用来监听某些特定数据的变化，从而进行某些具体的业务逻辑操作，监听属性的变化，需要在数据变化时执行异步或开销较大的操作时使用；</p><p>computed 计算属性：属性的结果会被缓存，当 computed 中的函数所以来的属性没有发生变化时，调用当前函数时就会从缓存中读取结果，只有当依赖的响应式属性变化时才会重新计算，主要当做属性来使用；computed 中的函数必须用 return 返回最后的结果，computed 更高效，优先使用；</p><p>使用场景：</p><ul><li>computed：当一个属性受多个属性影响的时候使用；</li><li>watch：当一条数据影响多条数据的时候使用。</li></ul><h3 id="data-为何是函数"><a href="#data-为何是函数" class="headerlink" title="data 为何是函数"></a>data 为何是函数</h3><ol><li>一个组件被复用多次的的话，也就会创建多个实例。本质上这些实例都是用的同一个构造函数。</li><li>如果 data 是对象的话，对象是引用类型，会影响到所有的实例。</li></ol><p>所以为了<strong>保证组件不同的实例之间 data 不冲突</strong>，data 必须是一个函数。</p><h3 id="v-for-和-v-if"><a href="#v-for-和-v-if" class="headerlink" title="v-for 和 v-if"></a>v-for 和 v-if</h3><ol><li>当 v-for 和 v-if 处于一个节点时，v-for 的优先级比 v-if 更高，这意味着 v-if 将分别重复运行于每个 v-for 循环中；如果要遍历的数组很大，而真正展示的数据又很少时，这将造成很大的性能浪费；</li><li>这种场景建议使用 computed，先对数据进行过滤；或者将 v-if 提至外层使用 template。</li></ol><blockquote><p>3.x 版本中 v-if 总是优先于 v-for 生效。</p></blockquote><p>由于语法上存在歧义，建议避免在同一元素上同时使用两者。</p><p>比起在模板层面管理相关逻辑，更好的办法是通过创建计算属性筛选出列表，并以此创建可见元素。</p><h3 id="React-Vue-中的-key"><a href="#React-Vue-中的-key" class="headerlink" title="React/Vue 中的 key"></a>React/Vue 中的 key</h3><ul><li><p>key 的作用是是为了在 diff 算法执行时更快的找到对应的节点，提高 diff 速度，更高效的更新虚拟 DOM；</p><p>vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中，会根据节点的 key 去对比就跌点数组中的 key，从而找到相应旧节点，若没有找到则认为是一个新增节点。如果没有 key，就需要采用遍历查找的方式去找到对应的节点。一种是 map 映射，另一种是遍历查找，相比而言，map 映射的速度更快；</p></li><li><p>为了在数据变化时强制更新组件，以避免就地复用带来的副作用；</p><p>当 vue 用 v-for 更新已渲染的元素列表时，默认使用就地复用策略，如果数据项的顺序被改变，vue 将不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素，重复的 key 将会造成渲染错误。</p></li></ul><h3 id="vue-组件的通信方式"><a href="#vue-组件的通信方式" class="headerlink" title="vue 组件的通信方式"></a>vue 组件的通信方式</h3><ul><li><code>props</code>/<code>$emit</code> 父子组件通信：<ul><li>父 -&gt; 子 <code>props</code>，子 -&gt; 父 <code>$on、$emit</code> 获取父子组件实例</li><li><code>parent、children</code> 获取实例的方式调用组件的属性或者方法</li><li>父 -&gt; 子孙 <code>Provide、inject</code> 官方不推荐使用，但写组件库时较为常用</li></ul></li><li><code>$emit</code>/<code>$on</code> 自定义事件 兄弟组件通信：<ul><li><code>Event Bus</code> 实现跨组件通信 <code>Vue.prototype.$bus = new Vue()</code> 自定义事件</li></ul></li><li>vuex 跨级组件通信<ul><li>Vuex、<code>$attrs、$listeners</code>、<code>Provide、reject</code> </li></ul></li></ul><h3 id="nextTick-的实现"><a href="#nextTick-的实现" class="headerlink" title="nextTick 的实现"></a>nextTick 的实现</h3><ol><li>nextTick 是 Vue 提供的一个全局 API，是在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后使用 <code>$nextTick</code>，则可以在回调中获取更新后的 DOM；</li><li>Vue 在更新 DOM 时时异步执行的，只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 <code>watcher</code> 被多次触发，只会被推入到队列中一次。这种在缓存时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。nextTick 方法会在队列中加入一个回调函数，确保该函数在前面的 DOM 操作完成后才调用；</li><li>会在 callbacks 中加入传入的函数，然后用 <code>timerFunc</code> 异步方式调用，首选的异步方式会是 Promise。</li></ol><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>在下次 DOM 更新循环之后执行延迟回调，在修改数据之后使用 nextTick 来获取更新后的 DOM。</p><p>nextTick 主要使用的宏任务和微任务，根据执行环境分别尝试采用 Promise、MutationObserver、setImmediate，若均不行则采用 setTimeout 定义一个异步方法，多次调用 nextTick 会将此方法存入队列中，通过这个异步方法清空当前队列。</p><h3 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h3><p>分为默认插槽、具名插槽和作用域插槽</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><p>作用：实现组件缓存，保持这些组件的状态，以避免反复渲染导致的性能问题。</p><p>场景：tabs 标签页、后台导航、vue 性能优化</p><p>原理：vue 内部将 DOM 节点抽象成了一个个的 VNode 节点，keep-alive 组件的缓存也是基于 VNode 节点而不是直接存储 DOM 结构。将满足条件（pruneCache）的组件在 cache 对象中缓存起来，在需要重新渲染时再将 VNode 节点从 cache 对象中取出并渲染。</p><h3 id="mixin"><a href="#mixin" class="headerlink" title="mixin"></a>mixin</h3><p>多个组件间有重复的逻辑就会用到 mixin，但 mixin 并不是完美的解决方案，会有一些问题（Vue3 提出的 Composition API 旨在解决这些问题）。</p><p>场景：PC 端新闻列表和详情页一样的右侧栏目，可以使用 mixin 进行混合</p><p>劣势：</p><ol><li>变量来源不明确，不利于阅读；</li><li>多 mixin 可能导致命名冲突；</li><li>mixin 和组件可能出现多对多的关系，使得项目复杂度变高。</li></ol><h3 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h3><p>Vuex 是一个专为 Vue 应用程序开发的状态管理模式。每一个 Vuex 的核心就是 store（仓库）。</p><ol><li>Vuex 的状态存储是响应式的；当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，则相应的组件也会得到高效更新；</li><li>改变 store 中的状态的唯一途径就是显式地提交（commit）mutation，这使得可以方便地跟踪每一个状态的变化。</li></ol><p>Vuex 包括以下核心模块：</p><ul><li><strong>State</strong>：定义了应用的状态数据；</li><li><strong>Getter</strong>：再 store 中定义 getter（相当于计算属性）；</li><li><strong>Mutation</strong>：是唯一更改 store 中状态的方法，且必须是同步函数；</li><li><strong>Action</strong>：用于提交 Mutation，而不是直接变更状态，可以包含任意异步操作；</li><li><strong>Module</strong>：允许将单一的 Store 拆分成多个 store 且同时保存在单一的状态树中。</li></ul><img src="/2022/04/11/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1/vuex.png" class title="vuex"><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>当一次操作中有多次更新 DOM 的动作，虚拟 DOM 不会立即操作 DOM，而是将这些更新内容保存在本地一个 JS 对象中，最终将这个 JS 对象一次性更新到 DOM 树上，避免无谓的计算量；操作内存中的 JS 对象的速度显然要更快。</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>以下一个真实的 DOM 节点：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;real-container&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>Real DOM<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>before update<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;item&quot;</span>&gt;</span>Item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用 JS 来模拟 DOM 节点实现虚拟 DOM：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;p&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Real DOM&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;before update&#x27;</span>]),</span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123;&#125;, [</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>]),</span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 3&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br><span class="line"><span class="keyword">const</span> root = tree.render()</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;virtualDom&#x27;</span>).appendChild(root)</span><br></pre></td></tr></table></figure><p><code>Element</code> 方法实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Element</span> (<span class="params">tagName, props, children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!(<span class="built_in">this</span> <span class="keyword">instanceof</span> Element)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Element(tagName, props, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.tagName = tagName</span><br><span class="line">  <span class="built_in">this</span>.props = props || &#123;&#125;</span><br><span class="line">  <span class="built_in">this</span>.children = children || []</span><br><span class="line">  <span class="built_in">this</span>.key = props ? props.key : <span class="literal">undefined</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> count = <span class="number">0</span></span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (child <span class="keyword">instanceof</span> Element) &#123;</span><br><span class="line">      count += child.count</span><br><span class="line">    &#125;</span><br><span class="line">    count++</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">this</span>.count = count</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Element.prototype.render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = <span class="built_in">document</span>.createElement(<span class="built_in">this</span>.tagName)</span><br><span class="line">  <span class="keyword">const</span> props = <span class="built_in">this</span>.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> propName <span class="keyword">in</span> props) &#123;</span><br><span class="line">    el.setAttributte(propName, props[propName])</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> childEl = (child <span class="keyword">instanceof</span> Element) ? child.render() : <span class="built_in">document</span>.createTextNode(child)</span><br><span class="line">    el.appendChild(childEl)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> el</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Diff 实现 O(n) 复杂度：</p><p>新的 DOM 树：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> tree = Element(<span class="string">&#x27;div&#x27;</span>, &#123; <span class="attr">id</span>: <span class="string">&#x27;real-container&#x27;</span> &#125;, [</span><br><span class="line">  Element(<span class="string">&#x27;h3&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;Virtual DOM&#x27;</span>]),<span class="comment">// REPLACE</span></span><br><span class="line">  Element(<span class="string">&#x27;div&#x27;</span>, &#123;&#125;, [<span class="string">&#x27;after update&#x27;</span>]), <span class="comment">// TEXT</span></span><br><span class="line">  Element(<span class="string">&#x27;ul&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;marginLeft10&#x27;</span> &#125;, [   <span class="comment">// PROPS</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 1&#x27;</span>]),</span><br><span class="line">    <span class="comment">// Element(&#x27;li&#x27;, &#123; class: &#x27;item&#x27; &#125;, [&#x27;Item 3&#x27;]), // REORDER remove</span></span><br><span class="line">    Element(<span class="string">&#x27;li&#x27;</span>, &#123; <span class="attr">class</span>: <span class="string">&#x27;item&#x27;</span> &#125;, [<span class="string">&#x27;Item 2&#x27;</span>])</span><br><span class="line">  ])</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p>diff 算法会从根节点开始，逐层向下比较旧虚拟 DOM 和新虚拟 DOM，如果在某一层的耨个节点发现不同，则判断变化类型，做出相应的处理，只有以下四种情况：</p><ol><li><p>节点类型变了，<code>p -&gt; h3</code>，此过程称为 <code>REPLACE</code>，<strong>直接将旧节点卸载并装载新节点</strong>，包括旧节点下的全部子节点也全部卸载；</p><p>当旧节点和新节点仅仅是类型变化，但下面的所有子节点都一样时，这种做法效率不高，但为了避免较高的时间复杂度，此做法值得；</p><p>所以开发时应避免无谓的节点类型的变化；</p></li><li><p>节点类型一样，仅仅属性或属性值变了，此过程称为 <code>PROPS</code>，此时不会触发节点卸载和装载，而是进行节点更新，查找不同属性的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">diffProps</span> (<span class="params">oldNode, newNode</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldProps = oldNode</span><br><span class="line">  <span class="keyword">const</span> newProps = newNode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">const</span> propsPatches = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> isSame = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> oldProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newProps[key] !== oldProps[key]) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> newProps) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(oldProps.hasOwnProperty(key))) &#123;</span><br><span class="line">      isSame = <span class="literal">false</span></span><br><span class="line">      propsPatches[key] = newProps[key]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isSame ? <span class="literal">null</span> : propsPatches</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>仅文本发生，直接修改文字内容即可，称为 <code>TEXT</code>；</p></li><li><p>移动/增加/删除 子节点，此过程称为 <code>REORDER</code>：</p><ul><li>若元素没有指定 key，或者在 for 循环中使用 index 作为 key，则会依次遍历，从改变项逐个向后做修改；</li><li>若有指定唯一不变的 key，则会直接找到改变项进行修改，极大提升了 diff 算法的效率。</li></ul></li></ol><h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>查看分支：<code>git branch</code> </li><li>创建分支：<code>git branch xxx</code> </li><li>切换分支：<code>git checkout xxx</code> </li><li>创建 + 切换分支：<code>git checkout -b xxx</code> </li><li>合并某分支到当前分支：<code>git merge xxx</code> </li><li>删除分支：<code>git branch -d xxx</code> </li></ul><h3 id="管理项目"><a href="#管理项目" class="headerlink" title="管理项目"></a>管理项目</h3><p>实际开发中，一个仓库主要存放两条主分支：master 与 develop 分支，生命周期为整个项目周期。</p><ul><li>master：这个分支最为稳定，这个分支表明项目处于可发布的状态；</li><li>develop：作为开发的分支，平行于 master 分支；</li><li>feature branches：功能分支，必须从 develop 分支建立，完成后合并回 develop 分支；</li><li>release branches：这个分支用来发布新版本。从 develop 分支建立，完成后合并回 develop 与 master 分支；</li><li>hotfix branches：这个分支主要为修复线上特别紧急的 bug 准备，必须从 master 分支建立，完成后合并回 develop 与 master 分支，主要是解决线上版本的紧急 bug 修复</li></ul><h3 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h3><ol><li>移除生产环境的控制台打印；<ul><li>eslint + pre-commit；</li><li>使用插件自动去除：如 <code>terser-webpack-plugin</code>，无需安装额外的插件，仅需在 configureWebpack 中设置 terser 插件的 drop_console 为 true 即可；</li><li>vscode 中的 turbo console；</li></ul></li><li>第三方库的按需加载；<ul><li>echarts：使用配置文件指定使用的模块；或使用 <code>babel-piugin-equire</code> 实现按需加载；</li><li>element-ui：使用 <code>babel-plugin-component</code> 实现按需引入；</li></ul></li><li>避免 CSS 表达式、滤镜，减少 DOM 操作，优化图片、精灵图，避免图片空链接等；</li></ol><p>优化技术方案：</p><ul><li>降低请求成本</li><li>减少请求数：<ul><li>JS、CSS打包到HTML；</li><li>JS 控制图片异步加载、懒加载；</li><li>小型图片使用 data-uri；</li></ul></li><li>减少传输体积：<ul><li>尽量使用 SVG/gradient 代替图片；</li><li>根据机型和网络状况控制图片清晰度；</li><li>对低清晰度图片使用锐化来提升体验；</li><li>设计上避免大型背景图；</li></ul></li><li>使用 CDN 加速</li></ul><h2 id="安全"><a href="#安全" class="headerlink" title="安全"></a>安全</h2><h3 id="XSS"><a href="#XSS" class="headerlink" title="XSS"></a>XSS</h3><p>XSS 是跨站脚本攻击（Cross Site Scripting），俗称脚本注入；典型的例子是在留言板的输入框中输入带有 html 标签的关键字进行恶意的修改页面以及盗取 Cookie。</p><p>解决方法：</p><ol><li>对诸如 <code>script</code>、<code>img</code>、<code>a</code> 等标签进行过滤；</li><li>像一些常见的符号，如 <code>&lt;&gt;</code> 在输入时要对其进行转码；</li><li>通过限制输入长度强制截断来进行防御。</li></ol><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="代码报错位置"><a href="#代码报错位置" class="headerlink" title="代码报错位置"></a>代码报错位置</h3><p>使用 <code>source-map</code> 库进行错误定位。</p><p><code>Source Map</code> 是一个 JSON 文件，包含了代码转换前后的位置信息。也就是说，给定一个转换之后的压缩代码的位置，就可以通过 <code>Source Map</code> 获取转换之前的代码位置，有以下属性：</p><ul><li>version：Source Map 的版本号；</li><li>sources：转换前的文件列表；</li><li>names：转换前的所有变量名和属性名；</li><li><strong>mappings</strong>：记录位置信息的字符串，经过编码；</li><li>file：转换前后的文件名；</li><li>sourceRoot：转换前的文件所在的目录，若在同一目录，则为空；</li><li>sourceContent：转换前的文件内容列表，与 sources 列表依次对应；</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sass</title>
      <link href="/2022/01/10/Sass/"/>
      <url>/2022/01/10/Sass/</url>
      
        <content type="html"><![CDATA[<h1 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h1><h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>sass 一个较大的好处就是为 css 引入了变量，可以把反复使用的 css 属性值定义成变量，然后通过变量名来引用。</p><p>sass 使用 <code>$</code> 符号来标识变量。</p><blockquote><p>老版本的 sass 使用 <code>!</code> 来标识变量。</p></blockquote><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight-color</span>: <span class="number">#f90</span>;</span><br></pre></td></tr></table></figure><p>这意味着变量 <code>$highlight-color</code> 现在的值是 <code>#F90</code>。</p><p>任何可以用作 css 属性值的赋值都可以用作 sass 的变量值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$basic-border</span>: <span class="number">1px</span> solid black;</span><br><span class="line"><span class="variable">$plain-font</span>: <span class="string">&quot;Myriad Pro&quot;</span>, Myriad, <span class="string">&quot;Helvetica Neue&quot;</span>, Helvetica,</span><br><span class="line">  <span class="string">&quot;Liberation Sans&quot;</span>, Arial, sans-serif;</span><br></pre></td></tr></table></figure><p>在声明变量时，变量值也可以引用其他变量：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight-color</span>: <span class="number">#f90</span>;</span><br><span class="line"><span class="variable">$highlight-border</span>: <span class="number">1px</span> solid <span class="variable">$highlight-color</span>;</span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="variable">$highlight-border</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>凡是 css 的标准值可存在的地方，变量就可以使用，css 生成时，变量会被它们的值所替代。</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$highlight-color</span>: <span class="number">#f90</span>;</span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="variable">$highlight-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.selected</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#f90</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sass 的变量名可以与 css 中的属性名和选择器名相同，包括中划线和下划线，使用中划线的更为普遍，但两种互相兼容，中划线和下划线的可以相互引用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link-color</span>: blue;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$link_color</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="嵌套-css-规则"><a href="#嵌套-css-规则" class="headerlink" title="嵌套 css 规则"></a>嵌套 css 规则</h2><p>在 css 中重复写选择器是非常恼人的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">article</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 sass 中，可以只写一遍，使样式可读性更高：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> &#123;</span><br><span class="line">  <span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="selector-tag">h1</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">p</span> &#123;</span><br><span class="line">      <span class="attribute">margin-bottom</span>: <span class="number">1.4em</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#eee</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="父选择器的标识符-amp"><a href="#父选择器的标识符-amp" class="headerlink" title="父选择器的标识符 &amp;"></a>父选择器的标识符 &amp;</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: red;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在为父级选择器添加 <code>:hover</code> 等伪类、伪元素时，这种方式非常有用。</p><p>同时还有另外一种用法，可以在父选择器之前添加选择器：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.ie</span> &amp; &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.ie</span> <span class="selector-id">#content</span> <span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="群组选择器的嵌套"><a href="#群组选择器的嵌套" class="headerlink" title="群组选择器的嵌套"></a>群组选择器的嵌套</h3><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="selector-tag">h1</span>,</span><br><span class="line">  <span class="selector-tag">h2</span>,</span><br><span class="line">  <span class="selector-tag">h3</span> &#123;</span><br><span class="line">    <span class="attribute">margin-bottom</span>: <span class="number">0.8em</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span>,</span><br><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="selector-tag">a</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="子组合选择器和同层组合选择器"><a href="#子组合选择器和同层组合选择器" class="headerlink" title="子组合选择器和同层组合选择器"></a>子组合选择器和同层组合选择器</h3><p>用同层相邻组合选择器 <code>+</code> 选择 <code>header</code> 元素后紧跟的 <code>p</code> 元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">header</span> + <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">1.1em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用同层全体组合选择器 <code>~</code> 选择所有在 <code>article</code> 后的同层 <code>article</code> 元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些组合选择器可以毫不费力地应用到 <code>sass</code> 的规则嵌套中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span> &#123;</span><br><span class="line">  ~ <span class="selector-tag">article</span> &#123;</span><br><span class="line">    <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &gt; <span class="selector-tag">section</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">dl</span> &gt; &#123;</span><br><span class="line">    <span class="selector-tag">dt</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="selector-tag">dd</span> &#123;</span><br><span class="line">      <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-tag">nav</span> + &amp; &#123;</span><br><span class="line">    <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">article</span> ~ <span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">1px</span> dashed <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> &gt; <span class="selector-tag">footer</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#eee</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">dl</span> &gt; <span class="selector-tag">dt</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">article</span> <span class="selector-tag">dl</span> &gt; <span class="selector-tag">dd</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#555</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">nav</span> + <span class="selector-tag">article</span> &#123;</span><br><span class="line">  <span class="attribute">margin-top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套属性"><a href="#嵌套属性" class="headerlink" title="嵌套属性"></a>嵌套属性</h3><p>除了 css 选择器，属性也可以进行嵌套，把属性名从中划线的地方断开，在根属性后边添加一个 <code>:</code> 紧跟一个 <code>&#123; &#125;</code> 块，把子属性写在这个 <code>&#123; &#125;</code> 中：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: &#123;</span><br><span class="line">    style: solid;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">1px</span>;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#ccc</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border-style</span>: solid;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#ccc</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以这样来嵌套：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span> &#123;</span><br><span class="line">    left: <span class="number">0px</span>;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">nav</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="导入-SASS-文件"><a href="#导入-SASS-文件" class="headerlink" title="导入 SASS 文件"></a>导入 SASS 文件</h2><p>css 有一个不常用的特性，即 <code>@import</code> 规则，它允许在一个 css 文件中导入其他 css 文件，但只有执行到 <code>@import</code> 时，浏览器才会去下载其他 css 文件，这会导致页面加载起来特别慢。</p><p>sass 也有一个 <code>@import</code> 规则，不同之处在于：sass 的 <code>@import</code> 规则在生成 css 文件时就把相关文件导入进来，无需发起额外的下载请求。</p><p>使用 sass 的 <code>@import</code> 规则并不需要指明被导入文件的全名，可以省略 <code>.sass</code> 或 <code>.scss</code> 文件后缀：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;colors&quot;</span>;</span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;mixins&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="使用-SASS-部分文件"><a href="#使用-SASS-部分文件" class="headerlink" title="使用 SASS 部分文件"></a>使用 SASS 部分文件</h3><p>sass 局部文件的文件名以下划线开头，这样，sass 在编译时就不会单独编译这个文件输出 css，只把该文件用作导入；在 <code>@import</code> 一个局部文件时，开头的下划线可以省略：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 themes/_night-sky.scss 这个局部文件</span></span><br><span class="line"><span class="keyword">@import</span> <span class="string">&quot;themes/night-sky&quot;</span>;</span><br></pre></td></tr></table></figure><h3 id="默认变量值"><a href="#默认变量值" class="headerlink" title="默认变量值"></a>默认变量值</h3><p>当反复声明一个变量，只有最后一处声明有效且会覆盖前面的值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$link-color</span>: blue;</span><br><span class="line"><span class="variable">$link-color</span>: red;</span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$link-color</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若可以定制修改 sass 库文件中的某些值，使用 sass 的 <code>!default</code> 标签可以实现这个目的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$fancybox-width</span>: <span class="number">400px</span> !default;</span><br><span class="line"><span class="selector-class">.fancybox</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$fancybox-width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.fancybox</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户在导入 sass 局部文件之前声明了一个 <code>$fancybox-width</code> 的值，那么局部文件中的默认值 <code>400px</code> 就无效，如果用户没有做这样的声明，则 <code>$fancybox-width</code> 将默认为 <code>400px</code></p><h3 id="嵌套导入"><a href="#嵌套导入" class="headerlink" title="嵌套导入"></a>嵌套导入</h3><p>sass 允许 <code>@import</code> 命令写在 css 规则内，生成对应的 css 文件时，局部文件会被直接插入到 css 规则内导入它的地方，一个名为 <code>_blue-theme.scss</code> 的局部文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">aside</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: blue;</span><br><span class="line">  <span class="attribute">color</span>: white;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将它导入一个 css 规则内：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.blue-theme</span> &#123;</span><br><span class="line">  <span class="keyword">@import</span> <span class="string">&quot;blue-theme&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.blue-theme</span> &#123;</span><br><span class="line">  <span class="selector-tag">aside</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: blue;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原生的-CSS-导入"><a href="#原生的-CSS-导入" class="headerlink" title="原生的 CSS 导入"></a>原生的 CSS 导入</h3><p>sass 兼容原生的 css，所以也支持原生的 <code>CSS@import</code>，在以下三种情况下会生成原生的 <code>CSS@import</code>：</p><ul><li>被导入文件的名字以 <code>.css</code> 结尾；</li><li>被导入文件的名字是一个 URL 地址；</li><li>被导入文件的名字是 CSS 的 url() 值。</li></ul><blockquote><p>也就是说，不能使用 sass 的 <code>@import</code> 直接导入一个原始的 css 文件，sass 会认为你想用 css 原生的 <code>@import</code>。</p><p>但是，因为 sass 的语法完全兼容 css，所以可以把原始的 css 文件改名为 <code>.scss</code> 后缀，就可以直接导入了。</p></blockquote><h2 id="静默注释"><a href="#静默注释" class="headerlink" title="静默注释"></a>静默注释</h2><p>提供了一种不同于 css 标准注释格式 <code>/* ... */</code> 的注释语法，即 <code>// ...</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#333</span>; <span class="comment">// 这种注释内容 不会 出现在生成的 css 文件中</span></span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>; <span class="comment">/* 这种注释内容 会 出现在生成的 css 文件中 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合器"><a href="#混合器" class="headerlink" title="混合器"></a>混合器</h2><p>可以通过 sass 的混合器实现大段样式的重用，混合器使用 <code>@mixin</code> 标识符定义，这个标识符给一大段样式赋予一个名字：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> rounded-corners &#123;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后通过 <code>@include</code> 来使用这个混合器：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#00aa00</span>;</span><br><span class="line">  <span class="keyword">@include</span> rounded-corners;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: green;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#00aa00</span>;</span><br><span class="line">  -moz-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  -webkit-<span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS-规则"><a href="#CSS-规则" class="headerlink" title="CSS 规则"></a>CSS 规则</h3><p>混合器中不仅仅可以包含属性，也可以包含选择器和选择器中的属性：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> no-bullets &#123;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">  <span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style-image</span>: none;</span><br><span class="line">    <span class="attribute">list-style-type</span>: none;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当一个混合器通过 <code>@include</code> 包含在一个父规则中，在混合器中最终会生成父规则中的嵌套规则：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  <span class="keyword">@include</span> no-bullets;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 解析后</span></span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#444</span>;</span><br><span class="line">  <span class="attribute">list-style</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">ul</span><span class="selector-class">.plain</span> <span class="selector-tag">li</span> &#123;</span><br><span class="line">  <span class="attribute">list-style-image</span>: none;</span><br><span class="line">  <span class="attribute">list-style-type</span>: none;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>混合器中也可以使用 sass 的父选择器标识符 <code>&amp;</code>。</p><h3 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h3><p>可以通过在 <code>@include</code> 混合器时给混合器传参，来定制混合器生成的精确样式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(<span class="variable">$normal</span>, <span class="variable">$hover</span>, <span class="variable">$visited</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$hover</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$visited</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> link-colors(blue, red, green);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@include</code> 时对每个参数做区分：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> link-colors(<span class="variable">$normal</span>: blue, <span class="variable">$visited</span>: green, <span class="variable">$hover</span>: red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以这种形式传参，参数顺序就可以打乱，但要保证不漏掉参数。</p><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>参数默认值使用 <code>$name: default-value</code> 的形式声明，默认值可以是任何有效的 css 属性值或者是其他参数的引用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> link-colors(<span class="variable">$normal</span>, <span class="variable">$hover</span>: <span class="variable">$normal</span>, <span class="variable">$visited</span>: <span class="variable">$normal</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$normal</span>;</span><br><span class="line">  &amp;<span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$hover</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  &amp;<span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="variable">$visited</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="comment">// 这样引用 $hover 和 $visited 也会被自动赋值为 red</span></span><br><span class="line">  <span class="keyword">@include</span> link-colors(red);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="选择器继承"><a href="#选择器继承" class="headerlink" title="选择器继承"></a>选择器继承</h2><p>选择器继承是说一个选择器可以继承为另一个选择器定义的所有样式，通过 <code>@extend</code> 语法实现：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .error;</span><br><span class="line">  <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>.seriousError</code> 将会继承样式表中任何位置处为 <code>.error</code> 定义的所有样式；</li><li>以 <code>class=&quot;seriousError&quot;</code> 修饰的 html 元素最终的展示效果就好像是 <code>class=&quot;seriousError error&quot;</code>；</li><li><code>.seriousError</code> 不仅会继承 <code>.error</code> 自身的所有样式，任何跟 <code>.error</code> 有关的组合选择器样式也会被 <code>.seriousError</code> 以组合选择器的形式继承。</li></ul><h3 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h3><p>任何 css 规则都可以继承其他规则，几乎任何 css 规则也都可以被继承。</p><p>定义一个名为 <code>.disabled</code> 的类，样式修饰使其像一个灰掉的超链接：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.disabled</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: grey;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一条样式规则继承了一个复杂的选择器，那么它只会继承这个复杂选择器命中的元素所应用的样式；</p><p>如果一个选择器序列 <code>@extend</code> 另一个选择器，那么只有完全匹配该选择器序列的元素才会继承该选择器样式。</p><h3 id="工作细节"><a href="#工作细节" class="headerlink" title="工作细节"></a>工作细节</h3><p>关于 <code>@extend</code> 的两个要点：</p><ol><li>跟混合器相比，继承生成的 css 代码更少；</li><li>继承遵从 css 层叠的规则：通常权重更高的选择器胜出，如果权重相同，则定义在后的规则胜出。</li></ol><h1 id="详细文档学习补充"><a href="#详细文档学习补充" class="headerlink" title="详细文档学习补充"></a>详细文档学习补充</h1><p>Sass 是一款强化 CSS 的辅助工具，使用 Sass 以及 Sass 的样式库（如 Compass）有助于更好地组织管理样式文件，以及更高效地开发项目。</p><h2 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h2><ul><li>完全兼容 CSS3</li><li>在 CSS 基础上增加 变量、嵌套（nesting）、混合（mixins）等功能</li><li>通过函数进行颜色值与属性值的运算</li><li>提供控制指令（control directives）等高级功能</li><li>自定义输出格式</li></ul><h2 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h2><p>Sass 有两种语法格式：</p><p>首先是 SCSS（Sassy CSS）—— 此格式仅在 CSS3 语法的基础上进行拓展，所有 CSS3 语法在 SCSS 中都是通用的，同时加入 Sass 的特色功能。这种格式以 <code>.scss</code> 作为拓展名。</p><p>另一种也是最早的 Sass 语法格式，被称为缩进格式（Indented Sass）通常简称 <code>Sass</code>，是一种简化格式。使用缩进代替花括号表示属性属于某个选择器，用换行代替分号分隔属性，也同样可以使用 Sass 的全部功能。这种格式以 <code>.sass</code> 作为拓展名。</p><blockquote><p>任何一种格式可以直接 <code>@import</code> 到另一种格式中使用，或者通过 <code>sass-convert</code> 命令行工具转换成另一种格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Convert Sass to SCSS</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sass-convert style.sass style.scss</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Convert SCSS to Sass</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sass-convert style.sass style.scss</span></span><br></pre></td></tr></table></figure></blockquote><h2 id="功能拓展"><a href="#功能拓展" class="headerlink" title="功能拓展"></a>功能拓展</h2><h3 id="父选择器-amp-补充"><a href="#父选择器-amp-补充" class="headerlink" title="父选择器 &amp; 补充"></a>父选择器 &amp; 补充</h3><p><code>&amp;</code> 必须作为选择器的第一个字符，其后可以跟随后缀生成新的选择器：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">  &amp;-sidebar &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: black;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main-sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符选择器"><a href="#占位符选择器" class="headerlink" title="占位符选择器 %"></a>占位符选择器 %</h3><p>Sass 提供了一种特殊类型的选择器：占位符选择器，与常用的 id 与 class 选择器写法类似，只是 <code>#</code> 或 <code>.</code> 换成了 <code>%</code>。必须通过 <code>@extend</code> 指令调用。</p><blockquote><p>当占位符选择器单独使用时（未通过 <code>@extend</code> 调用），不会编译到 CSS 文件中。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#content</span> <span class="selector-tag">a</span>%extreme &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> %extreme;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.notice</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: blue;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="SassScript"><a href="#SassScript" class="headerlink" title="SassScript"></a>SassScript</h2><p>Sass 在 CSS 属性的基础上提供类一些名为 SassScript 的新功能，可以作用于任何属性，允许属性使用变量、算数运算等额外功能。</p><p>全局安装 sass：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g sass</span><br></pre></td></tr></table></figure><p>启动 sass 命令行工具 Interactive Shell：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sass -i</span><br></pre></td></tr></table></figure><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>SassScript 支持 6 种主要的数据类型：</p><ul><li>数字</li><li>字符串：有引号字符串与无引号字符串</li><li>颜色</li><li>布尔值：<code>true</code>、<code>false</code></li><li>空值：<code>null</code></li><li>数组(list)，用空格或逗号作分隔符</li><li>maps：相当于 JavaScript 中的 Object</li></ul><h4 id="字符串（Strings）"><a href="#字符串（Strings）" class="headerlink" title="字符串（Strings）"></a>字符串（Strings）</h4><p>SassScript 支持两种字符串类型：</p><ul><li>有引号字符串：<code>&quot;Lucida Grande&quot;</code>、<code>&#39;http://agonilay.top&#39;</code></li><li>无引号字符串：<code>sans-serif</code>、<code>bold</code></li></ul><p>在编译 CSS 文件时不会改变其类型，除使用 <code>#&#123;&#125;</code>（interpolation）时之外，此时会将有引号字符串编译为无引号字符串，便于在 mixin 中引用选择器名：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> firefox-message(<span class="variable">$selector</span>) &#123;</span><br><span class="line">  <span class="selector-tag">body</span><span class="selector-class">.firefox</span> #&#123;<span class="variable">$selector</span>&#125;:before &#123;</span><br><span class="line">    content: <span class="string">&quot;Hi, Firefox users!&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> firefox-message(<span class="string">&quot;.header&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">body</span><span class="selector-class">.firefox</span> <span class="selector-class">.header</span>:before &#123;</span><br><span class="line">  content: <span class="string">&quot;Hi, Firefox users!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="数组（Lists）"><a href="#数组（Lists）" class="headerlink" title="数组（Lists）"></a>数组（Lists）</h4><p>数组指 Sass 如何处理 CSS 中 <code>margin: 10px 15px 0 0;</code> 或者 <code>font-face: Helvetica, Arial, sans-serif;</code> 这样通过空格或者逗号分隔的一系列的值。</p><ul><li><code>nth</code> 函数直接访问数组中的某一项</li><li><code>join</code> 函数可以将多个数组连接在一起</li><li><code>append</code> 函数可以在数组中添加新值</li><li><code>@each</code> 指令可以遍历数组中的每一项</li></ul><h4 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h4><p>Maps 可视为键值对的集合，和 list 不同，Maps 必须被 <code>()</code> 包围，键值对被 <code>,</code> 分隔：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">($key1: value1, $key2: value2)</span><br></pre></td></tr></table></figure><h3 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h3><h4 id="数字运算"><a href="#数字运算" class="headerlink" title="数字运算"></a>数字运算</h4><p>SassScript 支持数字的加减乘除取余等计算（<code>+ - * / %</code>），如果必要会自动在不同单位间转换：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1in</span> + <span class="number">8pt</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">1111111111in</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>关系运算 <code>&lt; &gt; &lt;= &gt;=</code> 也可用于数字运算，相等运算 <code>== !=</code> 可用于所有数据类型。</p></blockquote><h5 id="除法运算"><a href="#除法运算" class="headerlink" title="除法运算 /"></a>除法运算 /</h5><p><code>/</code> 在 CSS 中常起到分隔数字的用途，SassScript 也支持此功能，同时 <code>/</code> 也有除法运算的功能，以下三种情况 <code>/</code> 将被视为做除法运算：</p><ul><li>如果值或值的一部分是变量或者函数的返回值</li><li>如果值被 <code>()</code> 包围</li><li>如果值是算数表达式的一部分</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">10px</span>/<span class="number">8px</span>;</span><br><span class="line">  <span class="variable">$width</span>: <span class="number">1000px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="variable">$width</span>;</span><br><span class="line">  <span class="attribute">width</span>: round(<span class="number">1.5</span>) / <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">height</span>: (<span class="number">500px</span>/<span class="number">2</span>);</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">5px</span> + <span class="number">8px</span>/<span class="number">2px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">10px</span>/<span class="number">8px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">250px</span>;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">9px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果需要使用变量，又要确保 <code>/</code> 不做除法运算而是完整编译到 CSS 文件中，只需要使用 <code>#&#123;&#125;</code> 插值语句将变量包裹：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="variable">$font-size</span>: <span class="number">12px</span>;</span><br><span class="line">  <span class="variable">$line-height</span>: <span class="number">30px</span>;</span><br><span class="line">  <span class="attribute">font</span>: #&#123;<span class="variable">$font-size</span>&#125;/#&#123;<span class="variable">$line-height</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">12px</span>/<span class="number">30px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="颜色值运算"><a href="#颜色值运算" class="headerlink" title="颜色值运算"></a>颜色值运算</h4><p>颜色值的计算是分段式进行的，即分别计算红、绿、蓝的值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#010203</span> + <span class="number">#040506</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#010203</span> * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#050709</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#020406</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：若颜色值包含 alpha channel（rgba 或 hsla），必须拥有相同的 alpha 值才能进行运算，算术运算不会作用于 alpha 值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.75</span>) + rgba(<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.75</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>颜色值的 alpha 可以通过 opacify 或 transparentize 两个函数进行调整：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$translucent-red</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: opacity(<span class="variable">$translucent-red</span>, <span class="number">0.3</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: transparentize(<span class="variable">$translucent-red</span>, <span class="number">0.25</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.8</span>);</span><br><span class="line">  <span class="attribute">background-color</span>: rgba(<span class="number">255</span>, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0.25</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IE 滤镜要求所有的颜色值包含 alpha 层，并且格式必须固定 <code>#AABBCCDD</code>，使用 <code>ie_hex_str</code> 函数可以很容易地将颜色转化为 IE 滤镜要求的格式：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$translucent-red</span>: rgba(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.5</span>);</span><br><span class="line"><span class="variable">$green</span>: <span class="number">#00ff00</span>;</span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: progid:DXImageTransform.Microsoft.gradient(enabled=<span class="string">&#x27;false&#x27;</span>, startColorstr=<span class="string">&#x27;#&#123;ie-hex-str($green)&#125;&#x27;</span>, endColorstr=<span class="string">&#x27;#&#123;ie-hex-str($translucent-red)&#125;&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">filter</span>: progid:DXImageTransform.Microsoft.gradient(enabled=<span class="string">&#x27;false&#x27;</span>, startColorstr=<span class="number">#FF00FF</span>00, endColorstr=<span class="number">#80FF00</span>00);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串运算"><a href="#字符串运算" class="headerlink" title="字符串运算"></a>字符串运算</h4><p><code>+</code> 可用于连接字符串</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: e + -resize;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">cursor</span>: e-resize;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意，如果有引号字符串（位于 <code>+</code> 左侧）连接无引号字符串，运算结果是有引号的，相反，无引号字符串（位于 <code>+</code> 左侧）连接有引号字符串，运算结果则没有引号。</p></blockquote><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span>:before &#123;</span><br><span class="line">  content: <span class="string">&quot;Foo &quot;</span> + Bar;</span><br><span class="line">  <span class="attribute">font-family</span>: sans- + <span class="string">&quot;serif&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span>:before &#123;</span><br><span class="line">  content: <span class="string">&quot;Foo Bar&quot;</span>;</span><br><span class="line">  <span class="attribute">font-family</span>: sans-serif;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Rules-与指令"><a href="#Rules-与指令" class="headerlink" title="@-Rules 与指令"></a>@-Rules 与指令</h2><p>Sass 支持所有的 CSS3 @-Rules，以及 Sass 特有的指令。</p><h3 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h3><p>Sass 扩展了 <code>@import</code> 的功能，允许导入 sass 和 scss 文件。</p><p>Sass 允许同时导入多个文件：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@import</span> <span class="string">&quot;rounded-corners&quot;</span>, <span class="string">&quot;text-shadow&quot;</span>;</span><br></pre></td></tr></table></figure><p>导入文件也可以使用 <code>#&#123;&#125;</code> 插值语句，但只能作用于 CSS 的 <code>url()</code> 导入方式。</p><blockquote><p>不可以在混合指令或控制指令中使用嵌套 @import</p></blockquote><h3 id="media"><a href="#media" class="headerlink" title="@media"></a>@media</h3><p>Sass 中 <code>@media</code> 指令与 CSS 中的用法一样，只是使其允许在 CSS 中嵌套。</p><p>如果 <code>@media</code> 嵌套在 CSS 规则内，编译时，<code>@media</code> 将被编译到文件的最外层，包含嵌套的父选择器：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">orientation</span>: landscape) &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">500px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@media</code> 的 queries 允许互相嵌套使用，Sass 会在编译时自动添加 <code>and</code>；</p><p><code>@media</code> 也可以使用 SassScript 代替条件的名称或者值；</p><h3 id="extend"><a href="#extend" class="headerlink" title="@extend"></a>@extend</h3><p><code>@extend</code> 的作用是将重复使用的样式继承给需要包含这个样式的特殊样式，</p><p>在合并选择器时，<code>@extend</code> 会避免无谓的重复：</p><ul><li><code>.seriousError.seriousError</code> 将编译为 <code>.seriousError</code></li><li>不能匹配任何元素的选择器（如 <code>#main#footer</code>）也会删除</li></ul><p>Sass 允许继承任何定义给单个元素的选择器，如：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.hoverlink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> <span class="attribute">a</span>:<span class="attribute">hover</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">a</span>: hover, .hoverlink &#123;</span><br><span class="line">  text-decoration: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同一个选择器可以继承给多个选择器；</p><p>当一个选择器继承给第二个后，可以继续将第二个选择器继承给第三个；</p><p>暂时不可以将选择器列（如：<code>.foo .bar</code>、<code>.foo + .bar</code>）继承给其他元素，但可以将其他元素继承给选择器列；</p><p>当两个列合并时，如果没有包含相同的选择器，将生成两个新选择器：第一列出现在第二列之前，或者第二列出现在第一列之前：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.tabbar</span> <span class="selector-tag">a</span>,</span><br><span class="line"><span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-class">.fakelink</span>,</span><br><span class="line"><span class="selector-id">#demo</span> <span class="selector-class">.overview</span> <span class="selector-id">#admin</span> <span class="selector-class">.tabbar</span> <span class="selector-class">.fakelink</span> &#123;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果两个列包含了相同的选择器，相同部分合并，其他部分交替输出；</p><p>如果要求 <code>@extend</code> 不生成新的选择器，可以通过 <code>!optional</code> 声明达到这个目的：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-class">.important</span> &#123;</span><br><span class="line">  <span class="keyword">@extend</span> .notice !optional;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指令中使用 <code>@extend</code> 时有一些限制：</p><ul><li>Sass 不能将指令层外的 CSS 规则继承给指令层内的 CSS；</li><li>必须继承给相同指令层中的选择器</li></ul><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-class">.error</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    <span class="keyword">@extend</span> .error; <span class="comment">// 可行</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.error</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> <span class="number">#f00</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#fdd</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@media</span> print &#123;</span><br><span class="line">  <span class="selector-class">.seriousError</span> &#123;</span><br><span class="line">    <span class="comment">// INVALID EXTEND: .error is used outside of the &quot;@media print&quot; directive</span></span><br><span class="line">    <span class="keyword">@extend</span> .error; <span class="comment">// 不可行</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">3px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="控制指令"><a href="#控制指令" class="headerlink" title="控制指令"></a>控制指令</h2><h3 id="if"><a href="#if" class="headerlink" title="@if"></a>@if</h3><p>当 <code>@if</code> 的表达式返回值不是 <code>false</code> 或者 <code>null</code> 时，条件成立，输出 <code>&#123;&#125;</code> 内的代码：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">1</span> + <span class="number">1</span> == <span class="number">2</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@if</span> <span class="number">5</span> &lt; <span class="number">3</span> &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> dashed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">@if</span> null &#123;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">3px</span> double;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@if</code> 后面可以跟多个 <code>@else if</code> 声明，或者一个 <code>@else</code> 声明：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$type</span>: monster;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="keyword">@if</span> <span class="variable">$type</span> == ocean &#123;</span><br><span class="line">    <span class="attribute">color</span>: blue;</span><br><span class="line">  &#125; <span class="keyword">@else</span> if <span class="variable">$type</span> == monster &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">  &#125; <span class="keyword">@else</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: black;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="for"><a href="#for" class="headerlink" title="@for"></a>@for</h3><p><code>@for</code> 指令可以在限制的范围内重复输出格式，每次按照要求对输出结果做出变动，此指令包含两种格式：</p><ol><li><code>@for $var from &lt;start&gt; through &lt;end&gt;</code>：条件范围包含 <code>&lt;start&gt;</code> 和 <code>&lt;end&gt;</code> 的值；</li><li><code>@for $var from &lt;start&gt; to &lt;end&gt;</code> ：不包含。</li></ol><p><code>$var</code> 可以是任意变量（如：<code>$i</code>）；<code>&lt;start&gt;</code> 和 <code>&lt;end&gt;</code> 必须是整数值：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@for</span> <span class="variable">$i</span> from <span class="number">1</span> through <span class="number">3</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.item-1</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">2em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-3</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">6em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="each"><a href="#each" class="headerlink" title="@each"></a>@each</h3><p><code>@each</code> 指令格式是 <code>$var in &lt;list&gt;</code>，<code>$var</code> 可以是任意变量名；</p><p><code>@each</code> 将变量 <code>$var</code> 作用域值列表中的每一个项目，然后输出结果：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span> in puma, sea-slug, egret &#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&quot;./images/#&#123;$animal&#125;.png&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.puma-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;./images/puma.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.sea-slug-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;./images/sea-slug.png&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.egret-icon</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(<span class="string">&quot;./images/egret.png&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以对多维列表项遍历：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$animal</span>, <span class="variable">$color</span>, <span class="variable">$cursor</span> in (puma, black, default), (</span><br><span class="line">    sea-slug,</span><br><span class="line">    blue,</span><br><span class="line">    <span class="attribute">pointer</span></span><br><span class="line">  ), (egret, white, move)</span><br><span class="line">&#123;</span><br><span class="line">  .#&#123;<span class="variable">$animal</span>&#125;-<span class="attribute">icon</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(<span class="string">&quot;/images/#&#123;$animal&#125;.png&quot;</span>);</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">2px</span> solid <span class="variable">$color</span>;</span><br><span class="line">    <span class="attribute">cursor</span>: <span class="variable">$cursor</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@each</span> <span class="variable">$header</span>, <span class="variable">$size</span> in (h1: <span class="number">2em</span>, h2: <span class="number">1.5em</span>, h3: <span class="number">1.2em</span>) &#123;</span><br><span class="line">  #&#123;<span class="variable">$header</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="variable">$size</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="while"><a href="#while" class="headerlink" title="@while"></a>@while</h3><p><code>@while</code> 指令重复输出格式直到表达式返回结果为 <code>false</code>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$i</span>: <span class="number">6</span>;</span><br><span class="line"><span class="keyword">@while</span> <span class="variable">$i</span> &gt; <span class="number">0</span> &#123;</span><br><span class="line">  <span class="selector-class">.item-</span>#&#123;<span class="variable">$i</span>&#125; &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">2em</span> * <span class="variable">$i</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable">$i</span>: <span class="variable">$i</span> - <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.item-6</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">12em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-4</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">8em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.item-2</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">4em</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="混合指令"><a href="#混合指令" class="headerlink" title="混合指令"></a>混合指令</h2><p>使用 <code>@mixin</code> 定义，使用 <code>@include</code> 引用。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><h4 id="参数变量-…"><a href="#参数变量-…" class="headerlink" title="参数变量 …"></a>参数变量 …</h4><p>当无法确定混合指令需要使用多少个参数时，可以使用参数变量 <code>...</code> 声明（写在参数的最后），Sass 将这些参数视为值列表处理：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> box-shadow(<span class="variable">$shadows</span>...) &#123;</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="variable">$shadows</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.shadows</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> box-shadow(<span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.shadowed</span> &#123;</span><br><span class="line">  -moz-<span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">  -webkit-<span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">5px</span> <span class="number">#666</span>, <span class="number">2px</span> <span class="number">6px</span> <span class="number">10px</span> <span class="number">#999</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也可以在引用混合指令时（<code>@include</code>）使用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> colors(<span class="variable">$text</span>, <span class="variable">$background</span>, <span class="variable">$border</span>) &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="variable">$text</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="variable">$background</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="variable">$border</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$values</span>: <span class="number">#ff0000</span>, <span class="number">#00ff00</span>, <span class="number">#0000ff</span>;</span><br><span class="line"><span class="selector-class">.primary</span> &#123;</span><br><span class="line">  <span class="keyword">@include</span> colors(<span class="variable">$values</span>...);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line"><span class="selector-class">.primary</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#ff0000</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#00ff00</span>;</span><br><span class="line">  <span class="attribute">border-color</span>: <span class="number">#0000ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="混合样式内导入内容"><a href="#混合样式内导入内容" class="headerlink" title="混合样式内导入内容"></a>混合样式内导入内容</h4><p>在引用混合样式的时候，可以先将一段代码导入到混合指令中，然后再输出混合样式，导入部分将出现在 <code>@content</code> 标志的地方：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@mixin</span> apply-to-ie6-only &#123;</span><br><span class="line">  * <span class="selector-tag">html</span> &#123;</span><br><span class="line">    <span class="keyword">@content</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">@include</span> apply-to-ie6-only &#123;</span><br><span class="line">  <span class="selector-id">#logo</span> &#123;</span><br><span class="line">    <span class="attribute">background-image</span>: url(./logo.gif);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译后</span></span><br><span class="line">* <span class="selector-tag">html</span> <span class="selector-id">#logo</span> &#123;</span><br><span class="line">  <span class="attribute">background-image</span>: url(./logo.gif);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>为了便于书写，<code>@mixin</code> 可以用 <code>=</code> 表示，而 <code>@include</code> 可以用 <code>+</code> 表示。</p></blockquote><blockquote><p>当 <code>@content</code> 在指令中出现过多次或者出现在循环中时，额外的代码将被导入到每一个地方。</p></blockquote><h2 id="函数指令"><a href="#函数指令" class="headerlink" title="函数指令"></a>函数指令</h2><p>Sass 支持自定义函数，并能在任何属性值或 SassScript 中使用：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$grid-width</span>: <span class="number">40px</span>;</span><br><span class="line"><span class="variable">$gutter-width</span>: <span class="number">40px</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@function</span> grid-width(<span class="variable">$n</span>) &#123;</span><br><span class="line">  <span class="keyword">@return</span> <span class="variable">$n</span> * <span class="variable">$grid-width</span> + (<span class="variable">$n</span> - <span class="number">1</span>) * <span class="variable">$gutter-width</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: grid-width(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译为</span></span><br><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">240px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义函数同样可以使用关键词参数：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: grid-width(<span class="variable">$n</span>: <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h2><p>Sass 提供了四种输出格式，可以通过 <code>:style option</code> 选项设定，或者在命令行中使用 <code>--style</code> 选项。</p><h3 id="nested"><a href="#nested" class="headerlink" title=":nested"></a>:nested</h3><p>Nested（嵌套）样式是 Sass 的默认输出格式，可以清晰反映 CSS 与 HTML 的结构关系；</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.huge</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="expanded"><a href="#expanded" class="headerlink" title=":expanded"></a>:expanded</h3><p>Expanded 输出更像手写的形式，选择器、属性等各占用一行，属性根据选择器缩进，而选择器不做任何缩进：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.huge</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="compact"><a href="#compact" class="headerlink" title=":compact"></a>:compact</h3><p>Compact 输出比上面两种占用的空间更少，每条 CSS 规则只占一行，包含其下的所有属性：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.huge</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嵌套过的选择器在输出时没有空行，不嵌套的选择器会输出空白行作为分隔符。</p><h3 id="compressed"><a href="#compressed" class="headerlink" title=":compressed"></a>:compressed</h3><p>Compressed 输出方式删除所有无意义的空格、空白行、以及注释，同时也会做出其他调整，力求将文件体积压缩到最小（比如自动替换占用空间最小的颜色表达方式）：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#main</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-id">#main</span> <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">10em</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.huge</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">10em</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">text-decoration</span>: underline;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Sass </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 预编译器 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 相册实现</title>
      <link href="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="图片存储"><a href="#图片存储" class="headerlink" title="图片存储"></a>图片存储</h2><p>使用七牛：访问速度快，用户体验良好</p><h3 id="配置七牛"><a href="#配置七牛" class="headerlink" title="配置七牛"></a>配置七牛</h3><p>七牛云官网：<a href="https://portal.qiniu.com/">https://portal.qiniu.com/</a></p><p>右侧找到 对象存储 空间管理 新建存储空间</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201125934827.png" class title="image-20211201125934827"><p>按步骤往下即可创建完成。</p><h4 id="阿里云添加-CDN-加速域名"><a href="#阿里云添加-CDN-加速域名" class="headerlink" title="阿里云添加 CDN 加速域名"></a>阿里云添加 CDN 加速域名</h4><p>在域名管理中添加对应的加速域名（推荐为 <code>cdn.你的域名</code>），然后复制 CNAME 一栏上的值，去到阿里云域名管理界面点击进入对应的域名后的解析：</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201131027075.png" class title="阿里云域名解析"><p>点击添加记录：</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201133223423.png" class title="添加记录"><ul><li>记录类型选择 CNAME；</li><li>主机记录要与 CDN 中加速域名一致；</li><li>解析路线和 TTL 默认即可；</li><li>记录值写入 刚刚复制的 CNAME。</li></ul><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201131258915.png" class title="添加成功"><blockquote><p>当出现 CNAME 记录和 A 记录冲突时，则需要将 CDN 加速域名变为二级域名，也就是之前将加速域名设置为 <code>cdn.agonilay.top</code> 的好处。</p></blockquote><p>检查是否配置成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> windows</span></span><br><span class="line">nslookup cdn.agonilay.top</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> linus/mac</span></span><br><span class="line">dig cdn.agonilay.top</span><br></pre></td></tr></table></figure><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201132714959.png" class title="image-20211201132714959"><p>出现你配置的 加速域名 和 CNAME 则为配置成功。</p><h3 id="上传图片"><a href="#上传图片" class="headerlink" title="上传图片"></a>上传图片</h3><p>安装七牛依赖：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -S qiniu</span><br></pre></td></tr></table></figure><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201130549106.png" class title="image-20211201130549106"><blockquote><p>此处若无法成功安装，可以尝试加上 <code>-f</code> 参数。</p></blockquote><p>新建一个 <code>utils</code> 文件夹，新建 <code>index.js</code> 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取文件后缀名称，并转化成小写</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFilenameSuffix</span>(<span class="params">file_name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (file_name == <span class="string">&quot;.DS_Store&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;.DS_Store&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (file_name == <span class="literal">null</span> || file_name.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="regexp">/\.[^\.]+/</span>.exec(file_name);</span><br><span class="line">  <span class="keyword">return</span> result == <span class="literal">null</span> ? <span class="literal">null</span> : (result + <span class="string">&quot;&quot;</span>).toLowerCase();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类型匹配</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typeMatch</span>(<span class="params">type, filename</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ext = filename.extension();</span><br><span class="line">  <span class="keyword">if</span> (type.contain(ext)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取文件名后缀名</span></span><br><span class="line"><span class="built_in">String</span>.prototype.extension = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ext = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="built_in">this</span>.toLowerCase();</span><br><span class="line">  <span class="keyword">var</span> i = name.lastIndexOf(<span class="string">&quot;.&quot;</span>);</span><br><span class="line">  <span class="keyword">if</span> (i &gt; -<span class="number">1</span>) <span class="keyword">var</span> ext = name.substring(i);</span><br><span class="line">  <span class="keyword">return</span> ext;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断 Array 中是否包含某个值</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.contain = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>[i] === obj) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getFilenameSuffix,</span><br><span class="line">  typeMatch,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在博客根目录下新建一个 <code>photo.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> image = <span class="built_in">require</span>(<span class="string">&quot;imageinfo&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> qiniu = <span class="built_in">require</span>(<span class="string">&quot;qiniu&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> &#123; getFilenameSuffix, typeMatch &#125; = <span class="built_in">require</span>(<span class="string">&quot;./utils/&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相册相对路径</span></span><br><span class="line"><span class="keyword">const</span> path = <span class="string">&quot;./source/photos/images/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要填写你的 Access Key 和 Secret Key</span></span><br><span class="line"><span class="keyword">const</span> ACCESS_KEY = <span class="string">&quot;rBY-lqM9t0k8eX4tyEti1p8xugln-KrRQHpwPv6h&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> SECRET_KEY = <span class="string">&quot;n9TysfSKw9xZEONVoXVOCUv-DhTDrRHrN2Ff-7ka&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 要上传的空间 你自己的</span></span><br><span class="line"><span class="keyword">const</span> bucket = <span class="string">&quot;agonilay-blog&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建上传策略函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uptoken</span>(<span class="params">bucket, key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> putPolicy = <span class="keyword">new</span> qiniu.rs.PutPolicy(&#123; <span class="attr">scope</span>: bucket &#125;);</span><br><span class="line">  <span class="keyword">var</span> mac = <span class="keyword">new</span> qiniu.auth.digest.Mac(ACCESS_KEY, SECRET_KEY);</span><br><span class="line">  mac.key = key;</span><br><span class="line">  <span class="keyword">return</span> putPolicy.uploadToken(mac);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造上传函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">uploadFile</span>(<span class="params">uptoken, key, localFile</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">new</span> qiniu.conf.Config();</span><br><span class="line">  config.zone = qiniu.zone.Zone_z1;</span><br><span class="line">  <span class="keyword">var</span> formUploader = <span class="keyword">new</span> qiniu.form_up.FormUploader(config);</span><br><span class="line">  <span class="keyword">var</span> putExtra = <span class="keyword">new</span> qiniu.form_up.PutExtra();</span><br><span class="line">  formUploader.putFile(uptoken, key, localFile, putExtra, <span class="function"><span class="keyword">function</span> (<span class="params">err, res</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!err) &#123;</span><br><span class="line">      <span class="comment">// 上传成功，处理返回值</span></span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;upload success : &quot;</span>, res.hash, res.key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// console.log(err)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取文件封装</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFileList</span>(<span class="params">path, fileList, type</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> files = fs.readdirSync(path);</span><br><span class="line">  files.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> stat = fs.statSync(path + item);</span><br><span class="line">    <span class="keyword">if</span> (stat.isDirectory()) &#123;</span><br><span class="line">      readFileList(path + item + <span class="string">&quot;/&quot;</span>, fileList, item);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (stat.isFile()) &#123;</span><br><span class="line">      <span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">      obj.path = path;</span><br><span class="line">      obj.filename = item;</span><br><span class="line">      obj.type = type || <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="keyword">var</span> imgExt = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">&quot;.png&quot;</span>, <span class="string">&quot;.jpg&quot;</span>, <span class="string">&quot;.jpeg&quot;</span>, <span class="string">&quot;.bmp&quot;</span>, <span class="string">&quot;.gif&quot;</span>); <span class="comment">// 图片文件的后缀名</span></span><br><span class="line">      <span class="keyword">if</span> (typeMatch(imgExt, item)) &#123;</span><br><span class="line">        <span class="keyword">var</span> suffix = getFilenameSuffix(item);</span><br><span class="line">        <span class="keyword">if</span> (!(suffix == <span class="string">&quot;.js&quot;</span> || suffix == <span class="string">&quot;.DS_Store&quot;</span>)) &#123;</span><br><span class="line">          <span class="comment">// 生成上传 Token</span></span><br><span class="line">          <span class="keyword">var</span> token = uptoken(bucket, item);</span><br><span class="line">          uploadFile(token, item, path + item);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      fileList.push(obj);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> getFiles = &#123;</span><br><span class="line">  <span class="comment">// 获取文件夹下的所有文件</span></span><br><span class="line">  <span class="function"><span class="title">getFileList</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> fileList = [];</span><br><span class="line">    readFileList(path, fileList);</span><br><span class="line">    <span class="keyword">return</span> fileList;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 获取文件夹下的所有图片</span></span><br><span class="line">  <span class="function"><span class="title">getImageFiles</span>(<span class="params">path</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> imageList = [];</span><br><span class="line">    <span class="built_in">this</span>.getFileList(path).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">var</span> ms = image(fs.readFileSync(item.path + item.filename));</span><br><span class="line">      ms.mimeType &amp;&amp; imageList.push(&#123; <span class="attr">name</span>: item.filename, <span class="attr">type</span>: item.type &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> imageList;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> imageList = getFiles.getImageFiles(path);</span><br><span class="line">fs.writeFile(</span><br><span class="line">  <span class="string">&quot;./source/photos/output.json&quot;</span>,</span><br><span class="line">  <span class="built_in">JSON</span>.stringify(imageList, <span class="literal">null</span>, <span class="string">&quot;\t&quot;</span>),</span><br><span class="line">  <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在 <code>source</code> 目录下新建一个 <code>photos</code> 文件夹，其中放入图片或文件夹，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node photo.js</span><br></pre></td></tr></table></figure><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201162444120.png" class title="执行脚本文件"><p>去到七牛存储空间，已经上传成功：</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201162536277.png" class title="上传成功"><p><code>photos</code> 文件夹中生成了一个 <code>output.json</code> 文件：</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201162640781.png" class title="图片信息JSON文件"><p>此时已经可以通过之前设置的 CDN 加速域名访问图片：</p><img src="/2021/12/01/Hexo-%E7%9B%B8%E5%86%8C%E5%AE%9E%E7%8E%B0/image-20211201163450947.png" class title="CDN 域名访问图片">]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> 相册 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 快速搭建博客</title>
      <link href="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>大致流程：使用 Hexo 搭建博客，部署在 gitee 或 github 上。</p><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><h3 id="NodeJS"><a href="#NodeJS" class="headerlink" title="NodeJS"></a>NodeJS</h3><h4 id="一、安装"><a href="#一、安装" class="headerlink" title="一、安装"></a>一、安装</h4><p>NodeJS 中文官网下载：<a href="https://nodejs.org/zh-cn/download/">https://nodejs.org/zh-cn/download/</a></p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130151612835.png" class title="node 安装"><p>一路傻瓜式安装即可。</p><h4 id="二、验证"><a href="#二、验证" class="headerlink" title="二、验证"></a>二、验证</h4><p>安装完成后在命令行窗口（win + R =&gt; cmd）依次输入下列命令检查是否安装完成：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 检查 node 版本号</span></span><br><span class="line">node -v</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查 npm 版本号</span></span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130151748882.png" class title="node 检查版本"><h4 id="三、配置"><a href="#三、配置" class="headerlink" title="三、配置"></a>三、配置</h4><ol><li><p>在 NodeJS 安装目录下，如 <code>C:\Program Files\nodejs</code> 目录，新建两个文件夹 <code>node_global</code>（全局包存放目录）和 <code>node_cache</code>（缓存目录）；</p></li><li><p>在命令行中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm config set prefix &quot;D:\soft\nodejs\node_global&quot;</span><br><span class="line"></span><br><span class="line">npm config set cache &quot;D:\soft\nodejs\node_cache&quot;</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量：</p><ul><li>打开系统属性-高级-环境变量，在系统变量中新建变量名：<code>NODE_PATH</code>，变量值：<code>D:\soft\nodejs\node_global\node_modules</code>；</li><li>编辑用户变量的 <code>path</code>，将默认的 <code>C</code> 盘下 <code>APPData/Roaming\npm</code> 修改为 <code>D:\soft\nodejs\node_global</code>。</li></ul></li></ol><h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>目前来说世界上最先进的分布式版本控制系统。</p><p>此处用来将 Hexo 博客上传到 github 或 gitee 上的工具。</p><blockquote><p>可以看一下这个廖雪峰老师的教程：<a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote><p>直接下载并安装，地址：<a href="https://git-scm.com/download/win">https://git-scm.com/download/win</a></p><p>或者去镜像安装：<a href="https://npm.taobao.org/mirrors/git-for-windows/">https://npm.taobao.org/mirrors/git-for-windows/</a></p><p>安装后查看版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130191753849.png" class title="git 检查版本"><h3 id="Hexo"><a href="#Hexo" class="headerlink" title="Hexo"></a>Hexo</h3><p>使用 npm 安装 Hexo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>查看 hexo 版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo -v</span><br></pre></td></tr></table></figure><h2 id="开始建站"><a href="#开始建站" class="headerlink" title="开始建站"></a>开始建站</h2><p>初始化博客：</p><p>在某一个文件夹内开启命令行窗口，执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init &quot;博客文件夹名&quot;</span><br></pre></td></tr></table></figure><p>建站完毕，目录下执行 <code>hexo s</code> 开启本地服务，浏览器输入 <code>localhost:4000</code> 就可以看到了：</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130192021745.png" class title="本地预览"><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">hexo init &quot;博客文件夹名&quot;  # 初始化</span><br><span class="line"></span><br><span class="line">hexo new &quot;我的第一篇博客&quot; # 创建新的文件</span><br><span class="line">hexo clean              # 清理缓存</span><br><span class="line">hexo g                  # 生成</span><br><span class="line">hexo d                  # 部署</span><br><span class="line"></span><br><span class="line">hexo s                  # 本机启动测试，默认端口为 4000</span><br></pre></td></tr></table></figure><h2 id="部署到仓库"><a href="#部署到仓库" class="headerlink" title="部署到仓库"></a>部署到仓库</h2><h3 id="部署到-github"><a href="#部署到-github" class="headerlink" title="部署到 github"></a>部署到 github</h3><h4 id="新建仓库"><a href="#新建仓库" class="headerlink" title="新建仓库"></a>新建仓库</h4><p>首先创建一个 github 账户：<a href="http://www.github.com/">www.github.com</a></p><blockquote><p>修改用户名：</p><ol><li>右上角点击头像；</li><li>点击 Settings；</li><li>左侧选择 Account；</li><li>点击 Change username 修改。</li></ol></blockquote><p>登入后点击 <code>New repository</code> 新建仓库：</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130193125917.png" class title="新建仓库"><p>仓库名称起名为你的用户名 + github.io：</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130194048399.png" class title="新建仓库-仓库命名"><p>点击 <code>Create repository</code> 新建。</p><h4 id="生成-SSH-密钥"><a href="#生成-SSH-密钥" class="headerlink" title="生成 SSH 密钥"></a>生成 SSH 密钥</h4><p>在博客文件夹的命令行中执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;AgoniLi&quot;</span><br><span class="line">git config --global user.email &quot;2500XXX49@qq.com&quot;</span><br></pre></td></tr></table></figure><p>可以输入以下命令检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name</span><br><span class="line">git config user.email</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130195001066.png" class title="设置用户名和邮箱"><p>创建 SSH，若没有配置过则一直回车即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &quot;2500761049@qq.com&quot;</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130200548481.png" class title="生成 SSH 秘钥"><blockquote><p>这里修改了路径，文件名，因为应该配置生成过，未生成过一路回车即可。</p></blockquote><p>此时对应文件夹内已经生成对应文件：</p><ul><li><code>id_rsa</code>：本机私人秘钥</li><li><code>id_rsa.pub</code>：公共秘钥</li></ul><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130200731706.png" class title="秘钥所在目录"><p>去 Github 的 settings 中找到 SSH keys 设置选项，点击 <code>New SSH key</code> 新建：</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130195812691.png" class title="github 添加 SSH 秘钥"><p>复制刚刚生成的 <code>id_rsa</code> 中的秘钥粘贴到其中，新建秘钥：</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130200056689.png" class title="github 添加 SSH 秘钥"><p>命令行验证：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130203620509.png" class title="测试连接"><p>绑定成功！</p><h4 id="部署-Hexo"><a href="#部署-Hexo" class="headerlink" title="部署 Hexo"></a>部署 Hexo</h4><p>打开博客根目录下的 <code>_config.yml</code> 配置文件，拉到底，进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/AgoniLi/AgoniLi.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span></span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130204251218.png" class title="hexo 配置部署"><p>安装 <code>deploy-git</code> 第三方包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git -S</span><br></pre></td></tr></table></figure><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130204239704.png" class title="安装 hexo-deployer-git -S"><p>然后依次执行：<code>hexo clean</code>、<code>hexo g</code>、<code>hexo d</code> 进行部署，过程中输入用户名和密码，部署完成~</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130210113283.png" class title="部署完成"><p>在浏览器中已经可以通过 <code>agonili.github.io</code> 访问到部署的博客。</p><img src="/2021/11/30/Hexo-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/image-20211130210159928.png" class title="github 预览"><h3 id="部署到-gitee"><a href="#部署到-gitee" class="headerlink" title="部署到 gitee"></a>部署到 gitee</h3><blockquote><p>再做讲解，部署到 gitee 无法实时更新，还需多次部署，暂不考虑。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>闲谈</title>
      <link href="/2021/11/30/1130%E9%97%B2%E8%B0%88/"/>
      <url>/2021/11/30/1130%E9%97%B2%E8%B0%88/</url>
      
        <content type="html"><![CDATA[<h1 id="学习"><a href="#学习" class="headerlink" title="学习"></a>学习</h1><h2 id="课程-amp-考试"><a href="#课程-amp-考试" class="headerlink" title="课程&amp;考试"></a>课程&amp;考试</h2><p>学院安排的课程大部分没什么大用处，但都是基础，考试的内容都是在老师上课讲的里面（ppt、随堂测试、u+、学习通、云班课）</p><p>考试：提前复习，复习重点（前几年的题或者老师发的重点）</p><p>比较重要的学科：</p><ul><li>大一上：<ul><li>程序设计基础（C 语言，走 C++ 方向比较重要）</li></ul></li><li>大一下：<ul><li>数据结构与算法（有课设）</li></ul></li><li>大二上：<ul><li>毛概</li><li>计算机系统基础</li><li>数据库概论</li><li>面向对象程序设计（Java）（有课设）</li></ul></li><li>大二下：<ul><li>马原</li><li><strong>算法分析与设计</strong></li><li>网络及其计算</li><li>操作系统</li><li>软件工程导论</li><li>网页设计与网站建设（Java Web）</li><li>软件质量保证与测试技术</li></ul></li><li>大三（分方向，后面说）（实训）</li><li>大四（实习）</li></ul><blockquote><p>若要考研则需额外着重注意的学科：高等数学、线性代数</p></blockquote><p>能考的好一些尽量就考好一些，有奖学金赚。</p><h2 id="自主学习"><a href="#自主学习" class="headerlink" title="自主学习 *"></a>自主学习 *</h2><ol><li>首先最重要的是身体；</li><li>可以很好的管理自己的时间，安排妥当，该玩玩，该学学；</li><li>尽早会写使用笔记软件写笔记，推荐 Typora，养成学习中记笔记的好习惯（<code>markdown 语法</code>）；<ul><li>纸质笔记 VS 电子笔记</li></ul></li><li>其次在 CSDN 或其他文档网站上多发表自己的看法观点及笔记，最好尽快搭建一个属于自己的博客（推荐 hexo + github）</li><li>提前了解 考研 和 就业</li><li>提前了解 各个方向</li></ol><p>学习方式：</p><ol><li>视频学习</li><li>文章学习</li><li>看书学习</li><li>官方文档学习</li></ol><p>都行，找到最合适自己的即可。</p><h2 id="实验室-amp-实战"><a href="#实验室-amp-实战" class="headerlink" title="实验室&amp;实战"></a>实验室&amp;实战</h2><p>提前学一点东西，大二的时候，或者大一下半学期加入实验室（比如本实验室，虽然我应该就不在了）</p><p>好处：</p><ul><li>扩大人脉</li><li>接项目，赚外快（虽然不多），提升自身水平</li><li>氛围不同</li><li>组队打比赛</li></ul><p>做项目带来的提升和自己学不同，偏向于就业后的情况。</p><h2 id="专业方向"><a href="#专业方向" class="headerlink" title="专业方向"></a>专业方向</h2><p>A 软件开发与测试（基本就是打代码，分前端、后端、测试）</p><p>B 信息化与网络安全（就是网安，好上手，代码敲的少）</p><p>R 人工智能软件开发与应用（python，人工智能）</p><p>X 移动互联网软件开发与应用（c++、汇编语言、算法）</p><p>Y 云计算和大数据（云开发、大数据分析、数据库）</p><p>Z 物联网与智慧城市建设（硬件、智能，本人不了解）</p><h2 id="未来方向"><a href="#未来方向" class="headerlink" title="未来方向"></a>未来方向</h2><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>提前学习 纵向横向 精通，形成明确清晰的知识栈</p><p>目标公司、目标岗位、目标城市</p><p>春招 &amp; 秋招</p><h3 id="考研-amp-保研"><a href="#考研-amp-保研" class="headerlink" title="考研&amp;保研"></a>考研&amp;保研</h3><p>城市 &amp; 学校、专硕 or 学硕、考 or 保</p><blockquote><p>反正我是不考</p></blockquote><h2 id="竞赛"><a href="#竞赛" class="headerlink" title="竞赛"></a>竞赛</h2><ol><li>蓝桥杯</li><li>软件杯</li><li>小程序大赛</li><li>刘鼎杯</li><li>互联网+</li><li>大创</li></ol><p>如果不是保研，不用打太多的比赛，参与参与其实就行，有能力的话冲一冲更高的奖就行</p><h1 id="生活"><a href="#生活" class="headerlink" title="生活"></a>生活</h1><h2 id="体育锻炼"><a href="#体育锻炼" class="headerlink" title="体育锻炼"></a>体育锻炼</h2><p>坚持跑步锻炼，四年体测成绩很重要，尤其到了大四，别大三大四为体测发愁</p><h2 id="轮滑"><a href="#轮滑" class="headerlink" title="轮滑"></a>轮滑</h2><p>开心就完了</p><h2 id="入党-amp-职位"><a href="#入党-amp-职位" class="headerlink" title="入党&amp;职位"></a>入党&amp;职位</h2><p>能入就入，入了总比不入好</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>SpringBoot 复习笔记</title>
      <link href="/2021/11/29/SpringBoot-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/11/29/SpringBoot-%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h4 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">|-- src/main # 项目根目录</span><br><span class="line">|-- java# Java 源代码目录</span><br><span class="line">|-- resources # 资源目录</span><br><span class="line">|-- static# 静态资源目录</span><br><span class="line">|-- templates# 表示层页面目录</span><br><span class="line">|-- application.properties# springboot 配置文件</span><br><span class="line">|-- test# 测试文件目录</span><br></pre></td></tr></table></figure><p>application.properties 文件用于配置 springboot</p><blockquote><p>也可以是 <code>application.yml</code> 或 <code>application.yaml</code> 文件</p><p>在 yml 语法中，相同缩进代表同一个级别，使用键值对语法：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="maven"><a href="#maven" class="headerlink" title="maven"></a>maven</h4><h5 id="dependency"><a href="#dependency" class="headerlink" title="dependency"></a>dependency</h5><p><code>dependency</code> 标签：用来导入依赖</p><ul><li><strong>artifactId</strong>：用来导入项目（jar 包、各种场景启动器）</li><li><strong>groupId</strong>：这些项目的包名</li><li>version：版本号</li><li>type：该依赖的项目类型，jar、war…</li><li><strong>scope</strong>：该依赖的作用范围<ul><li>complie：默认值，用于编译、打包、测试、运行阶段</li><li>provided：不用于打包</li><li>runtime：不用于编译</li><li>test：只用于测试</li></ul></li><li>exclusion：排除依赖项</li></ul><h5 id="常用坐标"><a href="#常用坐标" class="headerlink" title="常用坐标"></a>常用坐标</h5><h6 id="springboot-起步依赖"><a href="#springboot-起步依赖" class="headerlink" title="springboot 起步依赖"></a><strong>springboot 起步依赖</strong></h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>xxx<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="web-启动依赖"><a href="#web-启动依赖" class="headerlink" title="web 启动依赖"></a>web 启动依赖</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="热部署"><a href="#热部署" class="headerlink" title="热部署"></a>热部署</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-devtools<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">optional</span>&gt;</span>true<span class="tag">&lt;/<span class="name">optional</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>true<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="mybatis"><a href="#mybatis" class="headerlink" title="mybatis"></a>mybatis</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>runtime<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="thymeleaf"><a href="#thymeleaf" class="headerlink" title="thymeleaf"></a>thymeleaf</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="junit5"><a href="#junit5" class="headerlink" title="junit5"></a>junit5</h6><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><h5 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h5><p>标明该注解的类为主启动类或者主配置类，作为 springboot 程序的入口</p><blockquote><p>SpringApplication.run(MySpringBootApplication.class) 代表 SpringBoot 的启动类，参数为 SpringBoot 启动类的字节码对象。</p></blockquote><h5 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h5><p>扫描 @SpringBootApplication 下的 @Controller、@Repositroy、@Service、@Component</p><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;请求地址&quot;)</span></span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line"><span class="meta">@RequestMapping(&quot;请求地址&quot;)</span></span><br></pre></td></tr></table></figure><p>其中还有 @GetMapping、@PostMapping、@PutMapping、@DeleteMapping、@PatchMapping，就相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(value = &quot;请求地址&quot;, method = &quot;RequestMethod.请求方法&quot;)</span></span><br></pre></td></tr></table></figure><blockquote><p>更新使用 <code>@PutMapping</code> 更合适，添加更偏向于使用 <code>@PostMapping</code></p></blockquote><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>请求参数在响应体中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@RequestBody</span> String str)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p>限定 HTTP 参数到 Controller 方法的映射关系。</p><p>请求参数在请求域中：<code>?userId=2&amp;userAge=25</code></p><h5 id="PathVariable"><a href="#PathVariable" class="headerlink" title="@PathVariable"></a>@PathVariable</h5><p>从 URL 中提取参数。</p><p>绑定参数和请求路径中的参数，接收请求路径中占位符的值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/login/&#123;id&#125;&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">(<span class="meta">@PathVariable</span>=(<span class="string">&quot;id&quot;</span>)</span> uid) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h5><p>将返回的数据放入响应体中，默认格式为 <code>json</code></p><blockquote><p><code>@RestController</code> 等同于 <code>@Contoller</code> + <code>@ResponseBody</code></p></blockquote><h5 id="Configuration"><a href="#Configuration" class="headerlink" title="@Configuration"></a>@Configuration</h5><p>标注该注解的类是 springboot 的配置类</p><p>在配置类中才可以进行 bean 注入</p><h5 id="Mapper"><a href="#Mapper" class="headerlink" title="@Mapper"></a>@Mapper</h5><p>标注该注解的接口是 mybatis 的接口，自动注入到 IOC 容器中</p><h5 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h5><p>自动获取 ICO 容器中的组件、实例</p><p>一般将它写在字段前或者 setter 方法前面，作为 bean 注入时的使用。</p><h5 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h5><p>通常作用在 Controller 的某个方法上，会首先被调用，并将方法结果作为 Model 的属性，然后再调用对应的 Controller 处理方法。</p><h4 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h4><p>控制反转，是一种思想，意味着将设计好的对象交给 spring 容器管理，而不是直接 new 对象进行控制，spring 容器称为 ioc 容器。</p><blockquote><p>DI 指依赖注入，实际上就是 IOC 的实现。</p></blockquote><h5 id="注入方式"><a href="#注入方式" class="headerlink" title="注入方式"></a>注入方式</h5><ol><li><p>引入 xml 注入；</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;&quot;</span> <span class="attr">class</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注解注入：</p><ul><li><code>@Configuration</code> + <code>@Bean</code> 注入；</li><li><code>@service</code>、<code>@Controller</code>、<code>@Mapper</code>、<code>@Component</code>、<code>@Repository</code> 注入 + <code>@ComponentScan</code> 扫描。</li></ul></li><li><p>获取 bean：</p><ul><li><p><code>@AutoWired</code></p></li><li><p><code>@Resource</code></p></li><li><p>bean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplication();</span><br><span class="line">context.getBean(<span class="string">&quot;id&quot;</span>); <span class="comment">// 根据 id 获取 bean</span></span><br><span class="line">context.getBean(<span class="string">&quot;student.class&quot;</span>); <span class="comment">// 根据类型获取 bean</span></span><br></pre></td></tr></table></figure></li><li><p>主启动类直接中获取。</p></li></ul></li></ol><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><p>面向切面编程，底层是<strong>动态代理模式</strong>，拦截器底层就是 AOP。</p><h5 id="配置开启"><a href="#配置开启" class="headerlink" title="配置开启"></a>配置开启</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ontext:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.agoni&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ontext:component-scan</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@Before</code>、<code>@AfterReturning</code>、<code>@AfterThrowing</code>、<code>@After</code>；</p><p><code>@Around</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Before</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// @AfterReturning</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> () &#123;</span><br><span class="line">  <span class="comment">// @AfterThrowing</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">  <span class="comment">// @After</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="实现流程"><a href="#实现流程" class="headerlink" title="实现流程"></a>实现流程</h5><blockquote><p>此小节来自 娃宇翔（QQ：985391895）！</p></blockquote><ol><li><p>声明一个切面类，并用 <code>@Component</code> 和 <code>@Aspect</code> 修饰</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAop</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>用 <code>@Pointcut</code> 注释声明一个切点，告诉切面谁是他的服务对象（此注释修饰的方法的方法体为空，不需要写功能，可以理解为切点对象的一个代理对象方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Pointcut(&quot;execution(public * com.agoni.service.UserServiceImpl.*(..))&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;&#125; <span class="comment">// 声明目标对象</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@Before(&quot;log()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;前置方法&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@After(&quot;log()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123; System.out.println(<span class="string">&quot;后置方法&quot;</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Around(&quot;log()&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">aroundAdvice</span><span class="params">(ProceedingJoinPoint point)</span> </span>&#123;</span><br><span class="line">  System.out.println(<span class="string">&quot;环绕通知的目标方法名：&quot;</span> + point.getSignature().getName());</span><br><span class="line">  point.proceed(); <span class="comment">// 执行方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在对应的方法前用对应的通知类型注释修饰，将对应的方法声明成一个且切面功能，为了切面服务</p></li></ol><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>所有的拦截器都需要实现 <code>HandlerInterceptor</code> 接口</p><h5 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义拦截器 HandlerInterceptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpSerletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;前置方法正在执行&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;后置方法正在执行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse reponse, Object handler)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;完成方法正在执行&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h5><ul><li><code>preHandle</code>：返回一个布尔值：false 结束所有流程，true 执行下一步；</li><li>执行处理器逻辑，包含控制器的功能；</li><li>执行 <code>postHandle</code> 方法；</li><li>执行视图解析和视图渲染；</li><li>执行 <code>afterCompletion</code> 方法；</li></ul><h5 id="注册拦截器"><a href="#注册拦截器" class="headerlink" title="注册拦截器"></a>注册拦截器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">App1</span> <span class="keyword">implements</span> <span class="title">webMvcConfigurer</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">    InterceptorRegistration rs = registry.addInterceptor(<span class="keyword">new</span> MyInterceptor());</span><br><span class="line">    rs.addPathPatterns(<span class="string">&quot;/**&quot;</span>);</span><br><span class="line">    rs.excludePathPatterns(<span class="string">&quot;/排除项&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>addPathPatterns</code>：添加拦截的请求地址；</li><li><code>excludePathPetterns</code>：排除不拦截的请求地址。</li></ul><h4 id="整合-Mybatis"><a href="#整合-Mybatis" class="headerlink" title="整合 Mybatis"></a>整合 Mybatis</h4><h5 id="mapper-实现"><a href="#mapper-实现" class="headerlink" title="mapper 实现"></a>mapper 实现</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.agoni.org&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 插入 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">parameterType</span>=<span class="string">&quot;类型&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">          <span class="attr">keyProperty</span>=<span class="string">&quot;id&quot;</span>&gt;</span></span><br><span class="line">    insert into 数据库名.表名(字段名1, ...) values (#&#123;数据1&#125;, ...)</span><br><span class="line">  <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 删除 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;类型&quot;</span>&gt;</span></span><br><span class="line">    delete from 数据库名.表名 where 字段名=#&#123;数据&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 更新 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">parameterType</span>=<span class="string">&quot;类型&quot;</span>&gt;</span></span><br><span class="line">    update 数据库名.表名 set 字段名1=#&#123;数据&#125;, ... where 字段名=$&#123;数据&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 查询 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;方法名&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;类型&quot;</span>&gt;</span></span><br><span class="line">    select * from 数据库名.表名</span><br><span class="line">    <span class="comment">&lt;!-- select * from 数据库名.表名 where 字段名=$&#123;数据&#125; --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- select * from 数据库名.表1 别名1 left join 数据库名.表2 别名2 on 检索条件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>连表查询中 on 和 where 区别：</p><ul><li>on：在满足条件后才进行连接；</li><li>where：在全部连接后寻找满足条件的。</li></ul></blockquote><h5 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h5><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">datasource:</span></span><br><span class="line"><span class="attr">username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">password:</span> <span class="number">123456</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">jdbc:mysql://localhost:3306/数据库名?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span></span><br><span class="line"><span class="attr">dirver-class-name:</span> <span class="string">com.mysql.cj.jdbc.Dirver</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">type-aliases-package:</span> <span class="string">com.agoni.包名</span></span><br><span class="line"><span class="attr">mapper-locations:</span> <span class="string">classpath:mybatis/mapper/*.xml</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">port:</span> <span class="number">8080</span></span><br></pre></td></tr></table></figure><h4 id="thymeleaf-1"><a href="#thymeleaf-1" class="headerlink" title="thymeleaf"></a>thymeleaf</h4><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping(&quot;/emps&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">list</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">  Collection&lt;Employee&gt; employee = employeeDao.getAll();</span><br><span class="line">  model.addAttribute(<span class="string">&quot;emps&quot;</span>, employee);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;list&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>list.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">&quot;emp: $&#123;emps&#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:test</span>=<span class="string">&quot;$&#123;emp.getId()&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">th:href</span>=<span class="string">&quot;@&#123;/emp/&#123;id&#125;&#125;&quot;</span>&gt;</span>编辑<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="Model-amp-ModelAndView"><a href="#Model-amp-ModelAndView" class="headerlink" title="Model &amp; ModelAndView"></a>Model &amp; ModelAndView</h5><ul><li>Model 中使用 addAttribute() 方法</li><li>ModelAndView 中使用 addObject() 方法</li></ul><h5 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h5><p>html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;file&quot;</span> <span class="attr">name</span>=<span class="string">&quot;photo&quot;</span> <span class="attr">enctype</span>=<span class="string">&quot;multipart/form-data&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileController</span> </span>&#123;</span><br><span class="line">  <span class="meta">@PostMapping(&quot;/upload/multipart&quot;)</span></span><br><span class="line">  <span class="meta">@ResponseBody</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">upload</span><span class="params">(<span class="meta">@RequestParam(&quot;photo&quot;)</span> MultipartFile photo)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>若是多文件上传则 <code>MultipartFile</code> 后添加一个 <code>[]</code></p></blockquote><p>欢迎在下面评论补充，纠错噢！！</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 源码剖析</title>
      <link href="/2021/11/26/vue%20%E6%BA%90%E7%A0%81/"/>
      <url>/2021/11/26/vue%20%E6%BA%90%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><h2 id="认识-Flow"><a href="#认识-Flow" class="headerlink" title="认识 Flow"></a>认识 Flow</h2><p>Flow 是 facebook 出品的 JavaScript 静态类型检查工具。Vue.js 的源码利用了 Flow 做了静态类型检查，了解 Flow 有利于阅读源码。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>安装命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install flow-bin -g</span><br></pre></td></tr></table></figure><p>flow 初始化：</p><p>会在本目录下生成一个 <code>.flowconfig</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow init</span><br></pre></td></tr></table></figure><p>![](vue 源码/image-20211112125710450.png)</p><p>在文件中加入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow  */</span></span><br><span class="line">或</span><br><span class="line"><span class="comment">// @flow</span></span><br></pre></td></tr></table></figure><p>就会被 Flow 检查，否则会跳过</p><p>运行检查：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flow check</span><br></pre></td></tr></table></figure><h3 id="为什么用-Flow"><a href="#为什么用-Flow" class="headerlink" title="为什么用 Flow"></a>为什么用 Flow</h3><p>JavaScript 是动态类型语言，它的灵活性有目共睹，但是过于灵活的副作用是很容易就写出非常隐蔽的隐患代码，在编译期甚至看上去都不会报错，但在运行阶段就可能出现各种奇怪的 bug。</p><blockquote><p>类型检查：就是在编译期尽早发现（由类型错误引起的）bug，又不影响代码运行（不需要运行时动态检查类型），使编写 JavaScript 具有和编写 Java 等强类型语言相近的体验。</p></blockquote><p>项目越复杂就越需要通过工具的手段来保证项目的维护性和增强代码的可读性。</p><p>Vue.js 在做 2.0 重构的时候，在 ES2015 的基础上，除了 ESLint 保证代码风格之外，也引入了 Flow 做静态类型检查。</p><p>选择 Flow 的原因：因为 Babel 和 ESLint 都有对应的 Flow 插件以支持语法，可以完全沿用现有的构建配置，非常小成本的改动就可以拥有静态类型检查的能力。</p><h3 id="Flow-的工作方式"><a href="#Flow-的工作方式" class="headerlink" title="Flow 的工作方式"></a>Flow 的工作方式</h3><p>通常类型检查分为两种方式：</p><ul><li><strong>类型推断</strong>：通过变量的使用上下文来推断出变量类型，然后根据这些推断来检查类型；</li><li><strong>类型注释</strong>：事先注释好我们期待的类型，Flow 会基于这些注释来判断。</li></ul><h4 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h4><p>它不需要任何代码修改即可进行类型检查，最小化开发者的工作量。</p><p>Flow 不会强制你改变开发习惯，因为它会自动推断出变量的类型。这就是所谓的<strong>类型推断</strong>，Flow 最重要的特性之一。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">split</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">split(<span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>随后在控制台执行 <code>flow check</code>：</p><p>![](vue 源码/image-20211112131100296.png)</p><p>Flow 检查后会报错，因为函数 split 期待的参数使字符串，而我们输入了数字。</p><h4 id="类型注释"><a href="#类型注释" class="headerlink" title="类型注释"></a>类型注释</h4><p>在某些特定的场景下，添加类型注释可以提供更好更明确的检查依据。</p><p>如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;Hello&#x27;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>Flow 检查时检查不出任何错误，因为 <code>+</code> 既可以用在字符串上，也可与用在数字上。</p><p>这种情况下，可以借助类型注释来指明期望的类型。</p><p>类型注释是以 <code>:</code> 开头，可以在函数参数，返回值，变量声明中使用。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x: <span class="built_in">number</span>, y: <span class="built_in">number</span></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="string">&#x27;hello&#x27;</span>, <span class="number">11</span>)</span><br></pre></td></tr></table></figure><p>现在 Flow 就能检查出错误，因为函数参数的期待类型为数字，而我们提供了字符串。</p><p>![](vue 源码/image-20211112131828406.png)</p><p>当传递的参数为两个数字时，则不会检查出错误。</p><h4 id="常见类型注释"><a href="#常见类型注释" class="headerlink" title="常见类型注释"></a>常见类型注释</h4><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><p>数组类型注释的格式是 <code>Array&lt;T&gt;</code>，<code>T</code> 表示数组中每项的数据类型：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">var</span> arr: <span class="built_in">Array</span>&lt;<span class="built_in">number</span>&gt; = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><h5 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h5><p>类的类型注释，可以对类自身的属性做类型检查，也可以对构造函数的参数做类型检查。</p><blockquote><p>属性的类型中间用 <code>|</code> 做间隔，表示两种类型均可接受。</p></blockquote><p>对象的注释类型类似于类，需要指定对象属性的类型。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> </span>&#123;</span><br><span class="line">  <span class="attr">x</span>: <span class="built_in">string</span>           <span class="comment">// x 是字符串</span></span><br><span class="line">  <span class="attr">y</span>: <span class="built_in">string</span> | <span class="built_in">number</span>  <span class="comment">// y 可以是字符串或者数字</span></span><br><span class="line">  <span class="attr">z</span>: <span class="built_in">boolean</span></span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params">x: <span class="built_in">string</span>, y: <span class="built_in">string</span> | <span class="built_in">number</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.x = x</span><br><span class="line">    <span class="built_in">this</span>.y = y</span><br><span class="line">    <span class="built_in">this</span>.z = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar: Bar = <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj: &#123; <span class="attr">a</span>: <span class="built_in">string</span>, <span class="attr">b</span>: <span class="built_in">number</span>, <span class="attr">c</span>: <span class="built_in">Array</span>&lt;<span class="built_in">string</span>&gt;, d: Bar &#125; = &#123;</span><br><span class="line">  <span class="attr">a</span>: <span class="string">&#x27;hello&#x27;</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">11</span>,</span><br><span class="line">  <span class="attr">c</span>: [<span class="string">&#x27;hello&#x27;</span>, <span class="string">&#x27;world&#x27;</span>],</span><br><span class="line">  <span class="attr">d</span>: <span class="keyword">new</span> Bar(<span class="string">&#x27;hello&#x27;</span>, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Null-Undefined"><a href="#Null-Undefined" class="headerlink" title="Null Undefined"></a>Null Undefined</h5><p>若想任意类型 <code>T</code>  可以为 <code>null</code> 或者 <code>undefined</code> ，只需要写成 <code>?T</code> 的格式即可：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">var</span> foo: ?<span class="built_in">string</span> = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>也可以在类型中加入 <code>| void</code> 使其可以不传值（但也不可以为 <code>null</code> ，可以为<code>undefined</code>）。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* #flow */</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span></span><br><span class="line"><span class="keyword">var</span> foo: <span class="built_in">string</span> | <span class="built_in">number</span> | <span class="built_in">void</span> = <span class="literal">undefined</span></span><br></pre></td></tr></table></figure><h3 id="Flow-在-Vue-js-源码中的应用"><a href="#Flow-在-Vue-js-源码中的应用" class="headerlink" title="Flow 在 Vue.js 源码中的应用"></a>Flow 在 Vue.js 源码中的应用</h3><p>在我们引用第三方库，或者自定义一些类型时，Flow 并不认识，因此在检查的时候会报错。因此，Flow 提出了一个 <code>libdef</code>  的概念，可以用来识别这些第三方库或者是自定义类型，而 Vue.js 也利用了这一特性。</p><p>在 Vue.js 的主目录下由 <code>.flowconfig</code> 文件，它是 Flow 的配置文件。</p><blockquote><p>官方文档地址：<a href="https://flow.org/en/docs/config">https://flow.org/en/docs/config</a> </p></blockquote><p>其中的 <code>[libs]</code> 部分用来描述包括指定库定义的目录，默认是名为 <code>flow-typed</code> 的目录。</p><p>Vue.js 源码中指定了 <code>flow</code> 目录，表示指定的库定义都在 flow 文件夹内，文件结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">flow</span><br><span class="line">├── compiler.js        # 编译相关</span><br><span class="line">├── component.js       # 组件数据结构</span><br><span class="line">├── global-api.js      # Global API 结构</span><br><span class="line">├── modules.js         # 第三方库定义</span><br><span class="line">├── options.js         # 选项相关</span><br><span class="line">├── ssr.js             # 服务端渲染相关</span><br><span class="line">├── vnode.js           # 虚拟 node 相关</span><br><span class="line">├── weex.js # weex 相关</span><br></pre></td></tr></table></figure><p>通过对 Flow 的认识，有助于阅读 Vue 的源码，并且这种静态类型检查的方式非常有利于大型项目源码的开发和维护。类似 Flow 的工具还有如 TypeScript。</p><h2 id="Vue-js-源码目录设计"><a href="#Vue-js-源码目录设计" class="headerlink" title="Vue.js 源码目录设计"></a>Vue.js 源码目录设计</h2><p>Vue.js 的源码都在 src 目录下，其目录结构如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">├── compiler        # 编译相关 </span><br><span class="line">├── core            # 核心代码 </span><br><span class="line">├── platforms       # 不同平台的支持</span><br><span class="line">├── server          # 服务端渲染</span><br><span class="line">├── sfc             # .vue 文件解析</span><br><span class="line">├── shared          # 共享代码</span><br></pre></td></tr></table></figure><h3 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h3><p>compiler 目录包含 Vue.js 所有编译相关的代码。它包括把模板解析成 AST 语法树，AST 语法树优化，代码生成等功能。</p><blockquote><p>编译的工作可以在构建时做（借助 webpack、vue-loader 等辅助插件）；也可以在运行时做，使用包含构建功能的 Vue.js。</p><p>编译是一项耗性能的工作，所以更推荐前者——离线编译。</p></blockquote><h3 id="core"><a href="#core" class="headerlink" title="core *"></a>core *</h3><p>core 目录包含了 Vue.js 的<strong>核心代码</strong>，包含内置组件、全局 API 封装、Vue 实例化、观察者、虚拟 DOM、工具函数等等。</p><p><strong>这里的代码可谓是 Vue.js 的灵魂</strong>。</p><h3 id="platforms"><a href="#platforms" class="headerlink" title="platforms"></a>platforms</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">platforms</span><br><span class="line">├── web# 打包成运行在 Web 上的 Vue.js</span><br><span class="line">├── weex# 打包成运行在 weex 上的 Vue.js</span><br></pre></td></tr></table></figure><p>Vue.js 是一个跨平台的 MVVM 框架，它可以跑在 web 上，也可以配合 weex 跑在 natvie 客户端上。</p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><p>Vue.js 2.0 支持了服务端渲染，所有服务端渲染相关的逻辑都在这个目录下。</p><blockquote><p>注意：这部分代码是跑在服务端的 Node.js，不要和跑在浏览器端的 Vue.js 混为一谈。</p></blockquote><p>服务端渲染主要的工作是把组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器上，最后将静态标记“混合”为客户端上完全交互的应用程序。</p><h3 id="sfc"><a href="#sfc" class="headerlink" title="sfc"></a>sfc</h3><p>通常我们开发 Vue.js 都会借助 webpack 构建， 然后通过 .vue 单文件的编写组件。</p><p>这个目录下的代码逻辑会把 .vue 文件内容解析成一个 JavaScript 的对象。</p><h3 id="shared"><a href="#shared" class="headerlink" title="shared"></a>shared</h3><p>Vue.js 会定义一些工具方法，这里定义的工具方法都是会被浏览器端的 Vue.js 和服务端的 Vue.js 所共享的。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>从 Vue.js 的目录设计可以看到，作者把功能模块拆分成的非常清楚，相关的逻辑放在以恶搞独立的目录下维护，并且把复用的代码也抽成一个独立目录。</p><p>这样的目录设计让代码的阅读性和可维护性都变强，是非常值得学习和推敲的。</p><h2 id="Vue-js-源码构建"><a href="#Vue-js-源码构建" class="headerlink" title="Vue.js 源码构建"></a>Vue.js 源码构建</h2><p>Vue.js 源码时基于 Rollup 构建的，构建相关配置都子啊 scripts 目录下。</p><blockquote><p>Rollup：<a href="https://rollupjs.org/guide/en/">https://rollupjs.org/guide/en/</a></p><p>和 Webpack 的区别：Webpack 较为强大，webpack 会把所有类型文件（包括图片等）统统编译成 JS 文件，而 Rollup 只编译 js 部分，所以 Rollup 更轻量，在编译代码时也较友好。</p></blockquote><h3 id="构建脚本"><a href="#构建脚本" class="headerlink" title="构建脚本"></a>构建脚本</h3><p>通常一个基于 NPM 托管的项目都会有一个 package.json 文件，它是对项目的描述文件——包描述文件，内容是一个标准的 JSON 对象。</p><p>通常会配置 <code>script</code> 字段作为 NPM 的执行脚本，Vue.js 源码构建的脚本如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;script&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;node scripts/build.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:ssr&quot;</span>: <span class="string">&quot;npm run build -- web-runtime-cjs,web-server-renderer&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build:weex&quot;</span>: <span class="string">&quot;npm run build --weex&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后面两条是在第一条命令的基础上，添加一些环境参数</p></blockquote><p>当在命令行运行 <code>npm run build</code> 时，实际上就会执行 <code>node scripts/builds.js</code>。</p><h3 id="构建过程"><a href="#构建过程" class="headerlink" title="构建过程"></a>构建过程</h3><p><code>scripts/build.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">let</span> builds = <span class="built_in">require</span>(<span class="string">&#x27;./config&#x27;</span>).getAllBuilds()</span><br><span class="line"></span><br><span class="line"><span class="comment">// filter builds via command line arg</span></span><br><span class="line"><span class="keyword">if</span> (process.argv[<span class="number">2</span>]) &#123;</span><br><span class="line">  <span class="keyword">const</span> filters = process.argv[<span class="number">2</span>].split(<span class="string">&#x27;,&#x27;</span>)</span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> filters.some(<span class="function"><span class="params">f</span> =&gt;</span> b.output.file.indexOf(f) &gt; -<span class="number">1</span> || b._name.indexOf(f) &gt; -<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// filter out weex builds by default</span></span><br><span class="line">  builds = builds.filter(<span class="function"><span class="params">b</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> b.output.file.indexOf(<span class="string">&#x27;week&#x27;</span>) === <span class="number">1</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>先从配置文件读取配置，在通过命令行参数对构建配置做过滤，这样就可以构建出不同用途的 Vue.js 了。</p><p><code>scripts/config.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> build = &#123;</span><br><span class="line">  <span class="comment">// Runtime only (CommonJS). Used by bundlers .eg. Webpack&amp;Browserify</span></span><br><span class="line">  <span class="string">&#x27;web-runtime-cjs&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: resolve(<span class="string">&#x27;web/entry-runtime.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: resolve(<span class="string">&#x27;dist/vue.runtime.common.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;cjs&#x27;</span>,</span><br><span class="line">    <span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// Runtime+complier development build (Browser)</span></span><br><span class="line">  <span class="string">&#x27;web-full-dev&#x27;</span>: &#123;</span><br><span class="line">    <span class="attr">entry</span>: resolve(<span class="string">&#x27;web/entry-runtime-with-compiler.js&#x27;</span>),</span><br><span class="line">    <span class="attr">dest</span>: resolve(<span class="string">&#x27;dist/vue.js&#x27;</span>),</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&#x27;umd&#x27;</span>,</span><br><span class="line">    <span class="attr">env</span>: <span class="string">&#x27;development&#x27;</span>,</span><br><span class="line">    <span class="attr">alias</span>: &#123; <span class="attr">he</span>: <span class="string">&#x27;./entry-decoder&#x27;</span>&#125;,</span><br><span class="line">    banner</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面列举了一些 Vue.js 构建的配置，对于单个的配置，它是遵循 Rollup 的构建规则的：</p><ul><li>entry：表示构建的入口 JS 文件地址；</li><li>dest：表示构建后的 JS 文件地址；</li><li>format：表示构建的格式：<ul><li>cjs：遵循 CommonJS 规范；</li><li>es：遵循 ES Module 规范；</li><li>umd：遵循 UMD 规范。</li></ul></li></ul><p><code>resolve()</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cosnt aliases = <span class="built_in">require</span>(<span class="string">&#x27;./alias&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> resolve = <span class="function">(<span class="params">p</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> base = p.split(<span class="string">&#x27;/&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">if</span> (aliases[base]) &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(aliases[base], p.slice(base.length + <span class="number">1</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> path.resolve(__dirname, <span class="string">&#x27;../&#x27;</span>, p)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先把 resolve 函数传入的参数 <code>p</code> 通过 <code>/</code> 做了分割成数组，然后取去租第一个元素设置为 <code>base</code>。<code>base</code> 并不是实际的路径，它的真实路径借助了别名的配置：</p><p><code>scripts/alisa.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">vue</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/web/entry-runtime-with-compiler&#x27;</span>),</span><br><span class="line">  <span class="attr">compiler</span>: path.resolve(__dirname, <span class="string">&#x27;../src/compiler&#x27;</span>),</span><br><span class="line">  <span class="attr">core</span>: path.resolve(__dirname, <span class="string">&#x27;../src/core&#x27;</span>),</span><br><span class="line">  <span class="attr">shared</span>: path.resolve(__dirname, <span class="string">&#x27;./src/shared&#x27;</span>),</span><br><span class="line">  <span class="attr">web</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/web&#x27;</span>),</span><br><span class="line">  <span class="attr">weex</span>: path.resolve(__dirname, <span class="string">&#x27;../src/platforms/weex&#x27;</span>),</span><br><span class="line">  <span class="attr">server</span>: path.resolve(__dirname, <span class="string">&#x27;../src/server&#x27;</span>),</span><br><span class="line">  <span class="attr">entries</span>: path.resolve(__dirname, <span class="string">&#x27;../src/entries&#x27;</span>),</span><br><span class="line">  <span class="attr">sfc</span>: path.resolve(__dirname, <span class="string">&#x27;../src/sfc&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>web</code> 对应的真实的路径是 <code>path.resolve(__dirname, &#39;../src/platforms/web&#39;)</code>，这个路径就找到了 Vue.js 源码的 web 目录。然后 <code>resolve</code> 函数通过 <code>path.resolve(aliases[base], p.slice(base.length + 1))</code> 找到了最终路径，也就是 Vue.js 源码 web 目录下的 <code>entry-runtime.js</code>。因此 <code>web-runtime-cjs</code> 配置对应的入口文件就找到了。它经过 Rollup 的构建打包后，最终在 dist 目录下生成 <code>vue.runtime.common.js</code>。</p><h3 id="Runtime-Only-VS-Runtime-Compiler"><a href="#Runtime-Only-VS-Runtime-Compiler" class="headerlink" title="Runtime Only VS Runtime+Compiler"></a>Runtime Only VS Runtime+Compiler</h3><p>通常，利用 vue-cli 去初始化我们的 Vue.js 项目的时候会询问用 Runtime Only 版本还是 Runtime+Comiler 版本，对比：</p><ul><li><p>Runtime Only：</p><p>在使用 Runtime Only 版本的 Vue.js 的时候，通常需要借助如 webpack 的 vue-loader 工具把 .vue 文件编译成 JavaScript，因为是在编译阶段做的，所以它只包含运行时的 Vue.js 代码，因此代码体积也会更轻量。</p></li><li><p>Runtime+Compiler：</p><p>如果没有对代码做预编译，但又使用了 Vue 的 template 属性并传入一个字符串，则需要在客户端编译模板：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要编译器的版本</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123; h1 &#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这种情况不需要</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  render (h) &#123;</span><br><span class="line">    <span class="keyword">return</span> h(<span class="string">&#x27;div&#x27;</span>, <span class="built_in">this</span>.hi)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>因为在 Vue.js 2.0 中，最终渲染都是通过 <code>render</code> 函数，如果写 <code>template</code> 属性，则需要编译成 <code>render</code> 函数，那么这个编译过程会发生运行时，所以需要带有编译器的版本。</p></li></ul><blockquote><p>很显然，Runtime+Compiler 的编译过程对性能会有一定损耗，所以通常更推荐使用 Runtime Only 的 Vue.js。</p></blockquote><h2 id="从入口开始"><a href="#从入口开始" class="headerlink" title="从入口开始"></a>从入口开始</h2><p>分析 Runtime+Compiler 构建出来的 Vue.js，入口文件：</p><p><code>src/platforms/web/entry-runtime-with-complier.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./runtime/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>当代码执行 <code>import Vue from &#39;vue&#39;</code> 时，就是从这个入口执行代码来初始化 Vue。</p><h3 id="Vue-的入口"><a href="#Vue-的入口" class="headerlink" title="Vue 的入口"></a>Vue 的入口</h3><p>在上面的入口 JS 的上方可以找到 <code>Vue</code> 的来源：<code>import Vue from &#39;./runtime/index&#39;</code> </p><p><code>src/platforms/web/runtime/index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;core/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>关键的代码就是 <code>import Vue from &#39;core/index&#39;</code>，之后的逻辑都是对 Vue 这个对象做一些扩展。</p><p><code>src/core/index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;./instance/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; initGlobalAPI &#125; <span class="keyword">from</span> <span class="string">&#x27;./global-api/index&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">initGlobalAAPI(Vue)</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> Vue</span><br></pre></td></tr></table></figure><p>两处关键代码：</p><ul><li><code>import Vue from &#39;./instance/index&#39;</code> </li><li><code>initGlobalAPI(Vue)</code> </li></ul><h3 id="Vue-的定义"><a href="#Vue-的定义" class="headerlink" title="Vue 的定义"></a>Vue 的定义</h3><p><code>src/core/instance/index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; initMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./init&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; stateMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./state&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; renderMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./render&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; eventsMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./events&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; lifecycleMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;./lifecycle&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; warn &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)     </span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;Vue is a costructor and should be called with the `new` keyword&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里就是 Vue 的庐山真面目，它实际上就是一个用 Function 实现的类，只能通过 <code>new Vue</code> 去实例化它。</p><blockquote><p><strong>不使用 ES6 的 Class 实现的原因</strong>：这里有很多 混入 的函数调用，并把 <code>Vue</code> 当参数传入，都是给 Vue 的 prototype 上扩展一些方法，Vue 按功能将这些扩展分散到多个模块中去实现，而不是在一个模块中实现所有，这是使用 Class 难以实现的。</p><p>好处：方便代码的维护和管理。</p></blockquote><p><code>initGlobalAPI</code>：</p><p>Vue.js 在整个初始化的过程中，除了给它的原型 prototype 上扩展方法，还会给 Vue 这个对象本身扩展全局的静态方法，它的定义在 <code>src/core/global-api/index.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">import</span> config <span class="keyword">from</span> <span class="string">&#x27;../config&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// config</span></span><br><span class="line">  <span class="keyword">const</span> configDef = &#123;&#125;</span><br><span class="line">  configDef.get = <span class="function">() =&gt;</span> config</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    configDef.set = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      warn(<span class="string">&#x27;Do not replace the Vue.config object, set individual fields instead.&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(Vue, <span class="string">&#x27;config&#x27;</span>, configDef)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// exposed util methods</span></span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> these are not considered part of the public API - avoid relying on</span></span><br><span class="line">  <span class="comment">// them unless you are aware of the risk</span></span><br><span class="line">  Vue.util = &#123;</span><br><span class="line">    warn,</span><br><span class="line">    extend,</span><br><span class="line">    mergeOptions,</span><br><span class="line">    defineReactive</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Vue.set = set</span><br><span class="line">  Vue.delete = del</span><br><span class="line">  Vue.nextTick = nextTick</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.6 explicit observable API</span></span><br><span class="line">  Vue.observable = &lt;T&gt;(obj: T): <span class="function"><span class="params">T</span> =&gt;</span> &#123;</span><br><span class="line">    observe(obj)</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  Vue.options = <span class="built_in">Object</span>,create(<span class="literal">null</span>)</span><br><span class="line">  </span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.options[type + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;x multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">  extend(Vue.options.components, builtInComponents)</span><br><span class="line">  </span><br><span class="line">  initUse(Vue)</span><br><span class="line">  initMixin(Vue)</span><br><span class="line">  initExtend(Vue)</span><br><span class="line">  initAssetRegisters(Vue)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是在 Vue 上扩展的一些全局方法的定义。</p><blockquote><p>注意：<code>Vue.util</code> 暴露的方法最好不要依赖，因为它可能经常会发生变化，是不稳定的。</p></blockquote><h1 id="数据驱动"><a href="#数据驱动" class="headerlink" title="数据驱动"></a>数据驱动</h1><p>Vue.js 一个核心思想是<strong>数据驱动</strong>。</p><p>数据驱动：是指视图是由数据驱动生成的，对视图的修改不会直接操作 DOM，而是通过修改数据。</p><p>相比于 jQuery 等前端库直接修改 DOM，==大大简化了代码量==；当交互复杂时，只关心数据的修改会让==代码的逻辑变得非常清晰==，因为 DOM 变成了数据的映射，所有的逻辑都是对数据的修改，而不用触碰 DOM，这样的==代码非常利于维护==。</p><p>在 Vue.js 中可以采用简洁的模板语法来声明式的将数据渲染为 DOM：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123; message &#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这一部分主要是要弄清楚模板和数据如何渲染成最终的 DOM。</p><h2 id="new-Vue"><a href="#new-Vue" class="headerlink" title="new Vue"></a>new Vue</h2><p>先来分析 <code>new Vue</code> 背后发生了哪些事情。<code>new</code> 关键字在 JavaScript 中代表实例化是一个对象，而 <code>Vue</code> 实际上是一个类，类在 JavaScript 中是用 Function 来实现的。</p><p><code>src/core/instance/index.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      !(<span class="built_in">this</span> <span class="keyword">instanceof</span> Vue)</span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">&#x27;...&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码中可以看到 <code>Vue</code> 只能通过 new 关键字初始化，然后会调用 <code>this._init</code> 方法。</p><h3 id="this-init"><a href="#this-init" class="headerlink" title="this._init"></a>this._init</h3><p><code>src/core/instance/init.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  vm._uid = uid++</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> startTag, endTag</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;vm._uid&#125;</span>`</span></span><br><span class="line">    mark(StartTag)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  vm._isVue = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    initInteralComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    initProxy(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm._renderProxy = vm</span><br><span class="line">  &#125;</span><br><span class="line">  vm._self = vm</span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  initInjections(vm)</span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm)</span><br><span class="line">  callHook(vm)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    mark(endTag)</span><br><span class="line">    measure(<span class="string">`vue <span class="subst">$&#123;vm._name&#125;</span> init`</span>, startTag, endTag)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Vue 初始化主要工作：合并配置选项 <code>options</code>、初始化生命周期、初始化事件中心、初始化渲染、初始化 data、props、computed、watcher 等等。</p><h2 id="mount"><a href="#mount" class="headerlink" title="$mount"></a>$mount</h2><p>Vue 中是通过 <code>$mount</code> 实例方法去挂载 <code>vm</code> 的。</p><blockquote><p><code>$mount</code> 方法在多个文件中都有定义，如：</p><ul><li><code>src/platform/web/entry-runtime-with-compiler.js</code> </li><li><code>src/platform/web/runtime/index.js</code> </li><li><code>src/platform/weex/runtime/index.js</code> </li></ul><p>因为 <code>$mount</code> 这个方法的实现是和平台、构建方式都相关的。</p></blockquote><h3 id="complier-mount"><a href="#complier-mount" class="headerlink" title="complier $mount"></a>complier $mount</h3><p>分析 complier 版本的 <code>$mount</code>：</p><p><code>src/platform/web/entry-runtime-with-compiler.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mount = Vue.prototype.$mount</span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; query(el)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (el === <span class="built_in">document</span>.body || el === <span class="built_in">document</span>.documentElement) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Do not mount Vue to &lt;html&gt; or &lt;body&gt; - mount to normal elements instead.`</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> options = <span class="built_in">this</span>.$options</span><br><span class="line">  <span class="comment">// resolve template/el and convert to render function</span></span><br><span class="line">  <span class="keyword">if</span> (!options.render) &#123;</span><br><span class="line">    <span class="keyword">let</span> template = options.template</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> template === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (template.charAt(<span class="number">0</span>) === <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">          template = idToTemplate(template)</span><br><span class="line">          <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">          <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !template) &#123;</span><br><span class="line">            warn(</span><br><span class="line">              <span class="string">`Template element not fount or is empty: <span class="subst">$&#123;options.template&#125;</span>`</span>,</span><br><span class="line">              <span class="built_in">this</span></span><br><span class="line">            )</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (template.nodeType) &#123;</span><br><span class="line">        template = template.innerHTML</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>)&#123;</span><br><span class="line">          warn(<span class="string">&#x27;invaid template option:&#x27;</span> + template, <span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (el) &#123;</span><br><span class="line">      template = getOuterHTML(el)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (template) &#123;</span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">const</span> &#123; render, staticRenderFns &#125; = compileToFunctions(template, &#123;</span><br><span class="line">        <span class="attr">outputSourceRange</span>: process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>,</span><br><span class="line">        shouldDecodeNewLines,</span><br><span class="line">        shouldDecodeNewLinesForHref,</span><br><span class="line">        <span class="attr">delimiters</span>: options.delimiters,</span><br><span class="line">        <span class="attr">comments</span>: options.comments</span><br><span class="line">      &#125;, <span class="built_in">this</span>)</span><br><span class="line">      options.render = render</span><br><span class="line">      options.staticRenderFns = staticRenderFns</span><br><span class="line">      </span><br><span class="line">      <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; mark) &#123;</span><br><span class="line">        mark(<span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">        measure(<span class="string">`vue <span class="subst">$&#123;<span class="built_in">this</span>._name&#125;</span> compile`</span>, <span class="string">&#x27;compile&#x27;</span>, <span class="string">&#x27;compile end&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> mount.call(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>过程分析：</p><ul><li><p>首先缓存了原型上的 <code>$mount</code> 方法，再重新定义该方法；</p></li><li><p>对 <code>el</code> 做了限制，Vue 不能挂载在 body、html 这样的根节点上；</p></li><li><p>如果没有定义 <code>render</code> 方法，就会把 <code>el</code> 或者 <code>template</code> 字符串转换成 <code>render</code> 方法；</p><blockquote><p>在 Vue 2.0 版本中，所有的 Vue 的组件的渲染最终都需要 <code>render</code> 方法，无论是用单文件 .vue 方式开发组件，还是写了 <code>el</code> 或者 <code>template</code> 属性，最终都会转换成 <code>render</code> 方法，这个过程是 Vue 的一个 “在线编译” 的过程，它是调用 <code>compileToFunctions</code> 方法实现的。</p></blockquote></li><li><p>最后调用原先原型上的 <code>$mount</code> 方法挂载。</p></li></ul><h3 id="prototype-mount"><a href="#prototype-mount" class="headerlink" title="prototype $mount"></a>prototype $mount</h3><p><code>src/platform/web/runtime/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// public mount method</span></span><br><span class="line">Vue.prototype.$mount = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">el?: <span class="built_in">string</span> | Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  el = el &amp;&amp; inBrowser ? query(el) : <span class="literal">undefined</span></span><br><span class="line">  <span class="keyword">return</span> mountComponent(<span class="built_in">this</span>, el, hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型上的 <code>$mount</code> 方法支持传入 2 个参数：</p><ul><li><code>el</code>：表示挂载的元素，可以是字符串，也可以是 DOM 对象；<ul><li>如果是字符串在浏览器环境下会调用 <code>query</code> 方法转换成 DOM 对象</li></ul></li><li>第二个参数和服务端渲染相关，在浏览器环境下不需要传第二个参数</li></ul><p>实际会去调用 <code>mountComponent</code> 方法。</p><h3 id="mountComponent"><a href="#mountComponent" class="headerlink" title="mountComponent()"></a>mountComponent()</h3><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el: ?Element,</span></span></span><br><span class="line"><span class="params"><span class="function">   hydrating?: booolean</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="keyword">if</span> (!vm.$options.render) &#123;</span><br><span class="line">    vm.$options.render = createEmptyVNode</span><br><span class="line">    <span class="keyword">if</span> (processenv.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="comment">/* istannul ignore if */</span></span><br><span class="line">      <span class="keyword">if</span> ((vm.options.template &amp;&amp; vm.$options.template.charAt(<span class="number">0</span>) !== <span class="string">&#x27;#&#x27;</span>) || vm.$options.el || el) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You are using the runtime-only build of Vue where the template &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;compiler is not available. Either pre-compile the templates into &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;render functions, or use the compiler-included build.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;Failed to mount component: template or render function not defined.&#x27;</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> updateComponent</span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; config.performance &amp;&amp; mark) &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> name = vm._name</span><br><span class="line">      <span class="keyword">const</span> id = vm._uid</span><br><span class="line">      <span class="keyword">const</span> startTag = <span class="string">`vue-perf-start:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      <span class="keyword">const</span> endTag = <span class="string">`vue-perf-end:<span class="subst">$&#123;id&#125;</span>`</span></span><br><span class="line">      </span><br><span class="line">      mark(startTag)</span><br><span class="line">      <span class="keyword">const</span> vnode = vm._render()</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> render`</span>, startTag, endTag)</span><br><span class="line">      </span><br><span class="line">      mark(startTag)</span><br><span class="line">      vm._update(vnode, hydrating)</span><br><span class="line">      mark(endTag)</span><br><span class="line">      measure(<span class="string">`vue <span class="subst">$&#123;name&#125;</span> patch`</span>, startTag, endTag)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      vm._update(vm._render(), hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mount hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted &amp;&amp; !vm.isDestroyed) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  hydrating = <span class="literal">false</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child componentd in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    callHook(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p><code>mountComponent</code> 的核心就是先实例化一个渲染 <code>Watcher</code>，在它的回调函数中会调用 <code>updateComponent</code> 方法，在此方法中调用 <code>vm._render</code> 方法先生成虚拟 Node，最终调用 <code>vm._update</code> 更新 DOM。</p><p><code>Watcher</code> 在这里起到的两个作用：</p><ol><li>初始化时执行回调函数；</li><li>当 vm 实例中的检测是数据发生变化时执行回调函数。</li></ol><p>函数最后判断为根节点时设置 <code>vm._isMounted</code> 为 <code>true</code>，表示这个实例已经挂载了，同时执行 <code>mounted</code> 钩子函数。</p><blockquote><p>这里 <code>vm.$vnode</code> 表示 Vue 实例的父虚拟 Node，为 null 表示当前是根 Vue 的实例。</p></blockquote><h2 id="render"><a href="#render" class="headerlink" title="render"></a>render</h2><p>Vue 的 <code>_render</code> 方法是实例的一个私有方法，它用来把实例渲染成一个虚拟 Node。</p><p><code>src/core/instance/render.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    vm.$scoprdSlots = normalizeScopedSlots(</span><br><span class="line">      _parentVnode.data.scopedSlots,</span><br><span class="line">      vm.$slots,</span><br><span class="line">      vm.$scopedSlots</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set parent vnode. this allows render functions to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder onde.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// there&#x27;s no need to maintain a stack because all render fns are called</span></span><br><span class="line">    <span class="comment">// separately from one another. Nested component&#x27;s render fns are called</span></span><br><span class="line">    <span class="comment">// when parent component is patched.</span></span><br><span class="line">    currentRenderingInstance = vm</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    handleError(e, vm, <span class="string">`render`</span>)</span><br><span class="line">    <span class="comment">// return error render result</span></span><br><span class="line">    <span class="comment">// or previous vnode to prevent render error causing blank component</span></span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; vm.$options.renderError) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`renderError`</span>)</span><br><span class="line">        vnode = vm._vnode</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = vm._vnode</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    currentRenderingInstance = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if the returned array contains only a single node, allow it</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(vnode) &amp;&amp; vnode.length === <span class="number">1</span>) &#123;</span><br><span class="line">    vnode = vnode[<span class="number">0</span>]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// return empty vnode in case the render function errored out</span></span><br><span class="line">  <span class="keyword">if</span> (!(vnode <span class="keyword">instanceof</span> VNode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="built_in">Array</span>.isArray(vnode)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Multiple root nodes returned from render function, Render function &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;should return a single root node.&#x27;</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    vonde = createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>最关键的是 <code>render </code> 方法的调用。</p><p>在平时的开发中手写 <code>render</code> 方法的场景比较少，而写的比较多的是 <code>template</code> 模板，在之前的 <code>mounted</code> 方法的实现中，会把 <code>template</code> 编译成 <code>render</code> 方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vnode = render.call(vm._renderProxy, vm.$createElement)</span><br></pre></td></tr></table></figure><p>可以看到，<code>render</code> 函数中的 <code>createElement</code> 方法就是 <code>vm.$createElement</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// bind the createElement fn to this instance</span></span><br><span class="line">  <span class="comment">// so that we get proper render context inside it.</span></span><br><span class="line">  <span class="comment">// args order: tag, data, children, normalizationType, alwaysNormalize</span></span><br><span class="line">  <span class="comment">// internal version is used by render functions compiled from templates</span></span><br><span class="line">  vm._c = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">false</span>)</span><br><span class="line">  <span class="comment">// normaliztion is always applied for the public version, used in </span></span><br><span class="line">  <span class="comment">// user-written render functions.</span></span><br><span class="line">  vm.$createElement = <span class="function">(<span class="params">a, b, c, d</span>) =&gt;</span> createElement(vm, a, b, c, d, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上， <code>vm.$createElement</code> 方法定义是在执行 <code>initRender</code> 方法的时候，除了该方法，还有一个 <code>vm._c</code> 方法，它是被模板编译成的 <code>render</code> 函数使用，而 <code>vm.$createElement</code> 是用户手写 <code>render </code>方法使用的，这两个方法支持的参数相同，且内部都调用了 <code>createElement</code> 方法。</p><blockquote><p><code>vm._render</code> 最终是通过执行 <code>createElement</code> 方法并返回的是 <code>vnode</code>，它是一个虚拟 Node。</p></blockquote><h2 id="Virtual-DOM"><a href="#Virtual-DOM" class="headerlink" title="Virtual DOM"></a>Virtual DOM</h2><p>在浏览器中将一个简单的 div 元素的属性全部遍历出来：</p><p>![DOM元素的属性](vue 源码/image-20211117132229078.png)</p><p>真正的 DOM 元素是非常庞大的，因为浏览器的标准就把 DOM 设计的非常复杂。当进行频繁的去做 DOM 更新，会产生一定的性能问题。</p><p>而 Virtual DOM 就是用一个原生的 JS 对象去描述一个 DOM 节点，所以它比创建一个 DOM 的代价要小很多。</p><p>在 Vue.js 中，Virtual DOM 是用一个叫 VNode 的 Class 去描述。</p><p><code>src/core/vdom/vnode.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* @flow */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">VNode</span> </span>&#123;</span><br><span class="line"><span class="attr">tag</span>: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  data: VNodeData | <span class="built_in">void</span>;</span><br><span class="line">  children: ?<span class="built_in">Array</span>&lt;VNode&gt;;</span><br><span class="line">  text: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  elm: Node | <span class="built_in">void</span>;</span><br><span class="line">  ns: <span class="built_in">string</span> | <span class="built_in">void</span>;</span><br><span class="line">  context: Component | <span class="built_in">void</span>;</span><br><span class="line">  key: stirng | <span class="built_in">number</span> | <span class="built_in">void</span>;</span><br><span class="line">  componentOptions: VNodeComponentOptions | <span class="built_in">void</span>;</span><br><span class="line">  componentInstance: Component | <span class="built_in">void</span>;</span><br><span class="line">  parent: VNode | <span class="built_in">void</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// strictly internal</span></span><br><span class="line">  raw: <span class="built_in">boolean</span>;</span><br><span class="line">isStatic: <span class="built_in">boolean</span>;</span><br><span class="line">isRootInsert: <span class="built_in">boolean</span>;</span><br><span class="line">  isComment: <span class="built_in">boolean</span>;</span><br><span class="line">  isCloned: <span class="built_in">boolean</span>;</span><br><span class="line">  isOnce: <span class="built_in">boolean</span>;</span><br><span class="line">  asyncFactory: <span class="built_in">Function</span> | <span class="built_in">void</span>;</span><br><span class="line">  asyncMeta: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  isAsyncPlaceholder: <span class="built_in">boolean</span>;</span><br><span class="line">  ssrContext: <span class="built_in">Object</span> | <span class="built_in">void</span>;</span><br><span class="line">  fnContext: Component | <span class="built_in">void</span>;</span><br><span class="line">  fnOptions: ?ComponentOptions;</span><br><span class="line">fnScopeId: ?stirng;</span><br><span class="line"></span><br><span class="line"><span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">    tag?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    data?: VNodeData,</span></span><br><span class="line"><span class="params">    children?: ?<span class="built_in">Array</span>&lt;VNode&gt;,</span></span><br><span class="line"><span class="params">    text?: <span class="built_in">string</span>,</span></span><br><span class="line"><span class="params">    elm?: Node,</span></span><br><span class="line"><span class="params">    context?: Component,</span></span><br><span class="line"><span class="params">    componentOptions?: VNodeComponentOptions,</span></span><br><span class="line"><span class="params">    asyncFactory?: <span class="built_in">Function</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.tag = tag</span><br><span class="line">    <span class="built_in">this</span>.data = data</span><br><span class="line">    <span class="built_in">this</span>.children = children</span><br><span class="line">    <span class="built_in">this</span>.text = <span class="built_in">this</span>.text</span><br><span class="line">    <span class="built_in">this</span>.elm = <span class="built_in">this</span>.elm</span><br><span class="line">    <span class="built_in">this</span>.ns = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.context = context</span><br><span class="line">    <span class="built_in">this</span>.fnContext = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnOptions = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.fnScopeId = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.key = data &amp;&amp; data.key</span><br><span class="line">    <span class="built_in">this</span>.componentOptions = componentOptions</span><br><span class="line">  <span class="built_in">this</span>.componentInstance = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.parent = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.raw = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isStatic = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isRootInsert = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.isComment = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isCloned = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.isOnce = <span class="literal">false</span></span><br><span class="line">    <span class="built_in">this</span>.asyncFactory = asyncFactory</span><br><span class="line">    <span class="built_in">this</span>.asyncMeta = <span class="literal">undefined</span></span><br><span class="line">    <span class="built_in">this</span>.isAsyncPlaceholder = <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DEPRECATED: alias for componentInstance for backwards compat.</span></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line">get child (): Component | <span class="built_in">void</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.componentInstance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到 Vue.js 中的 Virtual DOM 的定义还是略微复杂一些的，因为其中包含了很多 Vue.js 的特性。</p><blockquote><p>Vue.js 中 Virtual DOM 借鉴了一个开源库 <a href="https://github.com/snabbdom/snabbdom">snabbdom</a> 的实现，然后加入了一些 Vue.js 特色的东西。</p></blockquote><p>VNode 是对真实 DOM 的一种抽象描述，它的核心定义无非就几个关键属性，标签名、数据、子节点、键值等，其他属性都是用来扩展 VNode 的灵活性以及实现一些特殊 feature 的。</p><p>因为 VNode 只是用来映射到真实 DOM 的渲染，不需要包含操作 DOM 的方法，因此它是非常 <strong>轻量</strong> 和 <strong>简单</strong> 的。</p><h2 id="createElement"><a href="#createElement" class="headerlink" title="createElement"></a>createElement</h2><p>Vue.js 利用 createElement 方法创建 VNode。</p><p><code>src/core/vdom/create-element.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrapper function for providing a more flexible interface</span></span><br><span class="line"><span class="comment">// without gettting yelled at by flow</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">creatElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  tag: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  data: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  children: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  normalizationType: <span class="built_in">boolean</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  alwaysNormalize: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(data) || isPrimitive(data)) &#123;</span><br><span class="line">    normalizationType = children</span><br><span class="line">    children = data</span><br><span class="line">    data = <span class="literal">undefined</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(alwaysNormalize)) &#123;</span><br><span class="line">    normalizationType = ALWAYS_NORMALIZE</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> _createElement(context, tag, data, children, normalizationType)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElement</code> 方法实际上是对 <code>_createElement</code> 方法的封装，它允许传入的参数更加灵活，在处理之后，调用真正创建 VNode 的函数 <code>_createElement</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span> | Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data?: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> children?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> normalizationType?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef((data: <span class="built_in">any</span>).__ob__)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`Avoid using observed data object as vnode data: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(data)&#125;</span>\n`</span> +</span><br><span class="line">      <span class="string">&#x27;Always create fresh vnode data objects in each render!&#x27;</span>,</span><br><span class="line">      context</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> creatEmptyVNode()</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// object syntax in v-bind</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data) &amp;&amp; isDef(data.is)) &#123;</span><br><span class="line">    tag = data.is</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!tag) &#123;</span><br><span class="line">    <span class="comment">// in case of component :is set to falsy value</span></span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// warn against non-primitive key</span></span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      isDef(data) &amp;&amp; isDef(data.key) &amp;&amp; !isPrimitive(data.key)</span><br><span class="line">     ) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!__WEEX__ || !(<span class="string">&#x27;@binding&#x27;</span> <span class="keyword">in</span> data.key)) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">&#x27;Avoid using non-proimitive value as key, &#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;use string/number value instend &#x27;</span>,</span><br><span class="line">        context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// support single function children as default scoped slot</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children) &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> children[<span class="number">0</span>] === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">     ) &#123;</span><br><span class="line">    data = data || &#123;&#125;</span><br><span class="line">    data.scopedSlots = &#123; <span class="attr">default</span>: children[<span class="number">0</span>] &#125;</span><br><span class="line">    children.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (normalizationType === ALWAYS_NORMALIZE) &#123;</span><br><span class="line">    children = normalizeChildren(children)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (normalizationType === SIMPLE_NORMALIZE) &#123;</span><br><span class="line">    children = simpleNormalChildren(children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vonde &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; isDef(data) &amp;&amp; isDef(data.nativeOn) &amp;&amp; data.tag !== <span class="string">&#x27;component&#x27;</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`The .native modifier for v-on only valid components but it was used on &lt;<span class="subst">$&#123;tag&#125;</span>&gt;`</span>,</span><br><span class="line">          context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((!data || !data.pre) &amp;&amp; isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; </span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponet(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Arra.isArray(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(vnode)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ns)) applyNS(vnode, ns)</span><br><span class="line">    <span class="keyword">if</span> (isDef(data)) registerDeepBindings(data)</span><br><span class="line">    <span class="keyword">return</span> vnode</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> createEmptyVNode()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码参数分析：</p><p><code>_createElement</code> 方法有 5 个参数：</p><ul><li><code>context</code> 表示 VNode 的上下文环境，它是 <code>Component</code> 类型；</li><li><code>tag</code> 表示标签，它可以是一个字符串，而也可以是一个 <code>Component</code>；</li><li><code>data</code> 表示 VNode 的数据，它是一个 <code>VNodeData</code> 类型，可以在 <code>flow/vnode.js</code> 中找到定义</li><li><code>children</code> 表示当前 VNode 的子节点，是任意类型的，但之后会被规范为标准的 VNode 数组；</li><li><code>normalizationType</code> 表示子节点规范的类型，类型不同规范的方法就不同，主要参考 render 函数是编译生成还是用户手写的</li></ul><h3 id="children-的规范化"><a href="#children-的规范化" class="headerlink" title="children 的规范化"></a>children 的规范化</h3><p>Virtual DOM 实际上是一个树状结构，每一个 VNode 可能会有若干个子节点，这些子节点应该也是 VNode 的类型，所以需要对 <code>_createElement</code> 接收的 4 个参数 children 进行规范化：</p><p>根据 <code>normalizationType</code> 的不同，分别调用 <code>normalizeChildren(children)</code> 和 <code>simpleNormalizeChildren(children)</code> 方法。</p><p><code>src/core/vdom/helpers/normalzie-children.js</code>：</p><p><strong>simpleNormalizeChildren()</strong> </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">simpleNormalizeChildren</span> (<span class="params">children: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Arrar.isArray(children[i])) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.concat.apply([], children)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> children</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>simpleNormalizeChildren</code> 方法的调用场景是 <code>render</code> 函数是编译生成的。</p><p>理论上编译生成的 <code>chiuldren</code> 都已经是 VNode 类型的，但会有一个例外，就是 <code>functional component</code> 函数式组件返回的是一个数组而不是一个根节点，所以会通过 <code>Array.prototype.concat</code> 方法将整个 <code>children</code> 数组打平。让它的深度只有一层。</p><p><strong>normalizeChildren()</strong> </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">normalizeChildren</span> (<span class="params">children: <span class="built_in">any</span></span>): ?<span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> isPrimitive(children)</span><br><span class="line">  ? [createTextVNode(children)]</span><br><span class="line">: <span class="built_in">Array</span>.isArray(children)</span><br><span class="line">? normalizeArrayChildren(children)</span><br><span class="line">: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeChildren</code> 方法的调用场景有两种：</p><ul><li><code>render</code> 函数是用户手写的，当 <code>children</code> 之后一个节点的时候，Vue.js 从接口层面允许用户把 <code>children</code> 写成基础类型来创建单个简单的文本节点，则调用 <code>creatTextVNode</code> 创建一个文本节点的 VNode；</li><li>当编译 <code>slot</code>、<code>v-for</code> 时会产生嵌套数组的情况，会调用 <code>normalizeArrayChildren</code> 方法。</li></ul><p><strong>normalizeArrayChildren()</strong> </p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normalizeArrayChildren</span> (<span class="params">children: <span class="built_in">any</span>, nestedIndex?: <span class="built_in">string</span></span>): <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">let</span> i, c, lastIndex, last</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>, i &lt; children.length; i++) &#123;</span><br><span class="line">    c = children[i]</span><br><span class="line">    <span class="keyword">if</span> (inUndef(c) || <span class="keyword">typeof</span> c === <span class="string">&#x27;boolean&#x27;</span>) <span class="keyword">continue</span></span><br><span class="line">    lastIndex = res.length - <span class="number">1</span></span><br><span class="line">    last = res[lastIndex]</span><br><span class="line">    <span class="comment">// nested</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (c.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        c = normalizeArrayChildren(c, <span class="string">`<span class="subst">$&#123;nestedIndex || <span class="string">&#x27;&#x27;</span>&#125;</span>_<span class="subst">$&#123;i&#125;</span>`</span>)</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="keyword">if</span> (isTextNode(c[<span class="number">0</span>]) &amp;&amp; isTextNode(last)) &#123;</span><br><span class="line">          res[lastIndex] = createTextVNode(last.text + (c[<span class="number">0</span>]: <span class="built_in">any</span>).text)</span><br><span class="line">          c.shift()</span><br><span class="line">        &#125;</span><br><span class="line">        res.push.apply(res, c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(c)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        <span class="comment">// this is necessary for SSR bydration because text nodes are</span></span><br><span class="line">        <span class="comment">// essentialy merged when renderd to HTML strings</span></span><br><span class="line">        res[lastIndex] = createTextVNode(last.text + c)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (c !== <span class="string">&#x27;&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// convert primitive to vnode</span></span><br><span class="line">        res.push(createTextVNode(c))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (isTextNode(c) &amp;&amp; isTextNopde(last)) &#123;</span><br><span class="line">        <span class="comment">// merge adjacent text nodes</span></span><br><span class="line">        res[lastIndex = createTextVNode(last.text + c.text)]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// default key for nexted array children (likely generated by v-for)</span></span><br><span class="line">        <span class="keyword">if</span> (isTure(children.siVList) &amp;&amp;</span><br><span class="line">            isDef(c.tag) &amp;&amp;</span><br><span class="line">            isUndef(c.key) &amp;&amp;</span><br><span class="line">            isDef(nestedIndex)) &#123;</span><br><span class="line">          c.key = <span class="string">`__vlist<span class="subst">$&#123;nestedIndex&#125;</span>_<span class="subst">$&#123;i&#125;</span>__`</span></span><br><span class="line">        &#125;</span><br><span class="line">        res.push(c)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>normalizeArrayChildren</code> 接收 2 个参数：</p><ul><li><code>children</code> 表示要进行规范的子节点；</li><li><code>nestedIndex</code> 表示嵌套的索引，因为单个 <code>child</code> 可能是一个数组类型。</li></ul><p>方法的主要逻辑就是 遍历 <code>children</code>，获得单个节点 <code>c</code>，然后对 <code>c</code> 的类型判断，如果是一个数组类型，则递归调用 <code>normalizeArrayChildren</code>；如果是基础类型，则通过 <code>createTextVNode</code> 方法转换成 VNode 类型；否则本来就是 VNode 类型。如果 <code>children</code> 是一个列表并且列表还存在嵌套的情况，则根据 <code>nestedIndex</code> 去更新它的 key。</p><p>其中还做了优化处理：</p><p>如果存在两个连续的 <code>text</code> 节点，则会合并为一个 <code>text</code> 节点。</p><h3 id="VNode-的创建"><a href="#VNode-的创建" class="headerlink" title="VNode 的创建"></a>VNode 的创建</h3><p>规范化 <code>children</code> 之后，接下来会去创建一个 VNode 的实例：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params">context, tag, data, children, normalizationType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;stirng&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.parsePlatformTagName(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;components&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>先对 <code>tag</code> 做判断：</p><ul><li>如果是 <code>string</code> 类型，则接着判断；<ul><li>如果是内置的一些节点，则直接创建一个普通 VNode；</li><li>如果是为已注册的组件名，则通过 <code>createComponent</code> 创建一个组件类型的 VNode；</li><li>否则创建一个未知的标签的 VNode；</li></ul></li><li>如果 <code>tag</code> 是 <code>Component</code> 类型，则直接调用 <code>createElement</code> 创建一个组件类型的 VNode 节点。</li></ul><h3 id="补充方法"><a href="#补充方法" class="headerlink" title="补充方法"></a>补充方法</h3><h4 id="判断类型方法"><a href="#判断类型方法" class="headerlink" title="判断类型方法"></a>判断类型方法</h4><p><code>src/shared/util.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">inUndef</span> (<span class="params">v: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v === <span class="literal">undefined</span> || v === <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isDef</span> (<span class="params">v: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v !== <span class="literal">undefined</span> &amp;&amp; v !== <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Check if value is primitive.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">isPrimitive</span> (<span class="params">value: <span class="built_in">any</span></span>): <span class="title">boolean</span> %<span class="title">checks</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;string&#x27;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;number&#x27;</span> ||</span><br><span class="line">    <span class="comment">// $flow-disable-line</span></span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;symbol&#x27;</span> ||</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;boolean&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createEmptyVNode"><a href="#createEmptyVNode" class="headerlink" title="createEmptyVNode"></a>createEmptyVNode</h4><p><code>src/core/vdom/vnode.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> createEmptyVNode = <span class="function">(<span class="params">text: stirng = <span class="string">&#x27;&#x27;</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> VNode()</span><br><span class="line">  node.text = text</span><br><span class="line">  node.isComment = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="createTextVNode"><a href="#createTextVNode" class="headerlink" title="createTextVNode"></a>createTextVNode</h4><p><code>src/core/vdom/vnode.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createTextVNode</span> (<span class="params">val: <span class="built_in">string</span> | <span class="built_in">number</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(<span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="built_in">String</span>(val))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="update"><a href="#update" class="headerlink" title="update"></a>update</h2><p>Vue 的 <code>_update</code> 是实例的一个私有方法。</p><p>被调用的时机有 2 个：</p><ul><li>首次渲染</li><li>数据更新</li></ul><h3 id="update-1"><a href="#update-1" class="headerlink" title="_update"></a>_update</h3><p><code>_update</code> 方法的作用是把 VNode 渲染成真实的 DOM</p><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">lifecycleMixin</span> (<span class="params">Vue: Class&lt;Componment&gt;</span>) </span>&#123;</span><br><span class="line">  Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">    <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">    <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">    <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">    vm._vnode = vnode</span><br><span class="line">    <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">    <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">    <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">      <span class="comment">// initial render</span></span><br><span class="line">      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// updates</span></span><br><span class="line">      vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">    &#125;</span><br><span class="line">    restoreActiveInstance()</span><br><span class="line">    <span class="comment">// update __vue__ reference</span></span><br><span class="line">    <span class="keyword">if</span> (!prevEl) &#123;</span><br><span class="line">      prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">      vm.$el.__vue__ = vm</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">    <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">      vm.$parent.$el = vm.$el</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">    <span class="comment">// updated in a parent&#x27;s updated hook.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="patch"><a href="#patch" class="headerlink" title="__patch__"></a>__patch__</h3><p><code>_update</code> 的核心就是调用 <code>vm.__patch__</code> 方法，在不同平台（web 和 weex）上的定义是不一样的：</p><p><code>src/platforms/web/runtime/index.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install platfomr patch method</span></span><br><span class="line">Vue.prototype.__patch__ = inBrowser ? patch : noop</span><br></pre></td></tr></table></figure><p>在 web 平台上，是否是服务器端渲染也会对这个方法产生影响。因为在服务器端渲染中，没有真实的浏览器 DOM 环境，所以不需要把 VNode 最终转换成 DOM，因此是一个空函数 <code>noop</code>，而在浏览器端渲染中，它指向了 <code>patch</code> 方法。</p><p><code>src/platforms/web/runtime/patch.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> nodeOps <span class="keyword">from</span> <span class="string">&#x27;web.runtime/node-ops&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; createPatchFunction &#125; <span class="keyword">from</span> <span class="string">&#x27;core/vdom/patch&#x27;</span></span><br><span class="line"><span class="keyword">import</span> baseModules <span class="keyword">from</span> <span class="string">&#x27;core/vdom/modules/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> platformModules <span class="keyword">from</span> <span class="string">&#x27;web/runtime/modules/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// the directive module should be applied last, after all</span></span><br><span class="line"><span class="comment">// built-in modules have been applied.</span></span><br><span class="line"><span class="keyword">const</span> modules = platformModules.concat(baseModules)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> patch: <span class="built_in">Function</span> = createPatchFunction(&#123; nodeOps, modules &#125;)</span><br></pre></td></tr></table></figure><p>该方法的定义是调用 <code>createPatchFunction</code> 方法的返回值，这里传入了一个对象，包含 <code>nodeOps</code> 参数和 <code>modules</code> 参数：</p><ul><li><code>nodeOps</code> 封装了一系列 DOM 操作的方法；</li><li><code>modules</code> 定义了一些模块的钩子函数的实现。</li></ul><h3 id="createPatchFunction"><a href="#createPatchFunction" class="headerlink" title="createPatchFunction"></a>createPatchFunction</h3><p>定义在 <code>src/core/vdom/patch.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hooks = [<span class="string">&#x27;create&#x27;</span>, <span class="string">&#x27;activate&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;remove&#x27;</span>, <span class="string">&#x27;destroy&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createPatchFunction</span> (<span class="params">backend</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, j</span><br><span class="line">  <span class="keyword">const</span> cbs = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> &#123; modules, nodeOps &#125; = backend</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; hooks.length; ++i) &#123;</span><br><span class="line">    cbs[hooks[i]] = []</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; modules.length; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDef(modules[j][hooks[i]])) &#123;</span><br><span class="line">        cbs[hooks[i]].push(modules[j][hooks[i]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createPatchFunction</code> 内部定义了一系列辅助方法，最终返回了一个 <code>patch</code> 方法，这个方法就赋值给了 <code>vm._update</code> 函数里调用的 <code>vm.__patch__</code>。</p><blockquote><p>相关代码分散到各个目录，不在一个文件中定义的好处：</p><p><code>patch</code> 是平台相关的，在 Web 和 Weex 环境中把虚拟 DOM 映射到 “平台 DOM” 的方法是不同的，并且对 “DOM” 包括的属性模块创建和更新也不尽相同。因此每个平台都有各自的 <code>nodeOps</code> 和 <code>modules</code>，它们的代码需要托管到 <code>src/platforms</code> 这个大目录下。</p><p>而不同平台的 <code>patch</code> 的主要逻辑部分是相同的，所以这部分公共的部分托管在 <code>core</code> 这个大目录下，差异化部分只需要通过参数来区别，这里用到了一个<strong>函数柯里化</strong>的技巧，通过 <code>createPatchFunction</code> 把差异化参数提前固化，这样不用每次都调用 <code>patch</code> 的时候都传递 <code>nodeOps</code> 和 <code>modules</code> 了。</p></blockquote><blockquote><p><a href="https://www.jianshu.com/p/2975c25e4d71"><strong>函数柯里化</strong></a>：（Currying），把接收多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通的 add 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Currying 后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curryingAdd</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">y</span>) </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> x + y</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>)<span class="comment">// 3</span></span><br><span class="line">curryingAdd(<span class="number">1</span>)(<span class="number">2</span>)<span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>好处：</p><ol><li>参数复用</li><li>提前确认</li><li>延迟运行</li></ol><p>性能：</p><ul><li>存取 arguments 对象通常要比存取命名参数要慢一点；</li><li>老版本的浏览器在 arguments.length 的实现上相当慢；</li><li>使用 fn.apply(…) 和 fn.call(…) 通常比直接调用 fn(…) 稍微慢点；</li><li>创建大量嵌套作用域和闭包函数会带来内存和速度上的花销。</li></ul></blockquote><ul><li><code>nodeOps</code> 表示对 “平台 DOM” 的一些操作方法；</li><li><code>modules</code> 表示平台的一些模块，它们会在整个 <code>patch</code> 过程的不同阶段执行相应的钩子函数。</li></ul><p>代码分析：</p><p><code>patch</code> 方法接收 4 个参数：</p><ul><li><code>oldVnode</code> 表示旧的 VNode 节点，它也可以不存在或者是一个 DOM 对象；</li><li><code>vnode</code> 表示执行 <code>_render</code> 后返回的 VNode 的节点；</li><li><code>hydrating</code> 表示是否是服务端渲染；</li><li><code>removeOnly</code> 是给 <code>transition-group</code> 使用的。</li></ul><p>结合一个小例子：</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- ... --&gt;</span></span><br></pre></td></tr></table></figure><p>main.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>, &#123;</span><br><span class="line">      <span class="attr">attrs</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="string">&#x27;app&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, <span class="built_in">this</span>.message)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">message</span>: <span class="string">&#x27;Hello Vue!&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 <code>vm._update</code> 的方法里调用 <code>patch</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initial render</span></span><br><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line"><span class="comment">//            ⇩</span></span><br><span class="line"><span class="comment">// 对应返回的 patch 函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br></pre></td></tr></table></figure><p>场景为首次渲染，所以在执行 <code>patch</code> 函数时，传入的参数情况：</p><ul><li> <code>vm.$el</code> 对应的是例子中 id 为 <code>app</code> 的 DOM 对象，也就是在 index.html 中写的 <code>&lt;div id=&quot;app&quot;&gt;</code>，<code>vm.$el</code> 的赋值是在之前的 <code>mountComponent</code> 函数做的；</li><li><code>vnode</code> 对应的是调用 <code>render</code> 函数的返回值；</li><li><code>hydrating</code> 在非服务端渲染的情况下为 false；</li><li><code>removeOnly</code> 为 false。</li></ul><p>回看 <code>patch</code> 执行的关键步骤：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isRealElement = isDef(oldVnode.nodeType) <span class="comment">// true</span></span><br><span class="line"><span class="keyword">if</span> (!isRealElement &amp;&amp; sameVnode(oldeVnode, vnode)) &#123;</span><br><span class="line">  <span class="comment">// patch existing root node</span></span><br><span class="line">  patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isRealElement) &#123;</span><br><span class="line">   <span class="comment">// mounting to a real element</span></span><br><span class="line">    <span class="comment">// check if this is server-rendered content and if we can perform</span></span><br><span class="line">    <span class="comment">// a successful hydration.</span></span><br><span class="line">    <span class="keyword">if</span> (oldVnode.nodeType === <span class="number">1</span> &amp;&amp; oldVnode.hasVnode.hasAttribute(SSR_ATTR)) &#123;</span><br><span class="line">      oldVnode.removeAttribute(SSR_ATTR)</span><br><span class="line">      hydrating = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isTrue(hydrating)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hydrate(oldVnode, vnode, insertedVnodeQueue)) &#123;</span><br><span class="line">        invokeInsertHook(vnode, insertVnodeQueue, <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span> oldVnode</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;The client-side rendered virtual DOM tree is not matching &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;server-rendered content. This is likely caused by incorrect &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;HTML markup, for example nesting block-level elements inside &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;&lt;p&gt;, or missing &lt;tbody&gt;. Bailing hyration and performing &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;full client-side render.&#x27;</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// enther not server-rendered, or hydration failed.</span></span><br><span class="line">    <span class="comment">// create an empty node and replace it</span></span><br><span class="line">    oldVnode = emptyNodeAt(oldVnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// replacing existing element</span></span><br><span class="line">  <span class="keyword">const</span> oldElm = oldValue.elm</span><br><span class="line">  <span class="keyword">const</span> parentELm = nodeOps.parentNode(oldELm)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create new node</span></span><br><span class="line">  createElm(</span><br><span class="line">    vnode,</span><br><span class="line">    insertedVnodeQueue,</span><br><span class="line">    <span class="comment">// extremely rare edge case: do not insert if old element is in a</span></span><br><span class="line">    <span class="comment">// leaving transition. Only happens when combining transtion +</span></span><br><span class="line">    <span class="comment">// keep-alive + HOCs. (#4590)</span></span><br><span class="line">    oldElm._leaveCb ? <span class="literal">null</span> : parentElm,</span><br><span class="line">    nodeOps.nextSibling(oldElm)</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中传入的 <code>oldValue</code> 实际上是一个 DOM container（DOM 容器），所以 <code>isRealELement</code> 为 true，接下来通过 <code>emptyNodeAt</code> 方法把 <code>oldVnode</code> 转换成 <code>VNode</code> 对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">emptyNodeAt</span> (<span class="params">elm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> VNode(nodeOps.tagName(elm).toLowerCase, &#123;&#125;, [], <span class="literal">undefined</span>, elm)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后再调用 <code>createElm</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> creatingElmInVPre = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  vnode,</span></span></span><br><span class="line"><span class="params"><span class="function">  insertedVnodeQueue,</span></span></span><br><span class="line"><span class="params"><span class="function">  parentElm,</span></span></span><br><span class="line"><span class="params"><span class="function">  refElm,</span></span></span><br><span class="line"><span class="params"><span class="function">  nested,</span></span></span><br><span class="line"><span class="params"><span class="function">  ownerArray,</span></span></span><br><span class="line"><span class="params"><span class="function">  index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(vnode.elm) &amp;&amp; isDef(ownerArray)) &#123;</span><br><span class="line">    <span class="comment">// This vnode was used in a previous render!</span></span><br><span class="line">    <span class="comment">// now it&#x27;s used as a new node, overwriting its elm would cause</span></span><br><span class="line">    <span class="comment">// potential patch errors down the road when it&#x27;s used as a n insertion</span></span><br><span class="line">    <span class="comment">// reference node. Instead, we clone the node no-demand before creating</span></span><br><span class="line">    <span class="comment">// associated DOM element for it.</span></span><br><span class="line">    vnode = ownerArray[index] = cloneVNode(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vnode.isRootInsert = !nested <span class="comment">// for transition enter back</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag = vnode.tag</span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (data &amp;&amp; data.pre) &#123;</span><br><span class="line">        creatingElmInVPre++</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (isUnknownELement(vnode, creatingElmInVPre)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;unknown custom element: &lt;&#x27;</span> + tag + <span class="string">&#x27;&gt; - did you &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;register the component correctly? For recursive components, &#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;make sure to provide the &quot;name&quot; option.&#x27;</span>,</span><br><span class="line">          vnode.context</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">    ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">    : nodeOps.createElement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (process.en.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; data &amp;&amp; data.pre) &#123;</span><br><span class="line">      createElmInVPre--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isCommon)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode,elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElm</code> 的作用是通过虚拟节点创建真实的 DOM 并插入到它的父节点中。关键逻辑：</p><ul><li><code>createComponent</code> 方法目的是尝试创建子组件，组件篇章会详细展开分析，当前返回值为 false；</li><li>接下来判断 <code>vnode</code> 是否包含 <code>tag</code>，如果包含，先简单对 tag 的合法性在非生产环境下做校验，看是否是一个合法标签；</li><li>再去调用平台 DOM 的操作去创建一个占位符元素</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vnode.elm = vnode.ns</span><br><span class="line">? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">: nodeOps.createElement(tag, vnode)</span><br></pre></td></tr></table></figure><ul><li>接下来调用 <code>createChildren</code> 方法去创建子元素：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">createChildren(vnode, children, insertedVnodeQueue)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createChildren</span> (<span class="params">vnode, children, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(children)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      checkDuplicateKeys(children)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; children.length; ++i) &#123;</span><br><span class="line">      createElm(chidren[i], insertedVnodeQueue, vnode.elm, <span class="literal">null</span>, <span class="literal">true</span>, children, i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isPrimitive(vnode.text)) &#123;</span><br><span class="line">    nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(<span class="built_in">String</span>(vnode.text)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createChildren</code> 的逻辑很简单，遍历子虚拟节点，递归调用 <code>createElm</code>，这是一种常用的深度优先的遍历算法，遍历的过程中会把 <code>vnode.elm</code> 作为父容器的 DOM 节点占位符传入。</p><ul><li>接着再调用 <code>invokeCreateHooks</code> 方法执行所有的 create 的钩子并把 <code>vnode</code> push 到 <code>insertedVnodeQueue</code> 中：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ifDef(data)) &#123;</span><br><span class="line">  invokeCreateHooks(vnode, insertedVnodeQueue)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeCreateHooks</span> (<span class="params">vnode, insertedVnodeQueue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; cbs.create.length; ++i) &#123;</span><br><span class="line">    cbs.create[i](emptyNode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  i = vnode.data.hook <span class="comment">// Reuse variable</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(i.create)) i.create(emptyNode, vnode)</span><br><span class="line">    <span class="keyword">if</span> (isDef(i.insert)) insertedVnodeQueue.push(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>最后调用 <code>insert</code> 方法把 <code>DOM</code> 插入到父节点中，因为是递归调用，子元素会优先调用 <code>insert</code>，所以整个 <code>vnode</code> 树节点的插入顺序是 <strong>先子后父</strong>：</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">insert(parentElm, vnode.elm, refElm)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span> (<span class="params">parent, elm, ref</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(parent)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isDef(ref)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ref.parentNode === parent) &#123;</span><br><span class="line">        nodeOps.insertBefore(parent, elm, ref)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nodeOps.appendChild(parent, elm)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>insert</code> 的逻辑：调用一些 <code>nodeOps</code> 把子节点插入到父节点中：</p><p><code>src/platforms/web/runtime/node-ops.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">insertBefore</span> (<span class="params">parentNode: Node, newNode: Node, referenceNode: Node</span>) </span>&#123;</span><br><span class="line">  parentNode.insertBefore(newNode, referenceNode)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">appendChild</span> (<span class="params">node: Node, child: Node</span>) </span>&#123;</span><br><span class="line">  node.appendChild(child)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是调用原生 DOM 的 API 进行 DOM 操作。</p><p>在 <code>createELm</code> 过程中，如果 <code>vnode</code> 节点不包含 <code>tag</code>，则它又可能是一个注释或者纯文本节点，可以直接插到父元素中。</p><p>回看 <code>patch</code> 方法，首次渲染我们调用了 <code>createElm</code> 方法，传入的 <code>parentElm</code> 是 <code>lidVnode.elm</code> 的父元素，在例子中是 id 为 #app div 的父元素，也就是 Body；实际上整个过程就是递归创建了一个完整的 DOM 树并插入到 Body 上。</p><h3 id="patch-执行流程分析"><a href="#patch-执行流程分析" class="headerlink" title="patch 执行流程分析"></a>patch 执行流程分析</h3><p>在 vue.esm.js 源文件的 <code>patch</code> 方法定义下打一个 <code>debugger</code> 调试：</p><p>![image-20211118170756105](vue 源码/image-20211118170756105.png)</p><p>进行单步调试，可以看到 <code>vnode</code> 有值， <code>oldVnode</code> 是 id 为 <code>app</code> 的 div：</p><p>![image-20211118171208901](vue 源码/image-20211118171208901.png)</p><p>继续进行单步调试，可以看到 <code>isRealElement</code> 为 <code>true</code>：</p><p>![image-20211118171628548](vue 源码/image-20211118171628548.png)</p><p>之后执行 <code>emptyNodeAt(oldVnode)</code> 方法，<code>oldVnode</code> 成为 <code>VNode</code> 节点：</p><p>![image-20211118172049107](vue 源码/image-20211118172049107.png)</p><p>之后进入 <code>createElm</code> 方法调试：</p><p>![image-20211118172301881](vue 源码/image-20211118172301881.png)</p><p>向下执行，生成当前元素的占位符 <code>vnode.elm</code>，<code>setScope</code> 是 CSS 作用域相关的：</p><p>![image-20211118172400799](vue 源码/image-20211118172400799.png)</p><p>进入 <code>createChildren</code> 方法：</p><p>![image-20211118172723914](vue 源码/image-20211118172723914.png)</p><p>再进入 <code>createElm</code> 方法：</p><p>![image-20211118172827056](vue 源码/image-20211118172827056.png)</p><p>此时已没有子节点，故 <code>children</code>、<code>tag</code> 均为 <code>undefined</code>：</p><p>![image-20211118173120807](vue 源码/image-20211118173120807.png)</p><p>判断是注释节点还是文本节点，此处为 <code>Hello AgoniLay!</code> 文本：</p><p>![image-20211118173308852](vue 源码/image-20211118173308852.png)</p><p>执行完 <code>nodeOps.createTextNode</code> 方法之后，<code>vnode.elm</code> 已转换成 DOM 文本节点：</p><p>![image-20211118173439630](vue 源码/image-20211118173439630.png)</p><p>之后调用 <code>insert</code> 方法插入，继续前进，<code>createChild</code> 执行结束：</p><p>![image-20211118173654013](vue 源码/image-20211118173654013.png)</p><p>之后执行 <code>insert</code> 方法，插入 DOM 节点，可以看到此时已渲染至浏览器页面：</p><p>![image-20211118173935912](vue 源码/image-20211118173935912.png)</p><p>此时查看 body，发现此时有两个 id 为 <code>app</code> 的 div：</p><p>![image-20211118174103119](vue 源码/image-20211118174103119.png)</p><p>继续执行代码，向前调试，回到了 <code>patch</code> 执行：</p><p>![image-20211118174235569](vue 源码/image-20211118174235569.png)</p><p><code>removeVnodes</code> 方法执行结束过后，再次查看 body，旧 div 已被销毁：</p><p>![image-20211118174400121](vue 源码/image-20211118174400121.png)</p><p>此时，<code>patch</code> 基本执行结束，渲染成功。</p><h1 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h1><p>Vue.js 另一个核心思想是<strong>组件化</strong>。</p><p>所谓组件化，就是把页面拆分成多个组件（component），每个组件依赖的 CSS、JavaScript、模板、图片等资源放在一起开发和维护。</p><p>组件是资源独立的，组件在系统内部可复用，组件和组件之间可以嵌套。</p><p>接下来用 Vue-cli 初始化的代码为例，来分析 Vue 组件初始化的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line"><span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="comment">// 这里的 h 是 createElement 方法</span></span><br><span class="line">  render h =&gt; h(App)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>和之前分析相同的都是通过 <code>render</code> 函数去渲染，但这次通过 <code>createElement</code> 传的参数是一个组件而不是一个原生的标签。</p><h2 id="createComponent"><a href="#createComponent" class="headerlink" title="createComponent"></a>createComponent</h2><p>在分析 <code>createElement</code> 的实现时，它最终会调用 <code>_createElement</code> 方法，其中会对参数 <code>tag</code> 进行判断，如果是一个普通的 html 标签，则会实例化一个普通的 VNode 节点，否则会通过 <code>createComponent</code> 方法创建一个组件 VNode。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> tag === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> Ctor</span><br><span class="line">  ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">  <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">    <span class="comment">// platform built-in elements</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      consfig.parsePlatformTagNmae(tag), data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;component&#x27;</span>, tag))) &#123;</span><br><span class="line">    <span class="comment">// component</span></span><br><span class="line">    vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">    <span class="comment">// check at runtime because it may get assigned a namespace then its</span></span><br><span class="line">    <span class="comment">// parent normalizes children</span></span><br><span class="line">    vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      tag, data, children,</span><br><span class="line">      <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// direct component options / constructor</span></span><br><span class="line">  vnode = createComponent(tag, data, context, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处传入的一个 App 对象，本质上是一个 <code>Component</code> 类型，则会走 else 逻辑，直接通过 <code>createComponent</code> 方法来创建 <code>vnode</code>。</p><p><code>src/core/vdom/create-component.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">Ctor: Class&lt;Component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  data: VNodeData | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  children: <span class="built_in">Array</span>&lt;VNode&gt; | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  tag?: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(Ctor)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// plain options object: trurn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if at this stage it&#x27;s not a constructor or an async component factory,</span></span><br><span class="line">  <span class="comment">/// reject.</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Ctor === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      warn(<span class="string">`Invalid Component definition: <span class="subst">$&#123;<span class="built_in">String</span>(Ctor)&#125;</span>`</span>, context)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resloveAsyncComponent(asyncFactory, baseCtor, context)</span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">      <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">      <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  data = data || &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// resolve constructor options in case global mixins are applied after</span></span><br><span class="line"><span class="comment">// component constructor creation</span></span><br><span class="line">  resolveConstructorOptions(Ctor)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// transform component v-model data into props &amp; events</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(data.model)) &#123;</span><br><span class="line">    transfromModel(Ctor.options, data)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// extract props</span></span><br><span class="line">  <span class="keyword">const</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//fucntional component</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.functional)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createFunctionalComponent((Ctor, propsData, data, context, children))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// extract listeners, since these needs to be treated as</span></span><br><span class="line">  <span class="comment">// child component listeners instead og DOM listeners</span></span><br><span class="line">  <span class="keyword">const</span> listeners = data.on</span><br><span class="line">  <span class="comment">// replace with listeners with .native modifier</span></span><br><span class="line">  <span class="comment">// so it gets processd during parent component patch</span></span><br><span class="line">  data.on = data.nativeOn</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (istrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    <span class="comment">// abstract components do not keep anything</span></span><br><span class="line"><span class="comment">// other than props &amp; listeners &amp; slot</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// work around flow</span></span><br><span class="line">    <span class="keyword">const</span> slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">  installComponentHooks(data)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// return a placeholder vnode</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Weex specific: invoke recycle-list optimized @render function for</span></span><br><span class="line">  <span class="comment">// extractiong cell-slot template.</span></span><br><span class="line">  <span class="comment">// https://github.com/Hanks10100/weex-native-directive/tree/master/component</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (__WEEX__ &amp;&amp; isRecyclableComponent(vnode)) &#123;</span><br><span class="line">    <span class="keyword">return</span> renderRecyclableComponentTemplate(vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个代码中，针对组件渲染这个 case 主要就 3 个关键步骤：</p><ul><li>构造子类构造函数；</li><li>安装组件钩子函数；</li><li>实例化 <code>vnode</code> 。</li></ul><h3 id="构造子类钩子函数"><a href="#构造子类钩子函数" class="headerlink" title="构造子类钩子函数"></a>构造子类钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> baseCtor = context.$options._base</span><br><span class="line"></span><br><span class="line"><span class="comment">// plain options object: turn it into a construtor</span></span><br><span class="line"><span class="comment">// 普通选项对象：将其转换为一个构造器</span></span><br><span class="line"><span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">  Ctor = baseCtor.extend(Ctor) <span class="comment">// 此处为关键方法 extend</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>App.vue</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;.components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>export</code> 是一个对象，所以 <code>createComponent</code> 里的代码逻辑会执行到 <code>baseCtor.extend(Ctor)</code>，在这里 <code>baseCtor</code> 实际上就是 Vue，这个定义是在最开始初始化 Vue 的阶段：</p><p><code>src/core/global-api/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  <span class="comment">// 这用于识别“基本”构造函数</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里定义的是 <code>Vue.options</code>，但在 <code>createComponent</code> 取的是 <code>context.$options</code>，这在 Vue 原型上的 <code>_init</code> 函数中有定义：</p><p><code>src/core/instance/init.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  vm.$options = mergeOptions(</span><br><span class="line">    resolveConstuctorOptions(vm.constructor),</span><br><span class="line">    options || &#123;&#125;,</span><br><span class="line">    vm</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就把 Vue 上的一些 <code>option</code> 扩展到了 <code>vm.$options</code> 上，所以就能通过 <code>vm.$options._base</code> 拿到 Vue 这个构造函数了。</p><blockquote><p><code>mergeOptions</code> 的功能是把 Vue 构造函数上的 <code>options</code> 和用户传入的 <code>options</code> 做一层合并，到 <code>vm.$options</code> 上。</p></blockquote><h4 id="Vue-extend"><a href="#Vue-extend" class="headerlink" title="Vue.extend"></a>Vue.extend</h4><p><code>src/core/global-api/extend.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class inheritance  ---  类继承</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  extendOptions = extendOptions || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> Super = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> SuperId = Super.id</span><br><span class="line">  <span class="keyword">const</span> cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = &#123;&#125;)</span><br><span class="line">  <span class="keyword">if</span> (cachedCtors[SuperId]) &#123;</span><br><span class="line">    <span class="keyword">return</span> cachedCtors[SuperId]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> name = extendOptions.name || Super.options.name</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; name) &#123;</span><br><span class="line">    validateComponentName(name)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>._init(options)</span><br><span class="line">  &#125;</span><br><span class="line">  Sub.prototype = <span class="built_in">Object</span>.create(Super.prototype)</span><br><span class="line">  Sub.prototype.constructor = Sub</span><br><span class="line">  Sub.cid = cid++</span><br><span class="line">  Sub.options = mergeOptions(</span><br><span class="line">    Super.options,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  Sub[<span class="string">&#x27;super&#x27;</span>] = Super</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// For props and computed properties, we define the proxy getters on</span></span><br><span class="line">  <span class="comment">// the Vue instances at extension time , on the extended prototype. This</span></span><br><span class="line">  <span class="comment">// avoid Object.defineProperty calls for each instance created.</span></span><br><span class="line">  <span class="comment">// 在扩展时在 Vue 实例上定义扩展原型上的 proxy getters</span></span><br><span class="line">  <span class="keyword">if</span> (Sub.options.props) &#123;</span><br><span class="line">    initProps(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (Sub.options.computed) &#123;</span><br><span class="line">    initComputed(Sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// allow further extension/mixin/plugin usage</span></span><br><span class="line">  <span class="comment">// 允许之后使用 扩展/混入/插件</span></span><br><span class="line">  Sub.extend = Super.extend</span><br><span class="line">  Sub.mixin = Super.mixin</span><br><span class="line">  Sub.use = Super.use</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// create asset registers, so extended classes</span></span><br><span class="line">  <span class="comment">// can have their private assets too.</span></span><br><span class="line">  <span class="comment">// 创建资源寄存器，这样扩展的类也可以拥有其私有的资源</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">    Sub[<span class="keyword">type</span>] = Super[<span class="keyword">type</span>]</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// enable recursive self-lookup</span></span><br><span class="line">  <span class="comment">// 使其能够递归自我查找</span></span><br><span class="line">  <span class="keyword">if</span> (name) &#123;</span><br><span class="line">    Sub.option.components[name] = Sub</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">  <span class="comment">// later at instantiation we can check if Super&#x27;s options have</span></span><br><span class="line">  <span class="comment">// been updated.</span></span><br><span class="line">  <span class="comment">// 在扩展时保留对 Super 选项引用。稍后在实例化时，我们可以检查 Suoer 选项是否已经更新</span></span><br><span class="line">  Sub.superOptions = Super.options</span><br><span class="line">  Sub.extendOptions = extendOptions</span><br><span class="line">  Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cache constructor</span></span><br><span class="line">  <span class="comment">// 缓存构造函数</span></span><br><span class="line">  cachedCtors[SuperId] = Sub</span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Vue.extend</code> 的作用：</p><ul><li>构造一个 <code>Vue</code> 的子类，通过原型继承的方式把一个纯对象转换成一个继承于 <code>Vue</code> 的构造器 <code>Sub</code> 并返回，然后对 <code>Sub</code> 这个对象本身扩展了一些属性，如扩展 <code>options</code>、添加全局 API 等；</li><li>并对配置中的 <code>props</code> 和 <code>computed</code> 做了初始化工作；</li><li>最后对 <code>Sub</code> 这个构造函数做了缓存，避免多次执行 <code>Vue.extend</code> 的时候对同一个子组件重复构造。</li></ul><p>当去实例化 <code>Sub</code> 的时候，就会执行 <code>this._init</code> 逻辑再次走到 <code>Vue</code> 实例的初始化逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Sub = <span class="function"><span class="keyword">function</span> <span class="title">VueComponent</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>._init(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="安装组件钩子函数"><a href="#安装组件钩子函数" class="headerlink" title="安装组件钩子函数"></a>安装组件钩子函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// install component management hooks onto the placeholder node</span></span><br><span class="line">installComponentHooks(data)</span><br></pre></td></tr></table></figure><p>Vue 在初始化一个 Component 类型的 VNode 的过程中实现了几个钩子函数：</p><h4 id="installComponentHooks"><a href="#installComponentHooks" class="headerlink" title="installComponentHooks"></a>installComponentHooks</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// inline hooks to be invoked on component VNodes during patch</span></span><br><span class="line"><span class="keyword">const</span> componetVNodeHooks = &#123;</span><br><span class="line">  init (vnode: VNodeWithData, <span class="attr">hydrating</span>: <span class="built_in">boolean</span>): <span class="built_in">boolean</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (vnode.componentInstance &amp;&amp;</span><br><span class="line">        !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">        vnode.data.keepAlive</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">      <span class="keyword">const</span> mountedNode: <span class="built_in">any</span> = vnode <span class="comment">// work around flow</span></span><br><span class="line">      componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> child = vnode.componentInstance = createComponetInstanceForVnode(</span><br><span class="line">        vnode,</span><br><span class="line">        activeInstance</span><br><span class="line">      )</span><br><span class="line">      child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  prepatch (oldVnode: MountedComponentVNode, <span class="attr">vnode</span>: MountedCOmponentVNode) &#123;</span><br><span class="line"><span class="keyword">const</span> options = vnode.componentOptions</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = oldVnode.componentInstance</span><br><span class="line">    updateChildComponent(</span><br><span class="line">      child,</span><br><span class="line">      options.propsData, <span class="comment">// updated props</span></span><br><span class="line">      options.listeners, <span class="comment">// updated listeners</span></span><br><span class="line">      vnode,  <span class="comment">// new parent vnode</span></span><br><span class="line">      options.children  <span class="comment">// new children</span></span><br><span class="line">    )</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (vnode.data.keepAlive) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context._isMounted) &#123;</span><br><span class="line">        <span class="comment">// vue-router#1212</span></span><br><span class="line">        <span class="comment">// During updates, a kept-alive component&#x27;s child components may</span></span><br><span class="line">        <span class="comment">// change, so directly walking the tree here may call activated hooks</span></span><br><span class="line">        <span class="comment">// on incorrect children. Instead we push them into a queue which will</span></span><br><span class="line">        <span class="comment">// be processed after whole patch process ended.</span></span><br><span class="line">        queueActivatedComponent(componentInstance)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        activateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  </span><br><span class="line">  destory (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isDestroyed) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!vnode.data.keepAlive) &#123;</span><br><span class="line">        componentInstance.$destroy()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        deactivateChildComponent(componentInstance, <span class="literal">true</span> <span class="comment">/* direct */</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hooksToMerge = <span class="built_in">Object</span>.keys(componentVNodeHooks) <span class="comment">// [&#x27;init&#x27;, &#x27;prepatch&#x27;, &#x27;insert&#x27;, &#x27;destory&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">installComponentHooks</span> (<span class="params">data: VnodeData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> hooks = data.hook || (data.hook = &#123;&#125;)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; hooksToMerge.length; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = hooksToMerge[i]</span><br><span class="line">    <span class="keyword">const</span> existing = hooks[key]</span><br><span class="line">    <span class="keyword">const</span> toMerge = componentVNodeHooks[key]</span><br><span class="line">    <span class="comment">// 判断 是否相同 || 已经合并</span></span><br><span class="line">    <span class="keyword">if</span> (existing !== toMerge &amp;&amp; !(existing &amp;&amp; existing._merged)) &#123;</span><br><span class="line">      hooks[key] = existing ? mergeHook(toMerge, existing) : toMerge</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个 <code>installComponentHooks</code> 的过程就是把 <code>componentVNodeHooks</code> 的钩子函数合并到 <code>data.hook</code> 中，在 VNode 执行 <code>patch</code> 的过程中执行相关的钩子函数。</p><h4 id="mergeHook"><a href="#mergeHook" class="headerlink" title="mergeHook"></a>mergeHook</h4><p>合并策略：在合并过程中，如果某个时机的钩子已经存在 <code>data.hook</code> 中，那么通过执行 <code>mergeHook</code> 函数做合并，就是在最终执行的时候，依次执行这两个钩子函数即可。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params">f1: <span class="built_in">any</span>, f2: <span class="built_in">any</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> merged = <span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// flow complains about extra args which is why we use any</span></span><br><span class="line">    f1(a, b)</span><br><span class="line">    f2(a, b)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 做缓存，提高效率</span></span><br><span class="line">  merged._merged = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">return</span> merged</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实例化-VNode"><a href="#实例化-VNode" class="headerlink" title="实例化 VNode"></a>实例化 VNode</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">Ctor, data, context, children, tag</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">const</span> name = Ctor.options.name || tag</span><br><span class="line">  <span class="keyword">const</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    <span class="string">`vue-component-<span class="subst">$&#123;Ctor.cid&#125;</span><span class="subst">$&#123;name ? <span class="string">`-<span class="subst">$&#123;name&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>&#125;</span>`</span>,</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后通过 <code>new VNode</code> 实例化一个 <code>vnode</code>并返回。</p><blockquote><p>注意：和普通元素节点的 <code>vnode</code> 不同，组件的 <code>vnode</code> 是没有 <code>chldren</code> 的，这点很关键。</p></blockquote><h3 id="流程分析"><a href="#流程分析" class="headerlink" title="流程分析"></a>流程分析</h3><p>在 <code>vue.esm.js</code> 中在执行 <code>createComponent</code> 方法之前打一个 <code>debugger</code> 断点：</p><p>![image-20211119125713362](vue 源码/image-20211119125713362.png)</p><p>浏览器中执行代码，进到 <code>createComponent</code> 方法内执行，此时 <code>Ctor</code> 结构如下图所示：</p><p>![image-20211119125841531](vue 源码/image-20211119125841531.png)</p><p>向后执行，进入 <code>extend</code> 方法内：</p><p>![image-20211119130003696](vue 源码/image-20211119130003696.png)</p><p>进行一系列原型继承，方法合并之后返回 <code>Sub</code>，继续执行，退出到 <code>createComponent</code> 方法中：</p><p>![image-20211119130317549](vue 源码/image-20211119130317549.png)</p><p>一直执行到 <code>installComponentHooks(data)</code> 方法，执行前 <code>data</code> 中只有一个 <code>on</code>：</p><p>![image-20211119130507167](vue 源码/image-20211119130507167.png)</p><p>执行完成 <code>installComponentHooks</code> 方法过后，<code>data</code> 上添加了 <code>hook</code>：</p><p>![image-20211119130638202](vue 源码/image-20211119130638202.png)</p><p>继续执行，创建 <code>VNode</code>并返回，<code>createComponent</code> 执行结束：</p><p>![image-20211119130901213](vue 源码/image-20211119130901213.png)</p><p>![image-20211119131005730](vue 源码/image-20211119131005730.png)</p><p>![image-20211119131034122](vue 源码/image-20211119131034122.png) </p><h2 id="patch-1"><a href="#patch-1" class="headerlink" title="patch"></a>patch</h2><p>当通过 <code>createComponent</code> 创建了组件 VNode，接下来会走到 <code>vm._update</code>，执行 <code>vm.__patch__</code> 去把 VNode 转换成真正的 DOM 节点。</p><p>patch 的过程会调用 <code>createElm</code> 创建元素节点：</p><p><code>src/core/vdom/patch.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vnode, insertedVnodeQueue, parentElm, refElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> nested, ownerArray, index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="createComponent-1"><a href="#createComponent-1" class="headerlink" title="createComponent"></a>createComponent</h3><p>只看关键的逻辑，这里会判断 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值，如果为 <code>true</code> 则直接结束，那么接下来看一下 <code>createComponent</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="keyword">const</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hok) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// after calling the init hook, if the vnode is a child component</span></span><br><span class="line">    <span class="comment">// it should&#x27;ve created a child instance and mounted it. the child</span></span><br><span class="line">    <span class="comment">// component also has set the placeholder vnode&#x27;s elm.</span></span><br><span class="line">    <span class="comment">// in that case we can just return the element and be done.</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>creatComponent</code> 函数中，首先对 <code>vnode.data</code> 做了一些判断：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> i = vnode.data</span><br><span class="line"><span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">    i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 <code>vnode</code> 是一个组件 VNode，那么条件满足，得到 <code>i</code> 就是 <code>init</code> 钩子函数，上一节在创建 VNode 的时候合并钩子函数中就包含 <code>init</code> 钩子函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span> (<span class="params">vnode: Vnode, hydrating: <span class="built_in">boolean</span></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    vnode.componentInstance &amp;&amp;</span><br><span class="line">    !vnode.componentInstance._isDestroyed &amp;&amp;</span><br><span class="line">    vnode.data.keepAlive</span><br><span class="line">  ) &#123;</span><br><span class="line"><span class="comment">// kept-alive components, treat as a patch</span></span><br><span class="line">    <span class="keyword">const</span> mouted: <span class="built_in">any</span> = vnode <span class="comment">// work around flow</span></span><br><span class="line">    componentVNodeHooks.prepatch(mountedNode, mountedNode)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> child = vnode.componentInstance = createComponentInstanceForVnode(</span><br><span class="line">      vnode,</span><br><span class="line">      activeInstance</span><br><span class="line">    )</span><br><span class="line">    child.$mount(hydrating ? vnode.elm : <span class="literal">undefined</span>, hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先不考虑 keep-alive 的情况，它是通过 <code>createComponentInstanceForVnode</code> 创建一个 Vue 的实例，然后调用 <code>$mount</code> 方法挂载子组件：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForVnode</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"><span class="comment">// we known it&#x27;s MountedComponentVNode but flow doesn&#x27;t</span></span></span></span><br><span class="line"><span class="params"><span class="function">vnode: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  <span class="comment">// activeInstance is lisfecycle state</span></span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// check inline-template render functions</span></span><br><span class="line">  <span class="keyword">const</span> inlineTemplate = vnode.data.inlineTemplate</span><br><span class="line">  <span class="keyword">if</span> (isDef(inlineTemplate)) &#123;</span><br><span class="line">    options.render = inlineTemplate.render</span><br><span class="line">    options.staticRenderFns = inlineTemplate.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createComponentInstanceForVnode</code> 构造函数的一个内部组件的参数，然后执行 <code>new vnode.componentOptions.Ctor(options)</code>。这里的 <code>vnode.componentOptions.Ctor</code> 对应的就是子组件的构造函数，相当于之前的 <code>new Sub(options)</code>，这里的参数：</p><ul><li><code>_isComponent</code> 为 <code>true</code> 表示它是一个组件；</li><li><code>parent</code> 表示当前激活的组件实例</li></ul><p>接着进行子组件的实例化，执行实例的 <code>_init</code> 方法：</p><p><code>src/core/instance/init.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal component instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic merging is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment.</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveCOnstructorOPtions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">    vm.$mount(vm.$options.el)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是合并 <code>options</code> 的过程有变化，<code>_isComponent</code> 为 true，执行 <code>initInternalComponent</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// doing this because it&#x27;s faster than dynamic dnumeration.</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = vnodeComponentOptions.tag</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中较为重要的是：</p><ul><li><code>opts.parent = options.parent</code>；</li><li><code>opts._parentVnode = parentVnode</code>。</li></ul><p>是将之前通过 <code>createComponentInstanceForVnode</code> 函数传入的几个参数合并到内部的选项 <code>$options</code> 里。</p><p><code>_init</code> 函数最后执行代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (vm.$options.el) &#123;</span><br><span class="line">  vm.$mount(vm.$options.el)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于组件实例化是不传 el 的，因此组件是自己接管了 $mount 的过程，回到组件 <code>init</code> 的过程，<code>componentVNodeHooks</code> 的 <code>init</code> 钩子函数，在完成实例化的 <code>_init</code> 后，接着执行 <code>child.$mount(hydrating ? vnode.elm : undefined, hydrating)</code>：</p><p>这里 <code>hyrating</code> 为 true 一般为服务器端渲染，所以这里相当于执行 <code>child.$mount(undefined, false)</code>，它最终会调用 <code>mountComponent</code> 方法，进而执行 <code>vm._render()</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>): <span class="title">Vnode</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> &#123; render, _parentVnode &#125; = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// set parent vnode. this allows render function to have access</span></span><br><span class="line">  <span class="comment">// to the data on the placeholder node.</span></span><br><span class="line">  vm.$vnode = _parentVnode</span><br><span class="line">  <span class="comment">// render self</span></span><br><span class="line">  <span class="keyword">let</span> vnode</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    vnode = render.call(vm._renderProxy, vm.$createElement)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// set parent</span></span><br><span class="line">  vnode.parent = _parentVnode</span><br><span class="line">  <span class="keyword">return</span> vnode</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>_parentVnode</code> 就是当前组件的父 VNode，而 <code>render</code> 函数生成的 <code>vnode</code> 的 <code>parent</code> 指向了 <code>_parentVnode</code>，也就是 <code>vm.$vnode</code>，成父子关系。</p><p>执行完 <code>vm._render</code> 生成 VNode 后，接下来执行 <code>vm._update</code> 去渲染 VNode：</p><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> activeInstance: <span class="built_in">any</span> = <span class="literal">null</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">Vue.prototype._update = <span class="function"><span class="keyword">function</span> (<span class="params">vnode: VNode, hydrating?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">const</span> prevEl = vm.$el</span><br><span class="line">  <span class="keyword">const</span> prevVnode = vm._vnode</span><br><span class="line">  <span class="keyword">const</span> restoreActiveInstance = setActiveInstance(vm)</span><br><span class="line">  vm._vnode = vnode</span><br><span class="line">  <span class="comment">// Vue.prototype.__patch__ is injected in entry points</span></span><br><span class="line">  <span class="comment">// based on the rendering backend used.</span></span><br><span class="line">  <span class="keyword">if</span> (!prevVnode) &#123;</span><br><span class="line">    <span class="comment">// initial render</span></span><br><span class="line">    vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// updates</span></span><br><span class="line">    vm.$el = vm.__patch__(prevVnode, vnode)</span><br><span class="line">  &#125;</span><br><span class="line">  restoreActiveInstance()</span><br><span class="line">  <span class="comment">// update __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (prevEl) &#123;</span><br><span class="line">    prevEl.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = vm</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// if parent is an HOC, update its $el as well</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode &amp;&amp; vm.$parent &amp;&amp; vm.$vnode === vm.$parent._vnode) &#123;</span><br><span class="line">    vm.$parent.$el = vm.$el</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// updated hook is called by the scheduler to ensure that children are</span></span><br><span class="line">  <span class="comment">// update in a parent&#x27;s updated hook.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>vm._vnode = vnode</code> 中的 <code>vnode</code> 是通过 <code>vm._render()</code> 返回的组件渲染 VNode；</p></li><li><p><code>vm._vnode</code> 和 <code>vm.$vnode</code> 的关系就是一种父子关系，即：<code>vm._vnode.parent = vm.$vnode</code>；</p></li><li><p><code>activeInstance</code> 的作用就是保持当前上下文的 Vue 实例，是 <code>lifecycle</code> 模块的全局变量。</p><blockquote><p>JavaScript 是一个单线程，Vue 整个初始化是一个深度遍历的过程，在实例化子组件的过程中，它需要知道当前上下文的 Vue 实例是什么，并把它作为子组件的父 Vue 实例。</p></blockquote></li></ul><p>对子组件的实例化过程会先调用 <code>initInternalComponent(vm, options)</code> 合并 <code>options</code>，把 <code>parent</code> 存储在 <code>vm.$options</code> 中，在 <code>$mount</code> 之前会调用 <code>initLifecycle(vm)</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initLifecycle</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options = vm.$options</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// locale first non-abstract parent</span></span><br><span class="line">  <span class="keyword">let</span> parent = options.parent</span><br><span class="line">  <span class="keyword">if</span> (parent &amp;&amp; !options.abstract) &#123;</span><br><span class="line">    <span class="keyword">while</span> (parent.$options.abstract &amp;&amp; parent.$parent) &#123;</span><br><span class="line">      parent = parent.$parent</span><br><span class="line">    &#125;</span><br><span class="line">    parent.$children.push(vm)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  vm.$parent = parent</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>vm.$parent</code> 就是用来保留当前 <code>vm</code> 的父实例，并通过 <code>parent.$children.push(vm)</code> 将当前 <code>vm</code> 存储到父实例的 <code>$children</code> 中。</p><p>在 <code>vm._update</code> 的过程中，把当前的 <code>vm</code> 赋值给 <code>activeInstance</code>，同时通过 <code>const prevActiveInstance = activeInstance</code> 用 <code>prevActiveInstance</code> 保留上一次的 <code>activeInstance</code>。当一个 <code>vm</code> 实例完成了它的所有子树的 patch 或者 update 过程后，<code>activeInstance</code> 会回到它的父实例。</p><p>再回到 <code>_update</code>，最后调用 <code>__patch__</code> 渲染 VNode：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vm.$el = vm.__patch__(vm.$el, vnode, hydrating, <span class="literal">false</span> <span class="comment">/* removeOnly */</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">patch</span> (<span class="params">oldVnode, vnode, hydrating, removeOnly</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> isInitialPatch = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> insertedVnodeQueue = []</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(oldVnode)) &#123;</span><br><span class="line">    <span class="comment">// empty mount (likely as component), create new root element</span></span><br><span class="line">    inInitialPatch = <span class="literal">true</span></span><br><span class="line">    createElm(vnode, insertedVnodeQueue)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createElm</code> 负责渲染成 DOM，这里只传了 2 个参数，所以对应的 <code>parentElm</code> 是 <code>undefined</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElm</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vnode,</span></span></span><br><span class="line"><span class="params"><span class="function"> insertedVnodeQueue,</span></span></span><br><span class="line"><span class="params"><span class="function"> parentElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> refElm,</span></span></span><br><span class="line"><span class="params"><span class="function"> nested,</span></span></span><br><span class="line"><span class="params"><span class="function"> ownerArray,</span></span></span><br><span class="line"><span class="params"><span class="function"> index</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> data = vnode.data</span><br><span class="line">  <span class="keyword">const</span> children = vnode.children</span><br><span class="line">  <span class="keyword">const</span> tag =vnode.tag</span><br><span class="line">  <span class="keyword">if</span> (isDef(tag)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    vnode.elm = vnode.ns</span><br><span class="line">    ? nodeOps.createElementNS(vnode.ns, tag)</span><br><span class="line">    : nodeOps.createELement(tag, vnode)</span><br><span class="line">    setScope(vnode)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">    <span class="keyword">if</span> (__WEEX__) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createChildren(vnode, children, insertedVnodeQue)</span><br><span class="line">      <span class="keyword">if</span> (isDef(data)) &#123;</span><br><span class="line">        invokeCreateHooks(vnode,insertedVnodeQueue)</span><br><span class="line">      &#125;</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTrue(vnode.isComment)) &#123;</span><br><span class="line">    vnode.elm = nodeOps.createComment(vnode.text)</span><br><span class="line">    insert(parentElm, vnode.elm, refElm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vnode.elm = nodeOps.createTextNode(vnode.text)</span><br><span class="line">    insert(parentElm, cnode.elm, refElm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里传入的 <code>vnode</code> 是组件渲染的 <code>vnode</code>，也就是 <code>vm._vnode</code>，如果组件的根节点是个普通元素，那么 <code>vm._vnode</code> 也是普通的 <code>vnode</code>，这里 <code>createComponent(vnode, insertedVnodeQueue, parentElm, refElm)</code> 的返回值是 false，然后创建一个父节点占位符，然后再遍历所有子 VNode 递归调用 <code>createElm</code>，遍历过程中遇到 VNode 是一个组件的 VNode，则重复本节的过程，通过一个递归的方式完整地构建了整个组件树。</p><p>这时传入的 <code>parentElm</code> 是空，所以在 <code>createComponent</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.elm, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在完成组件的整个 <code>patch</code> 过程后，最后执行 <code>insert(parentElm, vnode.elm, refElm)</code> 完成组件的 DOM 插入，如果组件 <code>patch</code> 的过程中又创建了子组件，那么 DOM 的插入顺序是<strong>先子后父</strong>。</p><h2 id="合并配置"><a href="#合并配置" class="headerlink" title="合并配置"></a>合并配置</h2><p><code>new Vue</code> 的过程通常有 2 种场景：</p><ol><li>一种是外部代码主动调用 <code>new Vue(options)</code> 的方式实例化一个 Vue 对象；</li><li>另一种是组件过程中内部通过调用 <code>new Vue(options)</code> 实例化子组件。</li></ol><p>以上两种都会执行实例的 <code>_init(options)</code> 方法，它首先会执行一个 <code>mergeOptions</code> 的逻辑：</p><p><code>src/core/instance/init.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// merge options</span></span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponent) &#123;</span><br><span class="line">    <span class="comment">// optimize internal compnent instantiation</span></span><br><span class="line">    <span class="comment">// since dynamic options merhing is pretty slow, and none of the</span></span><br><span class="line">    <span class="comment">// internal component options needs special treatment</span></span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    vm.$options = mergeOptions(</span><br><span class="line">      resolveConstructorOptions(vm.constructor),</span><br><span class="line">      options || &#123;&#125;,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到不同场景对于 <code>options</code> 的合并逻辑是不一样的，并且传入的 <code>options</code> 值也有非常大的不同。</p><p>示例代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> childComp = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  created () &#123;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">&#x27;child created&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mounted () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;child mounted&#x27;</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Vue.mixin(&#123;</span><br><span class="line">  created () &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="params">h</span> =&gt;</span> h(childComp)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="外部调用场景"><a href="#外部调用场景" class="headerlink" title="外部调用场景"></a>外部调用场景</h3><p>当执行 <code>new Vue</code> 时，执行 <code>this._init(options)</code> 时就会执行如下逻辑去合并 <code>options</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>这里通过调用 <code>mergeOptions</code> 方法来合并，实际上就是吧 <code>resloveConstructorOptions(vm.constructor)</code> 的返回值和 <code>options</code> 做合并，现在认为 <code>resolveConstructorOptions</code> 简单返回 <code>vm.constructor.options</code>，相当于 <code>Vue.options</code>：</p><p><code>src/core/global-api/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initGlobalAPI</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Vue.options = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue.options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>] = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// this is used to identify the &quot;base&quot; constructor to extend all plain-object</span></span><br><span class="line">  <span class="comment">// components with in Weex&#x27;s multi-instance scenarios.</span></span><br><span class="line">  Vue.options._base = Vue</span><br><span class="line">  </span><br><span class="line">  extend(Vue.options.components, buildInComponents)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先通过 <code>Vue.options = Object.create(null)</code> 创建一个空对象；</p><p>然后遍历 <code>ASSET_TYPE</code>；</p><p><code>src/shared/constants.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPE = &#123;</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历 <code>ASSETS_TYPE</code> 后的代码相当于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.options.components = &#123;&#125;</span><br><span class="line">Vue.options.directives = &#123;&#125;</span><br><span class="line">Vue.options.filters = &#123;&#125;</span><br></pre></td></tr></table></figure><p>接着执行 <code>Vue.options._base = Vue</code>；</p><p>最后通过 <code>extend(Vue.options.components, builtInComponets)</code> 把一些内置组件扩展到 <code>Vue.options.components</code> 上，Vue 的内置组件有：</p><ul><li><code>&lt;keep-alive&gt;</code> </li><li><code>&lt;transition&gt;</code> </li><li><code>&lt;transition-group&gt;</code> </li></ul><p>再看 <code>mergeOptions</code> 这个函数</p><p><code>src/core/util/options.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Merge two option objects into a new one.</span></span><br><span class="line"><span class="comment"> * Core utility used in both instantiation and inheritance.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mergeOptions</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  child: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  vm?: Component</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Object</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    checkComponents(child)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> child === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    child = child.options</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  normalizeProps(child, vm)</span><br><span class="line">  normalizeInject(child, vm)</span><br><span class="line">  normalizeDirectives(child)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Apply extends and mixins on the child options,</span></span><br><span class="line">  <span class="comment">// but only if it is a raw options object that isn&#x27;t</span></span><br><span class="line">  <span class="comment">// the result of auother mergeOptions call.</span></span><br><span class="line">  <span class="comment">// Only merged options has the _base property.</span></span><br><span class="line">  <span class="keyword">if</span> (!child._base) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child.extends) &#123;</span><br><span class="line">      parent = mergeOptions(parent, child.extends, vm)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (child.mixins) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = child.mixins.length; i &lt; l; i++) &#123;</span><br><span class="line">        parent = mergeOptions(parent, child.mixin[i], vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> options = &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> key</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> parent) &#123;</span><br><span class="line">    mergeField(key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (key <span class="keyword">in</span> child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasOwn(parent, key)) &#123;</span><br><span class="line">      mergeField(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeField</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> strat = strats[key] || defaultStrat</span><br><span class="line">    options[key] = strat(parent[key], child[key], vm, key)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>mergeOptions</code> 主要功能就是把 <code>parent</code> 和 <code>child</code> 这两个对象根据一些合并策略，合并成一个新对象并返回：</p><ul><li>先递归把 <code>extends</code> 和 <code>mixins</code> 合并到 <code>parent</code> 上；</li><li>然后遍历 <code>parent</code>，调用 <code>mergeField</code>；</li><li>再遍历 <code>child</code>，如果 key 不在 <code>parent</code> 的自身属性上，则同样调用 <code>mergeField</code>。</li></ul><p><code>mergeField</code> 函数对不同的 <code>key</code> 有着不同的合并策略：</p><ul><li><p>对于生命周期函数：</p><p><code>src/core/util/options.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeHook</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">parentVal?: <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">  childVal?: <span class="built_in">Function</span> | <span class="built_in">Array</span>&lt;<span class="built_in">Function</span>&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Array</span>&lt;<span class="title">Function</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">const</span> res = childVal</span><br><span class="line">    ? parentVal</span><br><span class="line">    ? parentVal.concat(childVal)</span><br><span class="line">      : <span class="built_in">Array</span>.isArray(childVal)</span><br><span class="line">? childVal</span><br><span class="line">: [childVal]</span><br><span class="line">: parentVal</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">    ? dedupeHooks(res)</span><br><span class="line">    : res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupeHooks</span> (<span class="params">hooks</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, i &lt; hooks.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (res.indexOf(hooks[i]) === -<span class="number">1</span>) &#123;</span><br><span class="line">      res.push(hooks[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LIFECYCLE_HOOKS.forEach(<span class="function"><span class="params">hook</span> =&gt;</span> &#123;</span><br><span class="line">  strats[hook] = mergeHook</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>LIFECYCLE_HOOKS</code> 定义在 <code>src/shared/constants.js</code> 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> LIFECYCLE_HOOKS = [</span><br><span class="line">  <span class="string">&#x27;beforeCreate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;created&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeMount&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;mounted&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeUpdate&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;updated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;beforeDestroy&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;destroyed&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;activated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;deactivated&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;errorCaptured&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里定义了 Vue.js 的所有钩子函数名称，所以对于钩子函数，他们的合并策略都是 <code>mergeHook</code> 函数：</p><p>使用了一个多层 3 元运算符：</p><ul><li>如果不存在 <code>childVal</code>，就返回 <code>parentVal</code>；</li><li>否则再判断是否存在 <code>parentVal</code>，如果存在就把 <code>childVal</code> 添加到 <code>parentVal</code> 后返回新数组；</li><li>否则返回 <code>childVal</code> 的数组。</li></ul></li></ul><p>回到 <code>mergeOptions</code> 函数，一旦 <code>parent</code> 和 <code>child</code> 都定义了相同的钩子函数，那么它们会把 2 个钩子函数合并成一个数组。</p><p>通过执行 <code>mergeField</code> 函数，把合并后的结果保存到 <code>options</code> 对象中，最终返回。</p><p>执行完如下合并后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = mergeOptions(</span><br><span class="line">  resolveConstructorOptions(vm.constructor),</span><br><span class="line">  options || &#123;&#125;,</span><br><span class="line">  vm</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p><code>vm.$options</code> 的值大概如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">created</span>: [</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="attr">directive</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">filters</span>: &#123; &#125;,</span><br><span class="line">  <span class="attr">_base</span>: <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="组件场景"><a href="#组件场景" class="headerlink" title="组件场景"></a>组件场景</h3><p>组件的构造函数是通过 <code>Vue.extend</code> 继承自 <code>Vue</code> 的；</p><p><code>src/core/global-api/extend.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Class inheritance</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Vue.extend = <span class="function"><span class="keyword">function</span> (<span class="params">extendOptions: <span class="built_in">Object</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  Sub.options = mergeOptions(</span><br><span class="line">    Super.options,</span><br><span class="line">    extendOptions</span><br><span class="line">  )</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// keep a reference to the super options at extension time.</span></span><br><span class="line">  <span class="comment">// later at instantiation we can check if Super&#x27;s options have</span></span><br><span class="line">  <span class="comment">// been updated.</span></span><br><span class="line">  Sub.superOptions = Super.options</span><br><span class="line">  Sub.extendOptions = extendOptions</span><br><span class="line">  Sub.sealedOptions = extend(&#123;&#125;, Sub.options)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> Sub</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>extendOptions</code> 对应的就是前面定义的组件对象，它会和 <code>Vue.options</code> 合并到 <code>Sub.options</code> 中。</p><p>再来看一下子组件的初始化过程：</p><p><code>src/core/vdom/create-component.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponentInstanceForValue</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">vnode: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  parent: <span class="built_in">any</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> options: InternalComponentOptions = &#123;</span><br><span class="line">    <span class="attr">_isComponent</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">_parentVnode</span>: vnode,</span><br><span class="line">    parent</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> vnode.componentOptions.Ctor(options)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的 <code>vnode.componentOptions.Ctor</code> 就是执行那个 <code>Vue.extend</code> 的返回值 <code>Sub</code>，所以执行 <code>new vnode.componentOptions.Ctor(options)</code>，接着执行 <code>this._init(options)</code>，因为 <code>options._isComponent</code> 为 true，那么合并 <code>options</code> 的过程走到了 <code>initInternalComponent(vm, options)</code> 逻辑。</p><p><code>src/core/instance/init.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm: Component, options: InternalComponentOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="comment">// doing this because it&#x27;s faster than dunamic enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = nodeComponentOptions.tag</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 代码分析：</p><ul><li>首先执行 <code>const opts = vm.$options = Object.create(vm.constructor.options)</code>；</li><li>这里的 <code>vm.constructor</code> 就是子组件的构造函数 <code>Sub</code>，相当于 <code>vm.$options = Object.create(Sub.options)</code>；</li><li>接下来把实例化子组件传入的子组件父 VNode 实例 <code>parentVnode</code>、子组件的父 Vue 实例 <code>parent</code> 保存到 <code>vm.$options</code> 中；</li><li>另外还保留了 <code>parentVnode</code> 配置中的其他属性。</li></ul><p>因此执行完如下合并后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">initInternalComponent(vm, options)</span><br></pre></td></tr></table></figure><p><code>vm.$options</code> 的值差不多是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vm.$options = &#123;</span><br><span class="line">  <span class="attr">parent</span>: Vue <span class="comment">/* 父 Vue 实例 */</span>,</span><br><span class="line">  <span class="attr">propsData</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">_componentTag</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">_parentVnode</span>: VNode <span class="comment">/* 父 VNode 实例 */</span>,</span><br><span class="line">  <span class="attr">_renderChildren</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">__proto__</span>: &#123;</span><br><span class="line">    <span class="attr">components</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">directives</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">filters</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">_base</span>: <span class="function"><span class="keyword">function</span> <span class="title">Vue</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">_Ctor</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">created</span>: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;parent created&#x27;</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">created</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;child created&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">mounted</span>: [</span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">mounted</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;child mounted&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    data () &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">msg</span>: <span class="string">&#x27;Hello Vue&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对于 <code>options</code> 的两种合并方式中，子组件初始化过程通过 <code>initInternalComponent</code> 方式要比外部初始化 Vue 通过 <code>mergeOptions</code> 的过程要快，合并完的结果保留在 <code>vm.$options</code> 中。</p></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>每个 Vue 实例在被创建之前都要经过一系列的初始化过程，在这过程中会运行一些叫做生命周期的钩子函数：</p><p>![img](vue 源码/lifecycle.png)</p><p>源码中最终执行生命周期的函数都是调用 <code>callHook</code> 方法：</p><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">callHook</span> (<span class="params">vm: Component, hook: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// #7573 disable dep collection when invoking lifecycle hooks</span></span><br><span class="line">  pushTarget()</span><br><span class="line">  <span class="keyword">const</span> handlers = vm.$optons[hook]</span><br><span class="line">  <span class="keyword">const</span> info = <span class="string">`<span class="subst">$&#123;hook&#125;</span> hook`</span></span><br><span class="line">  <span class="keyword">if</span> (handlers) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, j = handlers.length; i &lt; j; i++) &#123;</span><br><span class="line">      invokeWithErrorHandling(handlers[i], vm, <span class="literal">null</span>, vm, info)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (vm._hasHookEvent) &#123;</span><br><span class="line">    vm.$emit(<span class="string">&#x27;hook:&#x27;</span> + hook)</span><br><span class="line">  &#125;</span><br><span class="line">  popTarget()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>callHook</code> 逻辑分析：</p><p>根据传入的字符串 <code>hook</code>，去拿到 <code>vm.$options[hook]</code> 对应的回调函数数组，然后遍历执行，执行时把 <code>vm</code> 作为函数执行的上下文</p><p><code>callHook</code> 函数的功能就是调用某个生命周期钩子注册的所有回调函数。</p><h3 id="beforeCreate-amp-created"><a href="#beforeCreate-amp-created" class="headerlink" title="beforeCreate &amp; created"></a>beforeCreate &amp; created</h3><p><code>beforeCreate</code> 和 <code>create</code> 都是在实例化 <code>Vue</code> 的阶段，在 <code>_init</code> 方法中执行。</p><p><code>src/core/instance/init.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  initLifecycle(vm)</span><br><span class="line">  initEvents(vm)</span><br><span class="line">  initRender(vm)</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeCreate&#x27;</span>)</span><br><span class="line">  initInjections(vm) <span class="comment">// resolve injections before data/props</span></span><br><span class="line">  initState(vm)</span><br><span class="line">  initProvide(vm) <span class="comment">// resolve provide after data/props</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;created&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeCreate</code> 和 <code>created</code> 的钩子调用是在 <code>initState</code> 的前后，<code>initState</code> 的作用是初始化 <code>props</code>、<code>data</code>、<code>methods</code>、<code>watch</code>、<code>computed</code> 等属性：</p><ul><li><code>beforeCreate</code> 的钩子函数中不能获取到 <code>props</code>、<code>data</code> 中定义的值，而又不能调用 <code>methods</code> 中定义的函数；</li><li>在这两个钩子函数执行的时候，并没有渲染 DOM，所以也不能够访问 DOM；</li><li>一般在组件加载的时候需要和后端有交互，则放在这两个钩子中均可；</li><li>如果是需要访问 <code>props</code>、<code>data</code> 等数据的话，就需要使用 <code>created</code> 钩子函数。</li></ul><blockquote><p>vue-router 和 vuex 都混合了 <code>beforeCreate</code> 钩子函数。</p></blockquote><h3 id="beforeMount-amp-mounted"><a href="#beforeMount-amp-mounted" class="headerlink" title="beforeMount &amp; mounted"></a>beforeMount &amp; mounted</h3><p><code>beforeMount</code> 钩子函数发生在 DOM 挂载之前，调用时机是在 <code>mountComponent</code> 函数中。</p><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  vm.$el = el</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeMount&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// manually mounted instance, call mounted on self</span></span><br><span class="line">  <span class="comment">// mounted is called for render-created child components in its inserted hook</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode == <span class="literal">null</span>) &#123;</span><br><span class="line">    vm._isMounted = <span class="literal">true</span></span><br><span class="line">    call(vm, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> vm</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行 <code>vm._render()</code> 函数渲染 VNode 之前，执行了 <code>beforeMounted</code> 钩子函数，在执行完 <code>vm._update()</code> 把 VNode patch 到真实 DOM 后，执行 <code>mounted</code> 钩子。</p><p>这里对 <code>mounted</code> 钩子函数执行有一个判断逻辑，<code>vm.$vnode</code> 如果为 <code>null</code>，则表明这不是依次组件的初始化过程，而是通过外部 <code>new Vue()</code> 初始化过程。</p><p>对于组件，<code>mounted</code> 的时机略有不同：</p><p>组件的 VNode patch 到 DOM 后，会执行 <code>invokeInsertHook</code> 函数，把 <code>insertedVnodeQueue</code> 里保存的钩子函数依次执行一遍。</p><p><code>src/core/vdom/patch.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">invokeInsertHook</span> (<span class="params">vnode, queue, initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// delay insert hook for component root nodes, invoke them after the</span></span><br><span class="line">  <span class="comment">// element is really inserted</span></span><br><span class="line">  <span class="keyword">if</span> (isTure(initial) &amp;&amp; inDef(vnode.parent)) &#123;</span><br><span class="line">    vnode.parent.data.pendingInsert = queue</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; queue.length; ++i) &#123;</span><br><span class="line">      queue[i].data.hook.insert(queue[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>invodeInsertHook</code> 函数会执行定义在 <code>componentVNodeHooks</code> 中的 <code>insert</code> 这个钩子函数。</p><p><code>src/core/vdom/create-component.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> componentVNodeHooks = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  insert (vnode: MountedComponentVNode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; context, componentInstance &#125; = vnode</span><br><span class="line">    <span class="keyword">if</span> (!componentInstance._isMounted) &#123;</span><br><span class="line">      componentInstance._isMounted = <span class="literal">true</span></span><br><span class="line">      callHook(componentInstance, <span class="string">&#x27;mounted&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个子组件都是在这个钩子函数中执行 <code>mounted</code> 钩子函数，且 <code>insertVnodeQueue</code> 的添加顺序是先子后父，所以对于同步渲染的子组件而言，<code>mounted</code> 钩子函数的执行顺序也是 <strong>先子后父</strong>。</p><h3 id="beforeUpdate-amp-updated"><a href="#beforeUpdate-amp-updated" class="headerlink" title="beforeUpdate &amp; updated"></a>beforeUpdate &amp; updated</h3><p><code>beforeUpdate</code> 和 <code>updated</code> 的钩子函数执行时机都应该是在数据更新的时候。</p><p><code>beforeUpdate</code> 的执行时机是在渲染 Watcher 的 <code>before</code> 函数中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// we set this to vm._watcher inside the watcher&#x27;s constructor</span></span><br><span class="line">  <span class="comment">// since the watcher&#x27;s initial patch may call $forceUpdate (e.g. inside child</span></span><br><span class="line">  <span class="comment">// component&#x27;s mounted hook), which relies on vm._watcher being already defined</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会判断，在组件已经 <code>mounted</code> 之后，才会去调用这个钩子函数。</p><p><code>update</code> 的执行时机是在 <code>flushSchedulerQueue</code> 函数调用的时候。</p><p><code>src/core/observer/scheduler.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 获取到 updatedQueue</span></span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callUpdatedHooks</span> (<span class="params">queue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = queue.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = queue[i]</span><br><span class="line">    <span class="keyword">const</span> vm = watcher.vm</span><br><span class="line">    <span class="keyword">if</span> (vm._watcher === watcher &amp;&amp; vm._isMounted &amp;&amp; !vm.isDestroyed) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;updated&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>updatedQueue</code> 是更新了的 <code>watcher</code> 数组，在 <code>callUpdatedHooks</code> 函数中，它对这些数组做遍历，只有满足当前 <code>watcher</code> 为 <code>vm._watcher</code> 以及组件已经 <code>mounted</code> 且未 <code>destroyed</code> 这三个条件，才会执行 <code>updated</code> 钩子函数。</p><p>在组件 mount 的过程中，会实例化一个渲染的 <code>Watcher</code> 去监听 <code>vm</code> 上的数据变化重新渲染，这发生在 <code>mountComponent</code> 函数执行的时候：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">mountComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  el?: Element,</span></span></span><br><span class="line"><span class="params"><span class="function">  hydrating?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 简写</span></span><br><span class="line">  <span class="keyword">let</span> updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    vm._update(vm._render(), hydrating)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">    before () &#123;</span><br><span class="line">      <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">        callHook(vm, <span class="string">&#x27;beforeUpdated&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="literal">true</span> <span class="comment">/* isRenderWatcher */</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实例化 <code>Watcher</code> 的过程中，在它的构造函数里会判断 <code>isRenderWatcher</code>，接着把当前 <code>watcher</code> 的实例赋值给 <code>vm._watcher</code>。</p><p><code>src/core/observer/watcher.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">   vm: Component,</span></span><br><span class="line"><span class="params">   expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   options?: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">   isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，还把当前 <code>watcher</code> 实例 push 到 <code>vm._watchers</code> 中，<code>vm._watcher</code> 是专门用来监听 <code>vm</code> 上数据变化然后重新渲染的，所以它是一个渲染相关的 <code>watcher</code>，因此在 <code>callUpdatedHook</code> 函数中，只有 <code>vm._watcher</code> 的回调执行完毕后，才会执行 <code>updated</code> 钩子函数。</p><h3 id="beforeDestroy-amp-destroyed"><a href="#beforeDestroy-amp-destroyed" class="headerlink" title="beforeDestroy &amp; destroyed"></a>beforeDestroy &amp; destroyed</h3><p><code>beforeDestroy</code> 和 <code>destroy</code> 钩子函数的执行时机在组件销毁的阶段，最终会调用 <code>$destroy</code> 方法：</p><p><code>src/core/instance/lifecycle.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$destroy = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._isBeingDestroyed) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  callHook(vm, <span class="string">&#x27;beforeDestroy&#x27;</span>)</span><br><span class="line">  <span class="comment">// ... 此处进行销毁操作</span></span><br><span class="line">  vm.isDestroyed = <span class="literal">true</span></span><br><span class="line">  <span class="comment">// incoke destroy hooks on current rendered tree</span></span><br><span class="line">  vm.__patch__(vm._vnode, <span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// fire destroyed hook</span></span><br><span class="line">  callHook(vm, <span class="string">&#x27;destroyed&#x27;</span>)</span><br><span class="line">  <span class="comment">// turn off all instance listeners</span></span><br><span class="line">  vm.$off()</span><br><span class="line">  <span class="comment">// remove __vue__ reference</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$el) &#123;</span><br><span class="line">    vm.$el.__vue__ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// release circular reference (#6759)</span></span><br><span class="line">  <span class="keyword">if</span> (vm.$vnode) &#123;</span><br><span class="line">    vm.$vnode.parent = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>beforeDestroy</code> 钩子函数的执行时机是在 <code>$destroy</code> 函数执行最开始的地方，接着执行了一些列的销毁操作：</p><ul><li>从 <code>parent</code> 的 <code>$children</code> 中删掉自身；</li><li>删除 <code>watcher</code>；</li><li>当前渲染的 VNode 执行销毁钩子函数等</li></ul><p>执行完毕后再调用 <code>destroyed</code> 钩子函数。</p><p>在 <code>$destroy</code> 的执行过程中，它又会执行 <code>vm.__patch__(vm.vnode, null)</code> 触发它子组件的销毁钩子函数，进行一层层的递归调用，所以 <code>destroyed</code> 钩子函数执行顺序是 <strong>先子后父</strong>，和 <code>mounted</code> 过程一样。</p><blockquote><p><code>beforeDestroy</code> 的调用顺序是 <strong>先父后子</strong>，<code>destroyed</code> 的调用顺序是 <strong>先子后父</strong>。</p></blockquote><h3 id="activated-amp-deactivated"><a href="#activated-amp-deactivated" class="headerlink" title="activated &amp; deactivated"></a>activated &amp; deactivated</h3><p><code>activated</code> 和 <code>deactivated</code> 钩子函数是专门为 <code>keep-alive</code> 组件定制的钩子。</p><blockquote><ul><li>在 <code>created</code> 钩子函数中可以访问到数据；</li><li>在 <code>mounted</code> 钩子函数中可以访问到 DOM；</li><li>在 <code>destroyed</code> 钩子函数中可以做一些定时器销毁工作…</li></ul></blockquote><h2 id="组件注册"><a href="#组件注册" class="headerlink" title="组件注册"></a>组件注册</h2><p>在 Vue.js 中，除了内置的组件 <code>keep-alive</code>、<code>transition</code>、<code>transition-group</code> 等，其他用户自定义组件在使用前必须注册，否则会报错：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;Unkown custom element: &lt;xxx&gt; - did you register the component correctly? For recursive components, make sure to provide the &quot;name&quot; option.&#x27;</span></span><br></pre></td></tr></table></figure><p>![image-20211123145637885](vue 源码/image-20211123145637885.png)</p><p>Vue.js 提供了 2 种组件注册的方式：全局注册 和 局部注册。</p><h3 id="全局注册"><a href="#全局注册" class="headerlink" title="全局注册"></a>全局注册</h3><p>要注册一个全局组件，可以使用 <code>Vue.component(tagName, options)</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;my-component&#x27;</span>, &#123;</span><br><span class="line">  <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>Vue.component</code> 的定义过程发生在初始化 Vue 的全局函数的时候：</p><p><code>src/core/global-api/assets.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; ASSET_TYPES &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/constants&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isplainObject, validateComponentName &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initAssetRegisters</span> (<span class="params">Vue: GlobalAPI</span>) </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create asset registration methods.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  ASSET_TYPES.forEach(<span class="function"><span class="params">type</span> =&gt;</span> &#123;</span><br><span class="line">    Vue[<span class="keyword">type</span>] = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    id: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">      definition: <span class="built_in">Function</span> | <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function">    </span>): <span class="title">Function</span> | <span class="title">Object</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!definition) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>,options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>][id]</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">        <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; <span class="keyword">type</span> === <span class="string">&#x27;component&#x27;</span>) &#123;</span><br><span class="line">          validateComponentName(id)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;component&#x27;</span> &amp;&amp; isPlainObject(definition)) &#123;</span><br><span class="line">          definition.name = definition.name || id</span><br><span class="line">          definition = <span class="built_in">this</span>.options._base.extend(definition)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">type</span> === <span class="string">&#x27;directive&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> definition === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          definition = &#123; <span class="attr">bind</span>: definition, <span class="attr">update</span>: definition &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">this</span>.options[<span class="keyword">type</span> + <span class="string">&#x27;s&#x27;</span>][id] = definition</span><br><span class="line">        <span class="keyword">return</span> definition</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>函数首先遍历 <code>ASSET_TYPES</code>，得到 <code>type</code> 后挂载到 Vue 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ASSET_TYPES = [</span><br><span class="line">  <span class="string">&#x27;component&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;directive&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;filter&#x27;</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>也就是 Vue 初始化了 3 个全局函数，并且当 <code>type</code> 是 <code>component</code> 且 <code>definition</code> 是一个对象的话，通过 <code>this.$options._base.extend</code>（即 <code>Vue.extend</code>）将这个对象转换成一个继承于 Vue 的构造函数，最后通过 <code>this.options[type + &#39;s&#39;][id] = definition</code> 把它挂载到 <code>Vue.options.components</code> 上。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Sub.options = mergeOptions(</span><br><span class="line">  Super.options,</span><br><span class="line">  extendOptions</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在继承中，会把 <code>Vue.options</code> 合并到 <code>Sub.options</code>，也就是组件的 <code>options</code> 上，然后在组件的实例化阶段，执行 <code>mergeOptions</code> 逻辑，把 <code>Sub.options.components</code> 合并到 <code>vm.$options.components</code> 上。</p><p>然后在创建 <code>vnode</code> 的过程中，会执行 <code>_createElement</code> 方法：</p><p><code>src/core/vdom/create-element.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">_createElement</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span> | Class&lt;Component&gt; | Funciton | <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data?: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> children?: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> normalizationType?: <span class="built_in">number</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> vnode, ns</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> tag == <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> Ctor</span><br><span class="line">    ns = (context.$vnode &amp;&amp; context.$vnode.ns) || config.getTagNamespace(tag)</span><br><span class="line">    <span class="keyword">if</span> (config.isReservedTag(tag)) &#123;</span><br><span class="line">      <span class="comment">// platform built-in elements</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">        config.parsePlatformTagName(tag), data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isDef(Ctor = resolveAsset(context.$options, <span class="string">&#x27;component&#x27;</span>, tag))) &#123;</span><br><span class="line">      <span class="comment">// component</span></span><br><span class="line">      vnode = createComponent(Ctor, data, context, children, tag)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// unknown or unlisted namespaced elements</span></span><br><span class="line">      <span class="comment">// check at runtime because it may get assigned a namespace when its</span></span><br><span class="line">      <span class="comment">// parent normalizes children</span></span><br><span class="line">      vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">      tag, data, children,</span><br><span class="line">        <span class="literal">undefined</span>, <span class="literal">undefined</span>, context</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// direct component options / constructor</span></span><br><span class="line">    vnode = createComponent(tag, data, context, children)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolveAsset</code> 的定义：</p><p><code>src/core/utils/options.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Resolve an asset.</span></span><br><span class="line"><span class="comment"> * This function is used because child instances need access</span></span><br><span class="line"><span class="comment"> * to assets defined in its ancestor chain.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsset</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">options: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> <span class="keyword">type</span>: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> id: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> warnMissing?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore is */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> id !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> assets = options[<span class="keyword">type</span>]</span><br><span class="line">  <span class="comment">// check local registration variations first</span></span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, id)) <span class="keyword">return</span> assets[id]</span><br><span class="line">  <span class="keyword">const</span> camelizedId = camelize(id)</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, camelizedId)) <span class="keyword">return</span> assets[camelizedId]</span><br><span class="line">  <span class="keyword">const</span> PascalCaseId = capitalize(camelizedId)</span><br><span class="line">  <span class="keyword">if</span> (hasOwn(assets, PascalCaseId)) <span class="keyword">return</span> assets[PascalCaseId]</span><br><span class="line">  <span class="comment">// fallback to prototype chain</span></span><br><span class="line">  <span class="keyword">const</span> res = assets[id] || assets[camelizedId] || assets[PascalCaseId]</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warnMissing &amp;&amp; !res) &#123;</span><br><span class="line">    warn(</span><br><span class="line">      <span class="string">&#x27;Failed to resolve &#x27;</span> + <span class="keyword">type</span>.slice(<span class="number">0</span>, -<span class="number">1</span>) + <span class="string">&#x27;: &#x27;</span> + id,</span><br><span class="line">      options</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li>先通过 <code>const assets = options[type]</code> 拿到 <code>assets</code>；</li><li>然后尝试拿 <code>assets[id]</code>：<ol><li>先直接使用 <code>id</code> 拿；</li><li>若不存在，把 <code>id</code> 变成驼峰的形式再拿；</li><li>还不存在，则在驼峰的基础上把首字母变成大写的形式再拿；</li><li>还拿不到，则报错。</li></ol></li></ol><blockquote><p>也就是说，在使用 <code>Vue.component(id, definition)</code> 全局注册组件时，id 可以是连字符、小驼峰或大驼峰。</p></blockquote><p>在 <code>resolveAsset(context.$options, &#39;components&#39;, tag)</code> 调用中，也就相当于拿 <code>vm.$options.component[tag]</code>，取到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p><h3 id="局部注册"><a href="#局部注册" class="headerlink" title="局部注册"></a>局部注册</h3><p>Vue.js 也支持局部注册，在一个组件内部使用 <code>components</code> 选项做组件的局部注册：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> HelloWorld <span class="keyword">from</span> <span class="string">&#x27;./components/HelloWorld&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    HelloWorld</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在组件的实例化阶段有一个合并 <code>option</code> 的逻辑，就是把 <code>components</code> 合并到 <code>vm.$options.components</code> 上，就可以在 <code>resolveAsset</code> 的时候拿到这个组件的构造函数，并作为 <code>createComponent</code> 的钩子的参数。</p><blockquote><p>局部组件的不同在于：只有该类型的组件才可以访问局部注册的子组件，而全局注册时扩展到 <code>Vue.options</code> 下。</p></blockquote><h2 id="异步组件"><a href="#异步组件" class="headerlink" title="异步组件"></a>异步组件</h2><p>为了减少首屏代码体积，往往会把一些非首屏的组件设计成异步组件，按需加载。Vue 也原生支持了异步的能力：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 这个特殊的 reuqire 语法告诉 webpack</span></span><br><span class="line">  <span class="comment">// 自动将编译后的代码分割成不同的块，</span></span><br><span class="line">  <span class="comment">// 这些块将通过 Ajax 请求自动下载</span></span><br><span class="line">  <span class="built_in">require</span>([<span class="string">&#x27;./my-async-component&#x27;</span>], resolve)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Vue 注册的组件不再是一个对象，而是一个工厂函数，函数有 <code>resolve</code> 和 <code>reject</code> 两个参数，内部调用了 <code>setTimeOut</code> 模拟了异步，实际使用可能是通过动态请求异步组件的 JS 地址，最终通过执行 <code>resolve</code> 方法，参数就是异步组件对象。</p><h3 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h3><p>组件的定义并不是一个普通对象，所以不会执行 <code>Vue.extend</code> 的逻辑变为一个组件的构造函数，但依旧执行 <code>createComponent</code> 函数：</p><p><code>src/core/vdom/create-component.js</code> 中：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">Ctor: Class&lt;component&gt; | <span class="built_in">Function</span> | <span class="built_in">Object</span> | <span class="built_in">void</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> data: VNodeData,</span></span></span><br><span class="line"><span class="params"><span class="function"> context: Component,</span></span></span><br><span class="line"><span class="params"><span class="function"> children: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function"> tag?: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> | <span class="title">Array</span>&lt;<span class="title">VNode</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isDef(Ctor)) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> baseCtor = context.$options._bases</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// plain options object: turn it into a constructor</span></span><br><span class="line">  <span class="keyword">if</span> (isObject(Ctor)) &#123;</span><br><span class="line">    Ctor = baseCtor.extend(Ctor)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// async component</span></span><br><span class="line">  <span class="keyword">let</span> asyncFactory</span><br><span class="line">  <span class="keyword">if</span> (isUndef(Ctor.cid)) &#123;</span><br><span class="line">    asyncFactory = Ctor</span><br><span class="line">    Ctor = resolveAsyncComponent(asuncFactory, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="comment">// return a placeholder node for async component, which is rendered</span></span><br><span class="line">      <span class="comment">// as a comment node but preserves all the raw information for the node.</span></span><br><span class="line">      <span class="comment">// the information will be used for async server-rendering and hydration.</span></span><br><span class="line">      <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">        asyncFactory,</span><br><span class="line">        data,</span><br><span class="line">        context,</span><br><span class="line">        children,</span><br><span class="line">        tag</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时传入的 <code>Ctor</code> 是一个函数，不会执行 <code>Vue.extend</code> 逻辑，因此 <code>cid</code> 是 <code>undefined</code>，进入异步组件创建逻辑，首先执行 <code>Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context)</code> 方法：</p><p><code>src/core/vdom/helpers/resolve-async-component.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">factory: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  baseCtor: Class&lt;Component&gt;</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Class</span>&lt;<span class="title">Component</span>&gt; | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.errorComp</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> owner = currrntRenderingInstance</span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; isDef(factory.owners) &amp;&amp; factory.owners.indexOf(owner) === -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">// already pending</span></span><br><span class="line">    factory.owners.push(owner)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingCamp)) &#123;</span><br><span class="line">    <span class="keyword">return</span> factory.owners.push(owner)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (owner &amp;&amp; !isDef(factory.owners)) &#123;</span><br><span class="line">    <span class="keyword">const</span> owners = factory.owners = [owner]</span><br><span class="line">    <span class="keyword">let</span> sync = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">let</span> timerLoading = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> timerTimeout = <span class="literal">null</span></span><br><span class="line">    </span><br><span class="line">    ;(owner: <span class="built_in">any</span>).$on(<span class="string">&#x27;hook:destroyed&#x27;</span>, <span class="function">() =&gt;</span> remove(owners, owner))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = owners.length; i &lt; l; i++) &#123;</span><br><span class="line">        (owner[i]: <span class="built_in">any</span>).$forceUpdate()</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">          timerLoading = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">          timerTimeout = <span class="literal">null</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> resolve = once(<span class="function">(<span class="params">res: <span class="built_in">Object</span> | Class&lt;Component&gt;</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// cache resolved</span></span><br><span class="line">      factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">      <span class="comment">// invoke callbacks only if this is not a synchronous resolve</span></span><br><span class="line">      <span class="comment">// (async resolves are shimmed as synchronous during SSR)</span></span><br><span class="line">      <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        owners.length = <span class="number">0</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`Failed to resolve async component: <span class="subst">$&#123;<span class="built_in">String</span>(factory)&#125;</span>`</span> +</span><br><span class="line">        (reason ? <span class="string">`\nReason: <span class="subst">$&#123;reason&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      )</span><br><span class="line">      <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">        factory.error = <span class="literal">true</span></span><br><span class="line">        forceRender(<span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> res = factory(resolve, reject)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sync = <span class="literal">false</span></span><br><span class="line">    <span class="comment">// return in case resolved synchronously</span></span><br><span class="line">    <span class="keyword">return</span> factory.loading</span><br><span class="line">    ? factory.loadingComp</span><br><span class="line">    : factory.resolved</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>resolveAsyncComponent</code> 函数逻辑较为复杂，实际处理了 3 种异步组件的创建方式：</p><ul><li><p>普通函数（工厂函数）异步组件；</p></li><li><p><code>Promise</code> 异步组件；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 该 `import` 函数返回一个 `Promise` 对象</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>高级异步组件。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件 -- 应当是一个 Promise</span></span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./MyComp.vue&#x27;</span>),</span><br><span class="line"><span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">  <span class="attr">loading</span>: LoasingComp,</span><br><span class="line">  <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">  <span class="attr">error</span>: ErrorComp,</span><br><span class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 最长等待时间。超出时间则渲染组件错误。默认：Infinity</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, AsyncComp)</span><br></pre></td></tr></table></figure></li></ul><h3 id="普通函数异步组件"><a href="#普通函数异步组件" class="headerlink" title="普通函数异步组件"></a>普通函数异步组件</h3><p>实际加载中，定义了 <code>forceRender</code>、<code>resolve</code> 和<code>inject</code> 函数，这里 <code>resolve</code> 和 <code>reject</code> 函数用 <code>once</code> 函数做了一层包装：</p><p><code>src/shared/util.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Ensure a function is called only once.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">once</span> (<span class="params">fn: <span class="built_in">Function</span></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> called = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!called) &#123;</span><br><span class="line">      called = <span class="literal">true</span></span><br><span class="line">      fn.apply(<span class="built_in">this</span>. <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：传入一个函数，并返回一个新函数，巧妙地利用闭包和一个标志位保证了它包装的函数只会执行一次。</p><p>接着执行 <code>const res = factory(resolve, reject)</code> 逻辑，即执行组件的工厂函数，同时把 <code>resolve</code> 和 <code>reject</code> 函数作为参数传入，组件的工厂函数通常会先发送请求去加载异步组件的 JS 文件，拿到组件定义的对象 <code>res</code> 后，执行 <code>resolve(res)</code> 逻辑，会先执行 <code>factory.resolved = ensureCtor(res, baseCtor)</code>：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ensureCtor</span> (<span class="params">comp: <span class="built_in">any</span>, base</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    comp.__esModule ||</span><br><span class="line">    (hasSymbol &amp;&amp; comp[<span class="built_in">Symbol</span>.toStringTag] === <span class="string">&#x27;Moudule&#x27;</span>)</span><br><span class="line">  ) &#123;</span><br><span class="line">    comp = comp.default</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> isObject(comp)</span><br><span class="line">? base.extend(comp)</span><br><span class="line">  : comp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ensureCtor</code> 的目的是为了保证能找到异步组件 JS 定义的组件对象，并且如果是一个普通对象，则调用 <code>Vue.extend</code> 把它转换成一个组件的构造函数。</p><p><code>resolve</code> 的逻辑最后判断了 <code>sunc</code>，为 <code>false</code> 则会执行 <code>forceRender</code> 函数：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> forceRender = <span class="function">(<span class="params">renderCompleted: <span class="built_in">boolean</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = owners.length; i &lt; l; i++) &#123;</span><br><span class="line">    (owners[i]: <span class="built_in">any</span>).$forceUpdate()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (renderCompleted) &#123;</span><br><span class="line">    owners.length = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (timerLoading !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerLoading)</span><br><span class="line">      timerLoading = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (timerTimeout !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timerTimeout)</span><br><span class="line">      timerTimeout = <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>遍历 <code>factory.owners</code>；</li><li>拿到每一个调用异步组件的实例 <code>vm</code>；</li><li>执行 <code>vm.$forceUpdate()</code> 方法。</li></ul><p><code>src/core/instance.lifecycle.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$forceUpdate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (vm._watcher) &#123;</span><br><span class="line">    vm._watcher.updata()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：调用渲染 <code>watcher</code> 的 <code>update</code> 方法，让渲染 <code>watcher</code> 对应的回调函数执行，也就是触发了组件的重新渲染。</p><h3 id="Promise-异步组件"><a href="#Promise-异步组件" class="headerlink" title="Promise 异步组件"></a>Promise 异步组件</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(</span><br><span class="line">  <span class="string">&#x27;async-webpack-example&#x27;</span>,</span><br><span class="line">  <span class="comment">// 该 `import` 函数返回一个 `Promise` 对象。</span></span><br><span class="line">  <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;./my-async-component&#x27;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>webpack 2+ 支持了异步加载的语法糖：<code>() =&gt; import(&#39;./my-async-component&#39;)</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回的值就是 <code>import(&#39;./my-async-component&#39;)</code> 的返回值，是一个 <code>Promise</code> 对象。</p><p>接着进入 if 条件判断 <code>isObject(res)</code> 和 <code>isPromise(res)</code>，条件满足，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isObject(res)) &#123;</span><br><span class="line">  <span class="keyword">if</span> (isPromise(res)) &#123;</span><br><span class="line">    <span class="comment">// () =&gt; Promise</span></span><br><span class="line">    <span class="keyword">if</span> (imUndef(factory.resolved)) &#123;</span><br><span class="line">      res.then(resolve, reject)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组件异步加载成功后，执行 <code>resolve</code>，加载失败则执行 <code>reject</code>，这样就非常巧妙地实现了配合 webpack 2+ 的异步加载组件方式（<code>Promise</code>）加载异步组件。</p><h3 id="高级异步组件"><a href="#高级异步组件" class="headerlink" title="高级异步组件"></a>高级异步组件</h3><p>由于异步加载组件需要加载 JS，有一定网络延时，而且有加载失败的情况，所以需要设计 loading 组件和 error 组件，并在适当的时机渲染它们。</p><p>Vue.js 2.3+ 支持了一种高级异步组件的方式，它通过一个简单的对象配置，搞定 loading 组件和 error 组件的渲染时机：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> AsyncComp = <span class="function">() =&gt;</span> (&#123;</span><br><span class="line">  <span class="comment">// 需要加载的组件。应当是一个 Promise</span></span><br><span class="line">  <span class="attr">component</span>: <span class="keyword">import</span>(<span class="string">&#x27;./MyComp.vue&#x27;</span>),</span><br><span class="line">  <span class="comment">// 加载中应当渲染的组件</span></span><br><span class="line">  <span class="attr">loading</span>: LoadingComp,</span><br><span class="line">  <span class="comment">// 出错时渲染的组件</span></span><br><span class="line">  <span class="attr">error</span>: ErrorComp,</span><br><span class="line">  <span class="comment">// 渲染加载中组件前的等待时间。默认：200ms</span></span><br><span class="line">  <span class="attr">delay</span>: <span class="number">200</span>,</span><br><span class="line">  <span class="comment">// 最长等待时间。超出此时间则渲染错误组件。默认：Infinity</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">3000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">&#x27;async-example&#x27;</span>, AsyncComp)</span><br></pre></td></tr></table></figure><p>高级一部组件的初始化逻辑和普通异步组件一样，也是执行 <code>resolveAsyncComponent</code>，当执行完 <code>res = factory(resolve, reject)</code>，返回值就是定义的组件对象，满足 <code>isObject(res)</code> 和 <code>isPromise(res.component)</code>，接着执行 <code>res.component.then(resolve, reject)</code>，当异步组件加载成功后，执行 <code>resolve</code>，失败执行 <code>reject</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isPromise(res.component)) &#123;</span><br><span class="line">  res.component.then(resolve, reject)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为异步组件加载是一个异步过程，所以接着执行以下逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">resolveAsyncComponent</span> (<span class="params">factory, baseCtor</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (isDef(res.error)) &#123;</span><br><span class="line">    factory.errorComp = ensureCtor(res.error, baseCtor)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isDef(res.loading)) &#123;</span><br><span class="line">    factory.loadingComp = ensureCtor(res.loading, baseCtor)</span><br><span class="line">    <span class="keyword">if</span> (res.delay === <span class="number">0</span>) &#123;</span><br><span class="line">      factory.loading = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeLoading = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        timerLoading = <span class="literal">null</span></span><br><span class="line">        <span class="keyword">if</span> (isUndef(factory.resolved) &amp;&amp; inUndef(factory.error)) &#123;</span><br><span class="line">          factory.loading = <span class="literal">true</span></span><br><span class="line">          forceRender(<span class="literal">false</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, res.delay || <span class="number">200</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDef(res.timeout)) &#123;</span><br><span class="line">    timerTimeout = <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      timerTmeout = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (inUndef(factory.resolved)) &#123;</span><br><span class="line">        reject(</span><br><span class="line">          process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">          ? <span class="string">`timeout (<span class="subst">$&#123;res.timeout&#125;</span>ms)`</span></span><br><span class="line">          : <span class="literal">null</span></span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, res.timeout)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>先判断 <code>res.error</code> 是否定义了 <code>error</code> 组件，有则赋值给 <code>factory.errorComp</code>；</li><li>接着判断 <code>res.loading</code> 是否定义了 <code>loading</code> 组件，有则赋值给 <code>factory.loadingComp</code>；</li><li>如果设置了 <code>res.delay</code> 且为 0，则设置 <code>factory.loading = true</code>，否则延时 <code>delay</code> 的时间执行；</li><li>最后判断 <code>res.timeout</code>，若配置了，则在 <code>res,timeout</code> 时间后没成功加载组件执行 <code>reject</code>。</li></ul><p>在 <code>resolveAsyncComponent</code> 最后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sync = <span class="literal">false</span></span><br><span class="line"><span class="keyword">return</span> factory.loading</span><br><span class="line">? factory.loadingComp</span><br><span class="line">: factory.resolved</span><br></pre></td></tr></table></figure><p>如果 <code>delay</code> 为 0，则直接渲染 loading 组件，否则延时 <code>delay</code> 执行 <code>forceRender</code>，那么在一次执行到 <code>resolveAsyncComponent</code>。</p><h4 id="加载失败-reject"><a href="#加载失败-reject" class="headerlink" title="加载失败 reject"></a>加载失败 reject</h4><p>当异步组件加载失败，会执行 <code>reject</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> reject = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">    <span class="string">`Failed to resolve async component: <span class="subst">$&#123;Stirng(factory)&#125;</span>`</span> +</span><br><span class="line">    (reason ? <span class="string">`\nReason: <span class="subst">$&#123;reason&#125;</span>`</span> : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">  <span class="keyword">if</span> (isDef(factory.errorComp)) &#123;</span><br><span class="line">    factory.error = <span class="literal">true</span></span><br><span class="line">    forceRender()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这时候会把 <code>factory.error</code> 设置为 <code>true</code>，同时执行 <code>forceRender()</code> 再次执行到 <code>resolveAsyncComponent</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(factory.error) &amp;&amp; isDef(factory.errorComp)) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory.errorComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会直接返回 <code>factory.errorComp</code>，直接渲染 error 组件。</p><h4 id="加载成功-resolve"><a href="#加载成功-resolve" class="headerlink" title="加载成功 resolve"></a>加载成功 resolve</h4><p>当异步组件加载失败，会执行 <code>resolve</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> resolve = once(<span class="function"><span class="params">reason</span> =&gt;</span> &#123;</span><br><span class="line">  factory.resolved = ensureCtor(res, baseCtor)</span><br><span class="line">  <span class="keyword">if</span> (!sync) &#123;</span><br><span class="line">    forceRender()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>首先把加载结果缓存到 <code>factory.resolved</code> 中，此时 <code>sync</code> 已经为 false，则执行 <code>forceRender()</code> 再次执行到 <code>resolvedAsyncComponent</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDef(factory.resolved)) &#123;</span><br><span class="line">  <span class="keyword">return</span> factory.resolved</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时直接返回 <code>factory.resolved</code>，渲染成功加载的组件。</p><h4 id="加载中-loading"><a href="#加载中-loading" class="headerlink" title="加载中 loading"></a>加载中 loading</h4><p>如果异步组件加载中并未返回，此时会执行以下逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isTrue(factory.loading) &amp;&amp; isDef(factory.loadingComp)) &#123;</span><br><span class="line">  <span class="keyword">return</span> dactory.loadingComp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时返回 <code>factory.loadingComp</code>，渲染 loading 组件。</p><h4 id="加载超时-timeout"><a href="#加载超时-timeout" class="headerlink" title="加载超时 timeout"></a>加载超时 timeout</h4><p>若加载超时，则走到了 <code>reject</code> 逻辑，之后同加载失败，渲染 error 组件。</p><blockquote><p>异步组件实现的本质是两次（或三次）渲染，先渲染成注释节点，当组件加载成功后，再通过 forceRender 重新渲染。</p></blockquote><h3 id="异步组件-patch"><a href="#异步组件-patch" class="headerlink" title="异步组件 patch"></a>异步组件 patch</h3><p>回看 <code>createComponent</code> 逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Ctor = resolveAsyncComponent(asyncFactory, baseCtor)</span><br><span class="line"><span class="keyword">if</span> (Ctor === <span class="literal">undefined</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> createAsyncPlaceholder(</span><br><span class="line">    asyncFactory,</span><br><span class="line">    data,</span><br><span class="line">    context,</span><br><span class="line">    children,</span><br><span class="line">    tag</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果是首次执行 <code>resolveAsyncComponent</code>，除非使用高级异步组件 <code>0 delay</code> 去创建了一个 loading 组件，否则返回是 <code>undefined</code>，接着通过 <code>createAsyncPlaceholder</code> 创建一个注释节点作为占位符：</p><p><code>src/core/vdom/helpers/resolve-async-components.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createAsyncPlaceholder</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">factory: Funciton,</span></span></span><br><span class="line"><span class="params"><span class="function">   data: VnodeData,</span></span></span><br><span class="line"><span class="params"><span class="function">   context: Compnent,</span></span></span><br><span class="line"><span class="params"><span class="function">   children: <span class="built_in">Array</span>&lt;VNode&gt;,</span></span></span><br><span class="line"><span class="params"><span class="function">   tag: <span class="built_in">string</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">VNode</span> </span>&#123;</span><br><span class="line"> <span class="keyword">const</span> node = createEmptyVNode()</span><br><span class="line">  node.asyncFactory = factory</span><br><span class="line">  node.asyncMeta = &#123; data, context, children, tag &#125;</span><br><span class="line">  <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是创建了一个占位的注释 VNode，同时把 <code>asyncFactory</code> 和 <code>asyncMeta</code> 赋值给当前 <code>vnode</code>。</p><p>当执行 <code>forceRender</code> 时，会触发组件的重新渲染，将会再一次执行 <code>resolveAsyncComponent</code>，此时就会根据情况返回 loading、error 或 成功加载的异步组件，返回值不为 <code>undefined</code>，因此就走正常的组件 <code>render</code>、<code>patch</code> 过程，与第一次渲染流程不一样。</p><h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p>前端开发最重要的 2 个工作：</p><ul><li>把数据渲染到页面</li><li>处理用户交互</li></ul><h2 id="响应式对象"><a href="#响应式对象" class="headerlink" title="响应式对象"></a>响应式对象</h2><p>Vue.js 实现响应式的核心是利用了 ES5 的 <code>Object.defineProperty</code>，这也是 Vue.js 不能兼容 IE8 及以下浏览器的原因。</p><h3 id="Object-defineProperty"><a href="#Object-defineProperty" class="headerlink" title="Object.defineProperty"></a>Object.defineProperty</h3><blockquote><p>MDN 文档：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</a></p></blockquote><p><code>Object.defineProperty</code> 方法会直接再一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回这个对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(obj, prop, descriptor)</span><br></pre></td></tr></table></figure><ul><li><code>obj</code>：要在其上定义属性的对象；</li><li><code>props</code>：要定义或修改的属性的名称；</li><li><code>descriptor</code>：将被定义或修改的属性描述符。</li></ul><p>其中 <code>descriptor</code> 是核心，它有很多可选键值：</p><ul><li><code>get</code>：是一个给属性提供的 getter 方法，访问该属性时会触发 getter 方法；</li><li><code>set</code>：是一个给属性提供的 setter 方法，对该属性做修改时会触发 setter 方法。</li></ul><p>一旦对象拥有了 getter 和 setter，我们就可以简单地把这个对象称为<strong>响应式对象</strong>。</p><h3 id="initState"><a href="#initState" class="headerlink" title="initState"></a>initState</h3><p>在 Vue 的初始化阶段，<code>_init</code> 方法执行时，会执行 <code>initState(vm)</code> 方法：</p><p><code>src/core/instance/state.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">const</span> opts = vm.$options</span><br><span class="line">  <span class="keyword">if</span> (opts.props) initProps(vm, opts.props)</span><br><span class="line">  <span class="keyword">if</span> (opts.methods) initMethods(vm, opts.methods)</span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (opts.computed) initComputed(vm, opts.computed)</span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>initState</code> 方法主要是对 <code>props</code>、<code>methods</code>、<code>data</code>、<code>computed</code> 和 <code>watcher</code> 等属性做初始化操作。</p><h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm: Component, propsOptions: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> props = vm._props = &#123;&#125;</span><br><span class="line">  <span class="comment">// cache prop keys so that future props updates can iterate using Array</span></span><br><span class="line">  <span class="comment">// instead of dynamic object key enumeration.</span></span><br><span class="line">  <span class="keyword">const</span> keys = vm.$options._propsKeys = []</span><br><span class="line">  <span class="keyword">const</span> isRoot = !vm.$parent</span><br><span class="line">  <span class="comment">// root instance props should be converted</span></span><br><span class="line">  <span class="keyword">if</span> (!isRoot) &#123;</span><br><span class="line">    toggleObsering(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> propsOptions) &#123;</span><br><span class="line">    keys.push(key)</span><br><span class="line">    <span class="keyword">const</span> value = validateProp(key, propsOptions, propsData, vm)</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> hyphenatedKey = hyphenate(key)</span><br><span class="line">      <span class="keyword">if</span> (isReservedAttribute(hyphenatedKey) ||</span><br><span class="line">          config.isReservedAttr(hyphenatedKey)) &#123;</span><br><span class="line">warn(</span><br><span class="line">          <span class="string">`&quot;<span class="subst">$&#123;hyphenatedKey&#125;</span>&quot; is a reserved attribute and cannot be used as component prop.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">      defineReactive(props, key, value, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isRoot &amp;&amp; !isUpdatingChildComponent) &#123;</span><br><span class="line">          warn(</span><br><span class="line">            <span class="string">`Avoid mutating a prop directly since the value will be `</span> +</span><br><span class="line">            <span class="string">`overwritten whenever the parent component re-renders. `</span> +</span><br><span class="line">            <span class="string">`Instead, use a data or computed property based on the prop&#x27;s `</span> +</span><br><span class="line">            <span class="string">`values. Prop being mutated: &quot;<span class="subst">$&#123;key&#125;</span>&quot;`</span>,</span><br><span class="line">            vm</span><br><span class="line">          )</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      defineReactive(props, key, value)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// static props are already proxied on the component&#x27;s prototype</span></span><br><span class="line">    <span class="comment">// during Vue.extend(). We only need to proxy props defined at</span></span><br><span class="line">    <span class="comment">// instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_props`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  toggleObserving(<span class="literal">true</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>props</code> 的初始化主要过程就是：遍历定义的 <code>props</code> 配置。</p><ol><li>调用 <code>defineReactive</code> 方法把每个 <code>prop</code> 对应的值变成响应式，可以通过 <code>vm._props.xxx</code> 访问到定义 <code>props</code> 中对应的属性；</li><li>通过 <code>proxy</code> 把 <code>vm._props.xxx</code> 的访问代理到 <code>vm.xxx</code> 上。</li></ol><h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm: Component</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> data = vm.$options.data</span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span></span><br><span class="line">  ? getData(data, vm)</span><br><span class="line">  : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (!isPLainObject(data)) &#123;</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">`data functions should return an object:\n`</span> +</span><br><span class="line">      <span class="string">&#x27;https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function&#x27;</span>,</span><br><span class="line">      vm</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// proxy data on instance</span></span><br><span class="line">  <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">const</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">const</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">let</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">`Method &quot;<span class="subst">$&#123;key&#125;</span>&quot; has already been defined as a data property.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">        <span class="string">`The data property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already declared as a prop. `</span> +</span><br><span class="line">        <span class="string">`Use prop default value instead.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">`_data`</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>data</code> 的初始化主要过程：</p><ol><li>对定义的 <code>data</code> 函数返回对象的遍历，通过 <code>proxy</code> 把每一个值 <code>vm._data.xxx</code> 都代理到 <code>vm.xxx</code> 上；</li><li>调用 <code>observe</code> 方法观测整个 <code>data</code> 的变化，把 <code>data</code> 也变成响应式，可以通过 <code>vm._data.xxx</code> 访问到定义 <code>data</code> 返回函数中对应的属性。</li></ol><h3 id="proxy"><a href="#proxy" class="headerlink" title="proxy"></a>proxy</h3><p>代理：作用就是把 <code>props</code> 和 <code>data</code> 上的属性代理到 <code>vm</code> 实例上。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sharedPropertyDefinition = &#123;</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">get</span>: noop,</span><br><span class="line">  set noop</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">proxy</span> (<span class="params">target: <span class="built_in">Object</span>, sourceKey: <span class="built_in">string</span>, key: <span class="built_in">string</span></span>) </span>&#123;</span><br><span class="line">  sharedPropertyDefinition.get = <span class="function"><span class="keyword">function</span> <span class="title">proxyGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>[sourceKey][key]</span><br><span class="line">  &#125;</span><br><span class="line">  sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> <span class="title">proxySetter</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>[sourceKey][key] = val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现原理：通过 <code>Object.defineProperty</code> 把 <code>target[sourceKey][key]</code> 的读写变成了对 <code>target[key]</code> 的读写。</p><h3 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h3><p><code>observe</code> 的功能就是用来监测数据的变化</p><p><code>src/core/observer/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Attempt to create an observer instance for a value,</span></span><br><span class="line"><span class="comment"> * returns the observer if successfully observed,</span></span><br><span class="line"><span class="comment"> * or the existing observer if the value already has one.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">observe</span> (<span class="params">value: <span class="built_in">any</span>, asRootData: <span class="built_in">boolean</span></span>): <span class="title">Observer</span> | <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!isObject(value) || value <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ob: Observer | <span class="built_in">void</span></span><br><span class="line">  <span class="keyword">if</span> (hasWon(value, <span class="string">&#x27;__ob__&#x27;</span>) &amp;&amp; value.__ob__ <span class="keyword">instanceof</span> Observer) &#123;</span><br><span class="line">    ob = value.__ob__</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    shouldObserve &amp;&amp;</span><br><span class="line">    !serverRendering() &amp;&amp;</span><br><span class="line">    (<span class="built_in">Array</span>.isArray(value) || isPlainObject(value)) &amp;&amp;</span><br><span class="line">    !value._isVue</span><br><span class="line">  ) &#123;</span><br><span class="line">    ob = <span class="keyword">new</span> Observer(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (asRootData &amp;&amp; ob) &#123;</span><br><span class="line">    ob.vmCount++</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ob</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作用：给非 VNode 的对象类型数据添加一个 <code>Observer</code>：</p><ul><li>如果已经添加过则直接返回；</li><li>否则在满足一定条件下去实例化一个 <code>Observer</code> 对象实例。</li></ul><h3 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h3><p><code>Observer</code> 是一个类，作用是给对象的属性添加 getter 和 setter，用于依赖收集和派发更新：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Observer class that is attacted to each observed</span></span><br><span class="line"><span class="comment"> * object. ONce attached, the observer converts the target</span></span><br><span class="line"><span class="comment"> * object&#x27;s property keys into getter/setters that</span></span><br><span class="line"><span class="comment"> * collect dependencies and dispatch updates.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: <span class="built_in">number</span>; <span class="comment">// number of vms that has this object as root $data</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCOunt = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Walk through all properties and convert them into</span></span><br><span class="line"><span class="comment">   * getter/setters. This method should only be called when</span></span><br><span class="line"><span class="comment">   * value type is Object.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  walk (obj: <span class="built_in">Object</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Observe a list of Array items.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  observeArray (items: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt;) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = items.length; i &lt; l; i++) &#123;</span><br><span class="line">      observe(items[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li><p>首先实例化 <code>Dep</code> 对象；</p></li><li><p>通过执行 <code>dep</code> 函数把自身实例添加到数据对象 <code>value</code> 的 <code>__ob__</code> 属性上；</p><p><code>src/core/util/lang.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a property.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">def</span> (<span class="params">obj: <span class="built_in">Object</span>, key: <span class="built_in">string</span>, val: <span class="built_in">any</span>, enumerable?: <span class="built_in">boolean</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">value</span>: val,</span><br><span class="line">    <span class="attr">enumerable</span>: !!enumerable,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>def</code> 函数是一个 <code>Object.defineProperty</code> 的封装。</p></li><li><p>对 <code>value</code> 做判断：</p><ul><li>数组：调用 <code>observeArray</code> 方法，遍历数组再次调用 <code>observe</code> 方法；</li><li>纯对象：调用 <code>walk</code> 方法，遍历对象的 key 调用 <code>defineReactive</code> 方法。</li></ul></li></ul><h3 id="defineReactive"><a href="#defineReactive" class="headerlink" title="defineReactive"></a>defineReactive</h3><p><code>defineReactive</code> 的功能就是定义一个响应式对象，给对象动态添加 getter 和 setter</p><p><code>src/core/observer/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Define a reactive property on an Object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">obj: <span class="built_in">Object</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> val: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> customSetter?: <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function"> shallow?: <span class="built_in">boolean</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// cater for pre-defined getter/setters</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="keyword">if</span> ((!getter || setter) &amp;&amp; argument.length === <span class="number">2</span>) &#123;</span><br><span class="line">    val = obj[key]</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ol><li>初始化 <code>Dep</code> 对象的实例；</li><li>拿到 <code>obj</code> 的属性描述符；</li><li>然后对子对象递归调用 <code>observe</code> 方法；</li><li>利用 <code>Object.defineProperty</code> 给 <code>obj</code> 的属性 <code>key</code> 添加 getter 和 setter。</li></ol><h2 id="依赖收集"><a href="#依赖收集" class="headerlink" title="依赖收集"></a>依赖收集</h2><p>响应式对象 getter 相关的逻辑就是做 <strong>依赖收集</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">definedReactive</span> (<span class="params">obj, key, val,customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">        <span class="keyword">if</span> (childOb) &#123;</span><br><span class="line">          childOb.dep.depend()</span><br><span class="line">          <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">            dependArray(value)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> value</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键点：</p><ol><li><code>const dep = new Dep()</code> 实例化一个 <code>Dep</code> 的实例；</li><li>通过 <code>dep.depend()</code> 做依赖收集，其中对 <code>childOb</code> 做判断。</li></ol><h3 id="Dep"><a href="#Dep" class="headerlink" title="Dep"></a>Dep</h3><p><code>Dep</code> 是整个 getter 依赖收集的核心</p><p><code>src/core/observer/dep.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> Watcher <span class="keyword">from</span> <span class="string">&#x27;./watcher&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; remove &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * A dep is an observable that can hace multiple</span></span><br><span class="line"><span class="comment"> * directives subscribing to it.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> target: Watcher;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  subs: <span class="built_in">Array</span>&lt;Watcher&gt;;</span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  addSub (sub: Watcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.subs.push(sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  removeSub (sub: Watcher) &#123;</span><br><span class="line">    remove(<span class="built_in">this</span>.subs, sub)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">      Dep.target.addDep(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subscriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not running async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      subs.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// The current target watcher being evaluated.</span></span><br><span class="line"><span class="comment">// This is globally unique because only one watcher</span></span><br><span class="line"><span class="comment">// can be evaluated at a time.</span></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br><span class="line"><span class="keyword">const</span> targetStack = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">target: Watcher</span>) </span>&#123;</span><br><span class="line">  targetStack.push(target)</span><br><span class="line">  Dep.target = target</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">popTarget</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  targetStack.pop()</span><br><span class="line">  Dep.target = targetStack[targetStack.length - <span class="number">1</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dep</code> 是一个 Class，定义了一些属性和方法，其中关键的是有一个静态属性 <code>target</code>，是一个全局唯一 <code>Watcher</code>，它的自身属性 <code>subs</code> 是一个 <code>Watcher</code> 的数组。</p><blockquote><p><code>Dep</code> 实际上就是对 <code>Watcher</code> 的一种管理，<code>Dep</code> 脱离 <code>Watcher</code> 单独存在是没有意义的。</p></blockquote><h3 id="Watcher"><a href="#Watcher" class="headerlink" title="Watcher"></a>Watcher</h3><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Wathcer</span> </span>&#123;</span><br><span class="line">  <span class="attr">vm</span>: Component;</span><br><span class="line">  expression: <span class="built_in">string</span>;</span><br><span class="line">  cb: <span class="built_in">Function</span>;</span><br><span class="line">  id: <span class="built_in">number</span>;</span><br><span class="line">  deep: <span class="built_in">boolean</span>;</span><br><span class="line">  user: <span class="built_in">boolean</span>;</span><br><span class="line">  lazy: <span class="built_in">boolean</span>;</span><br><span class="line">  sync: <span class="built_in">boolean</span>;</span><br><span class="line">  dirty: <span class="built_in">boolean</span>;</span><br><span class="line">  active: <span class="built_in">boolean</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  deps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  newDeps: <span class="built_in">Array</span>&lt;Dep&gt;;</span><br><span class="line">  depIds: SimpleSet;</span><br><span class="line">  newDepIds: SimpleSet;</span><br><span class="line">  before: <span class="built_in">Function</span>;</span><br><span class="line">  getter: <span class="built_in">Function</span>;</span><br><span class="line">  value: <span class="built_in">any</span>;</span><br><span class="line"></span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">   vm: Component,</span></span><br><span class="line"><span class="params">   expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">   options?: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">   isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params">  </span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.vm = vm</span><br><span class="line">    <span class="keyword">if</span> (isRenderWatcher) &#123;</span><br><span class="line">      vm._watcher = <span class="built_in">this</span></span><br><span class="line">    &#125;</span><br><span class="line">    vm._watchers.push(<span class="built_in">this</span>)</span><br><span class="line">    <span class="comment">// options</span></span><br><span class="line">    <span class="keyword">if</span> (options) &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">      <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">      <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">      <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">      <span class="built_in">this</span>.before = !!options.before</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.deep <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.cb = cb</span><br><span class="line">    <span class="built_in">this</span>.id = ++uid <span class="comment">// uid for batching</span></span><br><span class="line">    <span class="built_in">this</span>.active = <span class="literal">true</span></span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="built_in">this</span>.computed <span class="comment">// for computed watchers</span></span><br><span class="line">    <span class="built_in">this</span>.deps = []</span><br><span class="line">    <span class="built_in">this</span>.newDeps = []</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line">    <span class="built_in">this</span>.expression = process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span></span><br><span class="line">      ? expOrFn.toString()</span><br><span class="line">    : <span class="string">&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">// parse expression for getter</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> expOrFn === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.getter = parsePath(expOrFn)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.getter) &#123;</span><br><span class="line">        <span class="built_in">this</span>.getter = noop</span><br><span class="line">        process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">          <span class="string">`Failed watching path: &quot;<span class="subst">$&#123;expOrFn&#125;</span>&quot; `</span> +</span><br><span class="line">          <span class="string">`Watcher only accepts simple dot-delimited paths. `</span> +</span><br><span class="line">          <span class="string">`For full control, use a function instead.`</span>,</span><br><span class="line">          vm</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">      ? <span class="literal">undefined</span></span><br><span class="line">    : <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Evaluate the getter, and re-collect dependencies</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  get () &#123;</span><br><span class="line">    pushTarget(<span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">let</span> value</span><br><span class="line">    <span class="keyword">const</span> vm = <span class="built_in">this</span>.vm</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        handleError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      <span class="comment">// &quot;touch&quot; every property so they are all tracked as</span></span><br><span class="line">      <span class="comment">// dependencies for deep watching</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">        traverse(value)</span><br><span class="line">      &#125;</span><br><span class="line">      popTarget()</span><br><span class="line">      <span class="built_in">this</span>.cleanupDeps()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Add a dependency to this directive.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  addDep (dep: Dep) &#123;</span><br><span class="line">    <span class="keyword">const</span> id = dep.id</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.newDepIds.add(id)</span><br><span class="line">      <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">        dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Clean up for dependency collection.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  cleanupDeps () &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">    <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">      <span class="keyword">const</span> dep = <span class="built_in">this</span>.deps[i]</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">        dep.removeSub(<span class="built_in">this</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> tmp = <span class="built_in">this</span>.depIds</span><br><span class="line">    <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds</span><br><span class="line">    <span class="built_in">this</span>.newDepIds = tmp</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.clear()</span><br><span class="line">    tmp = <span class="built_in">this</span>.deps</span><br><span class="line">    <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps</span><br><span class="line">    <span class="built_in">this</span>.newDeps = tmp</span><br><span class="line">    <span class="built_in">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Watcher</code> 是一个 Class，其中定义了一些和 <code>Dep</code> 相关的属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.deps = []</span><br><span class="line"><span class="built_in">this</span>.newDeps = []</span><br><span class="line"><span class="built_in">this</span>.depIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="built_in">this</span>.newDepIds = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br></pre></td></tr></table></figure><ul><li><code>this.deps</code> 和 <code>this.newDeps</code> 表示 <code>Watcher</code> 实例特有的 <code>Dep</code> 实例的数组；</li><li><code>this.depIds</code> 和 <code>this.newDepIds</code> 分别代表 <code>this.deps</code> 和 <code>this.newDeps</code> 的 <code>id</code> Set；<ul><li>Set 是 ES6 的数据结构，实现在 <code>src/core/util/env.js</code> 中</li></ul></li><li>还定义了一些原型的方法，和依赖收集相关的包括<code>get</code>、<code>addDep</code>、<code>cleanupDeps</code> 方法。</li></ul><h3 id="过程分析"><a href="#过程分析" class="headerlink" title="过程分析"></a>过程分析</h3><p>Vue 的 mount 过程是通过 <code>mountComponent</code> 函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(), hydrating)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Watcher(vm, updateComponent, noop, &#123;</span><br><span class="line">  before () &#123;</span><br><span class="line">    <span class="keyword">if</span> (vm._isMounted) &#123;</span><br><span class="line">      callHook(vm, <span class="string">&#x27;beforeUpdate&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>当实例化一个渲染 <code>watcher</code> 时，首先进入 <code>watcher</code> 的构造函数逻辑，然后会执行它的 <code>this.get()</code> 方法，进入 <code>get</code> 函数，首先执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pushTarget(<span class="built_in">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">pushTarget</span> (<span class="params">_target: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Dep.target) targetStack.push(Dep.target)</span><br><span class="line">  Dep .target = _target</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上就是把 <code>Dep.target</code> 赋值为当前的渲染 <code>watcher</code> 并压栈；</p><p>接着执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br></pre></td></tr></table></figure><p><code>this.getter</code> 对应就是 <code>updateComponent</code> 函数，实际上就是在执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm._update(vm._render(), hydrating)</span><br></pre></td></tr></table></figure><p>先执行 <code>vm._render()</code> 方法，生成渲染 VNode，并访问 <code>vm</code> 上的数据，此时触发了数据对象的 getter。</p><p>每个对象值的 getter 都持有一个 <code>dep</code>，在触发 getter 时会调用 <code>dep.depend()</code> 方法，执行 <code>Dep.target.addDep(this)</code>。</p><p>此时 <code>Dep.target</code> 已经被赋值为渲染 <code>watcher</code>，执行到 <code>addDep</code> 方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addDep</span> (<span class="params">dep: Dep</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = dep.id</span><br><span class="line">  <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(id)) &#123;</span><br><span class="line">    <span class="built_in">this</span>.newDepIds.has(id)</span><br><span class="line">    <span class="built_in">this</span>.newDeps.push(dep)</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.depIds.has(id)) &#123;</span><br><span class="line">      dep.addSub(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>addDep</code> 方法中执行一些判断（保证统一数据不会被添加多次）后执行 <code>dep.addSub(this)</code>，然后执行 <code>this.subs.push(sub)</code>，将当前的 <code>watcher</code> 订阅到此数据持有的 <code>dep</code> 的 <code>subs</code> 中。</p><p>所以 <code>vm._render()</code> 过程中，会触发所有数据的 getter，也就是完成了一个依赖收集的过程。</p><p>还有后续逻辑处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">  traverse(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归去访问 <code>value</code> 触发所有子项的 <code>getter</code>；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">popTarget()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/dep.js</span></span><br><span class="line">Dep.target = targetStack.pop()</span><br></pre></td></tr></table></figure><p>实际上就是把 <code>Dep.target</code> 恢复成上一个状态，最后执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.cleanupDeps()</span><br><span class="line"></span><br><span class="line"><span class="comment">// src/core/observer/watcher.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cleanupDeps</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">const</span> dep = <span class="built_in">this</span>.deps[i]</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">this</span>.newDepIds.has(dep.id)) &#123;</span><br><span class="line">      dep.removeSub(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">let</span> tmp = <span class="built_in">this</span>.depIds</span><br><span class="line">  <span class="built_in">this</span>.depIds = <span class="built_in">this</span>.newDepIds</span><br><span class="line">  <span class="built_in">this</span>.newDepIds = tmp</span><br><span class="line">  <span class="built_in">this</span>.newDepIds.clear()</span><br><span class="line">  tmp = <span class="built_in">this</span>.deps</span><br><span class="line">  <span class="built_in">this</span>.deps = <span class="built_in">this</span>.newDeps</span><br><span class="line">  <span class="built_in">this</span>.newDeps = tmp</span><br><span class="line">  <span class="built_in">this</span>.newDeps.length = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为 Vue 是数据驱动的，所以每次数据变化都会重新 render，<code>vm._render()</code> 方法就会再次执行，并再次触发数据的 getters，所以 <code>Watcher</code> 在构造函数中会初始化 2 个 <code>Dep</code> 实例数组：</p><ul><li><code>newDeps</code> 表示新添加的 <code>Dep</code> 实例数组；</li><li>而 <code>deps</code> 表示上一次添加的 <code>Dep</code> 实例数组。</li></ul><p>在执行 <code>cleanupDeps</code> 函数时：</p><ol><li>首先会遍历 <code>deps</code>，移除对 <code>dep.subs</code> 数组中 <code>Watcher</code> 的订阅；</li><li>然后把 <code>newDepIds</code> 和 <code>depIds</code> 交换，<code>newDeps</code> 和 <code>deps</code> 交换；</li><li>将 <code>newDepIds</code> 和 <code>newDeps</code> 清空。</li></ol><h2 id="派发更新"><a href="#派发更新" class="headerlink" title="派发更新"></a>派发更新</h2><p>setter 负责 <strong>派发更新</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineReactive</span> (<span class="params">obj, key, val, customSetter, shallow</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">  <span class="keyword">const</span> getter = property &amp;&amp; property.get</span><br><span class="line">  <span class="keyword">const</span> setter = property &amp;&amp; property.set</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">let</span> childOb = !shallow &amp;&amp; observe(val)</span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">reactiveSetter</span> (<span class="params">newVal</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">const</span> value = getter ? getter.call(obj) : val</span><br><span class="line">      <span class="comment">/* eslint-disable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (newVal === value || (newVal !== newVal &amp;&amp; value !== value)) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/* eslint-enable no-self-compare */</span></span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;peoduction&#x27;</span> &amp;&amp; customSetter) &#123;</span><br><span class="line">        customSetter()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// #7981: for accessor properties without setter</span></span><br><span class="line">      <span class="keyword">if</span> (getter &amp;&amp; !setter) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (setter) &#123;</span><br><span class="line">        setter.call(obj, newVal)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        val = newVal</span><br><span class="line">      &#125;</span><br><span class="line">      childOb = !shallow &amp;&amp; observe(newVal)</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑中有 2 个关键点：</p><ul><li><code>childOb = !shallow &amp;&amp; observe(newVal)</code>：<code>shallow</code> 为 false 的情况下，会对新设置的值变成一个响应式对象；</li><li><code>dep.notify()</code>：通知所有的订阅者。</li></ul><h3 id="过程分析-1"><a href="#过程分析-1" class="headerlink" title="过程分析"></a>过程分析</h3><p>当在组件中对响应的数据做了修改，就会触发 setter 的逻辑，最后调用 <code>dep.notify()</code> 方法，它是 <code>Dep</code> 的一个实例方法：</p><h4 id="dep-notify"><a href="#dep-notify" class="headerlink" title="dep.notify"></a>dep.notify</h4><p><code>src/core/observer/dep.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="comment">// stabilize the subsriber list first</span></span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">      <span class="comment">// subs aren&#x27;t sorted in scheduler if not runnning async</span></span><br><span class="line">      <span class="comment">// we need to sort them now to make sure they fire in correct</span></span><br><span class="line">      <span class="comment">// order</span></span><br><span class="line">      sub.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.length; i &lt; l; i++) &#123;</span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑：遍历所有的 <code>subs</code>，也就是 <code>Watcher</code> 的实例数组，然后调用每一个 <code>watcher</code> 的 <code>update</code> 方法：</p><h4 id="watcher-update"><a href="#watcher-update" class="headerlink" title="watcher.update"></a>watcher.update</h4><p><code>src/core/observer/watcher.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">      <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">      <span class="built_in">this</span>.run()</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于 <code>Watcher</code> 的不同状态，会执行不同的逻辑：</p><p>一般组件数据更新会走到最后一个分支，执行 <code>queueWatcher(this)</code> </p><h4 id="queueWatcher"><a href="#queueWatcher" class="headerlink" title="queueWatcher"></a>queueWatcher</h4><p><code>src/core/observer/scheduler.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: <span class="built_in">number</span>]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Push a watcher into the watcher queue.</span></span><br><span class="line"><span class="comment"> * Jobs with deplicate IDs will be skipped unless it&#x27;s</span></span><br><span class="line"><span class="comment"> * pushed when the queue is being flushed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushingm splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i --</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// queue the flush</span></span><br><span class="line">    <span class="keyword">if</span> (!waiting) &#123;</span><br><span class="line">      waiting = <span class="literal">true</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; !config.async) &#123;</span><br><span class="line">        flushSchedulerQueue()</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处引入了队列：并不会每次数据改变都触发 <code>watcher</code> 的回调，而是这些 <code>watcher</code> 先添加到一个队列里，然后在 <code>nextTick</code> 后执行 <code>flushSchedulerQueue</code>。</p><ul><li><code>has</code> 对象保证同一个 <code>Watcher</code> 只添加一次；</li><li>通过 <code>waiting</code> 保证对 <code>nextTick(flushSchedulerQueue)</code> 的调用逻辑只有一次（异步执行）。</li></ul><h4 id="flushSchedulerQueue"><a href="#flushSchedulerQueue" class="headerlink" title="flushSchedulerQueue"></a>flushSchedulerQueue</h4><p><code>src/core/observer/scheduler.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Flush both queues and run the watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushSchedulerQueue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  currentFlushTimestamp = getNow()</span><br><span class="line">  flushing = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">let</span> watcher, id</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// Sort queue before flush.</span></span><br><span class="line">  <span class="comment">// This ensures that:</span></span><br><span class="line">  <span class="comment">// 1. Components are updated from parent to child. (because parent is always</span></span><br><span class="line">  <span class="comment">// created before the child)</span></span><br><span class="line">  <span class="comment">// 2. A component&#x27;s user watchers are run before its render watcher (because</span></span><br><span class="line">  <span class="comment">// user watchers are created before the render watcher)</span></span><br><span class="line">  <span class="comment">// 3. If a component is destroyed during a parent component&#x27;s watcher run,</span></span><br><span class="line">  <span class="comment">// its watchers can be skipped.</span></span><br><span class="line">  queue.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a.id - b.id)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// do not cache length because more watchers might be pushed</span></span><br><span class="line">  <span class="comment">// as we run existing watchers</span></span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; queue.length; index++) &#123;</span><br><span class="line">    watcher = queue[index]</span><br><span class="line">    <span class="keyword">if</span> (watcher.before) &#123;</span><br><span class="line">      watcher.before()</span><br><span class="line">    &#125;</span><br><span class="line">    id = watcher.id</span><br><span class="line">    has[id] = <span class="literal">null</span></span><br><span class="line">    watcher.run()</span><br><span class="line">    <span class="comment">// in dex child, check and stop circular updates.</span></span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; has[id] !== <span class="literal">null</span>) &#123;</span><br><span class="line">      circular[id] = (circular[id] || <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">      <span class="keyword">if</span> (circular[id] &gt; MAX_UPDATE_COUNT) &#123;</span><br><span class="line">        warn(</span><br><span class="line">          <span class="string">&#x27;You may have an infinite update loop &#x27;</span> + (</span><br><span class="line">            watcher.user</span><br><span class="line">            ? <span class="string">`in watcher with expression &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">            : <span class="string">`in a component render function.`</span></span><br><span class="line">          ),</span><br><span class="line">          watcher.vm</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// keep copies of post queues before resetting state</span></span><br><span class="line">  <span class="keyword">const</span> activatedQueue = activatedChildren.slice()</span><br><span class="line">  <span class="keyword">const</span> updatedQueue = queue.slice()</span><br><span class="line">  </span><br><span class="line">  resetSchledulerState()</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// call component updated and activated hooks</span></span><br><span class="line">  callActivatedHooks(activatedQueue)</span><br><span class="line">  callUpdatedHooks(updatedQueue)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// devtool hook</span></span><br><span class="line">  <span class="comment">/* istanbul ignore if */</span></span><br><span class="line">  <span class="keyword">if</span> (devtools &amp;&amp; config.devtools) &#123;</span><br><span class="line">    devtools.emit(<span class="string">&#x27;flush&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键逻辑分析：</p><p><strong>队列排序</strong>：</p><p><code>queue.sort((a, b) =&gt; a.id - b.id)</code> 对队列做了升序排序，可以确保：</p><ol><li>组件的更新由父到子；</li><li>用户的自定义 <code>watcher</code> 要优先于渲染 <code>watcher</code> 执行；</li><li>如果一个组件在父组件的 <code>watcher</code> 期间被销毁，那么它对应的 <code>watcher</code> 执行都可以被跳过，父组件的 <code>watcher</code> 先执行。</li></ol><p><strong>队列遍历</strong>：</p><p>在对 <code>queue</code> 排序后，接着对它进行遍历，拿到对应的 <code>watcher</code>，执行 <code>watcher.run()</code>。</p><p>遍历中每次都会对 <code>queue.length</code> 求值，因为在 <code>watcher.run()</code> 的时候，很可能用户会再次添加新的 <code>watcher</code>，然后再次执行到 <code>queueWatcher</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">queueWatcher</span> (<span class="params">watcher: Watcher</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> id = watcher.id</span><br><span class="line">  <span class="keyword">if</span> (has[id] == <span class="literal">null</span>) &#123;</span><br><span class="line">    has[id] = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">if</span> (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// if already flushingm splice the watcher based on its id</span></span><br><span class="line">      <span class="comment">// if already past its id, it will be run next immediately.</span></span><br><span class="line">      <span class="keyword">let</span> i = queue.length - <span class="number">1</span></span><br><span class="line">      <span class="keyword">while</span> (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i --</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + <span class="number">1</span>, <span class="number">0</span>, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时 <code>flushing</code> 为 true，执行到 else 中的逻辑，然后从后往前找到第一个待插入 <code>watcher</code> 的 id 比当前队列中 <code>watcher</code> 的 id 大的位置，因此 <code>queue</code> 的长度发生了变化。</p><p><strong>状态恢复</strong>：</p><p>就是执行 <code>resetSchedulerState</code> 函数：</p><p><code>src/core/observer/scheduler.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> queue: <span class="built_in">Array</span>&lt;Watcher&gt; = []</span><br><span class="line"><span class="keyword">let</span> has: &#123; [key: <span class="built_in">number</span>]: ?<span class="literal">true</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> circular: &#123; [key: <span class="built_in">number</span>]: <span class="built_in">number</span> &#125; = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> waiting = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> flushing = <span class="literal">false</span></span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reset the scheduler&#x27;s state.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resetSchedulerState</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  index = queu.length = activatedChildren.length = <span class="number">0</span></span><br><span class="line">  has = &#123;&#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">    circular = &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  waiting = flushing = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码逻辑就是把这些控制流程状态的变量恢复到初始值，把 <code>watcher</code> 队列清空。</p><h4 id="watcher-run"><a href="#watcher-run" class="headerlink" title="watcher.run"></a>watcher.run</h4><p><code>src/core/observer/watcher.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Scheduler job interface.</span></span><br><span class="line"><span class="comment">   * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  run () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">      <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        value !== <span class="built_in">this</span>.value ||</span><br><span class="line">        <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">        <span class="comment">// when the values is the same, because the value may</span></span><br><span class="line">        <span class="comment">// have mounted.</span></span><br><span class="line">        isObject(value) ||</span><br><span class="line">        <span class="built_in">this</span>.deep</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// set new value</span></span><br><span class="line">        <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">        <span class="built_in">this</span>.value = value</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">          <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">          incokeWithErrorHandling(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 函数逻辑：</p><ul><li>先通过 <code>this.get()</code> 得到当前的值，然后做判断；</li><li>若满足 新旧值不等、新值是对象类型、<code>deep</code> 模式 任意一个条件，则执行 <code>watcher</code> 的回调。</li></ul><p>对于渲染 <code>watcher</code> 来说，在执行 <code>this.get()</code> 方法求值时会执行 <code>getter</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">updateComponent = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  vm._update(vm._render(). hydrating)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是修改组件相关的响应式数据时，会触发组件重新渲染的原因，接着就会重新执行 <code>patch</code> 的过程。</p><h2 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h2><p><code>nextTick</code> 是 Vue 的一个核心实现</p><h3 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h3><p>JS 执行是单线程的，基于事件循环：</p><ol><li>所有同步任务都在主线程上执行，形成一个执行栈（execution context stack）；</li><li>主线程之外，还存在一个 “任务队列”（task queue）。只要异步任务有了运行结果，就在任务队列中放置一个事件；</li><li>一旦 执行栈 中的所有同步任务执行完毕，系统就会读取 “任务队列”，结束该任务等待状态，进入执行栈，开始执行；</li><li>主线程不断重复第三步。</li></ol><p>主线程的执行过程就是一个 tick，而所有的一部结果都是通过 “任务队列” 来调度。消息队列中存放的是一个个的任务（task：分为 macro task 和 micro task）：</p><ul><li>macro task<ul><li>setTimeout、MessageChannel、postMessage、setImmediate；</li></ul></li><li>micro task<ul><li>MutationObserver、Promise.then</li></ul></li></ul><h3 id="Vue-的实现"><a href="#Vue-的实现" class="headerlink" title="Vue 的实现"></a>Vue 的实现</h3><p>在 Vue 2.5+ 后，<code>nextTick</code> 的实现单独有一个 JS 文件来维护：</p><p><code>src/core/util/next-tick.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; noop &#125; <span class="keyword">from</span> <span class="string">&#x27;shared/util&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; handleError &#125; <span class="keyword">from</span> <span class="string">&#x27;./error&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isIE, isIOS, isNative &#125; <span class="keyword">from</span> <span class="string">&#x27;./env&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> isUsingMicroTask = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> callbacks = []</span><br><span class="line"><span class="keyword">let</span> pending = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">flushCallbacks</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  pending = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">const</span> copies = callbacks.slice(<span class="number">0</span>)</span><br><span class="line">  callbacks.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; copies.length; i++) &#123;</span><br><span class="line">    copies[i]()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">let</span> timerFunc</span><br><span class="line"></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line">  <span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(<span class="built_in">String</span>(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = <span class="built_in">String</span>(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// Fallback to setTimeout.</span></span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">nextTick</span> (<span class="params">cb?: <span class="built_in">Function</span>, ctx?: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> _resolve</span><br><span class="line">  callbacks.push(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        cb.call(ctx)</span><br><span class="line">      &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">        handleError(e, ctx, <span class="string">&#x27;nextTick&#x27;</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_resolve) &#123;</span><br><span class="line">      _resolve(ctx)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">if</span> (!pending) &#123;</span><br><span class="line">    pending = <span class="literal">true</span></span><br><span class="line">    timerFunc()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      _resolve = resolve</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>对外暴露了nextTick 函数：</p><p>把传入的回调函数 <code>cb</code> 压入 <code>callbacks</code> 数组，最后一次性地根据 <code>useMacroTask</code> 条件执行 <code>timerFunc</code>，在下一个 tick 执行 <code>flushCallbacks</code>；</p><p><code>flushCallbacks</code> 中对 <code>callbacks</code> 遍历，然后执行相应的回调函数。</p><blockquote><p>使用 <code>callbacks</code> 而不是直接在 <code>nextTick</code> 中执行回调函数的原因：</p><p>保证在同一个 tick 内多次执行 <code>nextTick</code>，不会开启多个异步任务，而是把这些异步任务都压成一个同步任务，在一个 tick 执行完毕。</p></blockquote><p><code>nextTick</code> 函数最后：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!cb &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    _resolve = resolve</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>nextTick</code> 不传 <code>cb</code> 参数的时候，提供一个 Promise 化的调用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nextTick().then(<span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>当 <code>_resolve</code> 函数执行，就会跳到 <code>then</code> 的逻辑中。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p>数据的变化到 DOM 的重新渲染是一个异步过程，发生在下一个 tick。</p><p>Vue.js 提供了 2 种调用 <code>nextTick</code> 的方式：</p><ul><li>全局 API <code>Vue.nextTick</code>；</li><li>实例上 <code>vm.$nextTick()</code>。</li></ul><h2 id="检测变化的注意事项"><a href="#检测变化的注意事项" class="headerlink" title="检测变化的注意事项"></a>检测变化的注意事项</h2><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对于使用 <code>Object.defineProperty</code> 实现响应式的对象，添加新属性时无法触发 setter：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// vm.b 是非响应式的</span></span><br><span class="line">vm.b = <span class="number">2</span></span><br></pre></td></tr></table></figure><p>Vue 为了解决这个问题，定义了一个全局 API <code>Vue.set</code> 方法，它在 <code>erc/core/global-api/index.js</code> 中初始化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set = set</span><br></pre></td></tr></table></figure><p><code>set</code> 方法定义在 <code>src/core/observer/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Set a property on an object. Adds the new property and</span></span><br><span class="line"><span class="comment"> * triggers change notification if the property doesn&#x27;t</span></span><br><span class="line"><span class="comment"> * already exist.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span> (<span class="params">target: <span class="built_in">Array</span>&lt;<span class="built_in">any</span>&gt; | <span class="built_in">Object</span>, key: <span class="built_in">any</span>, val: <span class="built_in">any</span></span>): <span class="title">any</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">      (isUndef(target) || isPrimitive(target))</span><br><span class="line">     ) &#123;</span><br><span class="line">    warn(<span class="string">`Cannot set reactive property on undefined, null, or primitive value: <span class="subst">$&#123;(target: <span class="built_in">any</span>)&#125;</span>`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(target) &amp;&amp; isValidArrayIndex(key)) &#123;</span><br><span class="line">    target.length = <span class="built_in">Math</span>.max(target.length, key)</span><br><span class="line">    target.splice(key, <span class="number">1</span>, val)</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (key <span class="keyword">in</span> target &amp;&amp; !(key <span class="keyword">in</span> <span class="built_in">Object</span>.prototype)) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> ob = (target: <span class="built_in">any</span>).__ob__</span><br><span class="line">  <span class="keyword">if</span> (target._isVue || (ob &amp;&amp; ob.vmCount)) &#123;</span><br><span class="line">    process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; warn(</span><br><span class="line">      <span class="string">&#x27;Avoid adding reactive properties to a Vue instance or its root $data &#x27;</span> +</span><br><span class="line">      <span class="string">&#x27;at runtime - declare it upfront in the data option.&#x27;</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!ob) &#123;</span><br><span class="line">    target[key] = val</span><br><span class="line">    <span class="keyword">return</span> val</span><br><span class="line">  &#125;</span><br><span class="line">  defineReactive(ob.value, key, val)</span><br><span class="line">  ob.def.notify()</span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p><code>set</code> 方法接收 3 个参数：</p><ul><li><code>target</code> 可能是数组或者普通对象；</li><li><code>key</code> 代表数组的下标或者对象的键值；</li><li><code>val</code> 代表添加的值。</li></ul><p>首先判断如果 <code>target</code> 是数组且 <code>key</code> 为合法下标，则通过 <code>splice</code> 添加进数组然后返回；</p><p>接着判断 <code>key</code> 是否已经存在于 <code>target</code> 中，若存在则直接赋值返回；</p><p>否则获取到 <code>target.__ob__</code> 并赋值给 <code>ob</code>（表示 <code>Observer</code> 的一个实例），若不存在则直接赋值并返回；</p><p>最后通过 <code>defineReactive(ob.value, key, val)</code> 把新添加的属性变成响应式对象；</p><p>再通过 <code>ob.dep.notify()</code> 手动地触发依赖通知。</p><h3 id="数组-1"><a href="#数组-1" class="headerlink" title="数组"></a>数组</h3><p>Vue 也不能检测到以下变动的数组：</p><ul><li>利用索引直接设置一个项时；</li><li>修改数组的长度时。</li></ul><p>在通过 <code>observe</code> 方法去观察对象的时候会实例化 <code>Observer</code>，在它的构造函数中时专门对数组做了处理：</p><p><code>src/core/observer/index.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="built_in">any</span>;</span><br><span class="line">  dep: Dep;</span><br><span class="line">  vmCount: <span class="built_in">number</span>; <span class="comment">// number of vms that have this object as root $data</span></span><br><span class="line">  </span><br><span class="line">  <span class="title">constructor</span> (<span class="params">value: <span class="built_in">any</span></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.value = value</span><br><span class="line">    <span class="built_in">this</span>.dep = <span class="keyword">new</span> Dep()</span><br><span class="line">    <span class="built_in">this</span>.vmCount = <span class="number">0</span></span><br><span class="line">    def(value, <span class="string">&#x27;__ob__&#x27;</span>, <span class="built_in">this</span>)</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(value)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (hasProto) &#123;</span><br><span class="line">        protoAugment(value, arrayMethods)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        copyAugment(value, arrayMethods, arrayKeys)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">this</span>.observeArray(value)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.walk(value)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先获取 <code>augment</code>，<code>hasProto</code> 用与判断对象中是否存在 <code>__proto__</code>，如果存在则 <code>augment</code> 指向 <code>protoAugment</code>，否则指向 <code>copyAugment</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment a target Object or Array by intercepting</span></span><br><span class="line"><span class="comment"> * the prototype chain using __proto__</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">protoAugment</span> (<span class="params">target, src: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">/* eslint-disable no-proto */</span></span><br><span class="line">  target.__proto__ = src</span><br><span class="line">  <span class="comment">/* eslint-enable no-proto */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Augment a target Object or a Array defining</span></span><br><span class="line"><span class="comment"> * hidden properties.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/* istanbul ignore next */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyAugment</span> (<span class="params">target: <span class="built_in">Object</span>, src: <span class="built_in">Object</span>, keys: <span class="built_in">Array</span>&lt;<span class="built_in">String</span>&gt;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = keys.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> key = keys[i]</span><br><span class="line">    def(target, key, src[key])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>protoAugment</code> 方法是直接把 <code>target.__proto__</code> 原型直接修改为 <code>src</code>；</li><li><code>copyAugment</code> 方法是遍历 keys，通过 <code>def</code>（也就是 <code>Object.defineProperty</code>） 去定义自身的属性值</li></ul><p>对于大部分现代浏览器都会走到 <code>protoAugment</code>，就把 <code>value</code> 的原型指向了 <code>arrayMethods</code>。</p><p><code>src/core/observer/array.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; def &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arrayProto = <span class="built_in">Array</span>.prototype</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> arrayMethods = <span class="built_in">Object</span>.create(arrayProto)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> methodsToPath = [</span><br><span class="line">  <span class="string">&#x27;push&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;shift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;unshift&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;splice&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;sort&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;reverse&#x27;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Intercept mutating methods and emit events</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">methodsToPath.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">method</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// cache original method</span></span><br><span class="line">  <span class="keyword">const</span> original = arrayProto[method]</span><br><span class="line">  def(arrayMethods, method, <span class="function"><span class="keyword">function</span> <span class="title">mutator</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> result = original.apply(<span class="built_in">this</span>, args)</span><br><span class="line">    <span class="keyword">const</span> ob = <span class="built_in">this</span>.__ob__</span><br><span class="line">    <span class="keyword">let</span> inserted</span><br><span class="line">    <span class="keyword">switch</span> (method) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;push&#x27;</span>:</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;unshift&#x27;</span>:</span><br><span class="line">        inserted = args</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;splice&#x27;</span>:</span><br><span class="line">        inserted = args.slice(<span class="number">2</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (inserted) ob.observeArray(inserted)</span><br><span class="line">    <span class="comment">// notify change</span></span><br><span class="line">    ob.dep.notify()</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>arrayMethods</code> 首先继承了 <code>Array</code>，然后对数组中所有能改变数组自身的方法进行重写：</p><ul><li>重写后的方法会先执行本身原有的逻辑；</li><li>并对能增加数组长度的 3 个方法 <code>push、unshift、splice</code> 方法做了判断，获取到插入的值，将新添加的值变成一个响应式对象；</li><li>并且再调用 <code>ob.dep.notify()</code> 手动触发依赖通知。</li></ul><h2 id="计算属性-VS-侦听属性"><a href="#计算属性-VS-侦听属性" class="headerlink" title="计算属性 VS 侦听属性"></a>计算属性 VS 侦听属性</h2><h3 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h3><p>计算属性的初始化是发生在 Vue 实例初始化阶段的 <code>initState</code> 函数中，执行了 <code>if(opts.computed) initComputed(vm, opts.computed)</code>。</p><h4 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h4><p><code>src/core/instance/state.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> computedWatcherOptions = &#123; <span class="attr">lazy</span>: <span class="literal">true</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm: Component, computed: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// $flow-disable-line</span></span><br><span class="line">  <span class="keyword">const</span> watchers = vm._computedWatchers = <span class="built_in">Object</span>.create(<span class="literal">null</span>)</span><br><span class="line">  <span class="comment">// computed properties are just getters during SSR</span></span><br><span class="line">  <span class="keyword">const</span> isSSR = isServerRendering()</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">const</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">const</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp; getter == <span class="literal">null</span>) &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Getter is missing for computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot;.`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// create internal watcher for the computed property.</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(</span><br><span class="line">        vm,</span><br><span class="line">        getter || noop,</span><br><span class="line">        noop,</span><br><span class="line">        computedWatcherOptions</span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// computed-defined computed properties are already defined on the</span></span><br><span class="line">    <span class="comment">// computed prototype. We only need to defined computed properties define</span></span><br><span class="line">    <span class="comment">// at instantiation here.</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined in data.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a props.`</span>, vm)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.methods &amp;&amp; key <span class="keyword">in</span> vm.$options.methods) &#123;</span><br><span class="line">        warn(<span class="string">`The computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; is already defined as a method.`</span>, vm)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li>首先创建 <code>vm._computedWatchers</code> 为一个空对象；</li><li>接着对 <code>computed</code> 对象做遍历，拿到计算属性的每一个 <code>userDef</code>；</li><li>尝试获取这个 <code>userDef</code> 对应的 <code>getter</code> 函数，拿不到则在开发环境下报警告；</li><li>为每一个 <code>getter</code> 创建一个 <code>wathcer</code>（一个 <code>computed watcher</code>）；</li><li>最后判断 <code>key</code> 是否是 <code>vm</code> 实例的属性：<ul><li>不是：调用 <code>defineComputed(vm, key, userDef)</code>；</li><li>是：判断是否对应的 <code>key</code> 是否已经被 <code>data、props、methods</code> 所占用，是则在开发环境下报相应的警告。</li></ul></li></ul><h4 id="defineComputed"><a href="#defineComputed" class="headerlink" title="defineComputed"></a>defineComputed</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">defineComputed</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> target: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  key: <span class="built_in">string</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  userDef: <span class="built_in">Object</span> | <span class="built_in">Function</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> shouldCache = !isServerRendering()</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    sharedPropertyDefinition.get = shouldCache</span><br><span class="line">    ? createComputedGetter(key)</span><br><span class="line">    : createGetterInvoker(userDef)</span><br><span class="line">    sharedPropertyDefinition.set = noop</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sharedPropertyDefinition.get = userDef.get</span><br><span class="line">    ? shouldCache &amp;&amp; userDef.cache !== <span class="literal">false</span></span><br><span class="line">    ? createComputedGetter(key)</span><br><span class="line">    : createGetterInvoker(userDef.get)</span><br><span class="line">    : noop</span><br><span class="line">    sharedPropertyDefinition.set = userDef.set || noop</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (process.env.NODE_ENV !== <span class="string">&#x27;production&#x27;</span> &amp;&amp;</span><br><span class="line">     sharedPropertyDefinition.set === noop) &#123;</span><br><span class="line">    sharedPropertyDefinition.set = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Computed property &quot;<span class="subst">$&#123;key&#125;</span>&quot; was assigned to but it has no setter.`</span>,</span><br><span class="line">        <span class="built_in">this</span></span><br><span class="line">      )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">Object</span>.definedProperty(target, key, sharedPropertyDefinition)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 <code>Object.defineProperty</code> 给计算属性对应的 <code>key</code> 值添加 getter 和 setter；</p><blockquote><p>setter 通常是计算属性是一个对象且拥有 <code>set</code> 方法的时候才有，否则是一个空函数。</p></blockquote><p>最终 getter 对应的是 <code>createComputedGetter(key)</code> 的返回值；</p><h4 id="createComputedGetter"><a href="#createComputedGetter" class="headerlink" title="createComputedGetter"></a>createComputedGetter</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComputedGetter</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">computedGetter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> watcher = <span class="built_in">this</span>._computedWatchers &amp;&amp; <span class="built_in">this</span>._computedWatchers[key]</span><br><span class="line">    <span class="keyword">if</span> (watcher) &#123;</span><br><span class="line">      <span class="keyword">if</span> (watcher.dirty) &#123;</span><br><span class="line">        watcher.evaluate()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        watcher.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> watcher.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createComputedGetter</code> 返回一个函数 <code>computedGetter</code>，就是计算属性对应的 getter。</p><p>计算属性的初始化过程结束。</p><h4 id="computed-watcher"><a href="#computed-watcher" class="headerlink" title="computed watcher"></a>computed watcher</h4><p>分析一下 <code>computed watcher</code> 和普通的 <code>watcher</code> 有什么区别。</p><p>当初始化 <code>comupted watcher</code> 时，构造函数部分逻辑略有不同：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">constructor</span> (<span class="params"></span></span><br><span class="line"><span class="params">  vm: Component,</span></span><br><span class="line"><span class="params">  expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  cb: <span class="built_in">Function</span>,</span></span><br><span class="line"><span class="params">  options?: ?<span class="built_in">Object</span>,</span></span><br><span class="line"><span class="params">  isRenderWatcher?: <span class="built_in">boolean</span></span></span><br><span class="line"><span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.lazy</span><br><span class="line">  ? <span class="literal">undefined</span></span><br><span class="line">  : <span class="built_in">this</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 <code>render</code> 函数执行访问到该计算属性时，则触发计算属性的 <code>getter</code>，会拿到计算属性对应的 <code>watcher</code>，然后执行 <code>watcher.depend()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Depend on all deps collected by this watcher.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">depend () &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="built_in">this</span>.deps.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="built_in">this</span>.deps[i].depend()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时，<code>this.deps[i].depend()</code> 相当于渲染 <code>watcher</code> 订阅了这个 <code>computed watcher</code> 的变化。</p><p>再执行 <code>watcher.evaluate()</code> 去求值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Evaluate and return the value if the watcher.</span></span><br><span class="line"><span class="comment"> * This only gets called for computed property watchers.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">evaluate () &#123;</span><br><span class="line">  <span class="built_in">this</span>.value = <span class="built_in">this</span>.get()</span><br><span class="line">  <span class="built_in">this</span>.dirty = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一旦对计算属性依赖的数据做修改，则会触发 setter 过程，通知所有订阅它变化的 <code>watcher</code> 更新，执行 <code>watcher.update()</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Subscriber interface.</span></span><br><span class="line"><span class="comment"> * Will be called when a dependency changes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">update () &#123;</span><br><span class="line">  <span class="comment">/* istanbul ignore else */</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="built_in">this</span>.dirty = <span class="literal">true</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上有 2 种模式，lazy 和 active，看 <code>watcher.run()</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Scheduler job interface.</span></span><br><span class="line"><span class="comment"> * Will be called by the scheduler.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.active) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = <span class="built_in">this</span>.get()</span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      value !== <span class="built_in">this</span>.value ||</span><br><span class="line">      <span class="comment">// Deep watchers and watchers on Object/Arrays should fire even</span></span><br><span class="line">      <span class="comment">// when the value is the same, because the value may</span></span><br><span class="line">      <span class="comment">// have mytated.</span></span><br><span class="line">      isObject(value) ||</span><br><span class="line">      <span class="built_in">this</span>.deep</span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="comment">// set new value</span></span><br><span class="line">      <span class="keyword">const</span> oldValue = <span class="built_in">this</span>.value</span><br><span class="line">      <span class="built_in">this</span>.value = value</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">        <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">        invokeWithErrorHanding(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>run</code> 中会重新计算，然后对比新旧值，如果变化了则执行回调函数，也就是 <code>this.dep.notify()</code>，触发渲染 <code>watcher</code> 重新渲染。</p><h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><p>侦听属性的初始化同样是发生在 Vue 实例初始化阶段的 <code>initState</code> 函数中，在 <code>computed</code> 初始化之后，执行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">  initWatch(vm, opts.watch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initWatch"><a href="#initWatch" class="headerlink" title="initWatch"></a>initWatch</h4><p><code>src/core/instance/state.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initWatch</span> (<span class="params">vm: Component, watch: <span class="built_in">Object</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> watch) &#123;</span><br><span class="line">    <span class="keyword">const</span> handler = watch[key]</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(handler)) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>,; i &lt; handler.length; i++) &#123;</span><br><span class="line">        createWatcher(vm, key, handler[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      createWatcher(vm, key, handler)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就遍历 <code>watch</code> 对象，拿到每一个 <code>handler</code>，如果 <code>handler</code> 是一个数组，则遍历这个数组，调用 <code>createWatcher</code> 方法，否则直接调用 <code>createWatcher</code>。</p><h4 id="createWatcher"><a href="#createWatcher" class="headerlink" title="createWatcher"></a>createWatcher</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWatcher</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> vm: Component,</span></span></span><br><span class="line"><span class="params"><span class="function">  expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  handler: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (isPlainObject(handler)) &#123;</span><br><span class="line">     options = handler</span><br><span class="line">     handler = handler.handler</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">typeof</span> handler === <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">     handler = vm[handler]</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> vm.$watch(expOrFn, handler, options)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>首先对 <code>handler</code> 的类型做判断，拿到最终的回调函数，最后调用 <code>vm.$watch(expOrFn, handler, options)</code> 函数，<code>$watch</code> 是 Vue 原型上的方法，在执行 <code>stateMixin</code> 时定义。</p><h4 id="watch-1"><a href="#watch-1" class="headerlink" title="$watch"></a>$watch</h4><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$watch = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> expOrFn: <span class="built_in">string</span> | <span class="built_in">Function</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  cb: <span class="built_in">any</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">  options?: <span class="built_in">Object</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">Function</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> vm: Component = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">if</span> (isPlainObject(cb)) &#123;</span><br><span class="line">    <span class="keyword">return</span> createWatcher(vm, expOrFn, cb, options)</span><br><span class="line">  &#125;</span><br><span class="line">  options = options || &#123;&#125;</span><br><span class="line">  options.user = <span class="literal">true</span></span><br><span class="line">  <span class="keyword">const</span> watcher = <span class="keyword">new</span> Watcher(vm, expOrFn, cb, options)</span><br><span class="line">  <span class="keyword">if</span> (options.immediate) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`callback for immediate watcher &quot;<span class="subst">$&#123;watcher.expression&#125;</span>&quot;`</span></span><br><span class="line">    pushTarget()</span><br><span class="line">    invokeWithErrorHandling(cb, vm, [watcher.value], vm, info)</span><br><span class="line">    popTarget()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">unwatchFn</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    watcher.teardown()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><ul><li>首先判断 <code>cb</code> 如果是一个对象，则调用 <code>createWatcher</code> 方法，这是因为 <code>$watch</code> 方法是用户可以直接调用的，可以传递一个对象，也可以传递函数；</li><li>接着执行 <code>const watcher = new Watcher(vm, expOrFn, cb, options)</code> 实例化一个 <code>watcher</code>，这里是一个 <code>user watcher</code>，因为 <code>options.user = true</code>；</li><li>若设置了 <code>immediate</code> 为 true，则直接会执行回调函数 <code>cb</code>；</li><li>最后返回 <code>unwatchFn</code> 方法，调用 <code>teardown</code> 方法移除这个 <code>watcher</code>。</li></ul><h3 id="Watcher-Options"><a href="#Watcher-Options" class="headerlink" title="Watcher Options"></a>Watcher Options</h3><p><code>Watcher</code> 支持了不同的类型，<code>Watcher</code> 的构造函数对 <code>options</code> 做了处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// options</span></span><br><span class="line"><span class="keyword">if</span> (options) &#123;</span><br><span class="line">  <span class="built_in">this</span>.deep = !!options.deep</span><br><span class="line">  <span class="built_in">this</span>.user = !!options.user</span><br><span class="line">  <span class="built_in">this</span>.lazy = !!options.lazy</span><br><span class="line">  <span class="built_in">this</span>.sync = !!options.sync</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.deep = <span class="built_in">this</span>.user = <span class="built_in">this</span>.lazy = <span class="built_in">this</span>.sync = <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见 <code>watcher</code> 一共 4 种类型</p><h4 id="deep-watcher"><a href="#deep-watcher" class="headerlink" title="deep watcher"></a>deep watcher</h4><p>通常想对一个对象做深度观生产线的测时，需要设置 <code>deep</code> 属性为 true；</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">a: &#123;</span><br><span class="line">deep: true,</span><br><span class="line">handler (newVal) &#123;</span><br><span class="line">console.log(newVal)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就创建了一个 <code>deep watcher</code> 了，在 <code>watcher</code> 执行 <code>get</code> 求值的过程中有一段逻辑：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="keyword">let</span> value = <span class="built_in">this</span>.getter.call(vm, vm)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.deep) &#123;</span><br><span class="line">    traverse(value)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在对 watch 的表达式或者函数求值后，会调用 <code>traverse</code> 函数；</p><p><code>src/core/observer.traverse.js</code>：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; _Set <span class="keyword">as</span> <span class="built_in">Set</span>, isObject &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">type</span> &#123; SimpleSet &#125; <span class="keyword">from</span> <span class="string">&#x27;../util/index&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VNode <span class="keyword">from</span> <span class="string">&#x27;../vdom/vnode&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> seenObjects = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Recursively traverse an object to evoke all converted</span></span><br><span class="line"><span class="comment"> * getters, so that every nested property inside the object</span></span><br><span class="line"><span class="comment"> * is collected as a &quot;deep&quot; dependency.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">traverse</span> (<span class="params">val: <span class="built_in">any</span></span>) </span>&#123;</span><br><span class="line">  _traverse(val, seenObjects)</span><br><span class="line">  seenObjects.clear()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_traverse</span> (<span class="params">val: <span class="built_in">any</span>, seen: SimpleSet</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> i, keys</span><br><span class="line">  <span class="keyword">const</span> isA = <span class="built_in">Array</span>.isArray(val)</span><br><span class="line">  <span class="keyword">if</span> ((!isA &amp;&amp; !isObject(val)) || <span class="built_in">Object</span>.isFrozen(val) || val <span class="keyword">instanceof</span> VNode) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (val.__ob__) &#123;</span><br><span class="line">    <span class="keyword">const</span> depId = val.__ob__.dep.id</span><br><span class="line">    <span class="keyword">if</span> (seen.has(depId)) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    seen.add(depId)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isA) &#123;</span><br><span class="line">    i = val.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[i], seen)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    keys = <span class="built_in">Object</span>.keys(val)</span><br><span class="line">    i = keys.length</span><br><span class="line">    <span class="keyword">while</span> (i--) _traverse(val[keys[i]], seen)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码分析：</p><p>对一个对象做深层递归遍历，因为遍历过程中就是对一个子对象的访问，触发所有的 hetter，收集依赖，订阅它们变化的 <code>watcher</code>；</p><p>遍历过程中会把子响应式对象通过它们的 <code>dep id</code> 记录到 <code>seenObjects</code>，避免重复访问。</p><h4 id="user-watcher"><a href="#user-watcher" class="headerlink" title="user watcher"></a>user watcher</h4><p>通过 <code>vm.$watch</code> 创建的 <code>watcher</code> 是一个 <code>user watcher</code>，功能就是在对 <code>watcher</code> 求值以及在执行回调函数的时候，会处理一下错误：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">get () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">    handlerError(e, vm, <span class="string">`getter for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> e</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run () &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.user) &#123;</span><br><span class="line">    <span class="keyword">const</span> info = <span class="string">`callback for watcher &quot;<span class="subst">$&#123;<span class="built_in">this</span>.expression&#125;</span>&quot;`</span></span><br><span class="line">    invokeWithErrorHandling(<span class="built_in">this</span>.cb, <span class="built_in">this</span>.vm, [value, oldValue], <span class="built_in">this</span>.vm, info)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.cb.call(<span class="built_in">this</span>.vm, value, oldValue)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>handleError</code> 是一个错误捕获并且暴露给用户的一个利器。</p><h4 id="lazy-watcher"><a href="#lazy-watcher" class="headerlink" title="lazy watcher"></a>lazy watcher</h4><p>就是为计算属性量身定制的，具体可以看前面计算属性中的分析。</p><h4 id="sync-watcher"><a href="#sync-watcher" class="headerlink" title="sync watcher"></a>sync watcher</h4><p>当响应式数据发生变化后，触发了 <code>watcher.update()</code>，只是把这个 <code>watcher</code> 推送到了一个队列中，在 <code>nextTick</code> 后才会真正执行 <code>watcher</code> 的回调函数。</p><p>当设置了 <code>sync</code> 为 true，就可以在当前 <code>Tick</code> 中同步执行 <code>watcher</code> 的回调函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">update () &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">this</span>.lazy) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.sync) &#123;</span><br><span class="line">    <span class="built_in">this</span>.run()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    queueWatcher(<span class="built_in">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>只有当需要 watch 的值的变化到执行 <code>watcher</code> 的回调函数是一个同步过程的时候才会去设置该属性为 <code>true</code>。</p></blockquote><h2 id="组件更新"><a href="#组件更新" class="headerlink" title="组件更新"></a>组件更新</h2>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源码 </tag>
            
            <tag> 前端框架 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React</title>
      <link href="/2021/11/26/React/"/>
      <url>/2021/11/26/React/</url>
      
        <content type="html"><![CDATA[<h1 id="入门教程"><a href="#入门教程" class="headerlink" title="入门教程"></a>入门教程</h1><p>目的：了解 React，完成一个小游戏。</p><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><h3 id="方式一、在浏览器中编写代码"><a href="#方式一、在浏览器中编写代码" class="headerlink" title="方式一、在浏览器中编写代码"></a>方式一、在浏览器中编写代码</h3><p>直接在浏览器中打开这个 <a href="https://codepen.io/gaearon/pen/oWWQNa?editors=0010">初始模板</a> 。是一个空的井字棋盘和 React 代码。</p><h3 id="方式二、搭建本地开发环境"><a href="#方式二、搭建本地开发环境" class="headerlink" title="方式二、搭建本地开发环境"></a>方式二、搭建本地开发环境</h3><ol><li><p>安装并配置了 Node.js；</p></li><li><p>快速创建一个新的项目；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx create-react-app my-app</span><br></pre></td></tr></table></figure></li><li><p>删掉创建好的 <code>src/</code> 文件夹下的所有文件。</p></li><li><p>在 <code>src/</code> 文件夹下创建 <code>index.css</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">  <span class="attribute">font</span>: <span class="number">14px</span> <span class="string">&quot;Century Gothic&quot;</span>, Futura, sans-serif;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">ol</span>,</span><br><span class="line"><span class="selector-tag">ul</span> &#123;</span><br><span class="line">  <span class="attribute">padding-left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.board-row</span>:after &#123;</span><br><span class="line">  clear: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.status</span> &#123;</span><br><span class="line">  <span class="attribute">margin-bottom</span>: <span class="number">10px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#999</span>;</span><br><span class="line">  <span class="attribute">float</span>: left;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">24px</span>;</span><br><span class="line">  <span class="attribute">font-weight</span>: bold;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">34px</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">margin-top</span>: -<span class="number">1px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">text-align</span>: center;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">34px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.square</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.kbd-navigation</span> <span class="selector-class">.square</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="number">#ddd</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.game</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.game-info</span> &#123;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在 <code>src/</code> 下创建 <code>index.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./index.css&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span>&gt;</span>&#123;/* TODO */&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderSquare</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> status = <span class="string">&quot;Next player: X&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;status&quot;</span>&gt;</span>&#123;status&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(0)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(1)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(2)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(3)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(4)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(5)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(6)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(7)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(8)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Board</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;/* status */&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;/* TODO */&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ========================================</span></span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Game</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure></li><li><p>运行项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure></li><li><p>在浏览器访问 <a href="http://localhost:3000/">http://localhost:3000/</a> ，可以看到一个空的井字棋的棋盘。</p></li></ol><h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><h3 id="React-是什么"><a href="#React-是什么" class="headerlink" title="React 是什么"></a>React 是什么</h3><p>React 是一个声明式，高效且灵活的用于构建用户界面的 JavaScript 库。</p><p>使用 React 可以将一些简短、独立的代码片段组合成复杂的 UI 界面，即为 <strong>组件</strong>。</p><p>看一个例子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shoppingList</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;shopping-list&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>shopping List for &#123;this.props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Instagram<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>WhatsApp<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span>Oculus<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法：&lt;shoppingList name=&quot;Mark&quot; /&gt;</span></span><br></pre></td></tr></table></figure><ul><li><code>shoppingList</code> 是一个 <strong>React 组件类</strong>，或 <strong>React 组件类型</strong>；</li><li>组件接收的参数叫做 <code>props</code>（properties 的简写）；</li><li>然后通过 <code>render</code> 方法返回需要展示在屏幕上的视图的层次结构。<ul><li><code>render</code> 方法的返回值描述了希望在屏幕上展示的内容；</li><li><code>render</code> 返回了一个 <strong>React 元素</strong>，是一种对渲染内容的轻量级描述；</li><li>JSX 语法可以很轻松地书写这些结构。</li></ul></li></ul><p>上面的代码等同于：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> React.createElement(</span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">  &#123; <span class="attr">className</span>: <span class="string">&#x27;shopping-list&#x27;</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;shopping List for &#x27;</span>, props.name)</span><br><span class="line">  React.createElement(</span><br><span class="line">    <span class="string">&#x27;ul&#x27;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    React.createElement(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Instagram&#x27;</span>)</span><br><span class="line">    React.createElement(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;WhatsApp&#x27;</span>)</span><br><span class="line">    React.createElement(<span class="string">&#x27;li&#x27;</span>, <span class="literal">null</span>, <span class="string">&#x27;Oculus&#x27;</span>)</span><br><span class="line">  )</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="初始代码分析"><a href="#初始代码分析" class="headerlink" title="初始代码分析"></a>初始代码分析</h3><p><code>src/index.js</code>：</p><p>有三个 React 组件：</p><ul><li>Square：渲染了一个单独的 <code>&lt;button&gt;</code>；</li><li>Board：渲染了 9 个方块；</li><li>Game：渲染了含有默认值的一个棋盘。</li></ul><h3 id="Props-数据传递"><a href="#Props-数据传递" class="headerlink" title="Props 数据传递"></a>Props 数据传递</h3><p>在 Board 组件的 <code>renderSquare</code> 方法中改写，传递一个名为 <code>value</code> 的 prop 到 Square 中：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderSquare</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;i&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Square 组件中的 <code>render</code> 方法，取到 Board 传递过来的 <code>this.props.value</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span>&gt;</span>&#123;this.props.value&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改前棋盘：</p><img src="/2021/11/26/React/image-20211125200631849.png" class><p>修改后：</p><img src="/2021/11/26/React/image-20211125200719853.png" class><p>在 React 应用中，数据通过 props 的传递，从父组件流向子组件。</p><h3 id="组件交互"><a href="#组件交互" class="headerlink" title="组件交互"></a>组件交互</h3><p>试着让棋盘的每一个格子在点击之后能落下一颗 <code>❌</code> 作为棋子。</p><p>首先，给 Square 组件中 button 标签添加点击事件：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> alert(&quot;click&quot;)&#125;&gt;</span></span><br><span class="line"><span class="xml">        &#123;this.props.value&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，给 Square 组件添加记忆功能，记住哪些个方格被点击过：</p><p>可以通过在 React 的构造函数中设置 <code>this.state</code> 来初始化 state。</p><p><code>this.state</code> 应该被视为一个组件的私有属性。</p><ol><li><p>向 class 中添加一个构造函数，用来初始化 state：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">value</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：在 JavaScript 的 class 中，每次定义其子类的构造函数时，都需要调用 <code>super</code> 方法。</p></blockquote><ol start="2"><li><p>修改 Square 组件的 <code>render</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">className</span>=<span class="string">&quot;square&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.setState(&#123; value: &quot;❌&quot; &#125;)&#125;</span></span><br><span class="line"><span class="xml">      &gt;</span></span><br><span class="line"><span class="xml">        &#123;this.state.value&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>render</code> 方法中的 <code>onClick</code> 事件监听函数中调用 <code>this.setState</code>，使其 <code>this.state.value</code> 的值变为 <code>❌</code>。</p><p>此时点击哪个方格，<code>❌</code> 就会出现在哪个方格内。</p></li></ol><blockquote><p>每次在组件中调用 <code>setState</code> 时，React 都会自动更新其子组件。</p></blockquote><h3 id="开发者工具"><a href="#开发者工具" class="headerlink" title="开发者工具"></a>开发者工具</h3><p>安装浏览器 <a href="https://chrome.google.com/webstore/detail/react-developer-tools/fmkadmapgofadopljbjfkapdkoienihi?utm_source=chrome-ntp-icon">React Developer Tools</a> 扩展。</p><p>工具栏会多展示 React 的选项卡（包含 <code>⚛️ Components</code> 和 <code>⚛️ Profiler</code>，可以使用前者检查组件树）。</p><h2 id="游戏完善"><a href="#游戏完善" class="headerlink" title="游戏完善"></a>游戏完善</h2><h3 id="状态提升"><a href="#状态提升" class="headerlink" title="状态提升"></a>状态提升</h3><p>每个 Square 组件都维护了游戏的状态，将所有 9 个 Square 的值房子啊一个地方，即可判断出胜者。</p><p>最好的解决方式是：</p><ul><li>直接将所有的 state 状态数据存储在 Board 父组件中；</li><li>之后 Board 组件将这些数据通过 props 传递给各个 Square 子组件。</li></ul><p>为 Board 组件添加构造函数，将 Board 组件的初始状态设为长度为 9 的空值数组，并传递给 Square：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">squares</span>: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">renderSquare</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Square</span> <span class="attr">value</span>=<span class="string">&#123;this.state.squares[i]&#125;</span> /&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 Board 组件向 Square 组件传递一个函数，当 Square 被点击时，函数就调用：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">renderSquare</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Square</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;this.state.squares[i]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onclick</span>=<span class="string">&#123;()</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在从 Board 组件向 Square 组件传递两个 props 参数：</p><ul><li><code>value</code>；</li><li><code>onClick</code>：一个 Square 组件点击事件的监听函数。</li></ul><p>修改 Square 组件：</p><ul><li><code>render</code> 中的 <code>this.state.value</code> 替换为 <code>this.props.value</code>；</li><li><code>render</code> 中的 <code>this.setState()</code> 替换为 <code>this.props.onClick()</code>；</li><li>删掉 Square 组件中的 <code>constructor</code>，因为不再需要保存 state。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Square</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.onClick()&#125;&gt;</span></span><br><span class="line"><span class="xml">        &#123;this.props.value&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每一个 Square 被点击时，Board 提供的 <code>onClick</code> 函数就会触发。</p><p>接下来给 Board 组件添加 <code>handleClick</code> 方法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> squares = <span class="built_in">this</span>.state.squares.slice();</span><br><span class="line">    squares[i] = <span class="string">&quot;❌&quot;</span>;</span><br><span class="line">    setState(&#123; squares &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="函数组件"><a href="#函数组件" class="headerlink" title="函数组件"></a>函数组件</h3><p>将 Square 组件重写为一个 <strong>函数组件</strong>。</p><p>如果想写的组件只包含一个 <code>render</code> 方法，且不包含 state，那么使用 <strong>函数组件</strong> 就会很简单：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Square</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">button</span> <span class="attr">className</span>=<span class="string">&quot;square&quot;</span> <span class="attr">onClick</span>=<span class="string">&#123;props.onClick&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      &#123;props.value&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收 <code>props</code> 作为参数，然后返回需要渲染的元素；</li><li><code>this.props</code> 均替换为 <code>props</code>；</li><li><code>() =&gt; this.props.onClick()</code> 替换成了 <code>props.onClick</code>（注意方法后没有括号）</li></ul><h3 id="轮流落子"><a href="#轮流落子" class="headerlink" title="轮流落子"></a>轮流落子</h3><p>交替放置 <code>❌</code> 和 <code>⚪</code></p><p>修改 Board 组件的构造函数中的初始 state 来设置默认的第一步棋子：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">squares</span>: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>),</span><br><span class="line">      <span class="attr">xIsNext</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每下一步棋，<code>xIsNext</code> 都会反转，此值确定下一步轮到哪位玩家，并且保留游戏的状态：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> squares = <span class="built_in">this</span>.state.squares.slice();</span><br><span class="line">    squares = <span class="built_in">this</span>.state.xIsNext ? <span class="string">&quot;❌&quot;</span> : <span class="string">&quot;⚪&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      squares,</span><br><span class="line">      <span class="attr">xInNext</span>: !<span class="built_in">this</span>.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>已实现轮流落子的效果。</p><p>修改 Board 组件的 <code>render</code> 方法中的 <code>status</code> 的值，显示下一步该哪个玩家落子。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">const</span> status = <span class="string">&#x27;Next play: &#x27;</span> + (<span class="built_in">this</span>.state.xIsNext ? <span class="string">&#x27;❌&#x27;</span> : <span class="string">&#x27;⚪&#x27;</span>)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断出胜者"><a href="#判断出胜者" class="headerlink" title="判断出胜者"></a>判断出胜者</h3><p>还需要显示游戏胜出的结果：</p><p>拷贝以下代码到文件底部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">calculateWinner</span>(<span class="params">squares</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lines = [</span><br><span class="line">    [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">    [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">3</span>, <span class="number">6</span>],</span><br><span class="line">    [<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">0</span>, <span class="number">4</span>, <span class="number">8</span>],</span><br><span class="line">    [<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>],</span><br><span class="line">  ];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = lines.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">const</span> [a, b, c] = lines[i];</span><br><span class="line">    <span class="keyword">if</span> (squares[a] &amp;&amp; squares[a] === squares[b] &amp;&amp; squares[a] === squares[c]) &#123;</span><br><span class="line">      <span class="keyword">return</span> squares[a];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Board 组件的 <code>render</code> 方法中调用 <code>calculateWinner(squares)</code> 检查是否有玩家胜出，修改 Board 的 <code>render</code> 函数中的 status ：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">render () &#123;</span><br><span class="line">  <span class="keyword">const</span> winner = calculateWinner(<span class="built_in">this</span>.state.squares)</span><br><span class="line">  <span class="keyword">let</span> status</span><br><span class="line">  <span class="keyword">if</span> (winner) &#123;</span><br><span class="line">    status = <span class="string">&#x27;Winner: &#x27;</span> + winner</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    status = <span class="string">&#x27;Next player: &#x27;</span> + (<span class="built_in">this</span>.state.xIsNext ?  <span class="string">&#x27;❌&#x27;</span> : <span class="string">&#x27;⚪&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，修改 <code>handleClick</code> 事件，有玩家胜出或者点击的 Square 已经被填充时，函数直接返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">handleClick (i) &#123;</span><br><span class="line">  <span class="keyword">const</span> squares = <span class="built_in">this</span>.state.squares.slice()</span><br><span class="line">  <span class="keyword">if</span> (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  squares[i] = <span class="built_in">this</span>.state.xIsNext ? <span class="string">&#x27;❌&#x27;</span> : <span class="string">&#x27;⚪&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">    squares,</span><br><span class="line">    <span class="attr">xIsNext</span>: !<span class="built_in">this</span>.state.xIsNext</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="时间回溯"><a href="#时间回溯" class="headerlink" title="时间回溯"></a>时间回溯</h2><h3 id="保存历史记录"><a href="#保存历史记录" class="headerlink" title="保存历史记录"></a>保存历史记录</h3><p>使用 <code>slice()</code> 函数为每一步创建 <code>squares</code> 数组的副本，即可实现保留所有 <code>squares</code> 数组的历史版本。</p><p>将所有版本的 <code>squares</code> 保存在 <code>history</code> 数组中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">history = [</span><br><span class="line">  <span class="comment">// 第一步之前</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">squares</span>: [<span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">null</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">];</span><br></pre></td></tr></table></figure><h3 id="状态提升-1"><a href="#状态提升-1" class="headerlink" title="状态提升"></a>状态提升</h3><p>把 <code>history</code> state 放在 Game 组件中，把 state 从 Board 提升到顶层的 Game 组件里：</p><p>首先在 Game 组件的构造函数中初始化 state：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">history</span>: [&#123; <span class="attr">squares</span>: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>) &#125;],</span><br><span class="line">      <span class="attr">xIsNext</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Board 组件：</p><ul><li>删除 Board 组件中的 <code>constructor</code> 构造函数；</li><li>把 Board 组件的 <code>renderSquare</code> 中的 <code>this.state.squares[i]</code> 替换为 <code>this.props.squares[i]</code>；</li><li>把 Board 组件的 <code>renderSquare</code> 中的 <code>this.handleClick(i)</code> 替换为 <code>this.props.onClick(i)</code>；</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Board</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">renderSquare</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Square</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">value</span>=<span class="string">&#123;this.props.squares[i]&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.props.onClick(i)&#125;</span></span><br><span class="line"><span class="xml">      /&gt;</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(0)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(1)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(2)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(3)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(4)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(5)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;board-row&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(6)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(7)&#125;</span></span><br><span class="line"><span class="xml">          &#123;this.renderSquare(8)&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>更新 Game 组件的 <code>render</code> 函数，使用最新一次的历史记录来确定并展示游戏的状态：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">history</span>: [&#123; <span class="attr">squares</span>: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>) &#125;],</span><br><span class="line">      <span class="attr">xIsNext</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.state.history;</span><br><span class="line">    <span class="keyword">const</span> current = history[history.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> squares = current.squares.slice();</span><br><span class="line">    <span class="keyword">if</span> (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    squares[i] = <span class="built_in">this</span>.state.xIsNext ? <span class="string">&quot;❌&quot;</span> : <span class="string">&quot;⚪&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">history</span>: history.concat([&#123; squares &#125;]),</span><br><span class="line">      <span class="attr">xIsNext</span>: !<span class="built_in">this</span>.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.state.history;</span><br><span class="line">    <span class="keyword">const</span> current = history[history.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> winner = calculateWinner(current.squares);</span><br><span class="line">    <span class="keyword">let</span> status;</span><br><span class="line">    <span class="keyword">if</span> (winner) &#123;</span><br><span class="line">      status = <span class="string">&quot;Winner: &quot;</span> + winner;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = <span class="string">&quot;Next player: &quot;</span> + (<span class="built_in">this</span>.state.xIsNext ? <span class="string">&quot;❌&quot;</span> : <span class="string">&quot;⚪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onClick</span>=<span class="string">&#123;(i)</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="xml">          /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;/* TODO */&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>concat()</code> 方法与 <code>push()</code> 不同，它不会改变原数组。</p></blockquote><h3 id="展示历史步骤记录"><a href="#展示历史步骤记录" class="headerlink" title="展示历史步骤记录"></a>展示历史步骤记录</h3><ul><li>通过使用 <code>map</code> 方法，把历史步骤映射为代表按钮的 React 元素，然后展示出一个按钮列表；</li><li>给构建的动态列表添加一个 <code>key</code>；</li><li>向 Game 组件的构造函数中添加 <code>stepNumber</code>，默认为 0；</li><li>修改 Game 组件 <code>handleClick</code> 方法；</li><li>修改 Game 组件的 <code>render</code> 方法，将代码根据最后一次移动渲染修改为根据当前 <code>stepNumber</code> 渲染。</li></ul><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Game</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">history</span>: [&#123; <span class="attr">squares</span>: <span class="built_in">Array</span>(<span class="number">9</span>).fill(<span class="literal">null</span>) &#125;],</span><br><span class="line">      <span class="attr">stepNumber</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">xIsNext</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">handleClick</span>(<span class="params">i</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.state.history.slice(<span class="number">0</span>, <span class="built_in">this</span>.state.stepNumber + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">const</span> current = history[history.length - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">const</span> squares = current.squares.slice();</span><br><span class="line">    <span class="keyword">if</span> (calculateWinner(squares) || squares[i]) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    squares[i] = <span class="built_in">this</span>.state.xIsNext ? <span class="string">&quot;❌&quot;</span> : <span class="string">&quot;⚪&quot;</span>;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">history</span>: history.concat([&#123; squares &#125;]),</span><br><span class="line">      <span class="attr">stepNumber</span>: history.length,</span><br><span class="line">      <span class="attr">xIsNext</span>: !<span class="built_in">this</span>.state.xIsNext,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">jumpTo</span>(<span class="params">step</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">stepNumber</span>: step,</span><br><span class="line">      <span class="attr">xIsNext</span>: step % <span class="number">2</span> === <span class="number">0</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> history = <span class="built_in">this</span>.state.history;</span><br><span class="line">    <span class="keyword">const</span> current = history[<span class="built_in">this</span>.state.stepNumber];</span><br><span class="line">    <span class="keyword">const</span> winner = calculateWinner(current.squares);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> moves = history.map(<span class="function">(<span class="params">step, move</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> desc = move ? <span class="string">&quot;Go to move #&quot;</span> + move : <span class="string">&quot;Go to game start&quot;</span>;</span><br><span class="line">      <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;move&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> this.jumpTo(move)&#125;&gt;&#123;desc&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line">      );</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> status;</span><br><span class="line">    <span class="keyword">if</span> (winner) &#123;</span><br><span class="line">      status = <span class="string">&quot;Winner: &quot;</span> + winner;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      status = <span class="string">&quot;Next player: &quot;</span> + (<span class="built_in">this</span>.state.xIsNext ? <span class="string">&quot;❌&quot;</span> : <span class="string">&quot;⚪&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-board&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Board</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">squares</span>=<span class="string">&#123;current.squares&#125;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">            <span class="attr">onClick</span>=<span class="string">&#123;(i)</span> =&gt;</span> this.handleClick(i)&#125;</span></span><br><span class="line"><span class="xml">          /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;game-info&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;status&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">ol</span>&gt;</span>&#123;moves&#125;<span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>基本的一个 tic-tac-toe（三连棋）完成！</p><h1 id="React-入门"><a href="#React-入门" class="headerlink" title="React 入门"></a>React 入门</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h3><ul><li>英文官网：<a href="https://reactjs.org/">https://reactjs.org/</a></li><li>中文官网：<a href="https://react.docschina.org/">https://react.docschina.org/</a></li></ul><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><ol><li>用于动态构建用户 <strong>界面</strong> 的 JavaScript 库（只关注于视图）</li><li>由 Facebook 开源</li></ol><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ol><li>采用 <strong>组件化</strong> 模式、<strong>声明式编码</strong>，提高开发效率及组件复用率；</li><li>在 React Native 中可以使用 React 语法进行 <strong>移动端开发</strong>；</li><li>使用 <strong>虚拟 DOM</strong> + <strong>Diff 算法</strong>，尽量减少与真实 DOM 的交互。</li></ol><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello_react<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入 react 核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 react-dom，用于支持 react 操作 DOM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 babel，用于将 jsx 转为 js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">/* 此处必须写 babel */</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1. 创建虚拟 DOM</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> VDOM = (</span></span><br><span class="line"><span class="javascript">        <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello,React<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">      ); <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 2. 渲染虚拟 DOM 到页面</span></span></span><br><span class="line"><span class="javascript">      ReactDOM.render(VDOM, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="相关的-JS-库"><a href="#相关的-JS-库" class="headerlink" title="相关的 JS 库"></a>相关的 JS 库</h3><ol><li>react.js：React 核心库</li><li>react-dom.js：提供操作 DOM 的 react 扩展库</li><li>babel.js：解析 JSX 语法代码转为 JS 代码的库</li></ol><h3 id="虚拟-DOM-与-真实-DOM"><a href="#虚拟-DOM-与-真实-DOM" class="headerlink" title="虚拟 DOM 与 真实 DOM"></a>虚拟 DOM 与 真实 DOM</h3><p>关于虚拟 DOM ：</p><ol><li>本质是 Object 类型的对象（一般对象）</li><li>虚拟 DOM 比较 “轻”，真实 DOM 比较“重”，因为虚拟 DOM 是 React 内部在用，无需真实 DOM 上那么多的属性</li><li>虚拟 DOM 最终会被 React 渲染成 真实 DOM</li></ol><h2 id="React-JSX"><a href="#React-JSX" class="headerlink" title="React JSX"></a>React JSX</h2><h3 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h3><p>JavaScript XML，react 定义的一种类似于 XML 的 JS 扩展语法，本质是 <code>React.createElement(component, props, ...childrens)</code> 方法的语法糖。</p><p>用来简化创建虚拟 DOM，不是字符串，也不是 HTML/XML 标签，最终产生的是一个 JS 对象。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建虚拟 DOM</span></span><br><span class="line"><span class="keyword">const</span> VDOM = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">id</span>=<span class="string">&quot;title&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello,React -- jsx<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">); <span class="comment">/* 此处一定不要写引号，因为不是字符串 */</span></span><br><span class="line"><span class="comment">// 2. 渲染虚拟 DOM 到页面</span></span><br><span class="line">ReactDOM.render(VDOM, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>基本语法规则：</p><ol><li>定义虚拟 DOM 时，不要写引号；</li><li>标签中混入 JS 表达式 时要用 {}；</li><li>样式的类名指定不要用 class，要用 className；</li><li>内联样式，要用 <code>style=&#123;&#123; key: value &#125;&#125;</code> 的形式去写；</li><li>虚拟 DOM 必须只有一个根标签；</li><li>所有的标签必须闭合；</li><li>标签首字母：<ol><li>若小写字母开头，则将该标签转为 html 中同名元素，则报错；</li><li>若大写字母开头，React 就去渲染对应的组件，若没有定义，则报错。</li></ol></li></ol><h3 id="渲染虚拟-DOM-元素"><a href="#渲染虚拟-DOM-元素" class="headerlink" title="渲染虚拟 DOM(元素)"></a>渲染虚拟 DOM(元素)</h3><p>语法：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(virtualDOM, containerDOM);</span><br></pre></td></tr></table></figure><ul><li>参数 1：纯 JS 或 JSX 创建的虚拟 DOM 对象；</li><li>参数 2：用来包含虚拟 DOM 元素的真实 DOM 元素对象（一般是一个 div）</li></ul><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>hello_react<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 准备好一个“容器” --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 引入 react 核心库 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/react.development.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 react-dom，用于支持 react 操作 DOM --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">      <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">src</span>=<span class="string">&quot;../js/react-dom.development.js&quot;</span></span></span><br><span class="line"><span class="tag">    &gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 引入 babel，用于将 jsx 转为 js --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../js/babel.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/babel&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 模拟一些数据</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> data = [<span class="string">&quot;Angular&quot;</span>, <span class="string">&quot;React&quot;</span>, <span class="string">&quot;Vue&quot;</span>];</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1. 创建虚拟 DOM</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> VDOM = (</span></span><br><span class="line"><span class="javascript">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">          <span class="tag">&lt;<span class="name">h1</span>&gt;</span>前端 JS 框架列表<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">          <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">            &#123;data.map((item, index) =&gt; &#123;</span></span></span><br><span class="line"><span class="xml"><span class="javascript">              return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;index&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span></span><br><span class="line"><span class="xml"><span class="javascript">            &#125;)&#125;</span></span></span><br><span class="line"><span class="xml"><span class="javascript">          <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="javascript">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 2. 渲染虚拟 DOM 到页面</span></span></span><br><span class="line"><span class="javascript">      ReactDOM.render(VDOM, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>一定注意区分：<strong>js 语句(代码)</strong> 与 <strong>js 表达式</strong>：</p><ul><li>表达式：一个表达式会产生一个值，可以放在任何一个需要值的地方<ul><li><code>a</code></li><li><code>a + b</code></li><li><code>demo(1)</code></li><li><code>arr.map()</code></li><li><code>function test () &#123;&#125;</code></li><li><code>a &gt; 1 ? 2 : 3</code></li></ul></li><li>语句(代码)：<ul><li><code>if () &#123;&#125;</code></li><li><code>for () &#123;&#125;</code></li><li><code>switch () &#123; case: xxx &#125;</code></li></ul></li></ul></blockquote><h1 id="面向组件编程"><a href="#面向组件编程" class="headerlink" title="面向组件编程"></a>面向组件编程</h1><h2 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建函数式组件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><ul><li>组件名必须首字母大写；</li><li>虚拟 DOM 元素只能有一个根标签；</li><li>虚拟 DOM 元素必须有结束标签。</li></ul><p>注意，此时函数式组件中的 <code>this</code> 是 <code>undefined</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyComponent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// babel 在转译时会开启严格模式，禁止自定义函数内 this 指向 window</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); <span class="comment">// undefined</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用函数定义的组件(适用于【简单组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/11/26/React/image-20211221194950389.png" class title="babel 转译"><p>执行了 <code>ReactDOM.render(&lt;MyComponent/&gt;...)</code> 之后：</p><ol><li>React 解析组件标签，找到了 <code>MyComponent</code> 组件；</li><li>发现组件是使用函数定义的，随后调用该函数，将返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。</li></ol><h2 id="类式组件"><a href="#类式组件" class="headerlink" title="类式组件"></a>类式组件</h2><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建类式组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是用类定义的组件(适用于【复杂组件】的定义)<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">MyComponent</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>此时 render 中的 this 是 <code>MyComponent</code> 的实例对象。</p><img src="/2021/11/26/React/image-20211221203820595.png" class title="类式组件"><p>执行了 <code>ReactDOM.render(&lt;MyComponent/&gt;...)</code> 之后：</p><ol><li>React 解析组件标签，找到了 <code>MyComponent</code> 组件；</li><li>发现组件是使用类定义的，随后 new 出来该类的实例，并通过该实例调用原型上的 render 方法；</li><li>将 render 返回的虚拟 DOM 转为真实 DOM，随后呈现在页面中。</li></ol><h2 id="三大核心属性"><a href="#三大核心属性" class="headerlink" title="三大核心属性"></a>三大核心属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><p>state 是组件对象最重要的属性，值是对象（可以包含多个 key-value 的组合）。</p><p>组件被称为”状态机”，通过更新组件的 state 来更新对应的页面显示（重新渲染组件）。</p><h4 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造器调用几次？ ---- 1 次</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;constructor&quot;</span>);</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="comment">// 初始化状态</span></span><br><span class="line">    <span class="built_in">this</span>.state = &#123;</span><br><span class="line">      <span class="attr">isHot</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 解决 changeWeather 中 this 指向问题</span></span><br><span class="line">    <span class="built_in">this</span>.changeWeather = <span class="built_in">this</span>.changeWeather.bind(<span class="built_in">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// render 调用几次？ ---- 1 + n 次</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;render&quot;</span>);</span><br><span class="line">    <span class="comment">// 读取状态</span></span><br><span class="line">    <span class="keyword">const</span> &#123; isHot, wind &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;，&#123;wind&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// changeWeather 调用几次？ ---- 点击几次调用几次</span></span><br><span class="line">  <span class="function"><span class="title">changeWeather</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;changeWeather&quot;</span>);</span><br><span class="line">    <span class="comment">// changeWeather 放在哪里？ ---- Weather 的原型对象上，供实例使用</span></span><br><span class="line">    <span class="comment">// 由于 changeWeather 是作为 onClick 的回调，所以不是通过实例调用的，是直接调用</span></span><br><span class="line">    <span class="comment">// 类中的方法默认开启了局部的严格模式，所以 changeWeather 中的 this 为 undefined</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取原来的 isHot 值</span></span><br><span class="line">    <span class="keyword">const</span> isHot = <span class="built_in">this</span>.state.isHot;</span><br><span class="line">    <span class="comment">// 严重注意：状态（state）不可直接更改！！！</span></span><br><span class="line">    <span class="comment">// this.state.isHot = !isHot // 这是错误的写法</span></span><br><span class="line">    <span class="comment">// console.log(this.state.isHot)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严重注意：状态必须通过 setState 进行更新，且更新是一种合并，不是替换。</span></span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">isHot</span>: !<span class="built_in">this</span>.state.isHot,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="代码简写"><a href="#代码简写" class="headerlink" title="代码简写"></a>代码简写</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Weather</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">isHot</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">wind</span>: <span class="string">&quot;微风&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; isHot, wind &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">onClick</span>=<span class="string">&#123;this.changeWeather&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        今天天气很&#123;isHot ? &quot;炎热&quot; : &quot;凉爽&quot;&#125;，&#123;wind&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 自定义方法 ---- 要用赋值语句的形式 + 箭头函数</span></span><br><span class="line">  changeWeather = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">isHot</span>: !<span class="built_in">this</span>.state.isHot,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2. 渲染组件到页面</span></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Weather</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>组件中 <code>render</code> 方法中的 this 为组件实例对象；</li><li>组件自定义方法中的 this 为 <code>undefined</code>：<ol><li>强制绑定 this，通过函数对象的 <code>bind()</code>；</li><li>箭头函数；</li></ol></li><li>状态数据不能直接修改或更新，需要调用内置 API <code>setState</code>。</li></ul><h4 id="setState"><a href="#setState" class="headerlink" title="setState"></a>setState</h4><p>React 的状态更新是异步的，第二个参数 callback 函数是可选的回调函数，在状态更新（render）后调用。</p><h5 id="对象式"><a href="#对象式" class="headerlink" title="对象式"></a>对象式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(&#123;&#125;, [callback]);</span><br></pre></td></tr></table></figure><h5 id="函数式"><a href="#函数式" class="headerlink" title="函数式"></a>函数式</h5><p>setState 更新状态的另一种方式：传递一个函数，返回状态对象，该函数可以接收到 state 和 props 作为参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.setState(<span class="function">() =&gt;</span> &#123;&#125;, [callback]);</span><br></pre></td></tr></table></figure><blockquote><p>对象形式的 setState 就是函数式的 setState 的简写方式（语法糖）。</p></blockquote><h5 id="使用原则"><a href="#使用原则" class="headerlink" title="使用原则"></a>使用原则</h5><ol><li>新状态不依赖原状态 — 使用对象方式；</li><li>新状态依赖原状态 — 使用函数方式；</li><li>若需要在 setState() 执行后获取最新的状态数据，在第二个 callback 函数中读取。</li></ol><h3 id="props"><a href="#props" class="headerlink" title="props"></a>props</h3><h4 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h4><p>在 render 函数中通过 <code>this.props</code> 获取属性</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建组件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; name, age, sex &#125; = <span class="built_in">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名: &#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别: &#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄: &#123;age + 1&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 渲染组件到页面</span></span><br><span class="line"><span class="keyword">const</span> p = &#123; <span class="attr">name</span>: <span class="string">&quot;lay&quot;</span>, <span class="attr">age</span>: <span class="number">30</span>, <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span> &#125;;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Person</span> &#123;<span class="attr">...p</span>&#125; /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test2&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>在 babel 和 react 的加持下，可以在标签属性位置使用 <code>...</code> 展开运算符展开对象。</p></blockquote><h4 id="属性限制"><a href="#属性限制" class="headerlink" title="属性限制"></a>属性限制</h4><h5 id="类型、必要性"><a href="#类型、必要性" class="headerlink" title="类型、必要性"></a>类型、必要性</h5><h6 id="方式一：React-PropTypes"><a href="#方式一：React-PropTypes" class="headerlink" title="方式一：React.PropTypes"></a>方式一：<del>React.PropTypes</del></h6><blockquote><p>注意：React v15.5 开始已弃用！</p></blockquote><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.propTypes = &#123;</span><br><span class="line">  <span class="attr">name</span>: React.PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">age</span>: React.PropTypes.number,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="方式二：prop-types-库"><a href="#方式二：prop-types-库" class="headerlink" title="方式二：prop-types 库"></a>方式二：prop-types 库</h6><p>引入 prop-types 库进行限制：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person.propTypes = &#123;</span><br><span class="line">  <span class="attr">name</span>: PropTypes.string.isRequired,</span><br><span class="line">  <span class="attr">age</span>: PropTypes.number,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> defaultProps = &#123;</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&#x27;男&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="props-与-构造器"><a href="#props-与-构造器" class="headerlink" title="props 与 构造器"></a>props 与 构造器</h4><p>在构造器中若需要通过 <code>this</code> 访问 <code>props</code>，则需要接收 <code>props</code> 并 <code>super(props)</code> 才可访问。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">props</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(props);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;constructor&quot;</span>, <span class="built_in">this</span>.props);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若不接受，不进行 <code>super</code>，则构造器中 <code>props</code> 为 <code>undefined</code>。</p><h4 id="函数式组件使用-props"><a href="#函数式组件使用-props" class="headerlink" title="函数式组件使用 props"></a>函数式组件使用 props</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; name, age, sex &#125; = props;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>姓名: &#123;name&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>性别: &#123;sex&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>年龄: &#123;age&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对标签属性进行类型、必要性的限制</span></span><br><span class="line">Person.propTypes = &#123;</span><br><span class="line">  <span class="attr">name</span>: PropTypes.string.isRequired, <span class="comment">// 限制 name 必传，且为字符串</span></span><br><span class="line">  <span class="attr">sex</span>: PropTypes.string, <span class="comment">// 限制 sex 为字符串</span></span><br><span class="line">  <span class="attr">age</span>: PropTypes.number, <span class="comment">// 限制 age 为数值</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定默认标签属性值</span></span><br><span class="line">Person.defaultProps = &#123;</span><br><span class="line">  <span class="attr">sex</span>: <span class="string">&quot;男&quot;</span>, <span class="comment">// sex 默认值为 男</span></span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>, <span class="comment">// age 默认值为 18</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 渲染组件到页面</span></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">Person</span> <span class="attr">name</span>=<span class="string">&quot;agoni&quot;</span> <span class="attr">sex</span>=<span class="string">&quot;男&quot;</span> <span class="attr">age</span>=<span class="string">&#123;18&#125;</span> /&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;test1&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>函数式的组件中只可以使用三大核心属性中的 <code>props</code>，无法使用 <code>state</code> 和 <code>refs</code>。</p><blockquote><p>指在新版本 React 之前，新版本通过 Hooks 可以实现。</p></blockquote><h3 id="refs"><a href="#refs" class="headerlink" title="refs"></a>refs</h3><h4 id="字符串形式"><a href="#字符串形式" class="headerlink" title="字符串形式"></a>字符串形式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;input1&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示数据&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点我提示左边的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 展示左边的数据</span></span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(this)</span></span><br><span class="line">    <span class="keyword">const</span> &#123; input1 &#125; = <span class="built_in">this</span>.refs;</span><br><span class="line">    alert(input1.value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>此方法有效率问题，React 官方已不推荐使用！</p></blockquote><h4 id="回调函数形式"><a href="#回调函数形式" class="headerlink" title="回调函数形式"></a>回调函数形式</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> (this.input1 = c)&#125;</span></span><br><span class="line"><span class="xml">          placeholder=&quot;点击按钮提示数据&quot;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.showData&#125;</span>&gt;</span>点我提示左边的数据<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 展示左边的数据</span></span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; input1 &#125; = <span class="built_in">this</span>;</span><br><span class="line">    alert(input1.value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><p>此方法若使用内联形式函数，则在重新渲染执行 render 时会执行两次内联的方法，其中一次传递的参数为 <code>null</code>（因为要做一次清空），使用以下方法可避免：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.saveInput&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  saveInput = <span class="function">(<span class="params">c</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.input = c;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;@&quot;</span>, c);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>但并没有什么影响！</p></blockquote><h4 id="createRef"><a href="#createRef" class="headerlink" title="createRef"></a>createRef</h4><p>使用 React 内置 API <code>createRef</code> 创建 ref 容器：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 创建 ref 容器</span></span><br><span class="line">  myRef = React.createRef();</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;this.myRef&#125;</span> <span class="attr">placeholder</span>=<span class="string">&quot;点击按钮提示数据&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 展示左边的数据</span></span><br><span class="line">  showData = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.myRef.current.value);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>));</span><br></pre></td></tr></table></figure><blockquote><p>React 官方最推荐使用的方式，但每次使用均需要创建一个 ref 容器，一个 ref 容器只能容纳一个节点，后者会顶掉前者。</p></blockquote><h2 id="事件处理"><a href="#事件处理" class="headerlink" title="事件处理"></a>事件处理</h2><p>React 通过 <code>onXxx</code> 属性指定事件处理函数（小驼峰格式）</p><ul><li>React 使用的是自定义(合成)事件，而不是使用的原生 DOM 事件</li><li>React 中的事件是通过事件委托方式处理的(委托给组件最外层的元素)</li></ul><p>通过 <code>event.target</code> 得到发生事件的 DOM 元素对象</p><h2 id="收集表单数据"><a href="#收集表单数据" class="headerlink" title="收集表单数据"></a>收集表单数据</h2><h3 id="非受控组件"><a href="#非受控组件" class="headerlink" title="非受控组件"></a>非受控组件</h3><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = <span class="built_in">this</span>;</span><br><span class="line">    alert(<span class="string">`你输入的用户名是: <span class="subst">$&#123;username.value&#125;</span>，密码是: <span class="subst">$&#123;password.value&#125;</span>。`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        用户名：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> (this.username = c)&#125; name=&quot;username&quot; /&gt;</span></span><br><span class="line"><span class="xml">        密码：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">ref</span>=<span class="string">&#123;(c)</span> =&gt;</span> (this.password = c)&#125;</span></span><br><span class="line"><span class="xml">          name=&quot;password&quot;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="受控组件"><a href="#受控组件" class="headerlink" title="受控组件"></a>受控组件</h3><p>示例代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 初始化状态</span></span><br><span class="line">  state = &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 用户名</span></span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;&quot;</span>, <span class="comment">// 密码</span></span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 保存用户名到状态中</span></span><br><span class="line">  saveUsername = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">username</span>: event.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 保存密码到状态中</span></span><br><span class="line">  savePassword = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      <span class="attr">password</span>: event.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    alert(<span class="string">`你输入的用户名是: <span class="subst">$&#123;username&#125;</span>，密码是: <span class="subst">$&#123;password&#125;</span>。`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        用户名：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.saveUsername&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        密码：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">onChange</span>=<span class="string">&#123;this.savePassword&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处可以使用 <strong>高阶函数</strong> 及 <strong>函数柯里化</strong> 简化代码：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 保存表单数据到状态中</span></span><br><span class="line">  saveFormData = <span class="function">(<span class="params">dataType</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">        [dataType]: event.target.value,</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">  handleSubmit = <span class="function">(<span class="params">event</span>) =&gt;</span> &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">    <span class="keyword">const</span> &#123; username, password &#125; = <span class="built_in">this</span>.state;</span><br><span class="line">    alert(<span class="string">`你输入的用户名是: <span class="subst">$&#123;username&#125;</span>，密码是: <span class="subst">$&#123;password&#125;</span>。`</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        用户名：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&quot;<span class="attr">username</span>&quot;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        密码：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onChange</span>=<span class="string">&#123;this.saveFormData(</span>&quot;<span class="attr">password</span>&quot;)&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">        /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>高阶函数</strong>：如果一个函数符合以下 2 个规范中的任何一个，该函数就是高阶函数</p><ol><li>接收的参数是一个函数；</li><li>调用的返回值是一个函数。</li></ol><blockquote><p>常见的高阶函数有：<code>Promise</code>、<code>setTimeout</code>、<code>arr.map</code> …</p></blockquote><p><strong>函数柯里化</strong>：通过函数调用继续返回函数的方式,实现多次接收参数最后哦统一处理的函数编码形式。</p><blockquote><p>不适用函数柯里化也可以达到上面效果：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Login</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="comment">// 保存表单数据到状态中</span></span><br><span class="line">  saveFormData = <span class="function">(<span class="params">dataType, event</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      [dataType]: event.target.value,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;#&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span> <span class="attr">onSubmit</span>=<span class="string">&#123;this.handleSubmit&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        用户名：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;username&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.saveFormData(&quot;username&quot;, e)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        密码：</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">type</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">name</span>=<span class="string">&quot;password&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">          <span class="attr">onChange</span>=<span class="string">&#123;(e)</span> =&gt;</span> this.saveFormData(&quot;password&quot;, e)&#125;</span></span><br><span class="line"><span class="xml">        /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">button</span>&gt;</span>登录<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><h3 id="旧生命周期"><a href="#旧生命周期" class="headerlink" title="旧生命周期"></a>旧生命周期</h3><img src="/2021/11/26/React/image-20220112193203522.png" class title="旧生命周期"><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>初始化状态: 由 <code>ReactDOM.render()</code> 触发 — 初次渲染<ol><li><code>constructor()</code></li><li><code>componentWillMount()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code> —-&gt; 常用<ul><li>一般在这个钩子中做一些初始化的事, 例如: 开启定时器、发送网络请求、订阅消息</li></ul></li></ol></li><li>更新阶段: 由组件内部 <code>this.setState()</code> 或父组件 <code>render</code> 触发<ol><li><code>shouldComponentUpdate()</code> 强制更新没有此过程</li><li><code>componentWillUpdate()</code></li><li><code>render()</code></li><li><code>componentDidUpdate()</code></li></ol></li><li>卸载组件: 由 <code>ReactDOM.unmountComponentAtNode()</code> 触发<ol><li><code>componentWillUnmount()</code> —-&gt; 常用<ul><li>一般在这个钩子中做一些守卫的事情，例如：关闭定时器、取消订阅消息</li></ul></li></ol></li></ul><h3 id="新生命周期"><a href="#新生命周期" class="headerlink" title="新生命周期"></a>新生命周期</h3><img src="/2021/11/26/React/image-20220112193325938.png" class title="新生命周期"><h4 id="即将废弃钩子"><a href="#即将废弃钩子" class="headerlink" title="即将废弃钩子"></a>即将废弃钩子</h4><p>在新版本中使用旧版本的三个带 will（除了 <code>componentWillUnmount</code>）的生命周期钩子函数不会报错但会报警告。</p><p>在新版本中需要给 <code>componentWillMount</code>、<code>componentWillUpdate</code>、<code>componentWillReceiveProps</code> 加上 <code>UNSAFE_</code> 前缀。</p><blockquote><p>这里的 <code>unsafe</code> 不是指安全性，而是表示这些生命周期的代码在 React 的未来版本中很有可能出现 bug，尤其是在启用异步渲染之后。</p><p>查看官网详情：<a href="https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html">https://zh-hans.reactjs.org/blog/2018/03/27/update-on-async-rendering.html</a></p></blockquote><h4 id="添加两个钩子"><a href="#添加两个钩子" class="headerlink" title="添加两个钩子"></a>添加两个钩子</h4><p><code>getDerivedStateFromProps</code>：</p><p><code>getDerivedStateFromProps</code> 会在调用 render 方法之前调用，并且在初始挂载及后续更新时都会被调用。它应返回一个对象来更新 state，如果返回 <code>null</code> 则不更新任何内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="function"><span class="title">getDerivedStateFromProps</span>(<span class="params">props, state</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Count - getDerivedStateFromProps&quot;</span>, props, state);</span><br><span class="line">    <span class="comment">// return props</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>派生状态</strong>会导致代码冗余，并使组件难以维护，了解即可。</p><blockquote><p>官方文档：<a href="https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops">https://zh-hans.reactjs.org/docs/react-component.html#static-getderivedstatefromprops</a></p></blockquote><p><code>getSnapshotBeforeUpdate</code>：</p><p><code>getSnapshotBeforeUpdate()</code> 在最近一次渲染输出（提交到 DOM 节点）之前调用。使得组件能在发生更改之前从 DOM 中捕获一些信息（例如，滚动位置）。</p><p>此生命周期方法的任何返回值将作为参数传递给 <code>componentDidUpdate()</code>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Count</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在更新之前获取快照</span></span><br><span class="line">  <span class="function"><span class="title">getSnapshotBeforeUpdate</span>(<span class="params">prevProps, prevState</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Count - getSnapshotBeforeUpdate&quot;</span>, prevProps, prevState);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;AgoniLay&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 组件更新完毕的钩子</span></span><br><span class="line">  <span class="function"><span class="title">componentDidUpdate</span>(<span class="params">prevProps, prevState, snapshotValue</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">&quot;Count - componentDidUpdate&quot;</span>,</span><br><span class="line">      prevProps,</span><br><span class="line">      prevState,</span><br><span class="line">      snapshotValue</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>初始化阶段：由 <code>ReactDOM.render()</code> 触发 — 初次渲染<ol><li><code>constructor()</code></li><li><code>getDerivedStateFromProps()</code></li><li><code>render()</code></li><li><code>componentDidMount()</code></li></ol></li><li>更新阶段：由组件内部 <code>this.setState()</code> 或父组件重新 render 触发<ol><li><code>getDerivedStateFromProps()</code></li><li><code>shouldComponentUpdate()</code></li><li><code>render()</code></li><li><code>getSnapshotBeforeUpdate()</code></li><li><code>componentDidUpdate()</code></li></ol></li><li>卸载组件：由 <code>ReactDOM.unmountComponentAtNode()</code> 触发<ol><li><code>componentWillUnmount()</code></li></ol></li></ul><h2 id="key-相关"><a href="#key-相关" class="headerlink" title="key 相关"></a>key 相关</h2><p>经典面试题：</p><ol><li>react/vue 中的 key 有什么作用? ( key 的内部原理是什么? )</li><li>为什么遍历列表时，key 最后不要用 index ?</li></ol><p>虚拟 DOM 中 key 的作用:</p><ol><li><p>简单的说: key 是虚拟 DOM 对象的标识，在更新显示时 key 起着极其重要的作用；</p></li><li><p>详细的说: 当状态中的数据发生变化时，react 会根据【新数据】生成【新的虚拟 DOM】</p><p>随后 React 进行【新虚拟 DOM】与【旧虚拟 DOM】的 diff 比较，比较规则如下：</p><ol><li><p>旧虚拟 DOM 中找到了与新虚拟 DOM 相同的 key:</p><ol><li>若虚拟 DOM 中内容没变，直接使用之前的真实 DOM</li><li>若虚拟 DOM 中内容变了，则生成新的真实 DOM，随后替换掉页面中之前的真实 DOM</li></ol></li><li><p>旧虚拟 DOM 中未找到与新虚拟 DOM 相同的 key：</p><p>根据数据创建新的真实 DOM，随后渲染到页面</p></li></ol></li></ol><p>用 index 作为 key 可能会引发的问题:</p><ol><li><p>若对数据进行：逆序添加、逆序删除等破环顺序操作：</p><p>会产生没有必要的真实 DOM 更新 –&gt; 界面效果没问题，但效率低</p></li><li><p>如果结构中还包含输入类的 DOM：</p><p>会产生错误 DOM 更新 –&gt; 界面有错误注意！</p></li><li><p>如果不存在对数据的逆序添加、逆序删除等破环顺序操作，仅用于渲染列表用于展示，使用 index 作为 key 是没有问题的。</p></li></ol><p>开发中如何选择 key?</p><ol><li>最好使用每条数据的唯一标识作为 key，比如 id、手机号、身份证号、学号等唯一值；</li><li>如果确定只是简单的展示数据，用 index 也是可以的。</li></ol><h1 id="React-应用-基于脚手架"><a href="#React-应用-基于脚手架" class="headerlink" title="React 应用(基于脚手架)"></a>React 应用(基于脚手架)</h1><h2 id="使用-create-react-app-创建"><a href="#使用-create-react-app-创建" class="headerlink" title="使用 create-react-app 创建"></a>使用 create-react-app 创建</h2><h3 id="react-脚手架"><a href="#react-脚手架" class="headerlink" title="react 脚手架"></a>react 脚手架</h3><ol><li>xxx 脚手架：用来帮助程序员快速船舰一个基于 xxx 库的模板项目<ol><li>包含了所有需要的配置（语法检查、jsx 编译、decServer…）</li><li>下载好了所有的相关依赖</li><li>可以直接运行一个简单效果</li></ol></li><li>react 提供了一个用于创建 react 项目的脚手架库：<strong>create-react-app</strong></li><li>项目的整体架构为：react + webpack + es6 + eslint</li><li>使用脚手架开发的项目的特点：模块化、组件化、工程化</li></ol><h3 id="创建项目并启动"><a href="#创建项目并启动" class="headerlink" title="创建项目并启动"></a>创建项目并启动</h3><p>第一步：全局安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g create-react-app</span><br></pre></td></tr></table></figure><p>第二步：切换到想创建项目的目录，使用命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create-react-app react-staging</span><br></pre></td></tr></table></figure><p>回车等待创建完成：</p><img src="/2021/11/26/React/image-20220114215342517.png" class title="创建完成"><p>第三步：进入项目文件夹：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd react_staging</span><br></pre></td></tr></table></figure><p>第四步：启动项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm start</span><br></pre></td></tr></table></figure><h3 id="react-脚手架项目结构"><a href="#react-脚手架项目结构" class="headerlink" title="react 脚手架项目结构"></a>react 脚手架项目结构</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">react-staging</span><br><span class="line">node_modules</span><br><span class="line">public</span><br><span class="line">src</span><br><span class="line">.gitignore</span><br><span class="line">package-lock.json</span><br><span class="line">package.json</span><br><span class="line">README.md</span><br></pre></td></tr></table></figure><h4 id="public"><a href="#public" class="headerlink" title="public"></a>public</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public --- 静态资源文件夹</span><br><span class="line">favicon.ico --- 网站页签图标</span><br><span class="line">index.html  --- 主页面 &lt;--</span><br><span class="line">logo192.png --- logo 图</span><br><span class="line">logo512.png --- logo 图</span><br><span class="line">manifest.json --- 应用加壳的配置文件</span><br><span class="line">robots.txt  --- 爬虫协议文件</span><br></pre></td></tr></table></figure><p>其中最重要的就是 index.html 文件：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- %PUBLIC_URL% 代表 public 文件夹的路径 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/favicon.ico&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 开启理想视口，用于做移动端网页的适配 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用于配置浏览器页签+地址栏的颜色（仅支持安卓收集浏览器，但兼容性不好） --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;theme-color&quot;</span> <span class="attr">content</span>=<span class="string">&quot;#000000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 描述网站信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span></span></span><br><span class="line"><span class="tag">      <span class="attr">name</span>=<span class="string">&quot;description&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">content</span>=<span class="string">&quot;Web site created using create-react-app&quot;</span></span></span><br><span class="line"><span class="tag">    /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 用于指定网页添加到主屏幕的图标，兼容性一般 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/logo192.png&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 应用加壳时的配置文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;manifest&quot;</span> <span class="attr">href</span>=<span class="string">&quot;%PUBLIC_URL%/manifest.json&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React App<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 若浏览器不支持 js 则展示此标签中的内容 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">noscript</span>&gt;</span>You need to enable JavaScript to run this app.<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="src"><a href="#src" class="headerlink" title="src"></a>src</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">App.css --- App 组件的样式</span><br><span class="line">App.js --- App 组件 &lt;--</span><br><span class="line">App.test.js --- 用于给 App 做测试</span><br><span class="line">index.css --- 配置全局样式</span><br><span class="line">index.js --- 入口文件 &lt;--</span><br><span class="line">logo.svg --- logo 图</span><br><span class="line">reportWebVitals.js --- 页面性能分析文件(需要 web-vitals 库的支持)</span><br><span class="line">setupTests.js --- 组件单元测试的文件(需要 jest-dom 库的支持)</span><br></pre></td></tr></table></figure><h1 id="React-Ajax"><a href="#React-Ajax" class="headerlink" title="React Ajax"></a>React Ajax</h1><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><h3 id="前置说明"><a href="#前置说明" class="headerlink" title="前置说明"></a>前置说明</h3><ul><li>React 本身只关注界面，并不包含发送 ajax 请求的代码</li><li>前端需要通过 ajax 请求与后台进行交互(json 数据)</li><li>React 应用中需要集成第三方 ajax 库(或自己封装)</li></ul><h3 id="常用的-Ajax-库"><a href="#常用的-Ajax-库" class="headerlink" title="常用的 Ajax 库"></a>常用的 Ajax 库</h3><ol><li>jQuery：比较重，而且不推荐在 React 中使用操作真实 DOM 的 jQuery；</li><li>axios：轻量级，建议使用：<ol><li>封装 XmlHttpRequest 对象的 ajax</li><li>promise 风格</li><li>可以在浏览器端和 node 服务器端使用</li></ol></li></ol><h2 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h2><blockquote><p>官方文档：<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p></blockquote><p>具体在 axios 中了解</p><h2 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h2><p>方法一：</p><p>在 <code>package.json</code> 文件中加入 <code>proxy</code> 一项，值为代理的 url 地址，开启全局代理：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">&quot;proxy&quot;</span>: <span class="string">&quot;http://localhost:5000&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：比较局限，不能设置多个不同的代理</p><p>方法二：</p><p>在 src 下新建文件 <code>src/setupProxy.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; createProxyMiddleware &#125; = <span class="built_in">require</span>(<span class="string">&quot;http-proxy-middleware&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app</span>) </span>&#123;</span><br><span class="line">  app.use(</span><br><span class="line">    createProxyMiddleware(<span class="string">&quot;/api1&quot;</span>, &#123;</span><br><span class="line">      <span class="comment">// 遇见 /api1 前缀的请求，就会触发该代理配置</span></span><br><span class="line">      <span class="attr">target</span>: <span class="string">&quot;http://localhost:5000&quot;</span>, <span class="comment">// 请求转发给谁</span></span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>, <span class="comment">// 控制服务器收到的响应头中 Host 字段的值</span></span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api1&quot;</span>: <span class="string">&quot;&quot;</span> &#125;, <span class="comment">// 重写请求路径</span></span><br><span class="line">    &#125;),</span><br><span class="line">    createProxyMiddleware(<span class="string">&quot;/api2&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">target</span>: <span class="string">&quot;http://localhost:5001&quot;</span>,</span><br><span class="line">      <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">pathRewrite</span>: &#123; <span class="string">&quot;^/api2&quot;</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>底层会自动去找这个文件，不需要做其他配置，修改配置后需重启项目。</p></blockquote><h2 id="消息订阅-发布机制"><a href="#消息订阅-发布机制" class="headerlink" title="消息订阅-发布机制"></a>消息订阅-发布机制</h2><p>使用到第三方工具：<strong>PubSubJS</strong></p><ul><li>关注分离（Separation of Concerns）</li></ul><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm i pubsub-js</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">yarn add pubsub-js</span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul><li>在安装引入后，先订阅后发布</li><li>在 <code>componentWillunmount</code> 钩子函数中取消订阅</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">import</span> PubSub <span class="keyword">from</span> <span class="string">&#x27;pubsub-js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 订阅</span></span><br><span class="line">componentDidMount () &#123;</span><br><span class="line">  <span class="built_in">this</span>.token = PubSub.subscribe(<span class="string">&#x27;agonilay&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">_, data</span>) </span>&#123;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发布</span></span><br><span class="line">search = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  PubSub.publish(<span class="string">&#x27;agonilay&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;Agonilay&#x27;</span> &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">componentWillUnmount () &#123;</span><br><span class="line">  PubSub.unsubscribe(<span class="string">&#x27;agonilay&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Fetch"><a href="#Fetch" class="headerlink" title="Fetch"></a>Fetch</h2><blockquote><p>github 官方文档：<a href="https://github.github.io/fetch/">https://github.github.io/fetch/</a></p><p>思否文档：<a href="https://segmentfault.com/a/1190000003810652">https://segmentfault.com/a/1190000003810652</a></p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><ul><li>原生函数，不需要下载，不需要引入，直接即可使用；</li><li>不再使用 XmlHttpRequest 对象提交 ajax 请求</li><li>老版本浏览可能不支持，使用不多</li></ul><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">search = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  fetch(<span class="string">`http://localhost:3000/api/search/users2?q=<span class="subst">$&#123;keyword&#125;</span>`</span>)</span><br><span class="line">    .then(</span><br><span class="line">      <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;联系服务器成功了&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.json();</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;联系服务器失败了&quot;</span>, error);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    .then(</span><br><span class="line">      <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(res);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以使用 async/await 和 try/catch 进行代码优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">search = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> fetch(</span><br><span class="line">      <span class="string">`http://localhost:3000/api/search/users2?q=<span class="subst">$&#123;keyword&#125;</span>`</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">const</span> data = <span class="keyword">await</span> res.json();</span><br><span class="line">    PubSub.publish(<span class="string">&quot;agonilay&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">isLoading</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">users</span>: data.items,</span><br><span class="line">      <span class="attr">err</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    PubSub.publish(<span class="string">&quot;agonilay&quot;</span>, &#123; <span class="attr">isLoading</span>: <span class="literal">false</span>, <span class="attr">err</span>: error &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="React-路由"><a href="#React-路由" class="headerlink" title="React 路由"></a>React 路由</h1><h2 id="相关理解"><a href="#相关理解" class="headerlink" title="相关理解"></a>相关理解</h2><h3 id="SPA"><a href="#SPA" class="headerlink" title="SPA"></a>SPA</h3><ul><li>单页 Web 应用（single page web application，SPA）</li><li>整个应用只有一个完整的页面</li><li>点击页面中的链接不会刷新页面，只会做页面的局部更新</li><li>数据都需要通过 ajax 请求获取，并且在前端异步展现</li></ul><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>一个路由就是一个映射关系（key: value）</li><li>key 为路径，value 可能是 function 或 component</li></ol><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p><strong>前端路由</strong>：</p><ol><li>浏览器路由，value 是 component，用于展示页面内容</li><li>注册路由：<code>&lt;Route path=&quot;/test&quot; component=&#123;Test&#125; /&gt;</code></li><li>工作过程：当浏览器的 path 变为 /test 时，当前路由组件就会变成 Test 组件</li></ol><p><strong>后端路由</strong>：</p><ol><li>value 是 function，用来处理客户端提交的请求</li><li>注册路由：<code>router.get(&#39;/test&#39;, function (req, res) &#123;&#125;)</code></li><li>工作过程：当 node 接收到一个请求时，根据请求路径找到匹配的路由，调用路由中的函数来处理请求，返回响应数据</li></ol><h3 id="react-router-dom"><a href="#react-router-dom" class="headerlink" title="react-router-dom"></a>react-router-dom</h3><ol><li>React 的一个插件库</li><li>专门用来实现一个 SPA 应用</li><li>基于 React 的项目基本都会用到此库</li></ol><h2 id="基本路由使用"><a href="#基本路由使用" class="headerlink" title="基本路由使用"></a>基本路由使用</h2><p>下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i react-router-dom</span><br></pre></td></tr></table></figure><p>使用：</p><p><code>index.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; BrowserRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">BrowserRouter</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">BrowserRouter</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>在最外层包一个 <code>BrowserRouter</code> 或 <code>HashRouter</code>。</p><p><code>App.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; Link, Routes, Route &#125; <span class="keyword">from</span> <span class="string">&#x27;react-router-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;./components/Home&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;./components/About&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;list-group&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* 原生 html 中，靠 a 跳转不同的页面 */&#125;</span></span><br><span class="line"><span class="xml">        &#123;/* <span class="tag">&lt;<span class="name">a</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./about.html&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">              <span class="tag">&lt;<span class="name">a</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item active&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./home.html&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">a</span>&gt;</span> */&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">        &#123;/* 在 React 中靠路由链接实现切换组件 -- 编写路由链接 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">Link</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">className</span>=<span class="string">&quot;panel-body&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="xml">        &#123;/* react-router-dom 6以下 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* react-router-dom 最新版本 */&#125;</span></span><br><span class="line"><span class="xml">        &#123;/*</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">Home</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">        */&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组件和普通组件"><a href="#路由组件和普通组件" class="headerlink" title="路由组件和普通组件"></a>路由组件和普通组件</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>写法不同</p><ul><li>一般组件：<code>&lt;Demo /&gt;</code></li><li>路由组件：<code>&lt;Route path=&quot;/demo&quot; component=&#123;Demo&#125; /&gt;</code></li></ul><p>存放位置不同</p><ul><li>一般组件：components 文件夹下</li><li>路由组件：pages 文件夹下</li></ul><p>接收到的 props 不同</p><ul><li><p>一般组件：写组件时传递了什么，就能收到什么</p></li><li><p>路由组件：接收到三个固定的参数（5.x 版本以下）</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">history:</span></span><br><span class="line"><span class="attr">go:</span> <span class="string">f</span> <span class="string">go(n)</span></span><br><span class="line"><span class="attr">goBack:</span> <span class="string">f</span> <span class="string">goBack()</span></span><br><span class="line"><span class="attr">goForward:</span> <span class="string">f</span> <span class="string">goForward()</span></span><br><span class="line"><span class="attr">push:</span> <span class="string">f</span> <span class="string">push(path,</span> <span class="string">state)</span></span><br><span class="line"><span class="attr">replace:</span> <span class="string">f</span> <span class="string">replace(path,</span> <span class="string">state)</span></span><br><span class="line"><span class="attr">location:</span></span><br><span class="line"><span class="attr">pathname:</span> <span class="string">&quot;/about&quot;</span></span><br><span class="line"><span class="attr">search:</span> <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="attr">state:</span> <span class="string">undefined</span></span><br><span class="line"><span class="attr">match:</span></span><br><span class="line"><span class="attr">params:</span> &#123;&#125;</span><br><span class="line"><span class="attr">path:</span> <span class="string">&quot;/about&quot;</span></span><br><span class="line"><span class="attr">url:</span> <span class="string">&quot;/about&quot;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="NavLink"><a href="#NavLink" class="headerlink" title="NavLink"></a>NavLink</h2><ol><li>NavLink 可以实现路由链接的高亮，通过 <code>activeClassName</code> 指定类名，默认添加 <code>active</code> 类名</li><li>标签体内容也是一个特殊的标签属性 <code>this.props.children</code></li></ol><p>二次封装 NavLink 示例：</p><p><code>components/NavLink/index.jsx</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MyNavLink</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.props);</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">NavLink</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">activeClassName</span>=<span class="string">&quot;demo&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        <span class="attr">className</span>=<span class="string">&quot;list-group-item&quot;</span></span></span></span><br><span class="line"><span class="tag"><span class="xml">        &#123;<span class="attr">...this.props</span>&#125;</span></span></span><br><span class="line"><span class="tag"><span class="xml">      /&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>App.js</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>Home<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>About<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Switch"><a href="#Switch" class="headerlink" title="Switch"></a>Switch</h2><p>React 在匹配路由时会将所有匹配到的展示</p><p>但通常情况下，path 和 component 时一一对应关系，Switch 可以提高路由匹配的效率（单一匹配）：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="comment">/* 注册路由 */</span>&#125;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Test&#125;</span> /&gt;</span></span></span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>&lt;Switch&gt;</code> 包裹中的路由执行单一匹配，匹配成功就不会继续向下匹配。</p><blockquote><p>路由丢失问题，多级路由时刷新页面导致样式丢失</p><p>解决办法：</p><ol><li>资源请求路径使用绝对路径或者 <code>%PUBLIC_URL%</code>（常用）</li><li>使用 <code>HashRouter</code> 而不是 <code>BrowserRouter</code>（少见）</li></ol></blockquote><h2 id="Redirect"><a href="#Redirect" class="headerlink" title="Redirect"></a>Redirect</h2><p>一般将 <code>Redirect</code> 写在所有路由注册的最下方，当所有路由都无法匹配时，跳转到 <code>Redirect</code> 的 <code>to</code> 属性指定的路由：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &#123;<span class="comment">/* 注册路由 */</span>&#125;</span><br><span class="line">      &lt;Switch&gt;</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> /&gt;</span></span></span><br><span class="line">      &lt;/Switch&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由匹配"><a href="#路由匹配" class="headerlink" title="路由匹配"></a>路由匹配</h2><p>默认使用的是模糊匹配：【输入的路径】必须包含【匹配的路径】（顺序要一致，且在开头）</p><p>开启精准匹配（严格匹配）：</p><p><code>exact</code> 或者 <code>exact=&#123;true&#125;</code></p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span> <span class="attr">path</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">component</span>=<span class="string">&#123;About&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Route</span> <span class="attr">exact</span>=<span class="string">&#123;true&#125;</span> <span class="attr">path</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Home&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>严格匹配不要随便开启，需要的时候再开，否则会导致无法继续匹配二级路由。</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>注册子路由时父路由的 path 值仍需要写上，匹配顺序按注册路由的顺序来。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Home</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  render () &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">ul</span> <span class="attr">className</span>=<span class="string">&quot;nav nav-tabs&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>News<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">MyNavLink</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>Message<span class="tag">&lt;/<span class="name">MyNavLink</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">        &#123;/* 注册路由 */&#125;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/news&quot;</span> <span class="attr">component</span>=<span class="string">&#123;News&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/home/message&quot;</span> <span class="attr">component</span>=<span class="string">&#123;Message&#125;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Redirect</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Switch</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由组件传参"><a href="#路由组件传参" class="headerlink" title="路由组件传参"></a>路由组件传参</h2><h3 id="params-参数"><a href="#params-参数" class="headerlink" title="params 参数"></a>params 参数</h3><p>路由链接携带参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 向路由组件传递 params 参数 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Link to=&#123;<span class="string">`/home/message/detail/<span class="subst">$&#123;msgObj.id&#125;</span>/<span class="subst">$&#123;msgObj.title&#125;</span>`</span>&#125;&gt;</span><br><span class="line">  &#123;msgObj.title&#125;</span><br><span class="line">&lt;/Link&gt;;</span><br></pre></td></tr></table></figure><p>注册路由时声明接收：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 声明接收 params 参数 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Route path=<span class="string">&quot;/home/message/detail/:id/:title&quot;</span> component=&#123;Detail&#125; /&gt;;</span><br></pre></td></tr></table></figure><p>接收参数：</p><p><code>this.props.match.params</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收 params 参数</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="built_in">this</span>.props.match.params;</span><br></pre></td></tr></table></figure><h3 id="search-参数"><a href="#search-参数" class="headerlink" title="search 参数"></a>search 参数</h3><p>路由链接携带参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 向路由组件传递 search 参数 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Link to=&#123;<span class="string">`/home/message/detail/?id=<span class="subst">$&#123;msgObj.id&#125;</span>&amp;title=<span class="subst">$&#123;msgObj.title&#125;</span>`</span>&#125;&gt;</span><br><span class="line">  &#123;msgObj.title&#125;</span><br><span class="line">&lt;/Link&gt;;</span><br></pre></td></tr></table></figure><p>无需声明接收；</p><p>接收参数：</p><p><code>this.props.location.search</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装第三方库 query-string</span></span><br><span class="line">npm i query-string</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> qs <span class="keyword">from</span> <span class="string">&quot;query-string&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收 search 参数</span></span><br><span class="line"><span class="keyword">const</span> &#123; search &#125; = <span class="built_in">this</span>.props.location;</span><br><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = qs.parse(search.slice(<span class="number">1</span>));</span><br></pre></td></tr></table></figure><blockquote><p>注意：</p><p>接收到的 search 是 urlencoded 编码字符串，需要借助 <code>query-string</code> 解析，且需要先去除掉 search 中开头的 <code>?</code>。</p></blockquote><h3 id="state-参数"><a href="#state-参数" class="headerlink" title="state 参数"></a>state 参数</h3><p>路由链接携带参数：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">/* 向路由组件传递 search 参数 */</span></span><br><span class="line">&#125;</span><br><span class="line">&lt;Link</span><br><span class="line">  to=&#123;&#123;</span><br><span class="line">    <span class="attr">pathname</span>: <span class="string">&quot;/home/message/detail&quot;</span>,</span><br><span class="line">    <span class="attr">state</span>: &#123; <span class="attr">id</span>: msgObj.id, <span class="attr">title</span>: msgObj.title &#125;,</span><br><span class="line">  &#125;&#125;</span><br><span class="line">&gt;</span><br><span class="line">  &#123;msgObj.title&#125;</span><br><span class="line">&lt;/Link&gt;;</span><br></pre></td></tr></table></figure><blockquote><p>好处：不会在地址栏体现，刷新也不会丢失！</p></blockquote><p>无需声明接收；</p><p>接受参数：</p><p><code>this.props.location.state</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接收 state 参数</span></span><br><span class="line"><span class="keyword">const</span> &#123; id, title &#125; = <span class="built_in">this</span>.props.location.state || &#123;&#125;;</span><br></pre></td></tr></table></figure><h2 id="路由跳转"><a href="#路由跳转" class="headerlink" title="路由跳转"></a>路由跳转</h2><h3 id="push"><a href="#push" class="headerlink" title="push"></a>push</h3><p>默认的路由跳转模式，会留下痕迹</p><h3 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h3><p>替换，不会留下痕迹，添加 <code>replace</code> 参数开启 replace 模式</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Link replace to=<span class="string">&quot;/home/message/detail&quot;</span>&gt;</span><br><span class="line">  &#123;msgObj.title&#125;</span><br><span class="line">&lt;/Link&gt;</span><br></pre></td></tr></table></figure><h2 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h2><p>借助 <code>this.props.history</code> 对象上的 API 操作路由跳转、前进和后退。</p><ul><li><code>this.props.history.push(path, state)</code></li><li><code>this.props.history.replace(path, state)</code><ul><li>state 用于传递 state 参数</li></ul></li><li><code>this.props.history.goBack()</code>：后退</li><li><code>this.props.history.goForward()</code>：前进</li><li><code>this.props.history.go(n)</code>：<ul><li>n 为正整数：前进 n 步</li><li>n 为负整数：后退 n 步</li><li>n 为 0：刷新页面</li></ul></li></ul><h2 id="withRouter"><a href="#withRouter" class="headerlink" title="withRouter()"></a>withRouter()</h2><p><code>withRouter()</code> 可以加工一般组件，让一般组件具备路由组件所特有的 API，返回值是加工后的新组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; withRouter &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Header</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> withRouter(Header);</span><br></pre></td></tr></table></figure><h2 id="BrowserRouter-和-HashRouter"><a href="#BrowserRouter-和-HashRouter" class="headerlink" title="BrowserRouter 和 HashRouter"></a>BrowserRouter 和 HashRouter</h2><p>底层原理不一样：</p><ul><li>BrowserRouter 使用的是 H5 的 history API，不兼容 IE9 以下版本</li><li>HashRouter 使用的是 URL 的哈希值</li></ul><p>url 的表现形式不一样：</p><ul><li>BrowserRouter 的路径中没有 <code>#</code></li><li>HashRouter 的路径中包含 <code>#</code>，不美观</li></ul><p>刷新后对路由 state 参数的影响：</p><ul><li>BrowserRouter 没有任何影响，应为 state 保存在 history 对象中</li><li>HashRouter 刷新后会导致路由 state 参数的丢失</li></ul><blockquote><p>HashRouter 可以用于解决一些路径错误相关的问题。</p></blockquote><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><p>通过 React 的 lazy 函数配合 <code>import()</code> 函数动态加载路由组件。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Component, lazy, Suspense &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; Routes, Route, NavLink &#125; <span class="keyword">from</span> <span class="string">&quot;react-router-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Loading <span class="keyword">from</span> <span class="string">&quot;./Loading&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> Home = lazy(<span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&quot;./Home&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">render</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">Suspense</span> <span class="attr">fallback</span>=<span class="string">&#123;</span>&lt;<span class="attr">Loading</span> /&gt;</span>&#125;&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">          <span class="tag">&lt;<span class="name">Route</span> <span class="attr">path</span>=<span class="string">&quot;/Home&quot;</span> <span class="attr">element</span>=<span class="string">&#123;</span>&lt;<span class="attr">About</span> /&gt;</span>&#125; /&gt;</span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">Routes</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">Suspense</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="React-UI-组件库"><a href="#React-UI-组件库" class="headerlink" title="React UI 组件库"></a>React UI 组件库</h1><h2 id="流行的开源-React-UI-组件库"><a href="#流行的开源-React-UI-组件库" class="headerlink" title="流行的开源 React UI 组件库"></a>流行的开源 React UI 组件库</h2><h3 id="material-ui-国外"><a href="#material-ui-国外" class="headerlink" title="material-ui(国外)"></a>material-ui(国外)</h3><p>官网：<a href="http://www.material-ui.com/#/">http://www.material-ui.com/#/</a></p><p>GitHub：<a href="https://github.com/callemall/material-ui">https://github.com/callemall/material-ui</a></p><h3 id="ant-design"><a href="#ant-design" class="headerlink" title="ant-design"></a>ant-design</h3><p>蚂蚁金服团队创作</p><p>官网：<a href="https://ant.design/index-cn">https://ant.design/index-cn</a></p><p>GitHub：<a href="https://github.com/ant-design/ant-design/">https://github.com/ant-design/ant-design/</a></p><h1 id="Redux"><a href="#Redux" class="headerlink" title="Redux"></a>Redux</h1><h2 id="理解-1"><a href="#理解-1" class="headerlink" title="理解"></a>理解</h2><p>英文文档：<a href="https://redux.js.org/">https://redux.js.org/</a></p><p>英文文档：<a href="http://cn.redux.js.org//">http://cn.redux.js.org//</a></p><h3 id="redux-是什么"><a href="#redux-是什么" class="headerlink" title="redux 是什么"></a>redux 是什么</h3><ol><li>redux 是一个专门用于做 <strong>状态管理</strong> 的 JS 库（不是 react 插件库）</li><li>可以用在 react、angular、vue 等项目中，但与 react 配合使用比较多</li><li>作用：集中式管理 react 应用中多个组件共享的状态</li></ol><h3 id="什么情况使用"><a href="#什么情况使用" class="headerlink" title="什么情况使用"></a>什么情况使用</h3><ol><li>某个组件的状态需要让其他组件可以随时拿到（共享）</li><li>一个组件需要改变另一个组件的状态（通信）</li><li>总体原则：能不用就不用，如果不用比较吃力才考虑使用</li></ol><h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><img src="/2021/11/26/React/image-20220120165311829.png" class title="React 工作原理图"><h2 id="三个核心概念"><a href="#三个核心概念" class="headerlink" title="三个核心概念"></a>三个核心概念</h2><h3 id="action"><a href="#action" class="headerlink" title="action"></a>action</h3><p>表示动作的对象，包含两个属性：</p><ul><li><code>type</code>：标识属性，值为字符串类型，唯一，必要属性</li><li><code>data</code>：数据属性，值类型任意，可选属性</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例子</span></span><br><span class="line">&#123; <span class="attr">type</span>: <span class="string">&#x27;ADD_STUDENT&#x27;</span>, <span class="attr">data</span>: &#123; <span class="attr">name</span>: <span class="string">&#x27;AgoniLay&#x27;</span>, <span class="attr">age</span>: <span class="number">20</span> &#125; &#125;</span><br></pre></td></tr></table></figure><h3 id="reducer"><a href="#reducer" class="headerlink" title="reducer"></a>reducer</h3><p>用于初始化状态、加工状态（加工状态时，根据旧的 state 和 action，产生新的 state 的<strong>纯函数</strong>）</p><h3 id="store"><a href="#store" class="headerlink" title="store"></a>store</h3><p>状态仓库，将 state、action、reducer 联系在一起的对象</p><p>得到方式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">&quot;./reducers&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(reducer);</span><br></pre></td></tr></table></figure><p>功能：</p><ol><li><code>getStaste()</code>：得到 state</li><li><code>dispatch(action)</code>：分发 action，触发 reducer 调用，产生新的 state</li><li><code>subscribe(listener)</code>：注册监听，当产生了新的 state 时，自动调用</li></ol><h2 id="核心-API"><a href="#核心-API" class="headerlink" title="核心 API"></a>核心 API</h2><h3 id="createState"><a href="#createState" class="headerlink" title="createState()"></a>createState()</h3><p>作用：创建包含指定 reducer 的 store 对象。</p><h3 id="applyMiddleware"><a href="#applyMiddleware" class="headerlink" title="applyMiddleware()"></a>applyMiddleware()</h3><p>作用：应用上基于 redux 的中间件（插件库）</p><h3 id="combineReducers"><a href="#combineReducers" class="headerlink" title="combineReducers()"></a>combineReducers()</h3><p>作用：合并多个 reducer 函数</p><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>在 src 下建立：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">src</span><br><span class="line">- redux</span><br><span class="line">- store.js</span><br><span class="line">- count_reducer.js</span><br><span class="line">- count_action.js</span><br><span class="line">- constant.js</span><br></pre></td></tr></table></figure><p><code>store.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 createStore，专门用于创建 redux 中最核心的 store 对象</span></span><br><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="comment">// 引入为 count 组件服务的 reducer</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./count_reducer&quot;</span>;</span><br><span class="line"><span class="comment">// 暴露 store</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(counterReducer);</span><br></pre></td></tr></table></figure><p><code>count_reducer.js</code>：</p><ol><li>本质是一个函数，接收 preState、action，返回加工后的状态</li><li>作用：初始化状态、加工状态</li><li>首次调用是 state 自动触发，传递的 preState 是 undefined</li></ol><p>在 index.js 中检测 store 中状态的改变，一旦发生改变重新渲染 <code>&lt;App /&gt;</code>：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">&quot;react-dom&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">&quot;./redux/store&quot;</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line"></span><br><span class="line">store.subscribe(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>redux 只负责管理状态，至于状态的改变驱动页面数据的更新，需要自己定义。</p></blockquote><p><code>count_action.js</code>：</p><p>用于定义直接返回 action 对象的方法</p><p><code>constant.js</code>：</p><p>用于定义 action 对象的中 type 类型的常量值</p><p>目的：便于管理的同时防止程序员单词写错</p><h2 id="redux-异步编程"><a href="#redux-异步编程" class="headerlink" title="redux 异步编程"></a>redux 异步编程</h2><ol><li>redux 默认是不能进行异步处理的</li><li>应用中需要在 redux 中执行异步任务（ajax、定时器）</li></ol><p>此时就需要引入异步中间件：<code>redux-thunk</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install --save redux-thunk</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">yarn add redux-thunk</span><br></pre></td></tr></table></figure><p>在 <code>store.js</code> 中导入使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore, applyMiddleware &#125; <span class="keyword">from</span> <span class="string">&quot;redux&quot;</span>;</span><br><span class="line"><span class="comment">// 引入为 count 组件服务的 reducer</span></span><br><span class="line"><span class="keyword">import</span> counterReducer <span class="keyword">from</span> <span class="string">&quot;./count_reducer&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> thunk <span class="keyword">from</span> <span class="string">&quot;redux-thunk&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> createStore(counterReducer, applyMiddleware(thunk));</span><br></pre></td></tr></table></figure><p>创建 action 的函数不再返回一般对象，而是一个函数，该函数中写异步任务，异步任务结束后分发一个同步的 action 去真正操作数据</p><blockquote><p>异步 action 不是必须要写的，可以自己等待异步任务之后再进行分发同步任务。</p></blockquote><h2 id="react-redux"><a href="#react-redux" class="headerlink" title="react-redux"></a>react-redux</h2><p>react-redux 是 react 的一个插件库，专门用来简化 react 应用中使用 redux。</p><h3 id="UI-组件和容器组件"><a href="#UI-组件和容器组件" class="headerlink" title="UI 组件和容器组件"></a>UI 组件和容器组件</h3><p>UI 组件：</p><ol><li>只负责 UI 的呈现，不带有任何业务逻辑</li><li>通过 props 接收数据（一般数据和函数）</li><li>不使用任何 redux 的 API</li><li>一般保存在 <code>components</code> 文件夹下</li></ol><p>容器组件：</p><ol><li>负责管理数据和业务逻辑，不负责 UI 的呈现</li><li>使用 redux 的 API</li><li>一般保存在 <code>containers</code> 文件夹下</li></ol><h3 id="相关-API"><a href="#相关-API" class="headerlink" title="相关 API"></a>相关 API</h3><h4 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a>Provider</h4><p>自动给所有容器组件传递 store：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;Provider store=&#123;store&#125;&gt;</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span></span></span><br><span class="line">&lt;/Provider&gt;</span><br></pre></td></tr></table></figure><h4 id="connect"><a href="#connect" class="headerlink" title="connect"></a>connect</h4><p>包装 UI 组件生成 容器组件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; connect &#125; <span class="keyword">from</span> <span class="string">&quot;react-redux&quot;</span>;</span><br><span class="line"></span><br><span class="line">connect(mapStateToprops, mapDispatchToprops)(Counter);</span><br></pre></td></tr></table></figure><p><code>mapStateToprops</code> 和 <code>mapDispatchToprops</code> 是两个函数，分别用于传递状态和操作状态的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认接收 state 参数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapStateToprops</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">count</span>: state,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认接收 dispatch 方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mapDispatchToprops</span>(<span class="params">dispatch</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">(<span class="params">number</span>) =&gt;</span> dispatch(createIncrementAction(number)),</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">(<span class="params">number</span>) =&gt;</span> dispatch(createDecrementAction(number)),</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">connect(</span><br><span class="line">  <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state &#125;),</span><br><span class="line">  <span class="function">(<span class="params">dispatch</span>) =&gt;</span> (&#123;</span><br><span class="line">    <span class="attr">increment</span>: <span class="function">(<span class="params">number</span>) =&gt;</span> dispatch(createIncrementAction(number)),</span><br><span class="line">    <span class="attr">decrement</span>: <span class="function">(<span class="params">number</span>) =&gt;</span> dispatch(createDecrementAction(number)),</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>第二个参数还可以接收一个对象，进行简写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect(<span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">count</span>: state &#125;), &#123;</span><br><span class="line">  <span class="attr">increment</span>: createIncrementAction,</span><br><span class="line">  <span class="attr">decrement</span>: createDecrementAction,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>底层会自动进行 dispatch 的操作。</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>容器组件和 UI 组件一般整合成为一个文件</li><li>无需自己给容器组件传递 store，给 <code>&lt;App /&gt;</code> 包裹一个 <code>&lt;Provider store=&#123;store&#125;&gt;&lt;/Provider&gt;</code> 即可</li><li>使用了 react-redux 之后无需自己检测 redux 中状态的改变，容器组件会自动完成该工作</li><li>connect 的第二个参数 <code>mapDispatchToprops</code> 可以简写为一个对象</li><li>reducers 文件夹中编写 <code>index.js</code> 专门用于汇总并暴露所有的 reducer</li></ol><h3 id="创建组件步骤"><a href="#创建组件步骤" class="headerlink" title="创建组件步骤"></a>创建组件步骤</h3><ol><li><p>在 <code>containers</code> 下新建组件文件夹下文件 <code>index.jsx</code></p></li><li><p>定义好 UI 组件，不暴露</p></li><li><p>引入 connect 生成一个容器组件，并暴露</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">connect(</span><br><span class="line">  <span class="function">(<span class="params">state</span>) =&gt;</span> (&#123; <span class="attr">key</span>: value &#125;), <span class="comment">// 映射状态</span></span><br><span class="line">  &#123; <span class="attr">key</span>: xxxAction &#125; <span class="comment">// 映射操作状态的方法</span></span><br><span class="line">)(UI组件);</span><br></pre></td></tr></table></figure></li><li><p>在 UI 组件中通过 <code>this.props.xxx</code> 读取和操作状态</p></li></ol><h3 id="数据共享"><a href="#数据共享" class="headerlink" title="数据共享"></a>数据共享</h3><p>不同组件的 reducer 要使用 <code>combineReducers</code> 进行合并，合并为一个对象，此时组件中获取到的 store 是总的 reducer。</p><h3 id="纯函数和高阶函数"><a href="#纯函数和高阶函数" class="headerlink" title="纯函数和高阶函数"></a>纯函数和高阶函数</h3><h4 id="纯函数"><a href="#纯函数" class="headerlink" title="纯函数"></a>纯函数</h4><p>只要是同样的输入（实参），必定得到同样的输出（返回）</p><p>纯函数必须遵守：</p><ol><li>不得改写参数数据</li><li>不会产生任何副作用：网络请求，输入和输出设备</li><li>不能调用 <code>Date.now()</code> 或者 <code>Math.random()</code> 等不纯的方法</li></ol><blockquote><p>redux 的 reducer 函数必须是一个纯函数</p></blockquote><h4 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h4><p>参数是函数或者返回是函数的函数</p><p>常见的高阶函数：</p><ol><li>定时器设置函数</li><li>数组的 forEach() / map() / filter() / reduce() / find() / bind()</li><li>promise</li><li>react-redux 中的 connect 函数</li></ol><p>作用：能实现更加动态，更加可扩展的功能。</p><h2 id="开发者工具-1"><a href="#开发者工具-1" class="headerlink" title="开发者工具"></a>开发者工具</h2><p>redux-devtools — chrome 浏览器插件</p><p>在项目中安装依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install redux-devtools-extension</span><br></pre></td></tr></table></figure><p>在 store 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; composeWithDevtools &#125; <span class="keyword">from</span> <span class="string">&quot;redux-devtools-extension&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = createStore(</span><br><span class="line">  allReducer,</span><br><span class="line">  composeWithDevtools(applyWiddleware(thunk))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>之后即可在浏览器开发者工具中的 redux 选项卡进行操作。</p><h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="模拟服务器"><a href="#模拟服务器" class="headerlink" title="模拟服务器"></a>模拟服务器</h2><p>使用第三方包 serve 快速生成服务器部署项目：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g serve</span><br></pre></td></tr></table></figure><p>在终端输入：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">serve 文件夹名</span><br></pre></td></tr></table></figure><p>即可快速开启服务器。</p><blockquote><p>本文件夹为根目录则无需输入文件夹名，<code>serve</code> 即可</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> 前端框架 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS模块化</title>
      <link href="/2021/11/11/JS%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
      <url>/2021/11/11/JS%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h1><p>进化路线：</p><p>全局 function 模式 –&gt; namespace 模式 –&gt; IIFE 模式（匿名函数自调用，闭包） –&gt; IIFE 增强：引入依赖</p><p>好处：</p><ol><li>避免命名冲突（减少命名空间污染）</li><li>更好的分离，按需加载</li><li>更高复用性</li><li>高可维护性</li></ol><p>问题：</p><ol><li>请求过多</li><li>依赖模糊</li><li>难以维护</li></ol><h1 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h1><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><p>说明：</p><ul><li><a href="http://wiki.commonjs.org/wiki/Modules/1.1">http://wiki.commonjs.org/wiki/Modules/1.1</a></li><li>每个文件都可当作一个模块</li><li>在服务器端：模块的加载时运行时同步加载的</li><li>在浏览器端：模块需要提前编译打包处理</li></ul><p>基本语法：</p><p>暴露模块</p><ul><li>module.exports = value</li><li>exports.xxx = value</li><li>暴露的本质：都是 exports 这个对象</li></ul><p>引入模块</p><ul><li>require(xxx)<ul><li>第三方模块：xxx 为模块名</li><li>自定义模块：xxx 为模块文件路径</li></ul></li></ul><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>使用 browserify 工具打包</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install browser -g // 全局安装</span><br><span class="line">npm install browser -D // 项目内开发安装</span><br></pre></td></tr></table></figure><p>生成时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">browserify 需要打包的文件名 -o 要输出的地址</span><br></pre></td></tr></table></figure><h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><h3 id="规范-1"><a href="#规范-1" class="headerlink" title="规范"></a>规范</h3><p>说明：</p><ul><li>Asynchronous Module Definition 异步模式定义</li><li>专门用于浏览器端</li><li>模块的加载是异步的</li></ul><p>基本语法：</p><p>暴露模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([<span class="string">&quot;module1&quot;</span>, <span class="string">&quot;module2&quot;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引入模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置路径映射</span></span><br><span class="line">requirejs.config(&#123;</span><br><span class="line">  <span class="attr">baseUrl</span>: <span class="string">&#x27;js/&#x27;</span>, <span class="comment">// 基本的路径 出发点根目录下</span></span><br><span class="line">  <span class="attr">paths</span>: &#123; <span class="comment">// 配置路径</span></span><br><span class="line">    <span class="attr">dataService</span>: <span class="string">&#x27;./modules/dataService&#x27;</span>, <span class="comment">// 默认会在末尾加 .js 所以这里不能加</span></span><br><span class="line">    <span class="attr">alerter</span>: <span class="string">&#x27;./modules/alerter&#x27;</span>,</span><br><span class="line">    <span class="attr">jquery</span>: <span class="string">&#x27;./libs/jquery.min&#x27;</span>,</span><br><span class="line">    <span class="attr">angular</span>: <span class="string">&#x27;./libs/angular&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">shim</span>: &#123;</span><br><span class="line">    <span class="attr">angular</span>: &#123;</span><br><span class="line">      <span class="attr">exports</span>: <span class="string">&#x27;angular&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">require</span>([<span class="string">&#x27;alerter&#x27;</span>, <span class="string">&#x27;anguler&#x27;</span>], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  使用 m1/m2</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">data-main</span>=<span class="string">&quot;./js/main.js&quot;</span> <span class="attr">src</span>=<span class="string">&quot;js/libs/requirejs.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="实现（浏览器端）"><a href="#实现（浏览器端）" class="headerlink" title="实现（浏览器端）"></a>实现（浏览器端）</h3><ul><li>Require.js （<a href="http://www.requirejs.org)/">http://www.requirejs.org）</a></li><li><a href="http://www.ruanyifeng.com/blog/2012/11/require_js.html">http://www.ruanyifeng.com/blog/2012/11/require_js.html</a></li></ul><blockquote><p>注意：</p><ul><li>jQuery 支持 AMD，但引入时必须使用 jquery （小写）；</li><li>augular 需要额外在 shim 中定义</li></ul></blockquote><h2 id="CMD-了解"><a href="#CMD-了解" class="headerlink" title="CMD(了解)"></a>CMD(了解)</h2><h3 id="规范-2"><a href="#规范-2" class="headerlink" title="规范"></a>规范</h3><p>说明：</p><ul><li>Common Module Definition 通用模块定义</li><li>专门用于浏览器端</li><li>模块的加载是异步的</li><li>模块使用时才会加载执行</li></ul><p>基本语法：</p><p>暴露模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引入依赖模块（同步）</span></span><br><span class="line">  <span class="keyword">var</span> module1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="comment">// 引入依赖模块（异步）</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>.async(<span class="string">&quot;./module2&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m2</span>) </span>&#123;&#125;);</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>引入模块：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&quot;./module1&quot;</span>);</span><br><span class="line">  <span class="keyword">var</span> m2 = <span class="built_in">require</span>(<span class="string">&quot;./module2&quot;</span>);</span><br><span class="line">  m1.show();</span><br><span class="line">  m2.show();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h3><ul><li>sea.js （<a href="http://www.zhangxinxu.com/sp/seajs/%EF%BC%89">http://www.zhangxinxu.com/sp/seajs/）</a></li></ul><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><h3 id="规范-3"><a href="#规范-3" class="headerlink" title="规范"></a>规范</h3><p>说明：</p><ul><li><a href="http://www.ruanyifeng.com/#docs/module">http://www.ruanyifeng.com/#docs/module</a></li><li>依赖模块需要编译打包处理</li></ul><p>语法：</p><p>暴露模块：</p><ul><li>export</li><li>export default （默认暴露）</li></ul><p>引入模块：import</p><h3 id="实现（浏览器端）-1"><a href="#实现（浏览器端）-1" class="headerlink" title="实现（浏览器端）"></a>实现（浏览器端）</h3><p>babel，browserify</p><p>安装 babel-cli，babel-preset-es2015 和 browserify</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-cli browserify -g</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-preset-es2015 --save-dev</span><br></pre></td></tr></table></figure><blockquote><p>cli：command line interface</p></blockquote><p>根目录下添加配置文件 .babelrc ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;es2015&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel js/src -d js/lib</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 模块化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS 黑马笔记</title>
      <link href="/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/"/>
      <url>/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<h1 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h1><h2 id="Node-js-介绍"><a href="#Node-js-介绍" class="headerlink" title="Node.js 介绍"></a>Node.js 介绍</h2><p>node 作者：Ryan Dahl</p><h3 id="为什么要学习-Node-js"><a href="#为什么要学习-Node-js" class="headerlink" title="为什么要学习 Node.js"></a>为什么要学习 Node.js</h3><p>企业需求</p><ul><li>具有服务端开发经验</li><li>front-end 前端</li><li>back-end 后端</li><li>全栈开发工程师<ul><li>全干</li></ul></li><li>基本的网站开发能力<ul><li>服务端</li><li>前端</li><li>运维部署</li></ul></li><li>多人社区</li></ul><h3 id="Node-js-是什么"><a href="#Node-js-是什么" class="headerlink" title="Node.js 是什么"></a>Node.js 是什么</h3><ul><li>==Node.js® is a JavaScript runtime built on <a href="https://v8.dev/">Chrome’s V8 JavaScript engine</a>.==<ul><li>Node.js 不是一门语言</li><li>Node.js 不是库、不是框架</li><li><strong>Node.js 是一个基于 Chorme V8 引擎的 JavaScript 运行时环境</strong></li><li>简单来说，Node.js 可以解析和执行 JavaScript 代码</li><li>以前只有浏览器可以解析执行 JavaScript 代码</li><li>现在的 JavaScript 可以完全脱离浏览器来运行，一切都归功于：Node.js</li></ul></li><li>浏览器中的 JavaScript：<ul><li>ECMAScript<ul><li>基本的语法：if、var、function、Object、Array…</li></ul></li><li>BOM</li><li>DOM</li></ul></li><li>Node.js 中的 JavaScript：<ul><li><strong>没有 BOM 、DOM</strong></li><li>在 Node.js 执行环境中为 JavaScript 提供了一些服务器级别的操作 API<ul><li>文件的读写</li><li>网络服务的构建</li><li>网络通信</li><li>http 服务器 等处理…</li></ul></li></ul></li><li>构建于 Chrome 的 V8 引擎之上<ul><li>代码只是具有特定格式的字符串而已</li><li>引擎可以认识它，引擎可以帮你去解释和执行</li><li>Google Chorme 的 V8 引擎是目前公认解析执行 JavaScript 代码最快最高效的</li><li>Node.js 的作者把 Google Chorme 中的 V8 引擎移植了出来，开发了一个独立的 JavaScript 运行时环境</li></ul></li><li>==Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.==<ul><li>event-driven 事件驱动</li><li>non-blocking I/O model 非阻塞 IO 模型（异步）</li><li>lightweight and efficient 轻量和高效</li></ul></li><li>==Node.js‘ package ecosystem, npm, is the largest ecosystem of open source libraries in the world.==<ul><li>npm 是世界上最大的开源库生态系统</li><li>绝大多数 JavaScript 相关的包都存放在了 npm 上，这样做的目的是为了开发人员更方便的去下载使用<br><code>npm install jquery</code></li></ul></li></ul><h3 id="Node-js-能做什么"><a href="#Node-js-能做什么" class="headerlink" title="Node.js 能做什么"></a>Node.js 能做什么</h3><ul><li>Web 服务器后台</li><li>命令行工具<ul><li>如：npm(node)、git(c 语言)、hexo(node) …</li></ul></li><li>对于前端开发工程师来将，接触 node 最多的是它的命令行工具<ul><li>webpack、gulp、npm…</li></ul></li></ul><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><ul><li>HTML</li><li>CSS</li><li>JavaScript</li><li>简单的命令行操作</li><li>具有服务端开发经验更佳</li></ul><h3 id="一些资源"><a href="#一些资源" class="headerlink" title="一些资源"></a>一些资源</h3><ul><li>《深入浅出 Node.js》<ul><li>朴灵，偏理论，理解原理底层</li></ul></li><li>《Node.js 权威指南》<ul><li>API 讲解</li></ul></li><li>JavaScript 标准参考教程：<a href="http://javascript.ruanyifeng.com/">http://javascript.ruanyifeng.com</a></li><li>Node 入门：<a href="http://www.nodebeginner.org/index-zh-cn.html">http://www.nodebeginner.org/index-zh-cn.html</a></li><li>官方 API 文档：<a href="https://nodejs.org/dist/latest-v6.x/docs/api">https://nodejs.org/dist/latest-v6.x/docs/api</a></li><li>CNode：<a href="http://cnodejs.org/">http://cnodejs.org</a></li></ul><h3 id="这门课程你能学到啥？"><a href="#这门课程你能学到啥？" class="headerlink" title="这门课程你能学到啥？"></a>这门课程你能学到啥？</h3><ul><li>B/S 编程模型<ul><li>Browser - Server</li><li>back-end</li><li>任何服务器端技术这种 BS 编程模型都是一样，和语言无关</li><li>Node 只是作为我们学习 BS 编程模型的一个工具而已</li></ul></li><li>模块化编程<ul><li>RequireJS</li><li>SeaJS</li></ul></li><li>Node 常用 API</li><li>异步编程<ul><li>回调函数、Promise、async、generator …</li></ul></li><li>Express Web 开发框架</li><li>ECMAScript 6</li></ul><h2 id="起步"><a href="#起步" class="headerlink" title="起步"></a>起步</h2><h3 id="安装-Node-环境"><a href="#安装-Node-环境" class="headerlink" title="安装 Node 环境"></a>安装 Node 环境</h3><ul><li><p>查看当前 Node 环境的版本号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node --version</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure></li><li><p>下载：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p></li><li><p>安装：</p><ul><li>傻瓜式的一路 <code>next</code> 就 OK</li><li>对于已经安装过的，安装新版会直接覆盖</li></ul></li><li><p>环境变量</p></li></ul><h3 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h3><h4 id="解析执行-JavaScript"><a href="#解析执行-JavaScript" class="headerlink" title="解析执行 JavaScript"></a>解析执行 JavaScript</h4><ol><li>创建编写 JavaScript 脚本文件</li><li>打开终端，定位到脚本文件所属目录</li><li>输入 <code>node 文件名</code> 执行对应文件</li></ol><h4 id="文件读写"><a href="#文件读写" class="headerlink" title="文件读写"></a>文件读写</h4><p>文件读取：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器中的 JavaScript 是没有文件操作的能力的</span></span><br><span class="line"><span class="comment">// 但是 Node 中的 JavaScript 具有文件操作的能力</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// fs 是 file-system 的简写,就是文件系统的意思</span></span><br><span class="line"><span class="comment">// 在 Node 中如果想要进行文件操作，就必须引入 fs 这个核心模块</span></span><br><span class="line"><span class="comment">// 在 fs 这个核心模块中，就提供了所有的文件操作相关的 API</span></span><br><span class="line"><span class="comment">// 例如：fs.readFile 就是用来读取文件的</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 使用 require 方法加载 fs 核心模块</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 读取文件</span></span><br><span class="line"><span class="comment">//    第一个参数就是要读取的文件路径</span></span><br><span class="line"><span class="comment">//    第二个参数是一个回调函数</span></span><br><span class="line"><span class="comment">//      成功</span></span><br><span class="line"><span class="comment">//        data 数据</span></span><br><span class="line"><span class="comment">//        error null</span></span><br><span class="line"><span class="comment">//      失败</span></span><br><span class="line"><span class="comment">//        data undefined 没有数据</span></span><br><span class="line"><span class="comment">//        error 错误对象</span></span><br><span class="line">fs.readFile(<span class="string">&quot;./data/hello.txt&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">error, data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// &lt;Buffer e9 83 91 e4 bd b3 e4 b8 bd e7 8c aa e5 a4 b4&gt;</span></span><br><span class="line">  <span class="comment">// 文件中存储的其实都是二进制数据 0 1</span></span><br><span class="line">  <span class="comment">// 这里看到的不是 0 和 1 是因为转为了 16 进制</span></span><br><span class="line">  <span class="comment">// 可以使用 toString() 方法转为我们认识的字符</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 在这里就可以通过判断 error 来确认是否有错误发生</span></span><br><span class="line">  <span class="keyword">if</span> (error) &#123;</span><br><span class="line">    <span class="comment">// console.log(error)</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取文件失败了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>文件写入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一个参数：文件路径</span></span><br><span class="line"><span class="comment">// 第二个参数：文件内容</span></span><br><span class="line"><span class="comment">// 第三个参数：回调函数</span></span><br><span class="line"><span class="comment">//    文件写入成功： error 是 null</span></span><br><span class="line"><span class="comment">//    文件写入失败： error 就是错误对象</span></span><br><span class="line">fs.writeFile(</span><br><span class="line">  <span class="string">&quot;./data/hello.md&quot;</span>,</span><br><span class="line">  <span class="string">&quot;Hello everyone, I am AgoniLay.&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;写入失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;写入成功&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h4 id="http"><a href="#http" class="headerlink" title="http"></a>http</h4><p>最简单的 http 服务：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 加载 http 核心模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 使用 http.createServer() 方法创建一个 Web 服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 注册 request 请求事件</span></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;收到客户端的请求了&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 绑定端口号，启动服务器</span></span><br><span class="line">server.listen(<span class="number">3000</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务器启动成功了，可以通过 http://127.0.0.1:3000/ 来访问&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><img src="/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/image-20211021173440069.png" class title="image-20211021173440069"><h2 id="Node-中的-JavaScript"><a href="#Node-中的-JavaScript" class="headerlink" title="Node 中的 JavaScript"></a>Node 中的 JavaScript</h2><h3 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h3><ul><li>没有 DOM、BOM</li></ul><h3 id="核心模块"><a href="#核心模块" class="headerlink" title="核心模块"></a>核心模块</h3><p>核心模块是由 Node 提供的一个个的具名的模块。它们都有自己特殊的名称表示。</p><p>Node 为 JavaScript 提供了很多服务器级别的 API，这些 API 绝大多数都被包装到了一个具名的核心模块中了，例如：</p><ul><li>fs：文件操作模块</li><li>http：网络服务构建模块</li><li>os：操作系统信息模块</li><li>path：路径处理模块</li><li>url：url 地址模块</li></ul><p>若要使用则需要：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>在 Node 中没有全局作用域的概念，而是模块作用域。</p><p>在 Node 中，只能通过 require 方法来加载执行多个 JavaScript 脚本文件</p><p>require 加载只能是执行其中的代码，文件与文件之间由于是模块作用域，所以不会有污染的问题</p><ul><li>外部访问不到内部</li><li>内部也访问不到外部</li><li>默认都是封闭的</li></ul><p>require 方法有两个作用：</p><ol><li>加载文件模块，并执行里面的代码</li><li>拿到被加载文件模块导出的接口对象</li></ol><p>每个文件模块中都提供了一个对象 exports，exports 默认是一个空对象，需要做的是将所有需要被外部访问的成员</p><h2 id="Web-服务器开发"><a href="#Web-服务器开发" class="headerlink" title="Web 服务器开发"></a>Web 服务器开发</h2><h3 id="ip-地址和端口号"><a href="#ip-地址和端口号" class="headerlink" title="ip 地址和端口号"></a>ip 地址和端口号</h3><ul><li>IP 地址用来定位计算机</li><li>端口号用来定位具体的应用程序</li><li>所有需要联网通信的应用程序都会占用一个端口号</li><li>端口号的范围从 0 - 65536 之间</li><li>在计算机中有一些默认端口号，最好不要去使用<ul><li>例如 http 服务的 80</li></ul></li><li>可以同时给 hi 开启多个服务，但一定要确保不同服务占用的端口号不一致才可以</li></ul><h3 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a>Content-Type</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resquest.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html; charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li>不同的资源对应的 Content-Type 是不一样的，具体参照：<a href="https://tool.oschina.net/commons">https://tool.oschina.net/commons</a></li><li>图片不需要指定编码（charset）</li><li>一般为字符数据才指定编码</li></ul><h4 id="客户端渲染和客户端渲染"><a href="#客户端渲染和客户端渲染" class="headerlink" title="客户端渲染和客户端渲染"></a>客户端渲染和客户端渲染</h4><ul><li>客户端渲染不利于 SEO 搜索引擎优化</li><li>服务端渲染可以被爬虫抓取到的，客户端异步渲染是很难被爬虫抓取到的</li></ul><h3 id="301-和-302-重定向"><a href="#301-和-302-重定向" class="headerlink" title="301 和 302 重定向"></a>301 和 302 重定向</h3><p>3xx 开头的状态码为重定向</p><ul><li>301 永久重定向，浏览器会记住</li><li>302 临时重定向</li></ul><h2 id="Node-中的模块系统"><a href="#Node-中的模块系统" class="headerlink" title="Node 中的模块系统"></a>Node 中的模块系统</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h3 id="CommonJS-模块规范"><a href="#CommonJS-模块规范" class="headerlink" title="CommonJS 模块规范"></a>CommonJS 模块规范</h3><p>加载 require</p><p>导出 exports</p><h4 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 Node 中，每个模块内部都有一个自己的 module 对象</span></span><br><span class="line"><span class="comment">// 该 module 对象中，有一个成员叫 exports 也是一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// var module = &#123;</span></span><br><span class="line"><span class="comment">//   exports: &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在模块中还有这么一句代码</span></span><br><span class="line"><span class="comment">// exports 和 module.exports 指向同一个引用</span></span><br><span class="line"><span class="comment">// var exports = module.exports</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者一致，那就说明，可以使用任意一方来导出</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">exports</span> === <span class="built_in">module</span>.exports); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接给 exports 赋值不管用</span></span><br><span class="line"><span class="built_in">exports</span> = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="comment">// 最后 return 的是 module.export</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 默认在代码的最后有一句</span></span><br><span class="line"><span class="comment">// return module.exports</span></span><br></pre></td></tr></table></figure><blockquote><p>要注意 exports 和 modules.export 的区别</p></blockquote><h4 id="require-加载规则"><a href="#require-加载规则" class="headerlink" title="require 加载规则"></a>require 加载规则</h4><blockquote><p>参考书籍资料：《深入浅出 Node.js》深入 Node.js 的模块机制</p></blockquote><ul><li>优先从缓存加载</li><li>判断模块标识<ul><li>核心模块</li><li>第三方模块</li><li>自己写的模块</li></ul></li></ul><p>路径形式的模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 路径形式的模块:</span></span><br><span class="line"><span class="comment">//  ./</span></span><br><span class="line"><span class="comment">//  ../</span></span><br><span class="line"><span class="comment">//  /xxx</span></span><br><span class="line"><span class="comment">//  首位的 / 在这里表示的是当前文件模块所属磁盘根路径\</span></span><br><span class="line"><span class="comment">//  .js 后缀名可以省略,但 ./ 不能省略</span></span><br><span class="line"><span class="comment">// require(&#x27;./foo.js&#x27;)</span></span><br></pre></td></tr></table></figure><p>非路径形式的模块标识</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 核心模块的本质也是文件</span></span><br><span class="line"><span class="comment">// 核心模块文件已经被编译到二进制文件中了</span></span><br><span class="line"><span class="comment">// require(&#x27;fs&#x27;)</span></span><br><span class="line"><span class="comment">// require(&#x27;http&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三方模块</span></span><br><span class="line"><span class="comment">// 凡是第三方模块都必须通过 npm 来瞎子</span></span><br><span class="line"><span class="comment">// 使用的是由就可以通过 require(&#x27;包名) 的方式来进行加载才可以使用</span></span><br><span class="line"><span class="comment">// 既不是核心模块也不是路径形式的模块</span></span><br><span class="line"><span class="comment">//    先找到当前文件所处目录的 node_modules 目录</span></span><br><span class="line"><span class="comment">//    然后找 相对应的包名</span></span><br><span class="line"><span class="comment">//    再找 该包下的 package.json 文件</span></span><br><span class="line"><span class="comment">//    再文件里面找 main 属性:记录了 该模块的入口</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果 package.json 文件不存在或者 main 指定的文件入口模块没有，</span></span><br><span class="line"><span class="comment">//    则 node 会自动寻找 模块中的 index.js // 作为默认备选项</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//    如果以上所有任何一个条件不成立，则会进入上一级目录中的 node_modules 目录查找，规则照旧，依次反复</span></span><br><span class="line"><span class="comment">//    直到当前磁盘根目录还找不到，最后报错：</span></span><br><span class="line"><span class="comment">//      Error: Cannot find module &#x27;xxx&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><p>npm（node package manager），node 的包管理器</p><p>官方网址：<a href="http://www.npmjs.com/">http://www.npmjs.com</a></p><p>npm 就是一个命令行工具，安装了 node 就已经安装了 npm</p><p>可以再命令行查看版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --version</span><br></pre></td></tr></table></figure><p>升级 npm（自己升级自己）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global npm</span><br></pre></td></tr></table></figure><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><p>npm init</p><ul><li><code>npm init -y</code> 可以跳过向导，快速生成</li></ul><p>npm install</p><ul><li><code>npm install</code>：一次性把 dependencies 选项中的依赖项全部安装</li><li><code>npm install 包名</code>：只下载</li><li><code>npm install --save 包名</code>：下载并且保存依赖项<ul><li>保存到 package.json 文件中的 dependencies 选项</li><li>简写：<code>npm i -S 包名</code></li></ul></li><li><code>npm uninstall 包名</code>：只删除，有依赖项依然会保存<ul><li>简写：<code>npm un 包名</code></li></ul></li><li><code>npm uninstall --save 包名</code>：删除同时将依赖信息也去除<ul><li>简写：<code>npm un -S 包名</code></li></ul></li><li><code>npm --help</code> &amp;&amp; <code>npm help</code>：查看使用帮助<ul><li><code>npm 命令 --help</code>：查看具体命令的使用帮助</li></ul></li></ul><h4 id="解决-npm-被墙问题"><a href="#解决-npm-被墙问题" class="headerlink" title="解决 npm 被墙问题"></a>解决 npm 被墙问题</h4><p>npm 存储包文件的服务器在国外，有时候会被墙，速度很慢。</p><p><a href="http://npm.taobao.org/">http://npm.taobao.org</a> 淘宝的开发团队把 npm 在国内做了一个备份。</p><p>安装淘宝的 cnpm：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在任意目录执行都可以</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --global 表示安装到全局，而非当前目录</span></span><br><span class="line">npm install --global cnpm</span><br></pre></td></tr></table></figure><p>接下来你安装包的时候把之前的 <code>npm</code> 替换成 <code>cnpm</code>。</p><p>如果不想安装 cnpm 又想使用淘宝的服务器来下载：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>但上面命令需要每一次手动添加参数很麻烦，所以可以把这个选项加入配置文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>只要经过了上面命令的配置，则以后所有的 <code>npm install </code> 都会默认通过淘宝的服务器来下载。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 npm 配置信息</span></span><br><span class="line">npm config list</span><br></pre></td></tr></table></figure><h3 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h3><p>建议每一个项目都要有一个 <code>package.json</code> 文件（包描述文件）。</p><p>可以自动初始化：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">❯ npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See `npm help init` for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use `npm install &lt;pkg&gt;` afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">package name: (npm-demo)</span><br><span class="line">version: (1.0.0) 0.0.1</span><br><span class="line">description: 这是一个测试项目</span><br><span class="line">entry point: (index.js) main.js</span><br><span class="line">test command:</span><br><span class="line">git repository:</span><br><span class="line">keywords:</span><br><span class="line">author: AgoniLay</span><br><span class="line">license: (ISC)</span><br><span class="line">About to write to F:\课堂笔记\web-pink\nodejs\nodejs黑马\03\code\npm-demo\package.json:</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;npm-demo&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;0.0.1&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;这是一个测试项目&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;main.js&quot;,</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;author&quot;: &quot;AgoniLay&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this OK? (yes) yes</span><br><span class="line">❯ npm i jquery --save</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">npm WARN npm-demo@0.0.1 No repository field.</span><br><span class="line"></span><br><span class="line">+ jquery@3.6.0</span><br><span class="line">added 1 package from 1 contributor in 0.414s</span><br><span class="line">❯</span><br></pre></td></tr></table></figure><p>目前最有用的是 <code>dependencies</code> 选项，可以用来帮我们保存第三方包的依赖信息。</p><ul><li>建议每个项目的根目录下都有一个 package.json 文件</li><li>建议执行 <code>npm install 包名 </code> 的时候都加上 <code>--save</code> 这个选项，目的是用来保存依赖项信息</li></ul><p>如果 <code>node_modules</code> 删除或丢失了也不用担心，只需要 <code>npm install</code> 就会自动把 <code>package.json</code> 中的 <code>dependencies</code> 中所有的依赖项 iang 都下载回来。</p><h3 id="package-json-和-package-lock-json"><a href="#package-json-和-package-lock-json" class="headerlink" title="package.json 和 package-lock.json"></a>package.json 和 package-lock.json</h3><p>npm 5 以前是不会有 <code>package-lock.json</code> 这个文件的，npm 5 以后才添加的。</p><p>当安装包时，npm 都会生成或者更新 <code>package-lock.json</code></p><ul><li>npm 5 以后的版本安装包时，不需要加 <code>--save</code> 参数，它会自动保存依赖信息；</li><li>当你安装包时，会自动生成 <code>package-lock.json</code> 这个文件<ul><li>这个文件会保存 <code>node_modules</code> 中所有包的信息（版本，下载地址），起到使 <code>npm install</code> 时<strong>速度提升</strong>的作用；</li><li>从文件来看，有一个 <code>lock</code>，这个 lock 是用来锁定版本的</li><li>如果项目依赖了 <code>1.1.1</code> 版本，如果重新 install 其实会下载最新版本，所以这个文件的另一个作用就是<strong>锁定版本号</strong>，防止自动升级新版</li></ul></li></ul><h3 id="path-路径操作模块"><a href="#path-路径操作模块" class="headerlink" title="path 路径操作模块"></a>path 路径操作模块</h3><blockquote><p>参考文档：<a href="http://nodejs.cn/api/path.html">http://nodejs.cn/api/path.html</a></p></blockquote><ul><li>path.basename：获取文件名（默认包含后缀名）</li><li>path.dirname：获取目录部分</li><li>path.extname：获取扩展名部分</li><li>path.parse：把一个路径转为对象<ul><li>root：根路径</li><li>dir：目录</li><li>base：包含后缀名的文件名</li><li>ext：后缀名</li><li>name：不包含后缀名的文件名</li></ul></li><li>path.join：路径拼接</li><li>path.isAbsolute：判断一个路径是否是绝对路径</li></ul><h3 id="Node-中的其他成员"><a href="#Node-中的其他成员" class="headerlink" title="Node 中的其他成员"></a>Node 中的其他成员</h3><p>在每个模块中，除了 <code>require</code>、<code>exports</code> 等模块相关 API 之外，还有两个特殊的成员：</p><ul><li><code>__dirname</code>：<strong>动态获取</strong> 可以用来获取当前文件模块所属目录的绝对路径</li><li><code>__filename</code>：<strong>动态获取</strong> 可以用来获取当前文件的绝对路径</li><li><code>__dirname</code> 和 <code>__filename</code> 是不受执行 node 命令所属路径影响的</li></ul><p>在文件操作中，使用相对路径是不可靠的，因为在 Node 中文件操作的路径被设计为相对于执行 node 命令所处的路径（不是 bug，这样设计有使用背景）。</p><p>解决办法就是换为绝对路径使用 <code>__dirname</code> 和 <code>__filename</code> 即可。</p><p>在拼接路径的过程中，为了避免手动拼接带来的一些低级错误，所以推荐多使用：<code>path.join()</code> 来辅助拼接。</p><p>所以为了尽量避免刚才所描述的这个问题，大家以后再文件操作中使用的相对路径都统一转换为 <strong>动态的绝对路径</strong>。</p><blockquote><p>补充：模块中的路径表示和这里的路径没关系，不受影响（相对于文件模块）</p></blockquote><h2 id="Node-目录结构"><a href="#Node-目录结构" class="headerlink" title="Node 目录结构"></a>Node 目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">|--app.js项目入口文件</span><br><span class="line">|--controllers</span><br><span class="line">|--models存储使用 mongoose 设计的数据模型</span><br><span class="line">|--node_modules第三方依赖包文件夹</span><br><span class="line">|--package.json包描述文件</span><br><span class="line">|--package-lock.json第三方包版本锁定文件（npm 5 以后才有）</span><br><span class="line">|--public公共的静态资源</span><br><span class="line">|--README.md项目说明文档</span><br><span class="line">|--routes路由分类文件夹</span><br><span class="line">|--views存储视图目录</span><br><span class="line">|--.gitignore</span><br></pre></td></tr></table></figure><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><p>原生的 http 在某些方面表现不足以应对我们的开发需求，所以需要使用框架来加快我们的开发效率，框架的目的就是提高效率，让我们的代码高度统一。</p><p>express，作者：TJ，目前已到社区维护（<a href="https://www.expressjs.com.cn/%EF%BC%89">https://www.expressjs.com.cn/）</a></p><h3 id="起步-1"><a href="#起步-1" class="headerlink" title="起步"></a>起步</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save express</span><br></pre></td></tr></table></figure><h4 id="hello-world"><a href="#hello-world" class="headerlink" title="hello world"></a>hello world</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.send(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;app is running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="基本路由"><a href="#基本路由" class="headerlink" title="基本路由"></a>基本路由</h4><p>路由器：</p><ul><li>请求方法</li><li>请求路径</li><li>请求处理函数</li></ul><p>get：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当你以 GET 方法请求 / 的时候，执行对应的处理函数</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>post：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当你以 POST 方法请求 / 的时候，执行对应的处理函数</span></span><br><span class="line">app.post(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;Got a POST request&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="静态服务"><a href="#静态服务" class="headerlink" title="静态服务"></a>静态服务</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当以 /public/ 开头的时候，去 ./public/ 目录中找对应的资源</span></span><br><span class="line">app.use(<span class="string">&quot;/public/&quot;</span>, express.static(<span class="string">&quot;./public/&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相当于给 public 起了一个别名，但不建议</span></span><br><span class="line">app.use(<span class="string">&quot;/a/&quot;</span>, express.static(<span class="string">&quot;./public/&quot;</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当省略第一个参数的时候，通过 省略 /public 的方式来访问</span></span><br><span class="line">app.use(express.static(<span class="string">&quot;./public/&quot;</span>));</span><br></pre></td></tr></table></figure><h3 id="在-Express-配置使用-art-template-模版引擎"><a href="#在-Express-配置使用-art-template-模版引擎" class="headerlink" title="在 Express 配置使用 art-template 模版引擎"></a>在 Express 配置使用 art-template 模版引擎</h3><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save art-template</span><br><span class="line">npm install --save express-art-template</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;express-art-template&quot;</span>));</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// express 默认会去项目中的 views 目录找 index.html</span></span><br><span class="line">  res.render(<span class="string">&quot;index.html&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;hello world&quot;</span>,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果希望修改默认的 views 视图渲染存储目录，可以：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：一个参数 views 是固定的，不要写错</span></span><br><span class="line">app.set(<span class="string">&quot;views&quot;</span>, <span class="string">&quot;目录路径&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="Express-获取表单-POST-请求参数"><a href="#Express-获取表单-POST-请求参数" class="headerlink" title="Express 获取表单 POST 请求参数"></a>Express 获取表单 POST 请求参数</h3><p>Express 内置了一个 API，可以直接通过 <code>req.query</code> 来获取</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">req.query;</span><br></pre></td></tr></table></figure><h3 id="Express-获取表单-POST-请求体数据"><a href="#Express-获取表单-POST-请求体数据" class="headerlink" title="Express 获取表单 POST 请求体数据"></a>Express 获取表单 POST 请求体数据</h3><p>在 express 中没有内置获取表单 POST 请求体的 API，这里是我们需要使用一个第三方包：<code>body-parser</code></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save body-parser</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">// 0. 引包</span></span><br><span class="line"><span class="keyword">var</span> bodyParser = <span class="built_in">require</span>(<span class="string">&quot;body-parser&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 配置 body-parser</span></span><br><span class="line"><span class="comment">// 只要加入这个配置，则在 req 请求对象上会多出来一个属性：body</span></span><br><span class="line">app.use(bodyParser.urlencoded(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;));</span><br><span class="line">app.use(bodyParser.json());</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/plain&quot;</span>);</span><br><span class="line">  res.write(<span class="string">&quot;you posted:\n&quot;</span>);</span><br><span class="line">  res.end(<span class="built_in">JSON</span>.stringify(req.body, <span class="literal">null</span>, <span class="number">2</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Express-配置使用-express-session-插件"><a href="#Express-配置使用-express-session-插件" class="headerlink" title="Express 配置使用 express-session 插件"></a>Express 配置使用 express-session 插件</h3><blockquote><p>参考文档：<a href="https://www.expressjs.com.cn/en/resources/middleware/session.html">https://www.expressjs.com.cn/en/resources/middleware/session.html</a></p></blockquote><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express-session</span><br></pre></td></tr></table></figure><p>配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该插件会为 req 请求对象添加一个成员：req.session 默认是一个对象</span></span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    <span class="comment">// 配置加密字符串，它会在原有加密基础之上和这个字符串拼起来去加密</span></span><br><span class="line">    <span class="comment">// 目的是为了增加安全性，防止客户端恶意伪造</span></span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">false</span>, <span class="comment">// 无论你是否使用 Session ，我都默认直接给你分配一把钥匙</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加 Session 数据</span></span><br><span class="line">req.session.foo = <span class="string">&quot;AgoniLay&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取 Session 数据</span></span><br><span class="line">req.session.foo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除 Session 数据</span></span><br><span class="line">req.session.foo = <span class="literal">null</span>; <span class="comment">// 不严谨</span></span><br><span class="line"><span class="keyword">delete</span> req.session.foo;</span><br></pre></td></tr></table></figure><p>提示：默认 session 数据是内存存储的，服务器一旦重启就会丢失，真正的生产环境会把 Session 进行持久化存储</p><h3 id="CRUD-案例"><a href="#CRUD-案例" class="headerlink" title="CRUD 案例"></a>CRUD 案例</h3><h4 id="路由设计"><a href="#路由设计" class="headerlink" title="路由设计"></a>路由设计</h4><table><thead><tr><th>请求方法</th><th>请求路径</th><th>get 参数</th><th>post 参数</th><th>备注</th></tr></thead><tbody><tr><td>GET</td><td>/students</td><td></td><td></td><td>渲染首页</td></tr><tr><td>GET</td><td>/students/new</td><td></td><td></td><td>渲染添加学生界面</td></tr><tr><td>POST</td><td>/students/new</td><td></td><td>name,age,gender,hobbies</td><td>处理添加学生请求</td></tr><tr><td>GET</td><td>/students/edit</td><td>id</td><td></td><td>渲染编辑页面</td></tr><tr><td>POST</td><td>/students/edit</td><td></td><td>id,name,age,gender,hobbies</td><td>处理编辑请求</td></tr><tr><td>GET</td><td>/students/delete</td><td>id</td><td></td><td>处理删除请求</td></tr></tbody></table><h4 id="自己编写的步骤"><a href="#自己编写的步骤" class="headerlink" title="自己编写的步骤"></a>自己编写的步骤</h4><ol><li>处理模板</li><li>配置开放静态资源</li><li>配置模板引擎</li><li>简单路由：/student 渲染静态页出来</li><li>路由设计</li><li>提取路由模块</li><li>由于接下来一系列的业务操作都需要处理文件数据，所以需要封装异步方法</li></ol><h3 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h3><p>中间件的本质就是一个请求处理方法，我们把用户从请求到响应的整个过程分发到多个中间件中去处理，这样做的目的是提高代码的灵活性，动态可扩展性。</p><h4 id="应用程序级别中间件"><a href="#应用程序级别中间件" class="headerlink" title="应用程序级别中间件"></a>应用程序级别中间件</h4><p>万能匹配：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Time: &quot;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>只要是以 <code>/xxx/</code> 开头的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&quot;/a&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Time: &quot;</span>, <span class="built_in">Date</span>.now());</span><br><span class="line">  next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="路由级别中间件"><a href="#路由级别中间件" class="headerlink" title="路由级别中间件"></a>路由级别中间件</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h2><h3 id="关系型数据库和非关系型数据库"><a href="#关系型数据库和非关系型数据库" class="headerlink" title="关系型数据库和非关系型数据库"></a>关系型数据库和非关系型数据库</h3><p>表就是关系</p><ul><li>所有的关系型数控都需要通过 <code>sql</code> 语言来操作</li><li>所有的关系型数据库在操作之前都需要设计表结构</li><li>而且数据表还支持约束</li></ul><p>非关系型数据库非常的灵活</p><ul><li>有的非关系型数据库就是 key-value 对儿</li><li>但是 MongoDB 是长的最像关系型数据库的非关系型数据库</li><li>MongoDB 不需要设计表结构，可以任意的往里面存数据</li></ul><h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><p>官方下载地址： <a href="https://www.mongodb.com/try/download">https://www.mongodb.com/try/download</a></p><p>需要配置环境变量 bin 目录路径</p><p>输入 <code>mongod --version</code> 测试是否安装成功</p><h3 id="启动和关闭数据库"><a href="#启动和关闭数据库" class="headerlink" title="启动和关闭数据库"></a>启动和关闭数据库</h3><p>启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mongodb 默认使用执行 mongd 命令所处盘符根目录下的 /data/db 做为自己的数据存储目录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 所以在第一次执行该命令之前先手动创建一个 /data/db</span></span><br><span class="line">mongod</span><br></pre></td></tr></table></figure><p>如果想要修改默认的数据存储目录，可以：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongo --dbpath=数据存储目录路径</span><br></pre></td></tr></table></figure><p>停止：</p><ol><li>在开启服务的控制台直接 ctrl + c 停止</li><li>关闭命令行窗口停止</li></ol><h3 id="连接和退出数据库"><a href="#连接和退出数据库" class="headerlink" title="连接和退出数据库"></a>连接和退出数据库</h3><p>连接：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 该命令默认连接本机的 MongoDB 服务</span></span><br><span class="line">mongo</span><br></pre></td></tr></table></figure><p>退出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在连接状态输入</span></span><br><span class="line">exit</span><br></pre></td></tr></table></figure><h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul><li><code>show dbs</code>：查看显示所有数据库<ul><li><code>db</code>：查看当前连接的数据库</li></ul></li><li><code>use 数据库名称</code>：切换到指定的数据库（如果没有会新建）</li><li>插入数据：<code>db.students.insertOne(&#123;&quot;name&quot;, &quot;AgoniLay&quot;&#125;)</code></li><li>查看所有集合：<code>db collections</code></li><li>查看某集合中所有数据：<code>db.students.find()</code></li></ul><h3 id="在-Node-中如何操作-MongoDB-数据"><a href="#在-Node-中如何操作-MongoDB-数据" class="headerlink" title="在 Node 中如何操作 MongoDB 数据"></a>在 Node 中如何操作 MongoDB 数据</h3><h4 id="使用官方的-mongodb-包来操作"><a href="#使用官方的-mongodb-包来操作" class="headerlink" title="使用官方的 mongodb 包来操作"></a>使用官方的 mongodb 包来操作</h4><p>github 地址：<a href="https://github.com/mongodb/node-mongodb-native">https://github.com/mongodb/node-mongodb-native</a></p><h4 id="使用第三方-mongoose-来操作-MongDB-数据库"><a href="#使用第三方-mongoose-来操作-MongDB-数据库" class="headerlink" title="使用第三方 mongoose 来操作 MongDB 数据库"></a>使用第三方 mongoose 来操作 MongDB 数据库</h4><p>第三方包：<code>mongoose</code> 基于 MongoDB 官方的 <code>mongodb</code> 包再一次做了封装</p><p>官网：<a href="https://mongoosejs.com/">https://mongoosejs.com/</a></p><h5 id="MongoDB-的基本概念"><a href="#MongoDB-的基本概念" class="headerlink" title="MongoDB 的基本概念"></a>MongoDB 的基本概念</h5><ul><li>数据库</li><li>一个数据库中可以有多个集合（表）</li><li>一个集合中可以有多个文档（表记录）</li><li>文档结构很灵活，没有任何限制</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  qq: &#123;</span><br><span class="line">    users: [</span><br><span class="line">      &#123; name: &#x27;AgoniLay&#x27;, age: <span class="number">15</span> &#125;, &#123;&#125;...</span><br><span class="line">    ],</span><br><span class="line">    products: []</span><br><span class="line">  &#125;,</span><br><span class="line">  taobao: &#123;&#125;,</span><br><span class="line">  baidu: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="起步-2"><a href="#起步-2" class="headerlink" title="起步"></a>起步</h5><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i mongoose</span><br></pre></td></tr></table></figure><p>小案例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接 MongoDB 数据库</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://localhost/test&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个模型</span></span><br><span class="line"><span class="comment">// 就是在设计数据库</span></span><br><span class="line"><span class="comment">// MongoDB 是动态的，非常灵活，只需要在代码中设计你的数据库就可以了</span></span><br><span class="line"><span class="keyword">const</span> Cat = mongoose.model(<span class="string">&quot;Cat&quot;</span>, &#123; <span class="attr">name</span>: <span class="built_in">String</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化一个 Cat</span></span><br><span class="line"><span class="keyword">const</span> kitty = <span class="keyword">new</span> Cat(&#123; <span class="attr">name</span>: <span class="string">&quot;AgoniLay&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 持久化保存 kitty 实例</span></span><br><span class="line">kitty.save(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;meow&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// .then(() =&gt; console.log(&#x27;meow&#x27;))</span></span><br></pre></td></tr></table></figure><h5 id="官方指南"><a href="#官方指南" class="headerlink" title="官方指南"></a>官方指南</h5><h6 id="设计-Schema-发布-Model"><a href="#设计-Schema-发布-Model" class="headerlink" title="设计 Schema 发布 Model"></a>设计 Schema 发布 Model</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mongoose = <span class="built_in">require</span>(<span class="string">&quot;mongoose&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Schema = mongoose.Schema;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 连接数据库</span></span><br><span class="line"><span class="comment">// 指定连接的数据库不需要存在，当你插入第一条数据之后就会自动被创建出来</span></span><br><span class="line">mongoose.connect(<span class="string">&quot;mongodb://localhost/itcast&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 设计集合结构（表结构）</span></span><br><span class="line"><span class="comment">// 字段名称就是表结构中的属性名称</span></span><br><span class="line"><span class="comment">// 约束的目的是为了保证数据的完整性，不要有脏数据</span></span><br><span class="line"><span class="keyword">var</span> userSchema = <span class="keyword">new</span> Schema(&#123;</span><br><span class="line">  <span class="attr">username</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>, <span class="comment">// 必须有</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">password</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">email</span>: &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="built_in">String</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 将文档结构发布为模型</span></span><br><span class="line"><span class="comment">//    mongoose.model 方法就是用来将一个架构发布为 model</span></span><br><span class="line"><span class="comment">//    第一个参数：传入一个大写单词字符串用来表示你的数据库名称</span></span><br><span class="line"><span class="comment">//               mongoose 会自动将大写名词的字符串生成 小写复数 的集合名称</span></span><br><span class="line"><span class="comment">//               例如这里的 User 最终会变为 users 集合名称</span></span><br><span class="line"><span class="comment">//    第二个参数：架构 Schema</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//    返回值：模型构造函数</span></span><br><span class="line"><span class="keyword">var</span> User = mongoose.model(<span class="string">&quot;user&quot;</span>, userSchema);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 当我们有了模型的构造函数之后，就可以使用这个构造函数对 users 集合中的数据为所欲为了（增删改查）</span></span><br></pre></td></tr></table></figure><h6 id="增加数据"><a href="#增加数据" class="headerlink" title="增加数据"></a>增加数据</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="keyword">new</span> User(&#123;</span><br><span class="line">  <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  <span class="attr">password</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">  <span class="attr">email</span>: <span class="string">&quot;admin@admin.com&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">user.save(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;保存失败&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;保存成功&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="查询数据"><a href="#查询数据" class="headerlink" title="查询数据"></a>查询数据</h6><p>查询所有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">User.find(<span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>按条件查询所有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User.find(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>按条件查询一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User.findOne(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&quot;查询失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;查询成功&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h6 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h6><p>根据条件删除所有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">User.remove(</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="built_in">console</span>.log(<span class="string">&quot;删除失败&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;删除成功&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>根据条件删除一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findOneAndRemove(conditions, [options], [callback]);</span><br></pre></td></tr></table></figure><p>根据 id 删除一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findByIdAndRemove(id, [options], [callback]);</span><br></pre></td></tr></table></figure><h6 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h6><p>根据条件更新所有：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.update(conditions, doc, [options], [callback]);</span><br></pre></td></tr></table></figure><p>根据指定条件更新一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Model.findOneAndUpdate([conditions], [update], [options], [callback]);</span><br></pre></td></tr></table></figure><p>根据 id 更新一个：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">User.findByIdAndUpdate(</span><br><span class="line">  <span class="string">&quot;6188a8f90f972021946da51e&quot;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;020316&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;更新失败&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;更新成功&quot;</span>);</span><br><span class="line">      <span class="built_in">console</span>.log(data); <span class="comment">// 返回更改前数据</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2 id="异步编程"><a href="#异步编程" class="headerlink" title="异步编程"></a>异步编程</h2><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y, callback</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// callback 就是回调函数</span></span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> ret = x + y;</span><br><span class="line">    callback(ret);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>, <span class="number">20</span>, <span class="function">(<span class="params">ret</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ret);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>基于原生 XMLHttpRequest 封装 get 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params">url, callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">  xhr.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    callback(xhr.responseText);</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.open(<span class="string">&quot;get&quot;</span>, url, <span class="literal">true</span>);</span><br><span class="line">  xhr.send();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">get(<span class="string">&quot;data.json&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h3><p>callback hell（回调地狱）</p><img src="/2021/11/11/NodeJS%E9%BB%91%E9%A9%AC/callback-hell.jpeg" class title="callback-hell"><p>无法保证顺序的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./data/a.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// return console.log(&#x27;读取失败&#x27;)</span></span><br><span class="line">    <span class="comment">// 抛出异常</span></span><br><span class="line">    <span class="comment">//  1. 阻止程序的执行</span></span><br><span class="line">    <span class="comment">//  2. 把错误消息打印到控制台</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./data/b.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./data/c.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>通过回调嵌套的方式来保证顺序：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line">fs.readFile(<span class="string">&quot;./data/a.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">  fs.readFile(<span class="string">&quot;./data/b.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    fs.readFile(<span class="string">&quot;./data/c.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">      <span class="built_in">console</span>.log(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>为了解决以上编码方式带来的问题（回调地狱嵌套），所以在 ECMAScript 6 中新增了一个 API：<code>Primose</code></p><p>Promise 基本语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;./data/a.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">      <span class="comment">// 失败了，承诺容器中的任务失败了</span></span><br><span class="line">      <span class="comment">// console.log(err)</span></span><br><span class="line">      <span class="comment">// 把容器的 pending 状态改为失败 rejected</span></span><br><span class="line">      reject(err);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 承诺容器中的任务成功了</span></span><br><span class="line">      <span class="comment">// console.log(data)</span></span><br><span class="line">      <span class="comment">// 把容器的 pending 状态改为成功 resolved</span></span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise.then(</span><br><span class="line">  <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取文件失败了&quot;</span>, err);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>封装 Promise 版本的 <code>readFile</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">pReadFile</span>(<span class="params">filePath</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    fs.readFile(filePath, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pReadFile(<span class="string">&quot;./data/a.txt&quot;</span>)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">&quot;./data/b.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">    <span class="keyword">return</span> pReadFile(<span class="string">&quot;./data/c.txt&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h3><ul><li>有分号风格</li><li>无分号风格<ul><li>只需要注意以 <code>(</code> <code>[</code> `` <code>开头的语句前面要加一个</code>;`</li></ul></li></ul><h3 id="修改代码自动重启"><a href="#修改代码自动重启" class="headerlink" title="修改代码自动重启"></a>修改代码自动重启</h3><p>使用第三方工具 nodemon 来解决频繁修改代码重启服务器问题</p><p><code>nodemon</code> 是一个基于 Node.js 开发的一个第三方命令行工具，需要独立安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --global nodemon</span><br></pre></td></tr></table></figure><p>安装完毕后，使用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node app.js</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用 nodemon</span></span><br><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure><p>凡是通过 <code>nodemon</code> 启动的服务，则它会监视你文件的变化，当文件发生变化时，自动重启服务器。</p><h3 id="文件操作路径和模块路径"><a href="#文件操作路径和模块路径" class="headerlink" title="文件操作路径和模块路径"></a>文件操作路径和模块路径</h3><p>文件操作路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在文件的相对路径中</span></span><br><span class="line"><span class="comment">//    ./ 和 不写 相对于当前目录</span></span><br><span class="line"><span class="comment">//    / 绝对路径，当前文件模块所处磁盘根目录</span></span><br><span class="line"><span class="comment">//    c:/xx 绝对路径</span></span><br><span class="line"><span class="comment">// Error: ENOENT: no such file or directory, open &#x27;F:\data\a.txt&#x27;</span></span><br><span class="line">fs.readFile(<span class="string">&quot;/data/a.txt&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">console</span>.log(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模块操作路径：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里如果忽略了 . 则也是磁盘根目录</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;/data/foo.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相对路径</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;./data/foo.js&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模块加载的路径中的相对路径不能省略 ./</span></span><br></pre></td></tr></table></figure><h3 id="Node-js-操作-MySql-数据库"><a href="#Node-js-操作-MySql-数据库" class="headerlink" title="Node.js 操作 MySql 数据库"></a>Node.js 操作 MySql 数据库</h3><p>使用第三方包 <code>mysql</code></p><p>npm 网址：<a href="https://www.npmjs.com/package/mysql">https://www.npmjs.com/package/mysql</a></p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mysql --save</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> nodejs </tag>
            
            <tag> express </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>axios 源码实现</title>
      <link href="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/"/>
      <url>/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="快速搭建服务"><a href="#快速搭建服务" class="headerlink" title="快速搭建服务"></a>快速搭建服务</h2><p>获取 axios 源代码：<a href="https://github.com/axios/axios">https://github.com/axios/axios</a></p><p>创建一个空的文件夹：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211004215257440.png" class title="image-20211004215257440"><p>快速搭建一个后端服务模式数据请求：</p><p>json-server 的使用的地址：<a href="https://www.npmjs.com/package/json-server">https://www.npmjs.com/package/json-server</a></p><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g json-server</span><br></pre></td></tr></table></figure><p>创建一个 bd.json 文件，这个服务放在 server 的目录下</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;posts&quot;</span>: [&#123; <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;json-server&quot;</span>, <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;typicode&quot;</span> &#125;],</span><br><span class="line">  <span class="attr">&quot;comments&quot;</span>: [&#123; <span class="attr">&quot;id&quot;</span>: <span class="number">1</span>, <span class="attr">&quot;body&quot;</span>: <span class="string">&quot;some comment&quot;</span>, <span class="attr">&quot;postId&quot;</span>: <span class="number">1</span> &#125;],</span><br><span class="line">  <span class="attr">&quot;profile&quot;</span>: &#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;typicode&quot;</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211004215538440.png" class title="image-20211004215538440"><p>启动服务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server --watch bd.json</span><br></pre></td></tr></table></figure><blockquote><p>注意：要启动的 json 文件格式要正确，否则无法启动</p></blockquote><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211004215729705.png" class title="image-20211004215729705"><h2 id="简单例子实现接口请求"><a href="#简单例子实现接口请求" class="headerlink" title="简单例子实现接口请求"></a>简单例子实现接口请求</h2><p>使用 cdn 引用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/axios/dist/axios.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用 axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts/1&quot;</span>,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> <span class="built_in">console</span>.log(response));</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005003504859.png" class title="image-20211005003504859"><p>返回结果</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005003521025.png" class title="image-20211005003521025"><p>另一种写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;http://localhost:3000/posts/1&quot;</span>).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="axios-当函数使用的原理"><a href="#axios-当函数使用的原理" class="headerlink" title="axios 当函数使用的原理"></a>axios 当函数使用的原理</h2><p>源码相关的参考 axios 源代码，在 lib 目录下</p><p>在 lib 文件夹下创建 axios.js 文件</p><p>写入如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(defaultConfig);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// var axios = createInstance(defaults);</span></span><br><span class="line">createInstance(&#123;</span><br><span class="line">  <span class="attr">gsd</span>: <span class="string">&quot;gsd&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// moudle.exports = axios</span></span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005005725102.png" class title="image-20211005005725102"><p>在 lib 下面创建 core,core 里面创建 Axios.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.defaultas = instanceConfig;</span><br><span class="line">  <span class="built_in">this</span>.interceptors = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;agoni&quot;</span>, config);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = Axios;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005012524052.png" class title="image-20211005012524052"><p>创建 defaults.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defaults = &#123;</span><br><span class="line">  <span class="attr">agoni2</span>: <span class="string">&quot;agoni2&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = defaults;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005012732009.png" class title="image-20211005012732009"><p>axios.js 代码调整如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Axios = <span class="built_in">require</span>(<span class="string">&quot;./core/Axios&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> defaults = <span class="built_in">require</span>(<span class="string">&quot;./defaults&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;agoni2&quot;</span>, defaultConfig);</span><br><span class="line">  <span class="comment">// 1. 创建实例</span></span><br><span class="line">  <span class="keyword">var</span> context = <span class="keyword">new</span> Axios(defaultConfig);</span><br><span class="line">  <span class="comment">// 2. 改变 prototype 的指向</span></span><br><span class="line">  <span class="comment">// TODO 为什么用bind(context)</span></span><br><span class="line">  <span class="keyword">var</span> instance = Axios.prototype.request.bind(context);</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> axios = createInstance(defaults);</span><br><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">agoni</span>: <span class="string">&quot;agoni&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">module</span>.exports = axios;</span><br></pre></td></tr></table></figure><p><strong>在这个位置，axios 就被当成了一个函数被使用</strong></p><blockquote><p>留意一个问题：Axios.prototype.request.bind(context)改变 this 指向的目的是什么？后面进行解释</p></blockquote><h2 id="使用-rollup-构建项目"><a href="#使用-rollup-构建项目" class="headerlink" title="使用 rollup 构建项目"></a>使用 rollup 构建项目</h2><p>安装 rollup</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install rollup -g</span><br></pre></td></tr></table></figure><p>创建 rollup.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解析 node_modules 中的模块</span></span><br><span class="line"><span class="keyword">import</span> resolve <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-node-resolve&quot;</span>;</span><br><span class="line"><span class="comment">// 将 commonjs 模块转成 es6 模块</span></span><br><span class="line"><span class="keyword">import</span> commonjs <span class="keyword">from</span> <span class="string">&quot;rollup-plugin-commonjs&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">input</span>: <span class="string">&quot;lib/axios.js&quot;</span>,</span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">file</span>: <span class="string">&quot;dist/bundle.js&quot;</span>,</span><br><span class="line">    <span class="attr">format</span>: <span class="string">&quot;iife&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;axios&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">plugins</span>: [resolve(), commonjs()],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005094104926.png" class title="image-20211005094104926"><p>初始化 npm：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005094415519.png" class title="image-20211005094415519"><p>安装依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev rollup-plugin-node-resolve</span><br><span class="line">npm install --save-dev rollup-plugin-commonjs</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rollup -c</span><br></pre></td></tr></table></figure><h2 id="使-axios-具备自己的方法"><a href="#使-axios-具备自己的方法" class="headerlink" title="使 axios 具备自己的方法"></a>使 axios 具备自己的方法</h2><p>在 lib 下面创建一个 utils.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">a, b, thisArg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Object</span>.keys(b).forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">    a[item] = b[item];</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  extend,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改 axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Axios = <span class="built_in">require</span>(<span class="string">&#x27;./core/Axios&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&#x27;./utils&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createInstance</span>(<span class="params">defaultConfig</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">var</span> instance = Axios.prototype.request</span><br><span class="line">    utils.extend(instance, Axios.prototype)</span><br><span class="line">    <span class="built_in">console</span>.dir(instance)</span><br><span class="line">    <span class="keyword">return</span> instance</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 Axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gsd1&#x27;</span>, config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.get = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gsd1get&#x27;</span>, config)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Axios.prototype.getUri = <span class="function"><span class="keyword">function</span> <span class="title">getUri</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;gsd1getUri&#x27;</span>, config)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>重新构建后 instance 打印内容如下：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005111616908.png" class title="image-20211005111616908"><h2 id="axios-发送请求大致流程"><a href="#axios-发送请求大致流程" class="headerlink" title="axios 发送请求大致流程"></a>axios 发送请求大致流程</h2><p>Axios.js 里面添加如下内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dispatchRequest = <span class="built_in">require</span>(<span class="string">&#x27;./dispatchRequest&#x27;</span>)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="built_in">this</span>.interceptors = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;agoni_request&#x27;</span>, config)</span><br><span class="line">  <span class="keyword">var</span> promise</span><br><span class="line">  promise = <span class="built_in">Promise</span>.resolve(config)</span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>]</span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift())</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005152137966.png" class title="image-20211005152137966"><p>在 core 文件夹下面创建 dispatchRequest.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defaults = <span class="built_in">require</span>(<span class="string">&quot;../defaults&quot;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;dispatchRequest&quot;</span>, config);</span><br><span class="line">  <span class="keyword">var</span> adapter = defaults.adapter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005152226428.png" class title="image-20211005152226428"><p>修改 defaults.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getDefaultAdapter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> adapter;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> XMLHttpRequest !== <span class="string">&quot;undefined&quot;</span>) &#123;</span><br><span class="line">    adapter = <span class="built_in">require</span>(<span class="string">&quot;./adapters/xhr&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> adapter;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> defaults = &#123;</span><br><span class="line">  <span class="attr">agoni2</span>: <span class="string">&quot;agoni2&quot;</span>,</span><br><span class="line">  <span class="attr">adapter</span>: getDefaultAdapter(),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports = defaults;</span><br></pre></td></tr></table></figure><p>创建 adapters 文件夹以及 xhr.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;agoni xhrAdapter&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005152553574.png" class title="image-20211005152553574"><p>继续修改 dispatchRequest.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response + <span class="string">&#x27; agoni_adapter&#x27;</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>index.html 修改</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    axios(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">agoni</span>: <span class="string">&#x27;agoni123&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(result)</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(error)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行 index.html，结果：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005153458783.png" class title="image-20211005153458783"><h2 id="采用-XMLHttpRequest-发送请求，响应结果"><a href="#采用-XMLHttpRequest-发送请求，响应结果" class="headerlink" title="采用 XMLHttpRequest 发送请求，响应结果"></a>采用 XMLHttpRequest 发送请求，响应结果</h2><p>继续修改 xhr.js 文件，内容如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> settle = <span class="built_in">require</span>(<span class="string">&quot;../core/settle&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">xhrAdapter</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">dispatchXhrRequest</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> requestData = config.data;</span><br><span class="line">    <span class="comment">// resolve(&#x27;agoni xhrAdapter&#x27;)</span></span><br><span class="line">    <span class="keyword">var</span> request = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">onloadend</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">var</span> response = &#123;</span><br><span class="line">        <span class="attr">data</span>: request.response,</span><br><span class="line">        <span class="attr">status</span>: request.status,</span><br><span class="line">        <span class="attr">statusText</span>: request.statusText,</span><br><span class="line">        <span class="attr">headers</span>: <span class="literal">null</span>,</span><br><span class="line">        config,</span><br><span class="line">        request,</span><br><span class="line">      &#125;;</span><br><span class="line">      settle(resolve, reject, response);</span><br><span class="line">      request = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    request.open(config.method, config.url, <span class="literal">true</span>);</span><br><span class="line">    request.onreadystatechange = <span class="function"><span class="keyword">function</span> <span class="title">handleLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// console.log(&#x27;done&#x27;, XMLHttpRequest.DONE)</span></span><br><span class="line">      <span class="keyword">if</span> (!request || request.readyState !== XMLHttpRequest.DONE) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">setTimeout</span>(onloadend());</span><br><span class="line">    &#125;;</span><br><span class="line">    request.send(requestData);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 core 目录下分别创建 settle.js，createError.js，enhanceError.js</p><p>分别写入：</p><p>settle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createError = <span class="built_in">require</span>(<span class="string">&quot;./createError&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">settle</span>(<span class="params">resolve, reject, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (response.status === <span class="number">200</span>) &#123;</span><br><span class="line">    resolve(response);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(</span><br><span class="line">      createError(</span><br><span class="line">        <span class="string">&quot;Request failed with status code &quot;</span> + response.status,</span><br><span class="line">        resolve.config,</span><br><span class="line">        <span class="literal">null</span>,</span><br><span class="line">        response.request,</span><br><span class="line">        response</span><br><span class="line">      )</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>createError.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> enhanceError = <span class="built_in">require</span>(<span class="string">&quot;./enhanceError&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">createError</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  message,</span></span></span><br><span class="line"><span class="params"><span class="function">  config,</span></span></span><br><span class="line"><span class="params"><span class="function">  code,</span></span></span><br><span class="line"><span class="params"><span class="function">  request,</span></span></span><br><span class="line"><span class="params"><span class="function">  response</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> error = <span class="keyword">new</span> <span class="built_in">Error</span>(message);</span><br><span class="line">  <span class="keyword">return</span> enhanceError(error, config, code, request, response);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>enhanceError.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">enhanceError</span>(<span class="params">error, config, code, request, response</span>) </span>&#123;</span><br><span class="line">  error.config = config;</span><br><span class="line">  <span class="keyword">if</span> (code) error.code = code;</span><br><span class="line">  error.request = request;</span><br><span class="line">  error.response = response;</span><br><span class="line">  error.isAxiosError = <span class="literal">true</span>;</span><br><span class="line">  error.toJSON = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> error;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005174948834.png" class title="image-20211005174948834"><p>在 index.html 中修改如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    axios(&#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">method</span>: <span class="string">&#x27;get&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/posts/1&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.dir(result)</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(error)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行，结果如下：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005174632017.png" class title="image-20211005174632017"><h2 id="拦截器定义"><a href="#拦截器定义" class="headerlink" title="拦截器定义"></a>拦截器定义</h2><p>Axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.defaults = instanceConfig;</span><br><span class="line">  <span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line">    <span class="attr">request</span>: &#123;&#125;,</span><br><span class="line">    <span class="attr">response</span>: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行代码后发现拦截器就挂载在了实例上面</p><p>在 core 目录下创建 InterceptorManager.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">InterceptorManager</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.handlers = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">InterceptorManager.prototype.use = <span class="function"><span class="keyword">function</span> <span class="title">use</span>(<span class="params">fulfilled, rejected</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> options</span></span><br><span class="line">  <span class="built_in">this</span>.handlers.push(&#123;</span><br><span class="line">    fulfilled,</span><br><span class="line">    rejected,</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.handlers.length - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = InterceptorManager;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005175018799.png" class><p>修改 Axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">const</span> InterceptorManager = <span class="built_in">require</span>(<span class="string">&#x27;./InterceptorManager&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Axios</span>(<span class="params">instanceConfig</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.default = instanceConfig</span><br><span class="line">  <span class="built_in">this</span>.interceptors = &#123;</span><br><span class="line">    <span class="attr">request</span>: <span class="keyword">new</span> InterceptorManager(),</span><br><span class="line">    <span class="attr">response</span>: <span class="keyword">new</span> InterceptorManager()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>运行结果：通过 use 分别加进去了拦截器</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005175318911.png" class title="image-20211005175318911"><h2 id="chain-存放拦截器及拦截器实现原理"><a href="#chain-存放拦截器及拦截器实现原理" class="headerlink" title="chain 存放拦截器及拦截器实现原理"></a>chain 存放拦截器及拦截器实现原理</h2><p>调整 Axios.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(&#x27;agoni_request&#x27;, config)</span></span><br><span class="line">  <span class="keyword">var</span> promise;</span><br><span class="line">  promise = <span class="built_in">Promise</span>.resolve(config);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> requestIntercepotorChain = [];</span><br><span class="line">  <span class="built_in">this</span>.interceptors.request.forEach(<span class="function">(<span class="params">interceptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先进后出</span></span><br><span class="line">    requestIntercepotorChain.unshift(</span><br><span class="line">      interceptor.fulfilled,</span><br><span class="line">      interceptor.rejected</span><br><span class="line">    );</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> responseInterceptorChain = [];</span><br><span class="line">  <span class="built_in">this</span>.interceptors.response.forEach(<span class="function">(<span class="params">interceptor</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 先进先出</span></span><br><span class="line">    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> chain = [dispatchRequest, <span class="literal">undefined</span>];</span><br><span class="line"></span><br><span class="line">  <span class="built_in">Array</span>.prototype.unshift.apply(chain, requestIntercepotorChain);</span><br><span class="line">  <span class="built_in">Array</span>.prototype.push.apply(chain, responseInterceptorChain);</span><br><span class="line">  <span class="built_in">console</span>.log(chain, <span class="string">&quot;agoni&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (chain.length) &#123;</span><br><span class="line">    promise = promise.then(chain.shift(), chain.shift());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改一下 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加请求拦截器</span></span></span><br><span class="line"><span class="javascript">    axios.interceptors.request.use(<span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;request&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> config</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">requestError</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 添加响应拦截器</span></span></span><br><span class="line"><span class="javascript">    axios.interceptors.response.use(<span class="function"><span class="keyword">function</span> <span class="title">response</span>(<span class="params">response</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&#x27;response&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// response.agoni = &#123;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">//   name: &#x27;AgoniLay&#x27;</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// &#125;</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> response</span></span><br><span class="line"><span class="javascript">    &#125;, <span class="function"><span class="keyword">function</span> <span class="title">responseError</span>(<span class="params">error</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(error)</span></span><br><span class="line"><span class="javascript">    &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211005201151502.png" class title="image-20211005201151502"><h2 id="取消请求实现原理"><a href="#取消请求实现原理" class="headerlink" title="取消请求实现原理"></a>取消请求实现原理</h2><p>在 lib 目录下创建 cancel 文件夹，在其下面创建 CancelToken.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">CancelToken</span>(<span class="params">executor</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> resolvePromise;</span><br><span class="line">  <span class="built_in">this</span>.promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">promiseExecutor</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    resolvePromise = resolve;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  executor(<span class="function"><span class="keyword">function</span> <span class="title">cancel</span>(<span class="params">mession</span>) </span>&#123;</span><br><span class="line">    resolvePromise();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = CancelToken;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211006203244361.png" class title="image-20211006203244361"><p>修改 axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> axios = createInstance(defaults)</span><br><span class="line">axios.CancelToken = <span class="built_in">require</span>(<span class="string">&#x27;./cancel/CancelToken&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.axios = axios</span><br></pre></td></tr></table></figure><p>修改 xhr.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (config.cancelToken) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;config.cancelToken&#x27;</span>, config.cancelToken)</span><br><span class="line">  config.cancelToken.promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onCanceled</span>(<span class="params">cancel</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!request) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    request.abort()</span><br><span class="line">    reject(cancel)</span><br><span class="line">    request = <span class="literal">null</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">request.send(requestData)</span><br></pre></td></tr></table></figure><p>修改 dispatchRequest.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">dispatchRequest</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> adapter(config).then(<span class="function"><span class="keyword">function</span> <span class="title">onAdapterResolution</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> response</span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="title">onAdapterRejection</span>(<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> reason <span class="comment">// &lt;-- return 修改为 throw</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改写 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">onclick</span>=<span class="string">&quot;cancelRequest()&quot;</span>&gt;</span>cancel<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> CancelToken = axios.CancelToken;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">var</span> cancel;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      axios(&#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">method</span>: <span class="string">&quot;get&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">url</span>: <span class="string">&quot;http://localhost:3000/posts/1&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">cancelToken</span>: <span class="keyword">new</span> CancelToken(<span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">c</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          cancel = c;</span></span><br><span class="line"><span class="javascript">        &#125;),</span></span><br><span class="line"><span class="javascript">      &#125;).then(</span></span><br><span class="line"><span class="javascript">        <span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.dir(result);</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(error + <span class="string">&quot;---&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">cancelRequest</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        cancel();</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>重新构建，运行，点击取消按钮，运行结果如下</p><blockquote><p>json-server 可以搭建延时服务：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">json-server --watch db.json -d 3000</span><br></pre></td></tr></table></figure></blockquote><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211006204300433.png" class title="image-20211006204300433"><h2 id="挂载-get-delete"><a href="#挂载-get-delete" class="headerlink" title="挂载 get delete"></a>挂载 get delete</h2><p>修改 utils.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isArray</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> toString.call(val) === <span class="string">&#x27;[object Array]&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">forEach</span>(<span class="params">obj, fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (obj === <span class="literal">null</span> || <span class="keyword">typeof</span> obj === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isArray(obj)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = obj.length; i &lt; l; i++) &#123;</span><br><span class="line">      fn.call(<span class="literal">null</span>, obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在 core 下面创建 mergeConfig.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">mergeConfig</span>(<span class="params">config1, config2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = &#123;&#125;;</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211006222228347.png" class title="image-20211006222228347"><p>修改 Axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">forEach([<span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;head&#x27;</span>, <span class="string">&#x27;options&#x27;</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span> (<span class="params">url, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(mergeConfig(</span><br><span class="line">      config || &#123;&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        method,</span><br><span class="line">        url,</span><br><span class="line">        <span class="attr">data</span>: (config || &#123;&#125;).data</span><br><span class="line">      &#125;</span><br><span class="line">    ))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>运行 index.html，可以看到方法都挂载上去了</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211006222512250.png" class title="image-20211006222512250"><h2 id="合并参数"><a href="#合并参数" class="headerlink" title="合并参数"></a>合并参数</h2><p>修改 mergeConfig.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> utils = <span class="built_in">require</span>(<span class="string">&quot;../utils&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">mergeConfig</span>(<span class="params">config1, config2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">mergeDeepProperties</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!utils.isUndefined(config2[prop])) &#123;</span><br><span class="line">      config[prop] = getMergeValue(config1[prop], config2[prop]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!utils.isUndefined(config1[prop])) &#123;</span><br><span class="line">      config[prop] = getMergeValue(<span class="literal">undefined</span>, config1[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getMergeValue</span>(<span class="params">target, source</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">    <span class="keyword">return</span> source;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> valueFromConfig2Keys = [<span class="string">&quot;url&quot;</span>, <span class="string">&quot;method&quot;</span>, <span class="string">&quot;data&quot;</span>];</span><br><span class="line">  utils.forEach(valueFromConfig2Keys, <span class="function"><span class="keyword">function</span> <span class="title">valueFromConfig2</span>(<span class="params">prop</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!utils.isUndefined(config2[prop])) &#123;</span><br><span class="line">      config[prop] = getMergeValue(<span class="literal">undefined</span>, config2[prop]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">var</span> axiosKeys = valueFromConfig2Keys; <span class="comment">// <span class="doctag">TODO:</span></span></span><br><span class="line">  <span class="keyword">var</span> otherKeys = <span class="built_in">Object</span>.keys(config1)</span><br><span class="line">    .concat(<span class="built_in">Object</span>.keys(config2))</span><br><span class="line">    .filter(<span class="function"><span class="keyword">function</span> <span class="title">filterAxiosKeys</span>(<span class="params">key</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> axiosKeys.indexOf(key) === -<span class="number">1</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  utils.forEach(otherKeys, mergeDeepProperties);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;agoni&quot;</span>, config);</span><br><span class="line">  <span class="keyword">return</span> config;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改 utils.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isUndefined</span>(<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;undefined&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">isUndefined</span>: isUndefined</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    axios</span></span><br><span class="line"><span class="javascript">      .get(<span class="string">&quot;http://localhost:3000/posts/1&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">gsd</span>: <span class="string">&quot;gsd&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">      .then(<span class="function">(<span class="params">result</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(result);</span></span><br><span class="line"><span class="javascript">      &#125;);</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211006224030426.png" class title="image-20211006224030426"><h2 id="结合默认配置项进行状态校验"><a href="#结合默认配置项进行状态校验" class="headerlink" title="结合默认配置项进行状态校验"></a>结合默认配置项进行状态校验</h2><p>修改 Axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">forEach([<span class="string">&#x27;post&#x27;</span>, <span class="string">&#x27;put&#x27;</span>, <span class="string">&#x27;patch&#x27;</span>], <span class="function"><span class="keyword">function</span> <span class="title">forEachMethodWithData</span>(<span class="params">method</span>) </span>&#123;</span><br><span class="line">  Axios.prototype[method] = <span class="function"><span class="keyword">function</span> (<span class="params">url, data, config</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.request(mergeConfig(</span><br><span class="line">      config || &#123;&#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        method,</span><br><span class="line">        url,</span><br><span class="line">        data</span><br><span class="line">      &#125;))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>修改 index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">    axios.post(<span class="string">&#x27;http://localhost:3000/posts&#x27;</span>,</span></span><br><span class="line"><span class="javascript">               &#123; <span class="string">&quot;title&quot;</span>: <span class="string">&quot;json-server2&quot;</span>, <span class="string">&quot;author&quot;</span>: <span class="string">&quot;AgoniLay&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">               &#123;</span></span><br><span class="line"><span class="javascript">                  <span class="attr">agoni2</span>: <span class="string">&#x27;agoni2&#x27;</span></span></span><br><span class="line"><span class="javascript">               &#125;).then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">                  <span class="built_in">console</span>.log(result)</span></span><br><span class="line"><span class="javascript">               &#125;)</span></span><br><span class="line"><span class="javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>会报一个错误，接着继续修改 Axios.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Axios.prototype.request = <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  config = mergeConfig(<span class="built_in">this</span>.defaults, config)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;mergeConfig&#x27;</span>, config)</span><br><span class="line">  <span class="keyword">var</span> promise</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> promise</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改 defaults.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="keyword">var</span> defaults = &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">validateStatus</span>: <span class="function"><span class="keyword">function</span> <span class="title">validateStatus</span>(<span class="params">status</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;agoni666&#x27;</span>, status)</span><br><span class="line">    <span class="keyword">return</span> status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = defaults</span><br></pre></td></tr></table></figure><p>修改 settle.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> createError = <span class="built_in">require</span>(<span class="string">&#x27;./createError&#x27;</span>)</span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> <span class="title">settle</span> (<span class="params">resolve, reject, response</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> validateStatus = response.config.validateStatus</span><br><span class="line">  <span class="keyword">if</span> (!validateStatus || validateStatus(response.status)) &#123;</span><br><span class="line">    resolve(response)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下</p><img src="/2021/10/08/axios%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/image-20211007181909895.png" class title="image-20211007181909895"><p>笔记文档：<a href="https://docs.qq.com/doc/DVWVjaXlmRXNNckNN">https://docs.qq.com/doc/DVWVjaXlmRXNNckNN</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> axios </tag>
            
            <tag> 源码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端综合笔记</title>
      <link href="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="html-模块"><a href="#html-模块" class="headerlink" title="html 模块"></a>html 模块</h1><h2 id="html-基本结构"><a href="#html-基本结构" class="headerlink" title="html 基本结构"></a>html 基本结构</h2><ol><li>html 标签是由&lt;&gt;包围的关键词。</li><li>html 标签通常成对出现，分为标签开头和标签结尾。</li><li>有部分标签是没有结束标签的，为单标签，单标签必须使用 / 结尾。</li><li>页面所有的内容，都在 html 标签中。</li><li>html 标签分为三部分：标签名称，标签内容，标签属性。</li><li>html 标签具有语义化，可通过标签名能够判断出该标签的内容，语义化的作 用是网页</li><li>结构层次更清晰，更容易被搜索引擎收录，更容易让屏幕阅读器读出网页内容。</li><li>标签的内容是在一对标签内部的内容。</li><li>标签的内容可以是其他标签。</li></ol><h2 id="标签属性"><a href="#标签属性" class="headerlink" title="标签属性"></a>标签属性</h2><ul><li>class 属性：用于定义元素的类名</li><li>id 属性：用于指定元素的唯一 id，该属性的值在整个 html 文档中具有唯一 性</li><li>style 属性：用于指定元素的行内样式，使用该属性后将会覆盖任何全局的样式设定</li><li>title 属性：用于指定元素的额外信息</li><li>accesskey 属性：用于指定激活元素的快捷键</li><li>tabindex 属性：用于指定元素在 tab 键下的次序</li><li>dir 属性：用于指定元素中内容的文本方向，属性只有<code>ltr</code>或<code>rtl</code>两种(8) lang 属性：用于指定元素内容的语言</li></ul><h2 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h2><ul><li>window 窗口事件，onload，在网页加载结束之后触发，onunload，在用户从网页离开时发生（点击跳转，页面重载，关闭浏览器窗口等）</li><li>form 表单事件：<ul><li>onblur，当元素失去焦点时触发</li><li>onchange，在元素的值被改变时触发</li><li>onfocus，当元素获得焦点时触发</li><li>onreset，当表单中的重置按钮被点击时触发</li><li>onselect，在元素中文本被选中后触发</li><li>onsubmit，在提交表单时触发</li></ul></li><li>keyboard 键盘事件：<ul><li>onkeydown，在用户按下按键时触发</li><li>onkeypress，在用户按下按键后，按着按键时触发。该属性不会对所有按键生效，不生效的有：alt, ctrl, shift, esc</li></ul></li><li>mouse 鼠标事件：<ul><li>onclick，当在元素上发生鼠标点击时触发</li><li>onblclick，当在元素上发生鼠标双击时触发</li><li>onmousedown，当元素上按下鼠标按钮时触发</li><li>onmousemove，当鼠标指针移动到元素上时触发</li><li>onmouseout，当元素指针移出元素时触发</li><li>onmouseup，当元素上释放鼠标按钮时触发</li></ul></li><li>Media 媒体事件：<ul><li>onabort，当退出时触发</li><li>onwaiting，当媒体已停止播放但打算继续播放时触发。 </li></ul></li></ul><h2 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h2><ul><li>段落标签 <code>&lt;p&gt;&lt;/p&gt;</code> ，段落标签用来描述一段文字 </li><li>标题标签 <code>&lt;hx&gt;&lt;/hx&gt;</code> ，标题标签用来描述一个标题，标题标签总共有六个级别，<code>&lt;h1&gt;&lt;/h1&gt;</code> 标签在每个页面中通常只出现一次 </li><li>强调语句标签 <code>&lt;em&gt;&lt;/em&gt;</code>，用于强调某些文字的重要性 </li><li>更加强调标签，<code>&lt;strong&gt;&lt;/strong&gt;</code> 和 <code>&lt;em&gt;</code> 标签一样，用于强调文本，但它强调的程度更强一些</li><li>无语义标签 <code>&lt;span&gt;&lt;/span&gt;</code> ，标签是没有语义的 </li><li>短文本引用标签 <code>&lt;q&gt;&lt;/q&gt;</code> ，简短文字的引用 </li><li>长文本引用标签 <code>&lt;blockquote&gt;&lt;/blockquote&gt;</code>，定义长的文本引用 </li><li>换行标签 <code>&lt;br/&gt;</code> </li></ul><h2 id="多媒体标签"><a href="#多媒体标签" class="headerlink" title="多媒体标签"></a>多媒体标签</h2><ol><li>链接标签，<code>&lt;a&gt;&lt;/a&gt;</code></li><li>图片标签，<code>&lt;img/&gt;</code> </li><li>视频标签，<code>&lt;video&gt;&lt;/video&gt;</code> </li><li>音频标签，<code>&lt;audio&gt;&lt;/audio&gt;</code> </li></ol><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><ol><li>无序列表标签，ul, li，<code>&lt;ul&gt;&lt;/ul&gt;</code> 列表定义一个无序列表，<code>&lt;li&gt;&lt;/li&gt;</code> 代表无需列表中的每一个元素 </li><li>有序列表，ol, li </li><li>自定义列表，<code>&lt;dl&gt;&lt;/dl&gt;</code> ，定义列表通常和 <code>&lt;dt&gt;&lt;/dt&gt;</code> 和 <code>&lt;dd&gt;&lt;/dd&gt;</code> 标签一起使用 </li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>表格标签 <code>&lt;table&gt;&lt;/table&gt;</code> </li><li>表格的一行 <code>&lt;tr&gt;&lt;/tr&gt;</code> </li><li>表格的表头 <code>&lt;th&gt;&lt;/th&gt;</code> </li><li>单元格 <code>&lt;td&gt;&lt;/td&gt;</code> </li><li>表格合并，同一行内，合并几列 <strong>colspan</strong>=”2”，同一列内，合并几行 <strong>rowspan</strong>=”3”</li></ol><h2 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h2><ol><li><p>表单标签 <code>&lt;form&gt;</code> 表单可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">method</span>=<span class="string">&quot;传送方式&quot;</span> <span class="attr">action</span>=<span class="string">&quot;服务器文件&quot;</span>&gt;</span> </span><br></pre></td></tr></table></figure><ul><li>action，浏览者输入的数据被传送到的地方 </li><li>method，数据传送的方式 </li></ul></li><li><p>输入标签 <code>&lt;input/&gt;</code> </p><ul><li>name：为文本框命名，用于提交表单，后台接收数据用。 </li><li>value：为文本输入框设置默认值。 </li><li>type：通过定义不同的 type 类型，input 的功能有所不同。 <ul><li>text 单行文本输入框 </li><li>password 密码输入框（密码显示为*) </li><li>radio 单选框 （checked 属性用于显示选中状态） </li><li>checkbox 复选框（checked 属性用于显示选中状态） </li><li>file 上传文件 </li><li>button 普通按钮 </li><li>reset 重置按钮（点击按钮，会触发 form 表单的 reset 事件） </li><li>submit 提交按钮（点击按钮，会吃饭 form 表单的 submit 事件） </li><li>email 专门用于输入 e-mail </li><li>url 专门用于输入 url </li><li>number 专门用于 number </li><li>range 显示为滑动条，用于输入一定范围内的值 </li><li>date 选取日期和时间（还包含：month、week、time、datetime、datetime-local） </li><li>color 选取颜色 </li></ul></li><li>button 按钮，下拉选择框 <code>&lt;select&gt;&lt;/select&gt;</code> <ul><li><code>&lt;option value=&quot;提交值&quot;&gt;选项&lt;/option&gt;</code> 是下拉选择框里面的每一个选项</li></ul></li></ul></li><li><p>文本域：<code>&lt;textarea&gt;&lt;/textarea&gt;</code> </p><p>当用户想输入大量文字的时候，使用文本域。</p><ul><li>cols，多行输入域的列数</li><li>rows，多行输入域的行数。 </li></ul></li></ol><h2 id="其他语义化标签"><a href="#其他语义化标签" class="headerlink" title="其他语义化标签"></a>其他语义化标签</h2><ul><li>盒子<div></div> </li><li>网页头部<header></header>，html5 新增语义化标签，定义网页的头部，主要用于布局，分割页面的结构 </li><li>底部信息<footer></footer>，html5 新增语义化标签，定义网页的底部，主要用于布局，分割页面的结构 </li><li>导航<nav></nav>，html5 新增语义化标签，定义一个导航，主要用于布局，分割页面的结构 </li><li>文章<article></article>，html5 新增语义化标签，定义一篇文章，主要用于布局，分割页面的结构 </li><li>侧边栏<aside></aside>，语义化标签，定义主题内容外的信息，主要用于布局，分割页面的结构。 </li><li>时间标签<time></time>，语义化标签，定义一个时间 </li></ul><h2 id="网页结构"><a href="#网页结构" class="headerlink" title="网页结构"></a>网页结构</h2><ol><li><code> &lt;!DOCTYPE html&gt;</code> 定义文档类型，告知浏览器用哪一种标准解释 HTML </li><li><code>&lt;html&gt;&lt;/html&gt;</code> 可告知浏览器其自身是一个 HTML 文档 </li><li><code>&lt;body&gt;&lt;/body&gt;</code> 标签之间的内容是网页的主要内容 </li><li><code>&lt;head&gt;&lt;/head&gt;</code> 标签用于定义文档的头部，它是所有头部元素的容器 </li><li><code>&lt;title&gt;&lt;/title&gt;</code> 元素可定义文档的标题 </li><li><code>&lt;link&gt;</code> 标签将 css 样式文件链接到 HTML 文件内 </li><li><code>&lt;meta&gt;</code> 定义文档的元数据</li></ol><h2 id="模块划分"><a href="#模块划分" class="headerlink" title="模块划分"></a>模块划分</h2><ul><li>常见的企业网站，多由<strong>头部区</strong>，<strong>展示图片区域</strong>，<strong>主题区域</strong>，<strong>底部信息区域</strong>组成 </li><li>网页拆分原则：- 由上到下 - 由内到外 </li></ul><h1 id="CSS-模块"><a href="#CSS-模块" class="headerlink" title="CSS 模块"></a>CSS 模块</h1><h2 id="CSS-代码语法"><a href="#CSS-代码语法" class="headerlink" title="CSS 代码语法"></a>CSS 代码语法</h2><ul><li>CSS 全称为层叠样式表(Cascading Style Sheets)，它主要是用于定义 HTML内容在浏览器内的显示样式，如文字大小、颜色、字体加粗等。 </li><li>css 代码通常存放在 <code>&lt;style&gt;&lt;/style&gt;</code> 标签内 </li><li>css 样式由选择符和声明组成，而声明又由属性和值组成 </li><li>语法格式：<code>选择符 &#123; 属性: 值 &#125;</code> </li><li>选择符：又称选择器，指明网页中要应用样式规则的元素 </li></ul><h2 id="CSS-放置位置"><a href="#CSS-放置位置" class="headerlink" title="CSS 放置位置"></a>CSS 放置位置</h2><ol><li>行内样式，不建议使用 </li><li>内联式样式表 </li><li>外联样式表 </li></ol><h2 id="CSS-的继承"><a href="#CSS-的继承" class="headerlink" title="CSS 的继承"></a>CSS 的继承</h2><ul><li>CSS 的某些样式是具有继承性的，继承是一种规则，它允许样式不仅应用于某个特定 html 标签元素，而且应用于其后代。 </li><li>不可继承样式：display、margin、border、padding、background、height、min-height、max-height、width、min-width、max-width、overflow、position、left、right、top、bottom、z-index、float、clear </li><li>可以继承的样式： letter-spacing、word-spacing、white-space、line-height、color、font、font-family、font-size、font-style、font-variant、font-weight、text-decoration、text-transform、direction、visibility、cursor </li></ul><h2 id="选择器的种类"><a href="#选择器的种类" class="headerlink" title="选择器的种类"></a>选择器的种类</h2><ol><li>标签选择器:通过标签的名字，修改 css 样式 </li><li>通配符选择器:选择页面中所有的元素 </li><li>属性选择器 []</li><li>后代选择器:选择某个父元素下面所有的元素 </li><li>一级子元素选则器:选择某个父元素的直接子元素，后代选择器是选择父元素的所有子孙元素，一级子元素原则器只选择第一级子元素，不会再向下查找元素 </li><li>id 选择器：通过 id 查找页面中唯一的标签 </li><li>class 选择器:通过特定的 class（类）来查找页面中对应的标签，以 .class 名称 </li><li>伪类选择器: <ul><li>:hover 鼠标移入某个元素; </li><li>:before 在某个元素的前面插入内容; </li><li>:after 在某个元素的后面插入内容 </li></ul></li><li>群组选择器:可以对多个不同的选择器设置相同的样式 </li></ol><h2 id="选择器的优先级"><a href="#选择器的优先级" class="headerlink" title="选择器的优先级"></a>选择器的优先级</h2><ol><li>当有不同的选择器对同一个对象进行样式指定时，并且两个选择器有相同的属性被赋予不同的值时。 </li><li>通过测算那个选择器的权重值最高，应用哪一个选择器的样式 </li><li>权重计算方式：<ul><li>标签选择器：1 </li><li>class 选择器：10 </li><li>id 选择器：100 </li><li>行内样式：1000 </li><li>!important 最高级别，提高样式权重，拥有最高级别 </li></ul></li></ol><h2 id="背景样式"><a href="#背景样式" class="headerlink" title="背景样式"></a>背景样式</h2><p>背景颜色 background-color </p><p>背景图片 background-image </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-image</span>:<span class="built_in">url</span>(<span class="string">bg01.jpg</span>);</span><br></pre></td></tr></table></figure><p>背景图片位置 background-position</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>:<span class="number">10px</span> <span class="number">100px</span>; </span><br><span class="line">// 代表坐标 x，y 轴 </span><br></pre></td></tr></table></figure><p>背景图片重复 background-repeat</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-repeat</span>: no-repeat</span><br><span class="line"></span><br><span class="line">// no-repeat 设置图像不重复，常用 </span><br><span class="line">// round 自动缩放直到适应并填充满整个容器 </span><br><span class="line">// space 以相同的间距平铺且填充满整个容器 </span><br></pre></td></tr></table></figure><p>背景图片定位 background-attachment</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span>: fixed </span><br><span class="line"></span><br><span class="line">// 背景图像是否固定或者随着页面的其余部分滚动 </span><br><span class="line">// background-attachment 的值可以是 scroll（跟随滚动），fixed（固定）</span><br></pre></td></tr></table></figure><p>background 缩写</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>:<span class="number">#ff0000</span> <span class="built_in">url</span>(<span class="string">bg01.jpg</span>) no-repeat fixed center </span><br></pre></td></tr></table></figure><h2 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h2><p>字体族 font-family</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-family</span>: <span class="string">&quot;微软雅黑&quot;</span>,<span class="string">&quot;黑体&quot;</span>; </span><br></pre></td></tr></table></figure><p>字体大小 font-size</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: <span class="number">12px</span>; </span><br></pre></td></tr></table></figure><blockquote><p>网页默认字体大小是 16px </p></blockquote><p>字体粗细 font-weight</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-weight</span>: <span class="number">400</span>; </span><br></pre></td></tr></table></figure><ul><li>normal（默认） </li><li>bold（加粗） </li><li>bolder（相当于<strong>和<b>标签） </b></strong></li><li>lighter （常规） </li><li>100 ~ 900 整百（400=normal，700=bold） </li></ul><p>字体颜色 color</p><ul><li>颜色的英文单词 <code>color:red;</code> </li><li>十六进制色：<code>color: #FFFF00;</code> </li><li>RGB(红绿蓝)：<code>color:rgb(255,255,0)</code> </li><li>RGBA（红绿蓝透明度）A 是透明度在 0~1 之间取值。<code>color:rgba(255,255,0,0.5)</code> </li></ul><p>字体斜体 font-style</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-style</span>:italic</span><br></pre></td></tr></table></figure><h2 id="文本属性"><a href="#文本属性" class="headerlink" title="文本属性"></a>文本属性</h2><p>行高 line-height</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line-height</span>:<span class="number">50px</span>; </span><br></pre></td></tr></table></figure><blockquote><p>可以将父元素的高度撑起来 </p></blockquote><p>文本水平对齐方式 text-align</p><ul><li>left 左对齐 </li><li>center 文字居中 </li><li>right 右对齐 </li></ul><p>文本所在行高的垂直对齐方式 vertical-align</p><ul><li>baseline 默认 </li><li>sub 垂直对齐文本的下标，和<sub>标签一样的效果 </sub></li><li>super 垂直对齐文本的上标，和<sup>标签一样的效果 </sup></li><li>top 对象的顶端与所在容器的顶端对齐 </li><li>text-top 对象的顶端与所在行文字顶端对齐 </li><li>middle 元素对象基于基线垂直对齐 </li><li>bottom 对象的底端与所在行的文字底部对齐 </li><li>text-bottom 对象的底端与所在行文字的底端对齐 </li></ul><p>文本缩进 text-indent</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>:<span class="number">2em</span>; </span><br></pre></td></tr></table></figure><blockquote><p>通常用在段落开始位置的首行缩进 </p></blockquote><p>字母之间的间距 letter-spacing</p><p>单词之间间距 word-spacing</p><p>文本的大小写 text-transform</p><ul><li>capitalize 文本中的每个单词以大写字母开头 </li><li>uppercase 定义仅有大写字母 </li><li>lowercase 定义仅有小写字母 </li></ul><p>文本的装饰 text-decoration</p><ul><li>none 默认 </li><li>underline 下划线 </li><li>overline 上划线 </li><li>line-through 中线 </li></ul><p>自动换行 word-wrap</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-wrap</span>: break-word;</span><br></pre></td></tr></table></figure><h2 id="基本样式"><a href="#基本样式" class="headerlink" title="基本样式"></a>基本样式</h2><p>宽度 width</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">width</span>: <span class="number">200px</span>; <span class="comment">/* 定义元素的宽度  */</span></span><br></pre></td></tr></table></figure><p>高度 height</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">height</span>: <span class="number">300px</span>;</span><br></pre></td></tr></table></figure><ul><li>元素默认没有高度 </li><li>需要设置高度 </li><li>可以不定义高度，让元素的内容将元素撑高 </li></ul><p>鼠标样式 cursor</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccursor:pointer </span><br></pre></td></tr></table></figure><ul><li>default 默认</li><li>pointer 小手形状 </li><li>move 移动形状 </li></ul><p>透明度 opacity</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">opacity</span>: <span class="number">0.3</span> </span><br></pre></td></tr></table></figure><ul><li>透明度的值 0~1 之间的数字，0 代表透明，1 代表完全不透明 </li><li>透明的元素，只是看不到了，但是还占据着文档流 </li></ul><p>可见性 visibility</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">visibility</span>:hidden; </span><br></pre></td></tr></table></figure><ul><li>visible 元素可见 </li><li>hidden 元素不可见 </li><li>collapse 当在表格元素中使用时，此值可删除一行或一列，不会影响表格的布局。</li></ul><p>溢出隐藏 overflow</p><p>设置当对象的内容超过其指定高度及宽度时如何显示内容 </p><ul><li>visible 默认值，内容不会被修剪，会呈现在元素框之外 </li><li>hidden 内容会被修剪，并且其余内容是不可见的 </li><li>scroll 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容 </li><li>auto 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容 </li></ul><p>边框颜色 outline </p><blockquote><p>input 文本输入框自带边框，且样式丑陋，我们可以通过 outline 修改边框 </p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line"><span class="comment">/* 清除边框 */</span></span><br><span class="line"><span class="attribute">outline</span>: none ;</span><br></pre></td></tr></table></figure><p>样式重置</p><p>早期的网页没有 css 样式，为了界面美观，很多元素自带 margin、padding 等样式，但这些样式在不同浏览器解析的值都不一样，需要将 css 样式重置，保证在 不同浏览器显示一致。 </p><ul><li>清除元素的 margin 和 padding </li><li>去掉自带的列表符 </li><li>去掉自带的下划线 </li></ul><p>盒模型样式</p><p>块状元素、内联元素和内联块状元素。</p><ul><li>块级元素: <ul><li>每个块级元素都从新的一行开始，并且其后的元素也另起一行。 </li><li>元素的高度、宽度、行高以及顶和底边距都可设置。 </li><li>元素宽度在不设置的情况下，是它本身父容器的 100%，除非设定一个宽度。 </li></ul></li><li>行内元素: <ul><li>和其他元素都在一行上 </li><li>元素的高度、宽度、行高及顶部和底部边距不可设置 </li><li>元素的宽度就是它包含的文字或图片的宽度，不可改变。 </li></ul></li><li>行内块状元素: <ul><li>和其他元素都在一行上 </li><li>元素的高度、宽度、行高以及顶和底边距都可设置。 </li></ul></li></ul><p>元素分类转换 <strong>display</strong> </p><ul><li>block：将元素转换为块级元素 </li><li>inline：将元素装换为行级元素 </li><li>inline-block：将元素转换为内联块元素 </li><li>none: 将元素隐藏</li></ul><p>描边 <strong>border</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>: <span class="number">2px</span> solid <span class="number">#f00</span>; </span><br></pre></td></tr></table></figure><ul><li>线条的样式： <ul><li>dashed（虚线）| dotted（点线）| <strong>solid</strong>（实线）。 </li></ul></li></ul><blockquote><p>css 样式中允许只为一个方向的边框设置样式： </p><ul><li>下描边 border-bottom:1px solid red; </li><li>上描边 border-top:1px solid red; </li><li>右描边 border-right:1px solid red; </li><li>左描边 border-left:1px solid red; </li></ul></blockquote><p>间距 <strong>margin</strong> </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span>&#123;<span class="attribute">margin</span>:<span class="number">20px</span> <span class="number">10px</span> <span class="number">15px</span> <span class="number">30px</span>;&#125; </span><br></pre></td></tr></table></figure><p>内填充 <strong>padding</strong> </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">padding</span>:<span class="number">10px</span> </span><br></pre></td></tr></table></figure><p>浮动 float</p><p>（1）浮动原理 </p><ul><li>浮动使元素脱离文档普通流，漂浮在普通流之上的。 </li><li>浮动元素依然按照其在普通流的位置上出现，然后尽可能的根据设置的浮动方向向左或者向右浮动，直到浮动元素的外边缘遇到包含框或者另一个浮动元素为止，且允许文本和内联元素环绕它。 </li><li>浮动会产生块级框（相当于设置了 display:block），而不管该元素本身是什么。 </li></ul><p>（2）清除浮动带来的影响clear 清除浮动： </p><ul><li>none : 不清除（默认值）。 </li><li>left : 不允许左边有浮动对象 </li><li>right : 不允许右边有浮动对象 </li><li>both : 不允许两边有浮动对象 </li></ul><p>（3）利用伪类实现清除浮动 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearFix</span> &#123; </span><br><span class="line">  <span class="attribute">content</span>=&quot;&quot;; </span><br><span class="line">  <span class="attribute">display</span>:block; </span><br><span class="line">  <span class="attribute">width</span>:<span class="number">0</span>; </span><br><span class="line">  <span class="attribute">height</span>:<span class="number">0</span>; </span><br><span class="line">  <span class="attribute">clear</span>:both; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定位 <strong>position</strong></p><ol><li><p>定位功能可以让布局变的更加自由。 </p></li><li><p>层模型–绝对定位（相对于父类） </p><p>绝对定位使元素的位置与文档流无关，因此不占据空间。这一点与相对定位不同，相对定位实际上被看作普通流定位模型的一部分，因为元素的位置相对于它在普通流中的位置。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: absolute; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想为元素设置层模型中的绝对定位，需要设置 <code>position:absolute</code> (绝对定位)，这条语句的作用将元素从文档流中拖出来，然后使用 <code>left、right、top、bottom</code> 属性相对于其最接近的一个具有定位属性的父包含块进行绝对定位。如果不存在这样的包含块，则相对于 <code>body</code> 元素，即相对于浏览器窗口。 </p></li><li><p>层模型–相对定位（相对于原位置）</p><p>相对定位是一个非常容易掌握的概念。如果对一个元素进行相对定位，它将出现在它所在的位置上。然后，可以通过设置垂直或水平位置，让这个元素“相对于”它的起点进行移动。 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-id">#box_relative</span> &#123; </span><br><span class="line">  <span class="attribute">position</span>: relative; </span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>; </span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果想为元素设置层模型中的相对定位，需要设置 <code>position:relative</code>（相对定位），它通过 <code>left、right、top、bottom</code> 属性确定元素在正常文档流中的偏移位置。相对定位完成的过程是首先按<code>static(float)</code>方式生成一个元素(并且元素像层一样浮动了起来)，然后相对于原位置移动，移动的方向和幅度由<code>left、right、top、bottom</code>属性确定，偏移前的位置保留不动。 </p></li><li><p>层模型–固定定位（相对于网页窗口） </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: fixed;</span><br></pre></td></tr></table></figure><p>与 absolute 定位类型类似，但它的相对移动的坐标是视图（屏幕内的网页窗口）本身。由于视图本身是固定的，它不会随浏览器窗口的滚动条滚动而变化，除非你在屏幕中移动浏览器窗口的屏幕位置，或改变浏览器窗口的显示大小，因此固定定位的元素会始终位于浏览器窗口内视图的某个位置，不会受文档流动影响，这与 background-attachment:fixed 属性功能相同。 </p></li></ol><p>浏览器默认样式</p><ol><li><p>页边距</p><p>IE 默认为 10px，通过 body 的 margin 属性设置要清除页边距一定要清除这两个属性值 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123; <span class="attribute">margin</span>: <span class="number">0</span>; <span class="attribute">padding</span>: <span class="number">0</span>; &#125; </span><br></pre></td></tr></table></figure></li><li><p>段间距 </p><p>IE 默认为 19px，通过 p 的 margin-top 属性设置 p 默认为块状显示，要清除段间距，一般可以设置 </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">p</span> &#123; <span class="attribute">margin-top</span>: <span class="number">0</span>; <span class="attribute">margin-bottom</span>: <span class="number">0</span>; &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="html5-模块"><a href="#html5-模块" class="headerlink" title="html5 模块"></a>html5 模块</h1><h2 id="HTML5-的优势"><a href="#HTML5-的优势" class="headerlink" title="HTML5 的优势"></a>HTML5 的优势</h2><ul><li>解决跨浏览器，跨平台问题</li><li>增强了 web 的应用程序 </li></ul><h2 id="HTML5-废弃元素"><a href="#HTML5-废弃元素" class="headerlink" title="HTML5 废弃元素"></a>HTML5 废弃元素</h2><ul><li>frame frameset noframes acronym applet dir basefont big center font strike tt </li></ul><h2 id="HTML5-新增元素"><a href="#HTML5-新增元素" class="headerlink" title="HTML5 新增元素"></a>HTML5 新增元素</h2><ul><li><code>&lt;header&gt;</code> 用于定义文档或节的页眉 </li><li><code>&lt;footer&gt;</code> 用于定义文档或节的页脚 </li><li><code>&lt;article&gt;</code> 用于定义文档内的文章 </li><li><code>&lt;section&gt;</code> 用于定义文档中的一个区域（或节） </li><li><code>&lt;aside&gt;</code> 用于定义与当前页面或当前文章的内容几乎无关的附属信息 </li><li><code>&lt;figure&gt;</code> 用于定义一段独立的引用，经常与说明(caption) <code>&lt;figcaption&gt;</code> 配合使用，通常用在主文中的图片，代码，表格等。</li><li><code>&lt;figcaption&gt;</code> 用于表示是与其相关联的引用的说明/标题，用于描述其父节点 <code>&lt;figure&gt;</code>元素里的其他数据。 </li><li><code>&lt;hgroup&gt;</code> 用于对多个<h1>~<h6>元素进行组合 </h6></h1></li><li><code>&lt;nav&gt;</code> 用于定义页面上的导航链接部分 </li><li><code>&lt;mark&gt;</code> 用于定义高亮文本 </li><li><code>&lt;time&gt;</code> 用于显示被标注的内容是日期或时间（24 小时制） </li><li><code>&lt;meter&gt;</code> 用于表示一个已知最大值和最小值的计数器</li><li><code>&lt;progress&gt;</code> 用于表示一个进度条  </li><li><code>&lt;audio&gt;</code> 定义声音，比如音乐或其他音频流 </li><li><code>&lt;video&gt;</code> 定义视频，比如电影片段或其他视频流4.HTML5 表单相关元素和属性</li></ul><h2 id="input-新增-type-类型"><a href="#input-新增-type-类型" class="headerlink" title="input 新增 type 类型"></a>input 新增 type 类型</h2><ul><li>color 用来创建一个允 许用户使用颜色选择器，或输入兼容 CSS 语法的颜色代码的区域 </li><li>time 生成一个时间选择器 </li><li>datetime 生成一个 UTC 的日期时间选择器 </li><li>datetime-local 生成一个本地化的日期时间选择器 </li><li>date 显示一个日期输入区域，可同时使用日期选择器，结果值包括年、月、日，不包括时间。 </li><li>month 生成一个月份选择器，它结果值包括年份和月份， 但不包括日期 </li><li>week 生成一个选择的几周的选择器 </li><li>email 生成一个 E-mail 输入框 </li><li>number 生成一个只能输入数字的输入框 </li><li>range 生成一个拖动条，通过拖动条，使得用户只能输入指定范围，指定步长的值 </li><li>search 生成一个专门用于输入搜索关键字的文本框 </li><li>tel 生成一个只能输入电话号码的文本框 </li><li>url 生成一个 URL 输入框 </li></ul><h2 id="HTML5-input-新增属性"><a href="#HTML5-input-新增属性" class="headerlink" title="HTML5 input 新增属性"></a>HTML5 input 新增属性</h2><ul><li><strong>placeholder</strong> 主要用在文本框，规定可描述输入字段预期值的简短的提示信息 </li><li>autocomplete 为了完成表单的快速输入，一般浏览器提供了自动补全的功能选择 </li><li>autofocus 当为某个表单控件增加该属性后，当浏览器打开这个页面， 这个表单控件会自动获得焦点 </li><li>list 为文本框指定一个可用的选项列表，当用户在文本框中输 入信息时，会根据输入的字符，自动显示下拉列表提示，供用户从中选择 </li><li>pattern 用于验证表单输入的内容，通常 HTML5 的 type 属性，比如email、tel、 number、url 等，已经自带了简单的数据格式验证功能了，加上 pattern 属性后， 验证会更加高效 </li><li>novalidate 当提交表单时不对其进行验证 </li><li>required 必需在提交之前填写输入字段 </li><li>spellcheck 拼写检查，为 <input> 、 <textarea> 等元素新增属性 </textarea></li><li>formenctype 规定在发送到服务器之前应该如何对表单数据进行编码 </li><li>formtarget 带有两个提交按钮的表单，会提交到不同的目标窗口 </li><li>multiple 一次上传多个文件 </li></ul><p>textarea 新增</p><ul><li>maxlength：用于规定文本区域最大字符数。</li><li>wrap：是否包含换号符（soft/ hard） </li></ul><h1 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h1><h2 id="CSS3-新增选择器"><a href="#CSS3-新增选择器" class="headerlink" title="CSS3 新增选择器"></a>CSS3 新增选择器</h2><ol><li><p>兄弟选择器</p><p><code>元素 1 ~ 元素 2</code> 第 1 个元素之后，所有的元素 2 都会被选择，且这些元素和第一个元素拥有同一个父元素（两个元素之间不一定要相邻）。 </p></li><li><p>属性选择器</p><ul><li><code>E[attribute^=value]</code> 用于选取带有以指定值开头的属性值的元素 </li><li><code>E[attribute$=value]</code> 用于选取属性值以指定值结尾的元素 </li><li><code>E[attribute*=value]</code> 用于选取属性值中包含指定值的元素，位置不限，也不限制整个单词 </li></ul></li><li><p>伪类选择器</p><ul><li>:root 选择文档的根元素，HTML 里，永远是 <code>&lt;html&gt;</code> 元素 </li><li>:last-child 向元素添加样式，且该元素是它的父元素的最后一个子元素 :nth-child(n) 向元素添加样式，且该元素是它的父元素的第 n 个子元素 </li><li>:nth-last-child(n) 向元素添加样式，且该元素是它的父元素的倒数第 n 个子元素 </li><li>:only-child 向元素添加样式，且该元素是它的父元素的唯一子元素 </li><li>:first-of-type 向元素添加样式，且该元素是同级同类型元素中第一个元素 </li><li>:last-of-type 向元素添加样式，且该元素是同级同类型元素中最后一个元素 </li><li>:nth-of-type(n) 向元素添加样式，且该元素是同级同类型元素中第 n 个元素 </li><li>:nth-last-of-type(n) 向元素添加样式，且该元素是同级同类型元素中倒 数第 n 个元素 </li><li>:only-of-type 向元素添加样式，且该元素是同级同类型元素中唯一的元素 </li><li>:empty 向没有子元素（包括文本内容）的元素添加样式 </li></ul></li><li><p>伪元素选择器</p><ul><li>:enabled 向当前处于可用状态的元素添加样式，通常用于定义表单的样式或者超链接的样式 </li><li>:disabled 向当前处于不可用状态的元素添加样式，通常用于定义表单的样式或者超链接的样式 </li><li>:checked 向当前处于选中状态的元素添加样式 </li><li>:not(selector) 向不是 selector 元素的元素添加样式 </li><li>:target 向正在访问的锚点目标元素添加样式 </li><li>::selection 向用户当前选取内容所在的元素添加样式 </li></ul></li></ol><h2 id="CSS3-新增属性"><a href="#CSS3-新增属性" class="headerlink" title="CSS3 新增属性"></a>CSS3 新增属性</h2><p>新增背景属性</p><ul><li>background-cli 设置背景覆盖范围 border-box/paddingbox/content-box </li><li>background-origin 设置背景覆盖的起点 border-box/paddingbox/content-box </li><li>background-size 设置背景的大小 cover/contain/长度/百分比 </li></ul><p>新增的字体文本相关属性</p><ul><li>text-overflow 设置当文本溢出元素框时处理方式 clip/ellipsis </li><li>word-wrap 规定单词的换行方式 normal/break-word </li><li>word-break 规定自动换行的方式 normal/break-all/keep-all </li></ul><p>新增盒模型属性</p><ul><li>box-shadow 阴影 h-shadow v-shadow blur spread color inset </li><li>resize 调整尺寸 none/both/horizontal </li><li>outline-offset 轮廓的偏移量 length/inherit </li></ul><p>新增变形动画属性</p><ol><li>transform<ul><li>translate(x,y) </li><li>rotate(angle) </li><li>scale(x,y) </li><li>skew(angleX ,angleY) </li></ul></li><li>transform-origin 表示元素旋转的中心点，默认值为 50% 50%。 <ul><li>第一个值表示元素旋转中心点的水平位置，它还可以赋值 left、right、center、长度、百分比。 </li><li>第二个值表示元素旋转中心点的垂直位置，它还可以赋值 top、bottom、center、长度、百分比。</li></ul></li></ol><h2 id="3D-变形属性"><a href="#3D-变形属性" class="headerlink" title="3D 变形属性"></a>3D 变形属性</h2><ol><li><p>transform 3D 函数 </p><p>transform 增加了三个变形函数： </p><ul><li>rotateX：表示元素沿着 x 轴旋转 </li><li>rotateY：表示元素沿着 y 轴旋转 </li><li>rotateZ：表示元素沿着 z 轴旋转 </li></ul></li><li><p>transform-style 用来设置嵌套的子元素在 3D 空间中显示效果。</p></li><li><p>perspective 设置成透视效果，透视效果为近大远小。 </p></li><li><p>perspective-origin 设置 3D 元素所基于的 x 轴和 y 轴，改变 3D 元素的底部位置，该属性取值同 transform-origin，默认值为 50% 50%。 </p></li><li><p>backface-visibility 用来设置当元素背面面向屏幕时是否可见，通常用于设置 不希望用户看到旋转元素的背面。它的属性值有 visible（背面可见，默认值）、 hidden（背面不可见）两个。</p></li></ol><h2 id="CSS3-的过渡属性"><a href="#CSS3-的过渡属性" class="headerlink" title="CSS3 的过渡属性"></a>CSS3 的过渡属性</h2><ul><li>transition-delay 设置过渡的延迟时间 </li><li>transition-duration 设置过渡的过渡时间 </li><li>transition-timing-function 设置过渡的时间曲线 </li><li>transition-property 设置哪条 CSS 使用过渡 </li><li>transition 一条声明设置 所有过渡属性 </li></ul><h2 id="CSS3-的动画属性"><a href="#CSS3-的动画属性" class="headerlink" title="CSS3 的动画属性"></a>CSS3 的动画属性</h2><p>animation</p><ul><li>@keyframes 定义动画选择器 </li><li>animation-name 使用@keyframes 定义的动画 animation-delay 设置动画的持续动画时间 </li><li>animation-timing-function 设置动画的时间曲线 </li><li>animation-iteration-count 设置动画播放次数 </li><li>animation-direction 设置动画反向播放 </li><li>animation-play-state 设置动画播放状态 </li><li>transition 一条声明设置所有动画属性 </li></ul><h2 id="CSS3-新增多列属性"><a href="#CSS3-新增多列属性" class="headerlink" title="CSS3 新增多列属性"></a>CSS3 新增多列属性</h2><ul><li>column-count 设置元素应该被分隔的列数 </li><li>column-width 设置列的宽度 </li><li>columns 一条声明设置列宽和列数 <code>column</code> </li><li>column-gap 设置列之间的间隔 </li><li>column-span 设置元素应该横跨的列数 </li><li>column-rule-style 设置列之间间隔的样式 </li><li>column-rule-color 设置列之间间隔的颜色 </li><li>column-rule-width 设置列之间间隔的宽度 </li><li>column-rule 一条声明设置列之间间 隔所有属性 </li></ul><h2 id="CSS3-新增单位"><a href="#CSS3-新增单位" class="headerlink" title="CSS3 新增单位"></a>CSS3 新增单位</h2><p>px、em、rem、vh、 vw 和 % 移动端长度单位 </p><p>使用 CSS 单位 px、em、rem、vh、 vw 等实现页面布局。 </p><ul><li>px：绝对单位，页面按精确像素展示 </li><li>em：相对单位，基准点为父节点字体的大小，如果自身定义了 font-size 按自身来计算（浏览器默认字体是 16px），整个页面内 1em 不是一个固定的值。em 会根据父级元素的大小而变化，但是如果嵌套了多个元素，要计算它的大小，是很容易出错的，这样就引申出了 rem。 </li><li>rem：相对单位，可理解为”root em”, 相对根节点 html 的字体大小来计算，CSS3 新加属性。 </li><li>%：% 百分比，相对长度单位，相对于父元素的百分比值 </li></ul><p>vw、vh、vmin、vmax 主要用于页面视口大小布局 </p><ul><li>vw：viewpoint width，视窗宽度，1vw 等于视窗宽度的 1%。 </li><li>vh：viewpoint height`，视窗高度，1vh 等于视窗高度的 1%。 </li><li>vmin：vw 和 vh 中较小的那个 </li><li>vmax：vw 和 vh 中较大的那个 </li></ul><h2 id="弹性盒模型"><a href="#弹性盒模型" class="headerlink" title="弹性盒模型"></a>弹性盒模型</h2><p>弹性盒模型的语法基础概念：任何一个容器都可以指定弹性布局 </p><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="JavaScript-基础"><a href="#JavaScript-基础" class="headerlink" title="JavaScript 基础"></a>JavaScript 基础</h2><ul><li>外部引入 js 文件：通过<script src="main.js"></script> </li><li>关键词 </li><li>变量名大小写敏感</li><li>命名规范 </li></ul><h2 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h2><ol><li><p>字符串(String) </p></li><li><p>数字（Number） </p></li><li><p>布尔值（Boolean） </p></li><li><p>未定义（Undefined） </p><p>undefined，表示未定义或只声明未给值的变量 </p><blockquote><p>undefined 有两种结果</p><ol><li><p>真的没定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="keyword">typeof</span> dada); <span class="comment">//undefined </span></span><br></pre></td></tr></table></figure></li><li><p>定义了，但是没有放东西进去 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dada; </span><br><span class="line">alert(dada); <span class="comment">//undefined </span></span><br></pre></td></tr></table></figure></li></ol></blockquote></li><li><p>对象（Object） </p><p>js 中内置了如下的对象： </p><ul><li>Object 是所有 JS 对象的超类(基类），JS 中的所有对象都是继承自 Object 对象的 </li><li>Array 数组对象 定义数组属性和方法 </li><li>Number 数字对象 </li><li>Boolean 布尔对象 布尔值相关 </li><li>Error 错误对象 处理程序错误 </li><li>Function 函数对象 定义函数属性和方法 Math 数学对象 </li><li>Date 日期对象 </li><li>RegExp 正则表达式对象 定义文本匹配与筛选规则 </li><li>String 字符串对象 定义字符串属性和方法 </li></ul></li></ol><h2 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h2><p><code>+ - * / % ++ --</code> </p><h2 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h2><ol><li>字符串转数字<code>parseInt() parseFloat() isNaN()</code> </li><li>数字转为字符串<code>toString()</code> </li></ol><h2 id="赋值运算"><a href="#赋值运算" class="headerlink" title="赋值运算"></a>赋值运算</h2><p><code>=</code> </p><p>复合的赋值运算符 <code>+= -= *= /= %=</code> </p><h2 id="关系运算"><a href="#关系运算" class="headerlink" title="关系运算"></a>关系运算</h2><ol><li>关系运算：<code>&gt; &lt; &lt;= &gt;= != == === ==和=== !=和!==</code></li><li>“=”、“==”、“===”有什么区别？<ul><li><code>=</code> 是赋值符号 </li><li><code>==</code> 忽略数据类型的判断 是否相等 </li><li><code>===</code> 数值和数据类型都要相等才判断为相等 </li></ul></li></ol><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><ul><li>逻辑与<code>&amp;&amp;</code> </li><li>逻辑或 <code>||</code> </li><li>逻辑非 <code>!</code> </li><li>复合逻辑表达式 </li></ul><h2 id="三元运算"><a href="#三元运算" class="headerlink" title="三元运算"></a>三元运算</h2><p>三元运算符：<code>(比较表达式)？结果 1:结果 2</code> </p><h2 id="分支循环"><a href="#分支循环" class="headerlink" title="分支循环"></a>分支循环</h2><p>程序运行的三大结构：顺序结构、选择结构、循环结构 </p><ul><li>单分支选择：<code>if</code>语句 </li><li>双分支选择：<code>if-else</code>语句 </li><li>多分支语句：<code>if-else if-else</code> 语句 </li></ul><h2 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h2><p>语法格式： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(num)&#123; <span class="comment">//表达式 </span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:<span class="comment">//执行代码块 1 </span></span><br><span class="line">    <span class="keyword">break</span>; <span class="comment">//中断执行，跳出 </span></span><br><span class="line">    <span class="comment">// ... </span></span><br><span class="line">  <span class="keyword">default</span>: <span class="comment">//默认，其他都不是的情况下执行 </span></span><br><span class="line">    <span class="comment">//执行代码块 </span></span><br><span class="line">    <span class="keyword">break</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//强调：break 非常重要，如果不加 break 的话，程序会一直继续往下执行</span></span><br></pre></td></tr></table></figure><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><p>while 循环的特点：不知道具体执行的次数时，使用最合适 </p><p>语法格式: </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(条件表达式)&#123; </span><br><span class="line">  <span class="comment">//要重复执行的代码段 - 循环体 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="do-while"><a href="#do-while" class="headerlink" title="do-while"></a>do-while</h2><p>语法格式： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  <span class="comment">//循环体 </span></span><br><span class="line">&#125;<span class="keyword">while</span>(循环条件判断); </span><br></pre></td></tr></table></figure><ul><li>do-while 是先执行循环体，再检测循环条件。 </li><li>do-while 能保证循环体至少执行一次。 </li><li>其他循环无法保证循环至少执行一次。</li></ul><h2 id="for"><a href="#for" class="headerlink" title="for"></a>for</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(循环变量初始化; 循环条件判断; 循环变量的修改 )&#123;</span><br><span class="line">  <span class="comment">// 循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="break-和-continue"><a href="#break-和-continue" class="headerlink" title="break 和 continue"></a>break 和 continue</h2><ul><li>break 退出循环 </li><li>continue 跳过本次循环，继续下一次循环 </li></ul><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><ol><li><p>数组定义 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(); </span><br><span class="line"><span class="keyword">var</span> arr = []; </span><br></pre></td></tr></table></figure></li><li><p>字面量方式定义 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>]; </span><br></pre></td></tr></table></figure></li><li><p>向数组赋值 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">arr[<span class="number">0</span>] = <span class="string">&quot;1&quot;</span>; </span><br><span class="line">arr[<span class="number">1</span>] = <span class="string">&quot;2&quot;</span>; </span><br></pre></td></tr></table></figure></li><li><p>数组索引 </p></li><li><p>数组长度 </p><ul><li>arr.length </li><li>arr.length-1 最后一个元素的索引 </li></ul></li></ol><h2 id="数组方法"><a href="#数组方法" class="headerlink" title="数组方法"></a>数组方法</h2><p>indexOf：数组可以通过 indexOf(`来搜索一个指定的元素的位置，如未找到返回 -1 </p><p>concat：concat()方法把当前的 数组 和 另一个 数组连接起来，并返回一个新的 数组 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> newArr = arr1.concat(arr2,<span class="string">&quot;dada&quot;</span>);</span><br></pre></td></tr></table></figure><p>push 和 pop：push()向数组的末尾添加若干元素，pop()则把 数组的最后一个元素删除掉 </p><blockquote><p>空数组继续 pop 不会报错，而是返回 undefined</p></blockquote><p>unshift 和 shift：unshift() 向数组前面添加若干元素，shift() 则把数组的第一个元素删除掉 </p><p>slice：slice() 截取数组的部分元素，然后返回一个新的数组 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">0</span>,<span class="number">3</span>)); <span class="comment">//从索引 0 开始，到索引 3 结束，但不包括 3 </span></span><br><span class="line"><span class="built_in">console</span>.log(arr.slice(<span class="number">3</span>)); <span class="comment">//从索引 3 开始到结束 </span></span><br></pre></td></tr></table></figure><blockquote><p>如果不给 slice() 传递任何参数，就会从头到尾截取所有元素。利用这一点， 可以很容易的复制一份新的数组 </p></blockquote><p>sort：sort() 可以对当前数组排序 </p><p>reverse：reverse() 把整个数组的元素给掉个个（逆转） </p><p>join：join() 方法把数组的每个元素用指定的字符串连接起来 </p><p>splice：可以从指定的索引开始删除若干元素，然后再从该位置添加若干元素 </p><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>],<span class="string">&quot;dadaqianduan&quot;</span>]; </span><br><span class="line"><span class="keyword">var</span> x = arr[<span class="number">1</span>][<span class="number">1</span>]; <span class="comment">//b</span></span><br></pre></td></tr></table></figure><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串属性 length：字符串的长度属性 </p><p>slice()：slice(start[,end])，start–开始索引 end–结束索引 </p><p>substr() ：substr(start[,length])，start：开始，取 length 个字符 </p><p>split()：split([separator[,limit]])，按条件分割字符串，返回数组 </p><p>indexOf()：在父串中首次出现的位置，从 0 开始！没有返回-1 </p><p>lastIndexOf()：倒序查找 </p><p>charAt(index)：charAt(index) 指定索引的字符 </p><p>toLowerCase()：转小写 </p><p>toUpperCase()：转大写 </p><h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="创建正则表达式"><a href="#创建正则表达式" class="headerlink" title="创建正则表达式"></a>创建正则表达式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;i&quot;</span>); </span><br><span class="line"><span class="comment">// 将匹配字母 a，第二个参数 i,表示匹配时不分大小写 </span></span><br></pre></td></tr></table></figure><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_1.png"></p><h2 id="模式修饰符"><a href="#模式修饰符" class="headerlink" title="模式修饰符"></a>模式修饰符</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_2.png"></p><h2 id="正则方法"><a href="#正则方法" class="headerlink" title="正则方法"></a>正则方法</h2><ol><li>test 方法：检索字符串中指定的值。 </li><li>exec 方法：该方法用于检索字符串中的正则表达式的匹配，该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。 </li></ol><h2 id="支持正则的-String-方法"><a href="#支持正则的-String-方法" class="headerlink" title="支持正则的 String 方法"></a>支持正则的 String 方法</h2><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/regexp_3.png"></p><h1 id="js-对象"><a href="#js-对象" class="headerlink" title="js 对象"></a>js 对象</h1><h2 id="定义对象"><a href="#定义对象" class="headerlink" title="定义对象"></a>定义对象</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用 new 运算符 </span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line"><span class="comment">//字面量 </span></span><br><span class="line"><span class="keyword">var</span> obj=&#123; </span><br><span class="line">  <span class="attr">name</span>:<span class="string">&quot;dadaqianduan&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>:<span class="number">12</span>,</span><br><span class="line">  <span class="attr">sex</span>:<span class="string">&quot;男&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="对象的数据访问"><a href="#对象的数据访问" class="headerlink" title="对象的数据访问"></a>对象的数据访问</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用.语法 </span></span><br><span class="line">obj.name </span><br><span class="line"><span class="comment">//用[]语法 </span></span><br><span class="line">obj[<span class="string">&quot;name&quot;</span>]</span><br></pre></td></tr></table></figure><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>json(JavaScript Object Notation)，是一种轻量级的数据交换格式。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> man = &#123; </span><br><span class="line">  <span class="string">&quot;name&quot;</span>:<span class="string">&quot;dadaqianduan&quot;</span>, </span><br><span class="line">  <span class="string">&quot;age&quot;</span>:<span class="number">12</span>, </span><br><span class="line">  <span class="string">&quot;sex&quot;</span>:<span class="string">&quot;男&quot;</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><ul><li>Object 是所有 JS 对象的超类(基类），JS 中的所有对象都是继承自 Object对象的 </li><li>Array 数组对象 </li><li>Number 数字对象 </li><li>Boolean 布尔对象 </li><li>Error 错误对象 </li><li>Function 函数对象 </li><li>Math 数学对象 </li><li>Date 日期对象 </li><li>RegExp 对象正则表达式对象 </li><li>String 字符串对象 </li></ul><h2 id="Math-方法"><a href="#Math-方法" class="headerlink" title="Math 方法"></a>Math 方法</h2><ul><li>abs() 绝对值 （去除正负） </li><li>random()随机数，<code>0-1</code>之间的随机数，<code>1</code>不会出现 </li><li>round() 四舍五入 </li><li>floor(x) 下舍入(向下取整) </li><li>ceil(x) 上舍入(向上取整) </li><li>max(x,y) x 和 y 中的最大值 </li><li>min(x,y) x 和 y 中的最小值 </li><li>cos(x) x 的余弦 </li><li>sin(x) x 的正弦 </li><li>pow(3,4) 返回 3 的 4 次方 </li></ul><h2 id="Date-方法"><a href="#Date-方法" class="headerlink" title="Date 方法"></a>Date 方法</h2><ul><li>getFullYear() 返回 年（4 位） </li><li>getMouth() 返回 月（0–11） </li><li>getDate() 返回 日期 getDay() 返回 星期 （0-6） </li><li>getHours() 返回 小时 </li><li>getMinutes() 返回 分钟 </li><li>getSeconds() 返回秒 </li><li>getTime() 返回 1970 年 1 月 1 日午夜到指定日期（字符串）的毫秒数 </li><li>setFullYear() 设置 年份 </li><li>setMouth() 设置 月 </li><li>setDate() 设置 天 </li><li>setHours() 设置小时 </li><li>setMinutes() 设置 分钟 </li><li>setSeconds() 设置 秒 </li><li>setTime() 使用毫秒的形式设置时间对象 </li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//判断闰年 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runYear</span>(<span class="params">year</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(year%<span class="number">4</span>==<span class="number">0</span> &amp;&amp; year%<span class="number">100</span>!=<span class="number">0</span> || year%<span class="number">400</span>==<span class="number">0</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="面向对象是一种编程思想"><a href="#面向对象是一种编程思想" class="headerlink" title="面向对象是一种编程思想"></a>面向对象是一种编程思想</h1><ol><li>类是一个抽象的概念 </li><li>对象：具体的事物 </li><li>类是对象的抽象，对象是类的具体实例 </li><li>类不占用内存，对象占用内存空间 </li><li>对象的访问 声明对象 </li><li>遍历对象 – for in 循环 </li></ol><h2 id="定义对象-1"><a href="#定义对象-1" class="headerlink" title="定义对象"></a>定义对象</h2><ol><li><p>字面量创建 </p></li><li><p>工厂模式 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 工厂模式中的函数，首字母大写 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">n,c</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">name</span>:n, </span><br><span class="line">    <span class="attr">color</span>:c, </span><br><span class="line">    <span class="attr">say</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">      alert(<span class="string">&quot;dadaqianduan&quot;</span>) </span><br><span class="line">    &#125; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构造函数 </p><ul><li><p>Javascript 提供了一个构造函数（Constructor）模式。 </p></li><li><p>所谓”构造函数”，其实就是一个普通函数，但是内部使用了 this 变量。 </p></li><li><p>对构造函数使用 new 运算符，就能生成实例，并且 this 变量会绑定在实例对象上。</p></li><li><p>构造函数首字母大写</p></li><li><p>构造函数中的 this，指向的 实例化的对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span>(<span class="params">n,c</span>)</span>&#123; </span><br><span class="line">  <span class="built_in">this</span>.name=n; </span><br><span class="line">  <span class="built_in">this</span>.color=c; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>生成实例对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cat1 = <span class="keyword">new</span> Cat(<span class="string">&quot;dadaqianduan&quot;</span>,<span class="string">&quot;黄色&quot;</span>) </span><br></pre></td></tr></table></figure><p>自动含有一个 constructor 属性，指向它们的构造函数 <code>alert(cat1.constructor == Cat); // true</code> </p></li></ul></li><li><p>Javascript 还提供了一个 instanceof 运算符 </p></li></ol><p>验证原型对象与实例对象之间的关系。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> txt = <span class="string">&#x27;dadaqianduan&#x27;</span>; </span><br><span class="line">alert(txt <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//false </span></span><br><span class="line"><span class="keyword">var</span> age = <span class="number">123123</span>; </span><br><span class="line">alert(age <span class="keyword">instanceof</span> <span class="built_in">Number</span>); <span class="comment">//false </span></span><br><span class="line"><span class="keyword">var</span> res = <span class="regexp">/\d/</span>; </span><br><span class="line">alert(res <span class="keyword">instanceof</span> <span class="built_in">RegExp</span>); <span class="comment">//true </span></span><br><span class="line"><span class="keyword">var</span> arr = []; </span><br><span class="line">alert(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">//true </span></span><br></pre></td></tr></table></figure><p>2.原型和原型链</p><ul><li>构造函数都有一个 <strong>prototype</strong> 属性，指向 另一个对象 。这个对象的所有属性和方法，都会被构造函数的实例继承。</li><li>所有的函数都是 Function 的实例。 </li><li>在构造函数上都有一个 原型 属性 prototype，prototype 也是一个对象；这个对象上有一个 constructor 属性，该属性指向的就是构造函数。 </li><li>实例对象上有一个 <code>_proto_</code> 属性，该属性也指向原型对象，该属性不是标准属性，不可以用在编程中，该属性用于浏览器内部使用。 </li></ul><h2 id="Constructor"><a href="#Constructor" class="headerlink" title="Constructor"></a>Constructor</h2><p>constructor 是 构造函数 创建的实例的属性，该属性的作用是 指向 创建当前对象的 构造函数。  </p><p>每个原型都有一个<code>constructor</code>属性，指向该关联的构造函数。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person===Person.prototype.constructor) <span class="comment">//true </span></span><br></pre></td></tr></table></figure><p>关系图： </p><p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E7%BB%BC%E5%90%88%E7%AC%94%E8%AE%B0/constructor.png"></p><p>区分一下普通对象和函数对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> f2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> f3 = <span class="keyword">new</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> o1 = &#123;&#125;; </span><br><span class="line"><span class="keyword">var</span> o2 = <span class="keyword">new</span> <span class="built_in">Object</span>(); </span><br><span class="line"><span class="keyword">var</span> o3 = <span class="keyword">new</span> f1(); </span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Object</span>); <span class="comment">// function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Function</span>); <span class="comment">// function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f1) <span class="comment">// function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f2) <span class="comment">// function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> f3) <span class="comment">// function </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o1) <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o2) <span class="comment">// object </span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> o3) <span class="comment">// object </span></span><br></pre></td></tr></table></figure><ul><li><p>在 JavaScript 中，原型是一个对象，原型的作用是 实现对象的继承。 </p></li><li><p>在 JavaScript 中的所有函数对象中，都存在一个属性 prototype 该属性对应当前对象的原型。 </p></li><li><p>所有的 JavaScript 对象，都存在一个 <code>_proto_</code> 属性，<code>_proto_</code> 属性指向实例对象的构造函数的原型。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Person(); <span class="comment">// 实例对象 </span></span><br><span class="line"><span class="built_in">console</span>.log(p._proto_ === Person.prototype); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>p 是实例对象, Person 是 p 的构造函数。p 的_proto_属性指向构造函数 Person 的原型。js 是如何通过原型进行继承的： </p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent = <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123; </span><br><span class="line">  <span class="built_in">this</span>.name = name; </span><br><span class="line">&#125;</span><br><span class="line">parent.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.name; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> parent(<span class="string">&quot;dadaqianduan&quot;</span>); </span><br><span class="line"><span class="built_in">console</span>.log(son.getName()); <span class="comment">// dadaqianduan </span></span><br></pre></td></tr></table></figure><p>son 继承了 parent 的原型中的函数属性 getName </p><h2 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h2><p>除了 Object 的 prototype 的原型是 null 外，所有的对象和原型都有自己的原型， 对象的原型指向原型对象。 </p><p>在层级多的关系中，多个原型层层相连则构成了原型链。 </p><p>在查找一个对象的属性时，如当前对象找不到该属性，就会沿着原型链一直往上查找，直到找到为止，如果到了原型链顶端，没找到，则返回 undefined </p><h2 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h2><ol><li><p>所有引用类型都有一个 <code>__proto__</code> 属性 </p></li><li><p>所有函数都有一个 prototype 属性 </p></li><li><p>所有引用类型的 <code>__proto__</code> 属性指向它构造函数的 prototype构造函数和实例原型之间的关系： </p><p>Person（构造函数）的 prototype 指向 Person.prototype </p></li><li><p><code>__proto__</code> </p><p>每个对象，除 null 外，都有的属性叫__proto__，这个属性会指向该对象的原型。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(); </span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype); <span class="comment">// true </span></span><br></pre></td></tr></table></figure></li></ol><p>梳理： </p><p>写一个构造函数<code>Person</code>，一般构造函数区别与普通函数要求首字母大写：function Person(){} </p><p>prototype 原型 </p><ul><li>原型是一个对象，在原型 prototype 上定义的属性，通过“继承”，实现实例也有这个属性。 </li><li>继承是在 new 操作符内部实现的。</li><li>构造函数内部有个 prototype 的属性，通过这个属性就能访问到原型。 </li><li>Person 是构造函数，Person.prototype 是原型。 </li></ul><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>有构造函数，可以在原型上创建可继承的属性，通过<code>new</code>操作符创建实例： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125; </span><br><span class="line">person = <span class="keyword">new</span> Person() </span><br><span class="line">da = person <span class="keyword">instanceof</span> Person <span class="comment">// 检查 person 是否是 Person 的实例 </span></span><br><span class="line">da <span class="comment">// true </span></span><br><span class="line"><span class="comment">// 继承 </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&#x27;dadaqianduan.cn&#x27;</span> </span><br><span class="line">person = <span class="keyword">new</span> Person() </span><br><span class="line">da = person.name <span class="comment">// 实例继承的属性 </span></span><br><span class="line">da <span class="comment">// &#x27;dadaqianduan.cn&#x27; </span></span><br></pre></td></tr></table></figure><h2 id="proto"><a href="#proto" class="headerlink" title="proto"></a>proto</h2><p>实例通过 <code>__proto__</code> 访问到原型。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line">Person.prototype.name = <span class="string">&#x27;dadaqianduan.cn&#x27;</span>person = <span class="keyword">new</span> Person() </span><br><span class="line">da = person.__proto__ === Person.prototype </span><br><span class="line">da <span class="comment">// true </span></span><br></pre></td></tr></table></figure><h2 id="constructor-构造函数"><a href="#constructor-构造函数" class="headerlink" title="constructor 构造函数"></a>constructor 构造函数</h2><p>原型也可以通过<code>constructor</code>访问到构造函数 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125; </span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&#x27;dadaqianduan.cn&#x27;</span> </span><br><span class="line">person = <span class="keyword">new</span> Person </span><br><span class="line">da = Person.prototype.constructor === Person </span><br><span class="line">da <span class="comment">// true </span></span><br></pre></td></tr></table></figure><p>小结：</p><ol><li>所有引用类型（函数，数组，对象）都拥有 <code>__proto__</code> 属性。 </li><li>所有函数拥有 prototype 属性。 </li><li>每个实例对象(Object)都有一个私有属性，为 <code>__proto__</code> 指向它的构造函数的原型对象(prototype)。该原型对象也有一个自己的原型对象 <code>__proto__</code> ，层层向上直到一个对象的原型对象为 null，null 没有原型，并作为这个原型链中的最后一个环节。 </li></ol><h1 id="常用的-JavaScript-设计模式"><a href="#常用的-JavaScript-设计模式" class="headerlink" title="常用的 JavaScript 设计模式"></a>常用的 JavaScript 设计模式</h1><p>百度百科： </p><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结。</p><p>使用设计模式是为了可重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的；设计模式使代码编制真正工程化；设计模式是软件工程的基石脉络，如同大厦的结构一样。 </p><h2 id="单体模式"><a href="#单体模式" class="headerlink" title="单体模式"></a>单体模式</h2><p>单体是一个用来划分 命名空间并将一批相关的属性和方法组织在一起的对象，如果它可以被实例化，那么它只能被实例化一次。 </p><p>特点： </p><ol><li>可以来划分命名空间，从而清除全局变量所带来的危险。 </li><li>利用分支技术来来封装浏览器之间的差异。 </li><li>可以把代码组织的更为一体，便于阅读和维护。 </li></ol><h2 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h2><p>工厂模式的定义： </p><p>提供创建对象的接口，意思就是根据领导（调用者）的指示（参数），生产相应的产品（对象）。 </p><ol><li>创建一个对象常常需要复杂的过程，所以不适合在一个复杂的对象中。 </li><li>创建对象可能会导致大量的重复代码，也可能提供不了足够级别的抽象。 </li></ol><p>工厂就是把成员对象的创建工作转交给一个外部对象，好处在于消除对象之间的耦合(也就是相互影响)。 </p><p>分类： </p><ul><li>简单工厂模式：使用一个类，通常为单体，来生成实例。 </li><li>复杂工厂模式定义：将其成员对象的实列化推到子类中，子类可以重写父类接口方法以便创建的时候指定自己的对象类型。 </li></ul><p>父类只对创建过程中的一般性问题进行处理，这些处理会被子类继承，子类之间是相互独立的，具体的业务逻辑会放在子类中进行编写。 </p><p>应用场景： </p><p>以下几种情景下工厂模式特别有用： </p><ol><li>对象的构建十分复杂； </li><li>需要依赖具体环境创建不同实例； </li><li>处理大量具有相同属性的小对象。 </li></ol><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>单例模式定义了一个对象的创建过程，此对象只有一个单独的实例，并提供一个访问它的全局访问点。也可以说单例就是保证一个类只有一个实例，实现的方法一般是先判断实例存在与否，如果存在直接返回，如果不存在就创建了再返回，这就确保了一个类只有一个实例对象。</p><p>使用闭包方式来实现单例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> single = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> unique; </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getInstance</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">// 如果该实例存在，则直接返回，否则就对其实例化 </span></span><br><span class="line">    <span class="keyword">if</span>( unique === <span class="literal">undefined</span> )&#123; </span><br><span class="line">      unique = <span class="keyword">new</span> Construct(); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unique; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Construct</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="comment">// ... 生成单例的构造函数的代码 </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> &#123; </span><br><span class="line">    <span class="attr">getInstance</span> : getInstance </span><br><span class="line">  &#125;</span><br><span class="line">&#125;)(); </span><br></pre></td></tr></table></figure><p>unique 是返回对象的引用，而 getInstance 是静态方法获得实例。Construct 是创建实例的构造函数。 </p><p>可以通过 single.getInstance() 来获取到单例，并且每次调用均获取到同一个单例。这就是单例模式所实现的效果。 </p><p>应用场景： </p><ol><li>单例模式是一种常用的模式，有一些对象我们往往只需要一个，比如全局缓存、浏览器的 window 对象。 </li><li>借助单例模式，可以把代码组织的更为一致，方便阅读与维护。 </li></ol><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>// 使用关键字 function 定义函数 </p><p>// 定义函数，吃饭 </p><p>function dada(){ </p><p>console.log(“点餐”); </p><p>console.log(“拿筷子”); </p><p>console.log(“吃东西”)； </p><p>}</p><h2 id="局部变量和全局变量"><a href="#局部变量和全局变量" class="headerlink" title="局部变量和全局变量"></a>局部变量和全局变量</h2><p>变量的作用域</p><ul><li>函数体内的变量：局部变量，仅在函数体内可以使用</li><li>函数体外的变量：全局变量，对全局可见 </li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>return 的含义：将函数的结果返回给当前函数名</p><p>return 使用方法：</p><ul><li>return 只能返回一个数据；</li><li>如果函数中没有 return，则返回 undefined</li><li>return 可以用来结束一个函数 </li></ul><h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>使用函数表达式定义函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;hello&quot;</span>); </span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure><h2 id="自运行函数"><a href="#自运行函数" class="headerlink" title="自运行函数"></a>自运行函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="comment">//这里是代码 </span></span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包 (closure) 有权访问另外一个函数作用域中的变量的函数。 </p><p>创建闭包的常见方式有：</p><ul><li>在一个函数内部创建另外一个函数，并且把这个函数 return 出去。 </li><li>用函数为元素绑定事件，当事件发生时，还可以操作该函数中的变量。 </li></ul><p>特性：</p><ol><li>可以读取其它函数内部的变量 </li><li>让这些变量的值始终保持在内存中 </li></ol><p>示例：</p><ol><li><p>函数内部 return 一个函数 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">run</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> a=<span class="number">10</span>; </span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    a++; </span><br><span class="line">    <span class="built_in">console</span>.log(a); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b=run(); </span><br><span class="line"><span class="comment">//alert(b); </span></span><br><span class="line"><span class="comment">//b 是一个函数b();//可以访问另外一个作用域中变量的函数 </span></span><br></pre></td></tr></table></figure></li><li><p>函数内部为绑定事件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addClick</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">var</span> txt=<span class="string">&quot;abcd&quot;</span>; </span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">&#x27;box&#x27;</span>).onclick=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    alert(txt); </span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br><span class="line">addClick(); </span><br></pre></td></tr></table></figure></li><li><p>函数内部将变量作为回调函数的参数 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">play</span>(<span class="params">num,fn</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(num&gt;<span class="number">10</span>)&#123; </span><br><span class="line">    <span class="keyword">return</span> fn &amp;&amp; fn(num); </span><br><span class="line">  &#125;; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> ss=play(<span class="number">20</span>,<span class="function"><span class="keyword">function</span>(<span class="params">n</span>)</span>&#123; </span><br><span class="line">  <span class="keyword">return</span> n+<span class="number">1</span>; </span><br><span class="line">&#125;); </span><br><span class="line"><span class="built_in">console</span>.log(ss); </span><br></pre></td></tr></table></figure></li></ol><h1 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h1><h2 id="BOM-概述"><a href="#BOM-概述" class="headerlink" title="BOM 概述"></a>BOM 概述</h2><p>BOM（browser object model）浏览器对象模型 </p><p>BOM 提供了独立于内容而与浏览器窗口进行交互的对象、载入页面的相关信息，其核心对象是 window 对象 </p><p>BOM 没有相关标准，每个浏览器都定义了自己的属性，并且，都有其自己对 BOM 的实现方式</p><p>W3C 虽然没有为 BOM 统一制定标准,但是其中的窗口对象、导航对象等，因功能趋同，实际上已经成为默认的标准</p><h2 id="window-方法"><a href="#window-方法" class="headerlink" title="window 方法"></a>window 方法</h2><ul><li>alert() 提示框 </li><li>confirm() 带有确认 取消 按钮的提示框 </li><li>prompt() 带有可输入内容的文本域的提示框 </li><li>setInterval() 间隔定时器，可按照指定的周期（以毫秒计）来调用函数或计算表达式 </li><li>setTimeout() 超时定时器，在指定的毫秒数后调用函数</li><li>clearInterval() 清除间隔定时器 </li><li>clearTimeout() 清除超时定时器 </li><li>requestAnimationFrame 帧定时器 </li></ul><h2 id="frames-框架集"><a href="#frames-框架集" class="headerlink" title="frames [ ] 框架集"></a>frames [ ] 框架集</h2><p>把浏览器窗口分成几个窗框，每个窗框同时取得多个 URL 地址，显示不同网页内容。 </p><h2 id="history-历史记录"><a href="#history-历史记录" class="headerlink" title="history 历史记录"></a>history 历史记录</h2><ul><li>window.history.go(1) 前进（跳转） </li><li>window.history.go(-1) 后退（跳转） </li><li>window.history.forward() 前进 </li><li>window.history.back() 后退 </li></ul><h2 id="location-定位"><a href="#location-定位" class="headerlink" title="location 定位"></a>location 定位</h2><ul><li>window.location.href=’…’ 页面跳转 </li><li>window.location.reload() 页面重载</li></ul><h2 id="navigator-导航"><a href="#navigator-导航" class="headerlink" title="navigator 导航"></a>navigator 导航</h2><p>window.navigator.userAgent 浏览器类型、版本、操作系统类型、浏览器引擎类型等信息 </p><h2 id="screen-屏幕"><a href="#screen-屏幕" class="headerlink" title="screen 屏幕"></a>screen 屏幕</h2><ul><li>window.screen.width 返回当前屏幕宽度(分辨率值) </li><li>window.screen.height 返回当前屏幕高度(分辨率值) </li></ul><h2 id="document-文档"><a href="#document-文档" class="headerlink" title="document 文档"></a>document 文档</h2><p>window 的 document 的属性，代表所有 html 的元素，这部分是 js 主要操作的部分，因此这部分必须规范，才能进行统一开发。因此，W3C 将这部分进行了规范 — DOM 标准。 </p><h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM（document object model ）文档对象模型，定义了表示和修改文档所需的对象、行为和属性，以及这些对象之间的关系。 </p><h2 id="DOM-对象方法"><a href="#DOM-对象方法" class="headerlink" title="DOM 对象方法"></a>DOM 对象方法</h2><ul><li>getElementById(id）通过 id 获取 DOM 对象（对象） </li><li>getElementsByTagName(tag) 通过标签获取 DOM 对象（“类似数组”对象） </li><li>getElementsByName(name) 通过 name 获取 DOM 对象（“类似数组”对象） </li><li>getElementsByClassName(class) 通过 class 获取 DOM 对象（IE8 以下不 支持）</li></ul><h2 id="操作-DOM-间的关系"><a href="#操作-DOM-间的关系" class="headerlink" title="操作 DOM 间的关系"></a>操作 DOM 间的关系</h2><ul><li>createElement(tag) 创建元素 </li><li>removeChild(对象) 删除元素 </li><li>appendChild(对象) 插入元素 </li><li>replaceChild(替换对象，被替换对象) 替换元素 </li><li>insertBefore(对象，目标对象) 前部插入 </li></ul><blockquote><p>appendChild replaceChild insertBefore 都具有移动对象的功能 </p></blockquote><p>节点属性：</p><ul><li>父节点 parentNode </li><li>第一级子节点 childNodes </li><li>第一个子节点 firstChild </li><li>最后一个子节点 lastChild </li><li>前一个兄弟节点 previousSbiling </li><li>后一个兄弟节点 nextSibling </li></ul><p>克隆节点：</p><p>cloneNode (布尔值) </p><ul><li>true：复制本节点以及所有子节点 </li><li>false：只复制节点本身 </li></ul><h2 id="DOM-节点属性"><a href="#DOM-节点属性" class="headerlink" title="DOM 节点属性"></a>DOM 节点属性</h2><ul><li>setAttribute(“属性名”,属性值) 设置属性</li><li>getAttribute( 属性名 ) 获取属性 </li><li>removeAttribute( 属性名 ) 删除属性: </li><li>hasAttributes(属性名) 判断属性是否存在（返回 ture / false）</li></ul><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><ul><li>addEventListener( ) 增加事件监听 </li><li>removeEventListener( ) 删除事件监听 </li></ul><h2 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h2><ol><li>window 事件 <ul><li>onload 加载（某个页面或图像被完成） </li><li>onunload 用户退出页面 </li><li>onresize 窗口或框架被调整尺寸 </li><li>onscroll 滚动条事件 </li></ul></li><li>鼠标事件 <ul><li>onclick 鼠标点击 </li><li>ondblclick 鼠标双击 </li><li>onmousedown 鼠标按键按下 </li><li>onmouseup 鼠标按键被松开 </li><li>onmouseout 鼠标从某元素移开 </li><li>onmouseover 鼠标被移到某元素之上</li><li>onmouseenter 鼠标进入某元素 </li><li>onmouseleave 鼠标离开某元素 </li><li>onmousemove 鼠标移动 </li><li>oncontextmenu 右键菜单 </li></ul></li><li>input 事件 <ul><li>onblur 元素失去焦点 </li><li>onfocus 元素获得焦点</li><li>onchange 内容改变时触发 </li></ul></li><li>键盘事件 <ul><li>onkeydown 按键按下 </li><li>onkeypress 按键按下并释放 </li><li>onkeyup 按键释放 </li></ul></li><li>form 事件 <ul><li>onreset 表单重置（重置按钮） </li><li>onsubmit 表单提交(form 内有 text 被聚焦，直接回车可触发 onsubmit) </li></ul></li></ol><h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><p>获取事件数据，不同的事件会有不同数据 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oDiv.onclick=<span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123; </span><br><span class="line">  <span class="comment">// e 就是事件对象 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="事件流"><a href="#事件流" class="headerlink" title="事件流"></a>事件流</h2><p>事件流方向：捕获 → 事件目标 → 冒泡 </p><p>1）事件捕获 </p><p>2）事件目标 </p><p>3）事件冒泡 与 阻止事件冒泡 </p><h2 id="事件目标"><a href="#事件目标" class="headerlink" title="事件目标"></a>事件目标</h2><ul><li>ev.targrt </li><li>ev.target.nodeName </li><li>ev.target.tagName </li></ul><h2 id="事件委派-delegate"><a href="#事件委派-delegate" class="headerlink" title="事件委派(delegate)"></a>事件委派(delegate)</h2><p>原理：将事件绑定在父级上，利用事件冒泡原理，通过判断事件的“目标元素”来触发父级上绑定的事件 </p><p>作用： </p><ul><li>不用分别为子元素绑定事件 </li><li>为未知元素绑定事件 </li></ul><h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><p>可以为一个元素，同时绑定多个事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">obj.addEventListener(事件，回调函数，冒泡/捕获) ; </span><br><span class="line"></span><br><span class="line">btn.addEventListener(<span class="string">&quot;click&quot;</span>,<span class="function"><span class="keyword">function</span>(<span class="params">ev</span>)</span>&#123; <span class="comment">//ev 事件对象 </span></span><br><span class="line">  alert(<span class="string">&#x27;dadaqianduan&#x27;</span>); </span><br><span class="line">&#125;,<span class="literal">false</span>) </span><br><span class="line"><span class="comment">//false 冒泡阶段</span></span><br></pre></td></tr></table></figure><h1 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h1><p>一款轻量级的 js 库 </p><p>优点：</p><ul><li>丰富的 DOM 选择器 </li><li>简单的事件操作 </li><li>重新封装方法，让操作 DOM 属性更简单 </li><li>链式操作 </li><li>丰富的动画效果 </li><li>Ajax 操作支持 </li><li>浏览器兼容 </li><li>插件扩展开发，可扩展性强 </li></ul><p>缺点：</p><ul><li>不能向后兼容 </li><li>插件兼容性 </li><li>多个插件冲突 </li></ul><h2 id="jQuery-选择器"><a href="#jQuery-选择器" class="headerlink" title="jQuery 选择器"></a>jQuery 选择器</h2><ol><li>id 选择器 $(‘#box’) </li><li>class 选择器 $(‘.box’) </li><li>标记选择器 $(‘p’) </li><li>* 代表所有标签</li></ol><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><ul><li>[attribute] 匹配包含给定属性的元素 </li><li>[attribute=value] 匹配给定的属性是某个特定值的元素 </li><li>[attribute!=value] 匹配给定的属性不是某个特定值的元素 </li><li>[attribute^=value] 匹配给定的属性是以某些值开始的元素 </li><li>[attribute$=value] 配给定的属性是以某些值结尾的元素 </li><li>[attribute*=value] 匹配给定的属性是以包含某些值的元素 </li></ul><h2 id="位置选择器"><a href="#位置选择器" class="headerlink" title="位置选择器"></a>位置选择器</h2><ul><li>:first 匹配第一个元素 </li><li>:last 获取最后一个元素 </li><li>:not 去除所有与给定选择器匹配的元素 </li><li>:even 匹配所有索引值为偶数的元素，从 0 开始计数 </li><li>:odd 匹配所有索引值为奇数的元素，从 0 开始计数 </li><li>:eq 匹配一个给定索引值的元素 </li><li>:gt 匹配所有大于给定索引值的元素 </li><li>:lt 匹配所有小于给定索引值的元素 </li></ul><h2 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h2><p>$(“选择器 1 选择器 2 ……”) </p><h2 id="子代选择器"><a href="#子代选择器" class="headerlink" title="子代选择器"></a>子代选择器</h2><p>$(“选择器 1&gt;选择器 2&gt;……”) </p><h2 id="选择器对象"><a href="#选择器对象" class="headerlink" title="选择器对象"></a>选择器对象</h2><ul><li>$(“选择器”).each(function(index){this}) 选择器对象的遍历 </li><li>$(“选择器”).find() 找前面选择器匹配到的元素的子元素 </li><li>$(“选择器”).not() 在前面选择器匹配到的元素中去除某个或某多个 </li><li>$(“选择器”).add() 在前面选择器中在追加节点 </li></ul><h2 id="子元素"><a href="#子元素" class="headerlink" title="子元素"></a>子元素</h2><ul><li>:first-child 匹配第一个子元素 </li><li>:last-child 匹配最后一个子元素 </li><li>:first-of-type 选择所有相同的元素名称的第一个兄弟元素 </li><li>:last-of-type 选择所有相同的元素名称的最后一个兄弟元素 </li><li>:nth-child 匹配其父元素下的第 N 个子或奇偶元素 </li><li>:nth-last-child() 选择所有他们父元素的第 n 个子元素。计数从最后一个元素开始到第一个 </li><li>:nth-last-of-type() 选择的所有他们的父级元素的第 n 个子元素，计数从最后一个元素到第一个 </li><li>:nth-of-type() 选择同属于一个父元素之下，并且标签名相同的子元素中的第 n 个 </li><li>:only-child 如果某个元素是父元素中唯一的子元素，那将会被匹配 </li><li>:only-of-type 选择所有没有兄弟元素，且具有相同的元素名称的元素。 </li></ul><p>表单</p><ul><li>:input 匹配所有 input, textarea, select 和 button 元素 </li><li>:text 匹配所有的单行文本框 </li><li>:password 匹配所有密码框 </li><li>:radio 匹配所有单选按钮 </li><li>:checkbox 匹配所有复选框 </li><li>:submit 匹配所有提交按钮 </li><li>:image 匹配所有图像域 :reset 匹配所有重置按钮 </li><li>:button 匹配所有按钮 </li><li>:file 匹配所有文件域 </li><li>:hidden 匹配所有隐藏域 </li></ul><p>表单对象属性</p><ul><li>:enabled 匹配所有可用元素 </li><li>:disabled 匹配所有禁用元素 </li><li>:checked 匹配所有选中的被选中元素 </li><li>:selected 匹配所有选中的 option 元素 </li></ul><h2 id="DOM-操作"><a href="#DOM-操作" class="headerlink" title="DOM 操作"></a>DOM 操作</h2><ol><li>查找获取 <ul><li>text() - 设置或返回所选元素的文本内容 </li><li>html() - 设置或返回所选元素的内容 </li><li>val() - 设置或返回表单字段的值 </li></ul></li><li>内部插入 <ul><li>append() 向每个匹配的元素内部追加内容 </li><li>appendTo() 把所有匹配的元素追加到另一个指定的元素集合中 </li><li>prepend() 向每个匹配的元素内部前置内容 </li><li>prependTo() 把所有匹配的元素前置到另一个、指定的元素集合中 </li></ul></li><li>外部插入 <ul><li>after() 在每个匹配的元素之后插入内容 </li><li>before() 在每个匹配的元素之前插入内容 </li><li>insertAfter() 把所有匹配的元素插入到另一个、指定的元素集合的后面 </li><li>insertBefore() 把所有匹配的元素插入到另一个、指定的元素集合的前面</li></ul></li><li>包裹 <ul><li>wrap() 把所有匹配的元素用其他元素的结构化标记包裹起来 </li><li>unwrap() 这个方法将移出元素的父元素。 </li><li>wrapAll() 将所有匹配的元素用单个元素包裹起来 </li><li>wrapInner() 将每一个匹配的元素的子内容(包括文本节点)用一个 HTML 结构包裹起来 </li></ul></li><li>替换 <ul><li>replaceWith() 将所有匹配的元素替换成指定的 HTML 或 DOM 元素 </li><li>replaceAll() 用匹配的元素替换掉所有 selector 匹配到的元素 </li></ul></li><li>删除 <ul><li>empty() 删除匹配的元素集合中所有的子节点 </li><li>remove() 从 DOM 中删除所有匹配的元素 </li></ul></li><li>克隆 <ul><li>clone() 克隆匹配的 DOM 元素并且选中这些克隆的副本 </li></ul></li></ol><h2 id="JQuery-事件"><a href="#JQuery-事件" class="headerlink" title="JQuery 事件"></a>JQuery 事件</h2><p>页面载入 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//简写方式 </span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>事件绑定 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;#box&quot;</span>).on(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; </span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">&quot;#box&quot;</span>).off(<span class="string">&quot;click, mousemove&quot;</span>); </span><br></pre></td></tr></table></figure><h2 id="容器适应"><a href="#容器适应" class="headerlink" title="容器适应"></a>容器适应</h2><p>获取元素的宽高有以下几种方法： </p><ul><li>$(选择器).width() | innerWidth() | outerWidth() </li><li>$(选择器).height() | innerHeight() | outerHeight() </li><li>innerWidth() 和 innerHeight() 是指元素里面内容的宽高加上内边距的宽高； </li><li>outerWidth() 和 outerHeight() 是指元素里面内容的宽高加上内边距的宽高和边框； </li></ul><p>获取窗口的宽高的方法如下：</p><ul><li>$(window).width() </li><li>$(window).height() </li></ul><h2 id="标签样式操作"><a href="#标签样式操作" class="headerlink" title="标签样式操作"></a>标签样式操作</h2><ul><li>$(选择器).css (样式属性名[,值])    方法设置或返回被选元素的一个或多个样式属性 </li><li>$(选择器).addClass(类别名)   增加类别样式 </li><li>$(选择器).removeClass(类别名)   去除类别样式 </li><li>$(选择器).toggleClass(类别名)    交替使用类别样式：有这个类别样式就去除，没有就追加；</li></ul><h2 id="滑动"><a href="#滑动" class="headerlink" title="滑动"></a>滑动</h2><ul><li>show() 显示元素 </li><li>hide() 隐藏元素</li></ul><ul><li>slidDown() 向下滑动显示 </li><li>slideUp() 向上滑动收起隐藏 </li><li>slideToggle() 交替滑动状态 </li></ul><ul><li>fadeIn() 淡入 </li><li>fadeOut() 淡出 </li><li>fadeTo() 动画到指定透明度 </li><li>fadeToggle() 交替淡出、淡入状态 </li></ul><h2 id="自定义动画"><a href="#自定义动画" class="headerlink" title="自定义动画"></a>自定义动画</h2><ul><li>animate() 自定义动画 </li><li>stop() 停止所有在指定元素上正在运行的动画 </li><li>delay() 设置一个延时来推迟执行队列中之后的项目 </li><li>finish() 停止当前正在运行的动画，删除所有排队的动画，并完成匹配元素所有的动画 </li></ul><h2 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h2><ul><li>$.ajax() </li><li>$.get() 通过远程 HTTP GET 请求载入信息 </li><li>$.post() 通过远程 HTTP POST 请求载入信息 </li><li>$.getJSON() 通过 HTTP GET 请求载入 JSON 数据</li></ul><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX = 异步 JavaScript 和 XML </p><h2 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h2><p>在浏览器中输入 url 地址请求服务器时，是通过 Ajax 发送 http 请求给服务器，服务的响应结果也是先返回给 Ajax，先 Ajax 处理之后在返回给浏览器显示在页面。 </p><h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><p>第一步： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr = <span class="keyword">new</span> XMLHttpRequest(); </span><br></pre></td></tr></table></figure><p>第二步 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(<span class="string">&quot;post&quot;</span>, <span class="string">&quot;test.php&quot;</span>); </span><br></pre></td></tr></table></figure><p>第三步： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br></pre></td></tr></table></figure><p>第四步： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(<span class="string">&quot;a=1&amp;b=2&quot;</span>);</span><br></pre></td></tr></table></figure><p>第五步： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="keyword">if</span>(xhr.status==<span class="number">200</span> &amp;&amp; xhr.readyState==<span class="number">4</span>)&#123; </span><br><span class="line">    <span class="keyword">var</span> result=xhr.responseText;<span class="comment">//获取到结果 </span></span><br><span class="line">    alert(result); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="XML-和-HTML-的区别"><a href="#XML-和-HTML-的区别" class="headerlink" title="XML 和 HTML 的区别"></a>XML 和 HTML 的区别</h2><p>XML：所有的标记必须成对出现，且区分大小写</p><p>HTML：不是所有的都需要成对出现，不区分大小写</p><h2 id="get-和-post"><a href="#get-和-post" class="headerlink" title="get() 和 post()"></a>get() 和 post()</h2><p>$.get(url,data,callback,dataType) </p><p>$.post(url,data,callback,dataType) </p><p>Ajax 的基本格式如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="attr">url</span>:<span class="string">&#x27;请求的资源&#x27;</span>,</span><br><span class="line">  <span class="attr">type</span>:<span class="string">&#x27;请求方式 get|post&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>:<span class="string">&#x27;发送数据 名=值&amp;名=值&#x27;</span>,</span><br><span class="line">  <span class="attr">dataType</span>:<span class="string">&#x27;回传值的类型&#x27;</span>,</span><br><span class="line">  <span class="attr">success</span>:<span class="function"><span class="keyword">function</span>(<span class="params">res</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// res 接收返回值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h1><p>HTTP（超文本传输协议）是一种通信协议，它允许将超文本标记语言（HTML）文档从 Web 服务器传送到客户端的浏览器。</p><h2 id="HTTP-消息结构"><a href="#HTTP-消息结构" class="headerlink" title="HTTP 消息结构"></a>HTTP 消息结构</h2><ul><li>request line <ul><li>请求行：第一行必须是请求行，用来说明请求类型、要访问的资源以及使用的HTTP 版本 </li></ul></li><li>header <ul><li>请求头：用来说明服务器要使用的附加信息 </li></ul></li><li>blank line <ul><li>空白行：请求头部与请求体之间必须有一个空白行，必不可少 </li></ul></li><li>body <ul><li>请求体：也叫请求正文，可以添加任意的其他数据 </li></ul></li></ul><p>状态行： </p><ul><li>Host 接受请求的服务器地址，可以是：IP：端口 或 域名 </li><li>User-Agent 发送请求的应用程序名称（浏览器信息） </li><li>Connection 指定与连接相关的属性，如：Connection:Keep-Alive </li><li>Accept-Charset 客户端可以接受的编码格式 </li><li>Accept-Encoding 客户端可以接受的数据压缩格式 </li><li>Accept-Language 客户端可以接受的语言 </li><li>referer 当前请求来自哪个链接（防盗连） </li><li>content-type 请求的文件类型 </li><li>cookie 该网站相关的会话信息 </li></ul><h2 id="url-请求过程"><a href="#url-请求过程" class="headerlink" title="url 请求过程"></a>url 请求过程</h2><ol><li>首先客户端与服务器需要建立连接。</li><li>建立连接后，客户端发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，客户端信息和可能的内容。 </li><li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码（status Code 状态码），后边服务器信息、实体信息和可能的内容。 </li><li>客户端接收完, 服务器所返回的信息后，与服务器断开连接。 </li></ol><blockquote><p>如果在以上过程中的某一步出现错误，那么产生错误的信息将返回到客户端。对于用户来说，这些过程是由 HTTP 自己完成的，用户只要用鼠标点击，等待信息显示就可以了。 </p></blockquote><h1 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h1><p>预加载：将所有所需的资源提前请求加载到本地，后面在需要使用就直接从缓存中存取资源 </p><ol><li><p>使用 image 对象 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none&quot;</span>/&gt;</span> </span><br></pre></td></tr></table></figure></li><li><p>使用 image 对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> image = <span class="keyword">new</span> Image(); </span><br><span class="line">image.src=<span class="string">&quot;&quot;</span>; </span><br></pre></td></tr></table></figure></li><li><p>使用 XMLHttpRequest 对象 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">xmlhttprequest.onreadystatechange = callback;</span><br><span class="line">xmlhttprequest.onprogress = progressCallback;</span><br><span class="line">xmlhttprequest.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&#x27;http://xx.jpg,true&#x27;</span>);</span><br><span class="line">xmlhttprequest.send();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callback</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(xmlhttprequest.readyState = <span class="number">4</span> &amp;&amp; xmlhttprequest.status == <span class="number">200</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> responseText = xmlhttprequest.responseText;</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Request was unsuccessful&quot;</span> + xmlhttprequest.status);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">progressCallback</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">  c = e || event;</span><br><span class="line">  <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Received&quot;</span> + e.loaded + <span class="string">&quot;of&quot;</span> + e.total + <span class="string">&quot;bytes&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h1><p>首屏加载，技术上显示要用的技术就是图片懒加载，即到可视区域再加载。 </p><h1 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h1><h2 id="JavaScript-代码优化"><a href="#JavaScript-代码优化" class="headerlink" title="JavaScript 代码优化"></a>JavaScript 代码优化</h2><ol><li>代码与结构分离 </li><li>样式与结构的分离 </li><li>数据与代码分离 </li></ol><p>AMD：Asynchronous Module Definition，即异步模块加载机制。 </p><p>CMD：Common Module Definition，即通用模块定义规范 </p><p>导出（export）与 导入（import）两个模块 </p><h2 id="提升文件加载速度"><a href="#提升文件加载速度" class="headerlink" title="提升文件加载速度"></a>提升文件加载速度</h2><ol><li>合并 JavaScript 代码，尽可能少的使用 script 标签。 </li><li>无堵塞加载 JavaScript </li><li>动态创建 script 标签来加载 </li></ol><h1 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h1><p>webpack 是一个 module bundler（模块构建工具），由于 JavaScript 应用程序的复杂性不断增加，构建工具已成为 web 开发中不可或缺的一部分。它帮助我们去打包、编译和管理项目需要的众多资源文件和依赖库。 </p><p>webpack 支持 CommonJS、AMD 和 ES6 模块系统，并且兼容多种 JS 书写规范，可以处理模块间的依赖关系，所以具有更强大的 JS 模块化的功能，它能压缩图片，对 CSS、js 文件进行语法检查、压缩、编译打包。 </p><h2 id="webpack-的特点"><a href="#webpack-的特点" class="headerlink" title="webpack 的特点"></a>webpack 的特点</h2><ol><li>可以很好的用于单页应用 </li><li>同时支持 require() 和 import 模块语法 </li><li>允许非常前沿的 code splitting（代码分割） 特性 </li><li>热加载可以让 React、Vue.js 和其它类似框架的本地开发更快 </li><li>它是目前最受欢迎的构建工具 </li></ol><h2 id="webpack-的缺点"><a href="#webpack-的缺点" class="headerlink" title="webpack 的缺点"></a>webpack 的缺点</h2><ol><li>不适合 web 开发的初学者 </li><li>对于 CSS、图片和其它非 JS 资源文件时，需要先混淆处理 </li><li>文档不够完善 </li><li>变化很大，不同版本的使用方法存在较大差异</li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>全局安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//安装全局 webpack </span></span><br><span class="line">npm install webpack -g </span><br><span class="line"></span><br><span class="line"><span class="comment">//安装全局 webpack-cli </span></span><br><span class="line">npm install webpack-cli -g </span><br></pre></td></tr></table></figure><h2 id="webpack-基本应用"><a href="#webpack-基本应用" class="headerlink" title="webpack 基本应用"></a>webpack 基本应用</h2><p>SPA（single page web application） 单页应用程序，是 webpack 打包的典型应用示例，主要的几个部分组成： </p><ul><li>index.html    主文件 </li><li>JS 文件    可能有多个 JS 文件，可通过 webpack 合并打包为一个文件 </li><li>CSS 文件    可能有多个 CSS 文件，可通过 webpack 合并打包为一个文件 </li><li>图片    可通过 webpack 压缩优化 </li></ul><p>dist 文件夹（存放打包后的文件，可以先不创建，打包时可以自动创建） </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-dis,dist,bulit </span><br></pre></td></tr></table></figure><p>打包： </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">webpack --mode development </span><br></pre></td></tr></table></figure><h2 id="配置文件入门"><a href="#配置文件入门" class="headerlink" title="配置文件入门"></a>配置文件入门</h2><p>默认的配置文件名为：webpack.config.js </p><p>核心概念</p><p>一个配置文件的基本结构如下： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//配置项</span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  <span class="comment">//入口</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">//输出配置</span></span><br><span class="line">  <span class="attr">output</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">//模块</span></span><br><span class="line">  <span class="attr">module</span>: &#123;&#125;,</span><br><span class="line">  <span class="comment">//解析</span></span><br><span class="line">  resolve：&#123;&#125;,</span><br><span class="line">  <span class="comment">//插件（数组）</span></span><br><span class="line">  <span class="attr">plugins</span>: [],</span><br><span class="line">  <span class="comment">//开发服务器</span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>entry 入口 定义入口文件，默认入口文件：./src/index.js </li><li>output 输出 定义出口文件，默认出口文件：./dist/main.js </li><li>resolve 解析 路径映射、省略后缀名等 </li><li>module 模块 定义不同 loader，让 webpack 能够处理非 JavaScript 模块 </li><li>plugins 插件 扩展 webpack 功能 </li><li>devServer 开发服务器 用于配置 webpack-dev-server 选项 </li></ul><p>设置配置文件自动完成： </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack 是基于 node 构建的，只支持 CommonJS 模块 </span></span><br><span class="line"><span class="built_in">module</span>.exports=&#123;</span><br><span class="line">  <span class="comment">// 入口配置 </span></span><br><span class="line">  <span class="attr">entry</span>:<span class="string">&#x27;./src/js/main.js&#x27;</span>, </span><br><span class="line">  <span class="comment">// 出口配置 </span></span><br><span class="line">  <span class="attr">output</span>:&#123; </span><br><span class="line">    <span class="attr">path</span>:__dirname +<span class="string">&#x27;/dist&#x27;</span>, <span class="comment">// 输出目录 </span></span><br><span class="line">    <span class="comment">// __dirname:本文件所在硬盘 </span></span><br><span class="line">    <span class="comment">// 路径（node 全局变量） </span></span><br><span class="line">    <span class="attr">filename</span>:<span class="string">&#x27;js/main.js&#x27;</span> <span class="comment">// 文件名称（可以有子目录） </span></span><br><span class="line">  &#125; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>修改 webpack.json 文件 </p><p>在 webpack.json 中的”scripts”下增加： </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123; </span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack --mode development&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span></span><br><span class="line">&#125;, </span><br></pre></td></tr></table></figure><p>执行打包</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run dev </span><br></pre></td></tr></table></figure><h2 id="entry-和-output"><a href="#entry-和-output" class="headerlink" title="entry 和 output"></a>entry 和 output</h2><ol><li>entry 入口配置 是指页面中的入口文件。也就是打包从哪个文件开始。默认入口文件：./src/index.js </li><li>output 出口配置 是指生成的文件输出到哪个地方去，默认出口文件：./dist/main.js，主要有以下属性：<ul><li>path 输出路径 </li><li>filename 输出文件名 </li></ul></li></ol><h2 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h2><p>webpack 只能打包 js 文件（只理解 JavaScript 语法），无法识别其他语法的文件，如果要让 webpack 打包其他文件，首先需要让 webpack 识别不同文件，这就需要特别的模块，这种模块统称为 loader。 </p><h3 id="loader-分类"><a href="#loader-分类" class="headerlink" title="loader 分类"></a>loader 分类</h3><ul><li>转换编译  script-loader，babel-loader，ts-loader，coffee-loader </li><li>处理样式  style-loader ， css-loader ， less-loader ， sass-loader ，postcss-loader </li><li>处理文件  raw–loader，url-loader，file-loader </li><li>处理数据  csv-loader，xml-loader </li><li>处理模板语言  html-loader，pug-loader，jade-loader，markdown-loader </li><li>清理和测试  mocha-loader，eslint-loader</li></ul><h3 id="常用-loader"><a href="#常用-loader" class="headerlink" title="常用 loader"></a>常用 loader</h3><ul><li>css-loader  解析 css 语句 </li><li>style-loader  将 css-loader 解析后的文本，添加 <code>&lt;style&gt;</code> 标签 </li><li>babel-loader  将 ES6+、JSX 语法转成 ES5 低版本语法 </li><li>url-loader  对未设置或者小于 limit byte 设置的图片以 base64 的格式进行转换，对于大于 limit byte 的图片用 file-loader 进行解析 </li><li>file-loader  解析项目中的 url 引入（包括 img 的 src 和 background 的 url）修改打包后文件引用路径，使之指向正确的文件 </li><li>less-loader less 编译器 </li><li>vue-loader  Vue 也推出了自己的 vue-loader，可以方便的打包 .vue 文件 的代码在 vue-cli（快速构建单页应用的脚手架）中得到应用。 </li></ul><h4 id="css-loader"><a href="#css-loader" class="headerlink" title="css loader"></a>css loader</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//index.js </span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;./a.js&quot;</span>; </span><br><span class="line"><span class="keyword">import</span> b <span class="keyword">from</span> <span class="string">&quot;./b.js&quot;</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> txt = <span class="string">&quot;hello world&quot;</span>; </span><br><span class="line">a.run(); </span><br><span class="line">b.play(txt);<span class="comment">//打包 css 文件 </span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;./style.css&quot;</span>; <span class="comment">//注意：是相对路径</span></span><br></pre></td></tr></table></figure><p>安装 loader（loader 也是依赖包，需要安装） </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install css-loader style-loader --save-dev </span><br></pre></td></tr></table></figure><p>在 module 中定义 ccs 模块相关的配置： </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">module: &#123;</span><br><span class="line">  rules: [</span><br><span class="line">    &#123;</span><br><span class="line">      test: /.css$/, <span class="comment">// 正则</span></span><br><span class="line">      <span class="comment">// 把 css 添加到 html 的 style 标签里(style-loader 要先加载)</span></span><br><span class="line">      loader: [<span class="string">&#x27;style-loader&#x27;</span>,<span class="string">&#x27;css-loader&#x27;</span>], <span class="comment">// loader 或者 use</span></span><br><span class="line">      exclude: /node_modules/, <span class="comment">// 正则 排除 node_modules 目录</span></span><br><span class="line">    &#125;</span><br><span class="line">  ] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="babel-loader"><a href="#babel-loader" class="headerlink" title="babel loader"></a>babel loader</h4><p>babel 是一个 js 编译器，它通过语法转换器支持最新版本的 JavaScript（包括 JSX、TypeScript 等新语法）。 这些插件允许你立刻使用新语法，无需等待浏览器支持。 </p><p>使用 Babel 首先要配置 .babelrc 文件，该文件用来设置转码规则和插件（ json 格式），存放在项目的根目录下。</p><blockquote><p>tips：在 linux 系统中，rc 结尾的文件通常代表运行时自动加载的 文件、配置 等等。 </p></blockquote><p>在 .babelrc 配置文件中，主要是对 预设（presets）和 插件（plugins）进行配置。</p><p>.babelrc 配置文件一般为如下： </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;presets&quot;</span>: [</span><br><span class="line">    [<span class="string">&quot;env&quot;</span>, &#123; <span class="string">&quot;modules&quot;</span>: <span class="literal">false</span> &#125; ] <span class="comment">// modules 是配置项</span></span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;plugins&quot;</span>: [</span><br><span class="line">    [ <span class="string">&quot;transform-runtime&quot;</span>, &#123; <span class="string">&quot;polyfill&quot;</span>: <span class="literal">false</span>&#125; ] <span class="comment">// polyfill 是配置项</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>预设 对 js 最新的语法糖进行编译，并不负责转译新增的 api 和全局对象。 </li><li>插件 控制如何转换代码，babel 默认只转换新的 js 语法，而不转换新的 API </li></ul><h2 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h2><p>插件（plugins）可以扩展 webpack 的功能，</p><p>loader 不能做的处理都能交给 plugin 来做。 </p><p>如：HtmlWebpackPlugin 插件简化了 HTML 文件的创建，可以通过模板文件，生成一个 HTML 文件 </p><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>resolve（译：解析）配置 webpack 如何寻找模块对应的文件。 </p><p>alias（译：别名）通过别名将原来导入路径映射成一个新的导入路径 extensions（译：扩展）数组 导入模块时，可以省略的文件后缀名 </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">  alias: &#123;</span><br><span class="line">    <span class="string">&quot;@&quot;</span>: path.join(__dirname, <span class="string">&quot;./src&quot;</span>) <span class="comment">// 将项目根目录下的 src 目录，映射为 @</span></span><br><span class="line">  &#125;,</span><br><span class="line">  extensions: [<span class="string">&quot;.js&quot;</span>, <span class="string">&quot;.json&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他配置项示例： </p><ul><li>devtool  是否生成以及如何生成 sourcemap </li><li>devserver  开启一个本地开发服务器 </li><li>watch  监听文件变化并自动打包 </li><li>watchoption  用来定制 watch 模式的选项 </li><li>performance  打包后命令行如何展示性能提示，如果超过某个大小是警告还是报错</li></ul><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack-dev-server 是一个小型的 web 服务器，可以自动监视项目文件的变化，自动刷新浏览器，其 HMR（Hot Module Replacement 热模块替换）方式只替换更新的部分，而不是重载页面，大大提高了刷新效率。 </p><p>需要本地安装 webpack 和 webpack-cli </p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack webpack-cli webpack-dev-server --save-dev </span><br></pre></td></tr></table></figure><p>webpack.config.js 配置文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> path=<span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>); </span><br><span class="line"></span><br><span class="line"><span class="comment">// HtmlWebpackPlugin 插件</span></span><br><span class="line"><span class="keyword">let</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&#x27;html-webpack-plugin&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>, <span class="comment">// 生成的新文件</span></span><br><span class="line">  <span class="attr">template</span>: __dirname + <span class="string">&quot;/src/index_temp.html&quot;</span>, <span class="comment">// 模板文件</span></span><br><span class="line">  <span class="attr">minify</span>: &#123; <span class="comment">//压缩</span></span><br><span class="line">    <span class="attr">removeComments</span>: <span class="literal">true</span>, <span class="comment">// 刪除注释</span></span><br><span class="line">    <span class="attr">collapseWhitespace</span>: <span class="literal">true</span> <span class="comment">// 合并空格</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//配置项</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="comment">//输入</span></span><br><span class="line">  <span class="attr">entry</span>: <span class="string">&#x27;./src/js/main.js&#x27;</span>, <span class="comment">// 主入口文件 </span></span><br><span class="line"></span><br><span class="line">  <span class="comment">//输出 </span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: __dirname + <span class="string">&quot;/dist&quot;</span>, <span class="comment">// 打包后的文件存放的地方</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;main.js&quot;</span> <span class="comment">// 打包后输出的文件名</span></span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//模块</span></span><br><span class="line">  <span class="attr">module</span>: &#123;</span><br><span class="line">    <span class="attr">rules</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/.css$/</span>, <span class="comment">//正则 解析 css 文件</span></span><br><span class="line">        <span class="comment">// 把 css 添加到 html 的 style 标签里(style-loader 要先加载) </span></span><br><span class="line">        use: [<span class="string">&#x27;style-loader&#x27;</span>, <span class="string">&#x27;css-loader&#x27;</span>],</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="comment">// 正则 必须要写 exclude！！</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">test</span>: <span class="regexp">/\.js$/</span>,</span><br><span class="line">        use: <span class="string">&#x27;babel-loader&#x27;</span>,</span><br><span class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span>, <span class="comment">// 正则 必须要写 exclude！！</span></span><br><span class="line">      &#125;]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插件</span></span><br><span class="line">  <span class="attr">plugins</span>:[</span><br><span class="line">    htmlPlugin</span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 解析</span></span><br><span class="line">  <span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: path.join(__dirname, <span class="string">&quot;./src&quot;</span>) <span class="comment">// 将项目根目录下的 src 目录，映射为 &quot;@&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">extensions</span>:[<span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.json&#x27;</span>]</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开发服务器 </span></span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">inline</span>: <span class="literal">true</span>, <span class="comment">// 支持 dev-server 自动刷新</span></span><br><span class="line">    <span class="attr">port</span>: <span class="string">&quot;8080&quot;</span>, <span class="comment">// 端口</span></span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,   <span class="comment">// 自动打开默认浏览器</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123; </span><br><span class="line">  <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack-dev-server --hot&quot;</span>, </span><br><span class="line">  <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><h2 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h2><p>MVC 模式是移动最广泛的软件架构之一，把应用程序强制性地划分为三部分：模型（Model）、视图（View）和控制器（Controller）。 </p><h2 id="MVVM-模式"><a href="#MVVM-模式" class="headerlink" title="MVVM 模式"></a>MVVM 模式</h2><p>MVVM 模式是把 MVC 模式的 Controller 改成 ViewModel。View 的变化会自动更新 ViewModel，ViewModel 的变化也会自动同步到 View 上显示。 </p><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><ul><li>el   把 Vue 实例挂载到 DOM 元素上，通过 id 绑定 html 元素 </li><li>data  数据对象，Vue 实例的数据（注意：数据不要与 methods 中的方法重名）</li><li>methods  事件对象，包含事件所要触发的函数（注意：方法名不要与 data 中的数据重名） </li><li>computed  计算属性 </li><li>watch  监听器 </li><li>directives  自定义指令 </li><li>钩子（hook）函数（8 个）  hook（钩子）函数，不同生命周期引发的动作 </li><li>路由钩子函数（3 个）  路由组件在不同状态时触发 </li><li>components  组件容器 </li><li>template  定义模板，可以是字符串，也可以是”#“选择器 </li><li>props  用于接收来自父组件的数据</li><li>router  路由 </li><li>store  vuex 状态 </li></ul><h2 id="实例属性-方法"><a href="#实例属性-方法" class="headerlink" title="实例属性/方法"></a>实例属性/方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>vm.$el  Vue 实例使用的根 DOM 元素 </li><li>vm.$data  Vue 的 data 配置项 </li><li>vm.$options  用于当前 Vue 实例的初始化选项 </li><li>vm.$props  当前组件接收到的 props 对象 </li><li>vm.$parent  父实例（如果当前实例有的话） </li><li>vm.$root  当前组件树的根 Vue 实例 </li><li>vm.$children  当前实例的直接子组件 </li><li>vm.$refs  原生 DOM 元素或子组件注册引用信息 </li><li>vm.$slots  用来访问被插槽分发的内容 </li><li>vm.$router  全局路由（vue-router 插件） </li><li>vm.$store vuex  状态对象（vuex 插件）</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li>vm.$emit()  子组件可以使用 $emit 触发父组件的自定义事件 </li><li>vm.$set()  Vue.set 的别名，设置对象的属性， 这个方法主要用于避开 Vue 不能检测属性被添加的限制 </li><li>vm.$watch  侦听数据变化vm.$on() 监听当前实例上的自定义事件。事件可以由 vm.$emit 触发。回调函数会接收所有传入事件触发函数的额外参数。 </li><li>vm.$mount  可以使用 vm.$mount() 手动挂载（Vue 实例化时没有 el 选项） </li><li>vm.$destroy  完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。 触发 beforeDestroy 和 destroyed 的钩子。 </li></ul><h2 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h2><p>v-bind 动态改变 dom 标签上的属性</p><p><code>v-bind:class=&quot;&quot;</code>  简写  <code>:class=&quot;&quot;</code>  </p><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><p>4 个阶段：创建 → 挂载 → 更新 → 销毁 </p><p>beforeCreate  实例创建前 </p><p>created  实例创建后 初始化数据（Ajax 数据请求，获取 Vuex 状态、路由切换等） </p><p>beforeMount  载入前 </p><p>mounted  载入后 需要操作 DOM 时（应用第三方插件等） </p><p>beforeUpdate  更新前 </p><p>updated  更新后 通过事件修改数据、v-model 引发数据变化、AJAX 异步更新数据</p><p>beforeDestroy  实例销毁前 </p><p>destroyed  实例销毁后 切换路由（组件将被销毁） </p><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。 </p><p>计算属性具有缓存 </p><h2 id="数组的更新检查"><a href="#数组的更新检查" class="headerlink" title="数组的更新检查"></a>数组的更新检查</h2><p>变异方法，可触发视图更新</p><ul><li>push()、pop()、shift()、unshift()、splice()、sort()、reverse() </li></ul><p>非变异方法，不触发视图更新 </p><ul><li>filter(), concat() 和 slice() </li><li>它们可以返回新数组，用新数组替换旧数组，就可以刷新视图 </li></ul><h2 id="事件对象-1"><a href="#事件对象-1" class="headerlink" title="事件对象"></a>事件对象</h2><p>event.type 触发的事件类型 </p><p>event.target 触发事件的 HTML 元素 </p><p>event.preventDefault( ) 阻止事件的默认行为 </p><p>event.stopPropagation( ) 阻止事件冒泡 </p><h2 id="Vue-组件"><a href="#Vue-组件" class="headerlink" title="Vue 组件"></a>Vue 组件</h2><p>创建组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> myTemp = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;#temp&#x27;</span>, <span class="comment">// 模板 id</span></span><br><span class="line">  <span class="attr">data</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// 必须为 函数(闭包)</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 必须有 return，返回值为 对象&#123;&#125;</span></span><br><span class="line">      <span class="attr">title</span>: <span class="string">&quot;dadaqianduan&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注册组件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 components 配置项中注册组件</span></span><br><span class="line"><span class="keyword">let</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#box&quot;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123; myTemp &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局注册组件，还可以使用 Vue.component 方法（仅限全局注册，不建议使用）</span></span><br><span class="line">Vue.component(<span class="string">&#x27;myTemp&#x27;</span>, MyTemp);</span><br></pre></td></tr></table></figure><p>使用组件 </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--在 Vue 实例中使用组件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;box&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--组件名如果用驼峰定义，改为短横线命名--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-temp</span>&gt;</span><span class="tag">&lt;/<span class="name">my-temp</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>事件通信 </p><p>父子组件之间的数据操作，是通过 <strong>props</strong> 属性和 <strong>$emit()</strong> 方法来实现的 </p><h2 id="路由使用"><a href="#路由使用" class="headerlink" title="路由使用"></a>路由使用</h2><p>定义路由包括路由路径（path）、路由名称（name）、路由组件对象（component） </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">    <span class="comment">// 路由路径</span></span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;home&#x27;</span>,</span><br><span class="line">    <span class="comment">// 路由名称</span></span><br><span class="line">    <span class="attr">component</span>: Home</span><br><span class="line">    <span class="comment">// 路由组件对象</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UserComponent</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;about&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>( <span class="string">&#x27;./views/About.vue&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>动态路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&#x27;/users/:username/post/:postid&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;Users&#x27;</span>,</span><br><span class="line">    <span class="attr">component</span>: UserComponent,</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><blockquote><p>/user/:username  –&gt;  /user/tom </p><p>{ username: ‘tom’ } </p></blockquote><blockquote><p>/user/:username/post/:postId  –&gt;  /user/tom/post/3 </p><p>{ username: ‘tom’, postId: ‘3’ }</p></blockquote><h2 id="路由导航"><a href="#路由导航" class="headerlink" title="路由导航"></a>路由导航</h2><h3 id="路由导航守卫"><a href="#路由导航守卫" class="headerlink" title="路由导航守卫"></a>路由导航守卫</h3><p>路由导航守卫可以简单理解为路由组件的生命周期回调函数。 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 作用：在第一次进入当前路由组件之前被调用</span></span><br><span class="line"><span class="comment">// 使用场景：获取 ajax 数据</span></span><br><span class="line"><span class="function"><span class="title">beforeRouteEnter</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// to：表示要进入的路由组件</span></span><br><span class="line">  <span class="comment">// from：表示将要离开的路由组件</span></span><br><span class="line">  <span class="comment">// next：表示后续操作函数</span></span><br><span class="line">  <span class="comment">// 此时还未进入到组件中，故不能使用 this 获取当前组件的实例</span></span><br><span class="line">  next(<span class="function"><span class="keyword">function</span>(<span class="params">app</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 进入到当前组件后，才执行的回调</span></span><br><span class="line">    <span class="comment">// 此时回调参数 app 表示当前组件的实例对象</span></span><br><span class="line">    axios.get(<span class="string">&#x27;/users/&#x27;</span> + app.id).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      app.user = res.data.data;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">beforeRouteUpdate</span>(<span class="params">to, <span class="keyword">from</span>, next</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// 此时，可以使用 this 表示当前组件对象</span></span><br><span class="line">  <span class="keyword">const</span> app = <span class="built_in">this</span>;</span><br><span class="line">  <span class="comment">// 发送 ajax 请求</span></span><br><span class="line">  <span class="comment">// this 表示切换前的状态</span></span><br><span class="line">  <span class="comment">// to 表示要切换到的路由对象 route</span></span><br><span class="line">  axios.get(<span class="string">&#x27;/users/&#x27;</span> + to.params.id).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    app.user = res.data.data;</span><br><span class="line">  &#125;); <span class="comment">// 执行后续</span></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编程式路由导航"><a href="#编程式路由导航" class="headerlink" title="编程式路由导航"></a>编程式路由导航</h3><ul><li>push() 跳转到指定的路由地址， 并把当前地址写入到 history 中，参数可以是字符串路径或描述地址信息的对象 <ul><li>字符串 router.push(‘home’) </li><li>对象 router.push({path:’home’}) </li><li>命名的路由 router.push({name:user,params:{userId:1}}) </li></ul></li><li>replace( )：跳转到指定路由，它不会向 history 添加新记录，而是替换掉当前的 history 记录。 </li></ul><h3 id="全局路由导航守卫"><a href="#全局路由导航守卫" class="headerlink" title="全局路由导航守卫"></a>全局路由导航守卫</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">children: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: 路由名</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;路径名&quot;</span>,</span><br><span class="line">    <span class="attr">component</span>: 路由名</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="命名视图"><a href="#命名视图" class="headerlink" title="命名视图"></a>命名视图</h2><p>使用 <code>&lt;router-view&gt;</code> 可以使用 name 属性为其设置名称，即命名路由的视图简称命名视图。 </p><p>示例： </p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">router-view</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">router-view</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span> </span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;./views/About.vue&#x27;</span>;</span><br><span class="line">routes: [</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;about&quot;</span>,</span><br><span class="line">    <span class="attr">components</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: About,</span><br><span class="line">      <span class="attr">content</span>: UserComponent</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> DOM </tag>
            
            <tag> BOM </tag>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
            <tag> CSS </tag>
            
            <tag> webpack </tag>
            
            <tag> CSS3 </tag>
            
            <tag> vue </tag>
            
            <tag> jQuery </tag>
            
            <tag> AJAX </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端面试复习</title>
      <link href="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/"/>
      <url>/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="前端基础"><a href="#前端基础" class="headerlink" title="前端基础"></a>前端基础</h1><h2 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// AgoniLay</span></span><br></pre></td></tr></table></figure><p>Person 就是一个构造函数，使用 new 创建了一个实例对象 person。</p><h4 id="prototype"><a href="#prototype" class="headerlink" title="prototype"></a>prototype</h4><p>每一个函数都有一个 prototype 属性，指向正在调用该构造函数而创建的实例的<strong>原型</strong>（每一个 JavaScript 对象(null 除外)在创建的时候会与另一个对象关联，也就是原型，每一个对象都会从原型上继承属性）。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065312e706e67.png" class title="原型和构造函数"><h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>每一个JavaScript对象(null除外)都具有一个属性，也就是 <code>__proto__</code>，这个属性指向该对象的原型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="built_in">console</span>.log(person.__proto__ === Person.prototype) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>关系图：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065322e706e67.png" class title="实例与实例原型的关系图"><blockquote><p>绝大部分浏览器都支持这个非标准的方法访问原型，但并不存在于 Person.prototype 中，而是来自于 Object.prototype，与其说是一个属性，不如说是一个 getter/setter，当使用 <code>obj.__proto__</code> 时，可以理解为返回了 <code>Object.getPrototypeOf(obj)</code>。</p></blockquote><h4 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h4><p>一个构造函数可以生成多个实例，原型没有属性指向实例，但有原型指向构造函数的属性 <code>constructor</code>，每个原型都有一个 constructor 属性指向关联的构造函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(Person === Person.prototype.constructor) <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065332e706e67.png" class title="实例原型与构造函数的关系图"><p>综上：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.__proto__ === Person.prototype <span class="comment">// true</span></span><br><span class="line">Person.prototype.constructor === Person <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 一个 ES5 的方法，可以得到对象的原型</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(person) === Person.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220124151146083.png" class title="image-20220124151146083"><h4 id="原型链和继承"><a href="#原型链和继承" class="headerlink" title="原型链和继承"></a>原型链和继承</h4><p>当读取实例的属性时，如果找不到，就会查找与对象关联的原型中的属性，如果还查不到，就去找原型的原型，一直找到最顶层为止。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.name = <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;agoni&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name</span><br><span class="line"><span class="built_in">console</span>.log(person.name) <span class="comment">// &#x27;AgoniLay&#x27;</span></span><br></pre></td></tr></table></figure><p>原型的最顶层是 <code>Object</code>，<code>Object</code> 的原型是 null</p><blockquote><p>null 表示“没有对象”，即此处不应该有值。参考：<a href="http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html">undefined 和 null</a> </p></blockquote><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f63646e2e6a7364656c6976722e6e65742f67682f6d717971696e6766656e672f426c6f672f496d616765732f70726f746f74797065352e706e67.png" class title="原型链示意图"><p>上图中由相互关联的原型组成的链状结构就是原型链（蓝色的那条）。</p><blockquote><p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，而是在两个对象之间创建一个关联，这样一个对象就可以通过委托访问另一个对象的属性和函数，所以其实叫委托更准确。</p></blockquote><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><h4 id="原型链继承"><a href="#原型链继承" class="headerlink" title="原型链继承"></a>原型链继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child.getName() <span class="comment">// &#x27;AgoniLay&#x27;</span></span><br></pre></td></tr></table></figure><p>注意：</p><ol><li>引用类型的属性将被所有实例共享；</li><li>在创建 Child 实例时，不能向 Person 传参</li></ol><h4 id="借用构造函数-经典继承"><a href="#借用构造函数-经典继承" class="headerlink" title="借用构造函数(经典继承)"></a>借用构造函数(经典继承)</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.names = [<span class="string">&#x27;agoni&#x27;</span>, <span class="string">&#x27;lay&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child()</span><br><span class="line">child1.names.push(<span class="string">&#x27;AgoniLay&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1.names) <span class="comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;, &#x27;AgoniLay&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child()</span><br><span class="line"><span class="built_in">console</span>.log(child2.names) <span class="comment">// [&#x27;agoni&#x27;, &#x27;lay&#x27;]</span></span><br></pre></td></tr></table></figure><p>优点：</p><ol><li>避免了引用类型的属性被所有实例共享</li><li>可以在 Child 中向 Parent 传参</li></ol><p>缺点：</p><ol><li>方法都在构造函数中定义，每次创建实例都会创建一遍方法</li></ol><h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>结合了原型链继承和经典继承：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototpye.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent()</span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">20</span>)</span><br><span class="line">child1.colors.push(<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child1.name)<span class="comment">// &#x27;AgoniLay&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.age)<span class="comment">// 20</span></span><br><span class="line"><span class="built_in">console</span>.log(child1.colors)<span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;, &#x27;pink&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child11 = <span class="keyword">new</span> Child(<span class="string">&#x27;agoni&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.name)<span class="comment">// &#x27;agoni&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.age)<span class="comment">// 18</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.colors)<span class="comment">// [&#x27;red&#x27;, &#x27;blue&#x27;, &#x27;green&#x27;]</span></span><br></pre></td></tr></table></figure><p>优点：融合原型链继承和构造函数的优点，是 JavaScript 中最常用的继承模式。</p><p>缺点：会调用两次父构造函数</p><h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是 ES5 <code>Object.create()</code> 的模拟实现，将传入的对象多为创建的对象的原型。</p><p>缺点：包含引用类型的属性始终都会共享相应的值，同原型链继承。</p><h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>创建一个仅用于封装继承过程的函数，该函数在内部以某种形式来做增强对象，最后返回对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createObj</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o)</span><br><span class="line">  clone.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>缺点：和借用构造函数模式一样，每次创建对象都会创建一遍方法。</p><h4 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h4><p>避免组合继承中的两次调用父构造函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.colors = [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>, <span class="string">&#x27;green&#x27;</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototpye.getName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name)</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关键步骤</span></span><br><span class="line"><span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">F.prototype = Parent.prototype</span><br><span class="line">Child.prototype = <span class="keyword">new</span> F()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child1 = <span class="keyword">new</span> Child(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child1)</span><br></pre></td></tr></table></figure><p>对这个继承方法进行封装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span> (<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">prototype</span> (<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(parent.prototype)</span><br><span class="line">  prototype.constructor = child</span><br><span class="line">  child.prototype = prototype</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">prototype(Child, Parent)</span><br></pre></td></tr></table></figure><p>优点：高效率，体现在只调用了一次 Parent 构造函数，并且因此避免了在 <code>Parent.prototype</code> 上创建不必要的属性，同时原型链还能保持不变，因此也可以正常使用 <code>instanceof</code> 和 <code>isPrototypeOf</code>。</p><blockquote><p>普遍认为 寄生组合式继承式引用类型最理想的继承方式。</p></blockquote><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>当 JavaScript 代码执行一段可执行代码（execution code）时，会创建对应的执行上下文（execution context）。</p><p>对于每个执行上下文，都有三个重要属性：</p><ul><li></li><li><p>变量对象（Variable Object，VO）</p></li><li><p>作用域链（Scope chain）</p></li><li><p>this</p></li></ul><p>函数的作用域在函数定义的时候就确定了，因为函数有一个内部属性 <code>[[scope]]</code>，当函数创建时，就会保存多有父变量对象到其中，可以将 <code>[[scope]]</code> 理解为所有父变量对象的层级链，但 <code>[[scope]]</code> 并不代表完整的作用域链。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>函数创建时，各自的 <code>[[scope]]</code> 如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo.[[scope]] = [</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">bar.[[scope]] = [</span><br><span class="line">  fooContext.AO,</span><br><span class="line">  globalContext.VO</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>当函数激活时，进入函数上下文，创建 VO/AO 后，就会将活动对象添加到作用域链的前端：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 执行上下文的作用域链</span></span><br><span class="line">Scope = [AO].concat([[scope]])</span><br></pre></td></tr></table></figure><p>作用域链创建完毕。</p><h3 id="变量对象"><a href="#变量对象" class="headerlink" title="变量对象"></a>变量对象</h3><p>变量对象是与执行上下文相关的数据作用域，存储了在上下文中定义的变量和函数声明。</p><h4 id="全局对象"><a href="#全局对象" class="headerlink" title="全局对象"></a>全局对象</h4><ol><li>可以通过 this 引用，在客户端 JavaScript 中，全局对象就是 Window 对象；</li><li>全局对象是由 Object 构造函数实例化的一个对象；</li><li>预定义了一些函数和属性；</li><li>作为全局变量的宿主；</li><li>客户端 JavaScript 中，全局对象由 window 属性指向自身；</li></ol><p>全局上下文中的变量对象就是全局对象。</p><h4 id="活动对象"><a href="#活动对象" class="headerlink" title="活动对象"></a>活动对象</h4><p>在函数上下文中，用活动对象（Activation object，AO）来表示变量对象。</p><p>变量对象是规范上或者说是引擎上实现的，不可以在 JavaScript 环境中访问，只有在进入到一个执行上下文中，变量对象才会被激活，也就成为了活动对象，其中的各种属性才可以被访问。</p><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>执行上下文的代码会分为两个阶段进行处理：分析和执行</p><ol><li>进入执行上下文</li><li>代码执行</li></ol><h5 id="进入执行上下文"><a href="#进入执行上下文" class="headerlink" title="进入执行上下文"></a>进入执行上下文</h5><p>变量对象包括：</p><ol><li>函数的所有形参（是函数上下文的话）<ul><li>由名称和对应值组成的一个变量对象的属性被创建</li><li>没有实参，属性值设为 <code>undefined</code> </li></ul></li><li>函数声明<ul><li>由名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建</li><li>如果变量对象已经存在相同名称的属性，则<strong>完全替代</strong>这个属性</li></ul></li><li>变量声明<ul><li>由名称和对应值（undefined）组成一个变量对象的属性被创建</li><li>如果变量名称跟已经声明的形式参数或函数相同，则变量声明<strong>不会干扰</strong>已经存在的这类属性</li></ul></li></ol><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">2</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> d = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  b = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>进入执行上下文后，这时候的 AO 为：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="attr">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">    <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="literal">undefined</span>,</span><br><span class="line">  <span class="attr">c</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span> (<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="attr">d</span>: <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h5><p>在代码执行阶段，顺序执行代码，根据代码修改变量对象的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AO = &#123;</span><br><span class="line">  <span class="attr">arguments</span>: &#123;</span><br><span class="line">    <span class="number">0</span>: <span class="number">1</span></span><br><span class="line">    <span class="attr">length</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">a</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="attr">b</span>: <span class="number">3</span>,</span><br><span class="line">  <span class="attr">c</span>: reference to <span class="function"><span class="keyword">function</span> <span class="title">c</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">  <span class="attr">d</span>: reference to FunctionExpression <span class="string">&quot;d&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ol><li>全局上下文的变量对象初始化是全局对象；</li><li>函数上下文的变量对象初始化只包括 arguments 对象；</li><li>在进入执行上下文时会给变量对象添加形参、函数声明、变量声明等初始的属性值；</li><li>在代码执行阶段，会再次修改变量对象的属性值</li></ol><h3 id="this"><a href="#this" class="headerlink" title="this"></a>this</h3><h4 id="Types"><a href="#Types" class="headerlink" title="Types"></a>Types</h4><p>ECMAScript 的类型分为语言类型和规范类型。</p><ul><li>语言类型是开发者直接使用 ECMAScript 可以操作的，包括：<code>Undefined</code>、<code>Null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 和 <code>Object</code>；</li><li>规范类型先相当于 meta-values，是用来用算法描述 ECMAScript 语言结构和 ECMAScript 语言类型的，包括：<code>Reference</code>、<code>List</code>、<code>Completion</code>、<code>Property Descriptor</code>、<code>Property Identifier</code>、<code>Lexical Environment</code> 和 <code>Environment Record</code> </li></ul><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p>Reference 类型是用来解释 delete、typeof 以及赋值等操作行为的</p><blockquote><p>这里的 Reference 是一个 Specification Type，也就是只存在于规范里的抽象类型。是为了更好地描述语言的底层行为逻辑而存在，并不存在于实际的 js 代码中。</p></blockquote><p>Reference 由三部分构成：</p><ul><li>base value：属性所在的对象，它的值只能是 <code>Undefined</code>、<code>Object</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code> 或者 <code>environment record</code> 其中的一种</li><li>referenced name：属性的名称</li><li>strict reference：一个 <code>Boolean</code> 值，用来检测 strict mode 下的一些限制</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar()</span><br><span class="line"></span><br><span class="line"><span class="comment">// foo 对应的 Reference 是：</span></span><br><span class="line"><span class="keyword">var</span> fooReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: EnvironmentRecord,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bar 对应的 Rederence 是：</span></span><br><span class="line"><span class="keyword">var</span> barReference = &#123;</span><br><span class="line">  <span class="attr">base</span>: foo,</span><br><span class="line">  <span class="attr">propertyName</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">  <span class="attr">strict</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Reference 方法：</p><ul><li><code>GetBase()</code>：返回 reference 的 base value</li><li><code>IsPropertyReference()</code>：如果 base value 是一个对象则返回 true</li><li><code>GetValue()</code>：返回对象属性真正的值，<strong>返回的将是具体的值，而不再是一个 Reference</strong>。</li></ul><h4 id="确定-this"><a href="#确定-this" class="headerlink" title="确定 this"></a>确定 this</h4><ol><li>计算 <code>MemeberExpression</code> 的结果赋值给 ref</li><li>判断 ref 是不是一个 Reference 类型<ol><li>是，并且 <code>IsPropertyReference(ref)</code> 是 true，那么 this 的值为 <code>GetBase(ref)</code> </li><li>不是，this 为 undefined</li></ol></li></ol><p><code>MemeberExpression</code>：</p><ul><li><code>PrimaryExpression</code>：原始表达式</li><li><code>FunctionExpression</code>：函数定义表达式</li><li><code>MemeberExpression[Expression]</code>：属性访问表达式</li><li><code>MemeberExpression.IdentifierName</code>：属性访问表达式</li><li><code>new MemeberExpression Arguments</code>：对象创建表达式</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">foo() <span class="comment">// MemeberExpression 是 foo</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo()() <span class="comment">// MemeberExpression 是 foo()</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line">foo.bar() <span class="comment">// MemeberExpression 是 foo.bar</span></span><br></pre></td></tr></table></figure><blockquote><p>可以简单理解 <code>MemeberExpression</code> 就是 <code>()</code> 左侧的部分</p></blockquote><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">  <span class="attr">bar</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//示例1</span></span><br><span class="line"><span class="built_in">console</span>.log(foo.bar())<span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例2</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar)())<span class="comment">// 2</span></span><br><span class="line"><span class="comment">//示例3</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar = foo.bar)())<span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例4</span></span><br><span class="line"><span class="built_in">console</span>.log((<span class="literal">false</span> || foo.bar)())<span class="comment">// 1</span></span><br><span class="line"><span class="comment">//示例5</span></span><br><span class="line"><span class="built_in">console</span>.log((foo.bar, foo.bar)())<span class="comment">// 1</span></span><br></pre></td></tr></table></figure><blockquote><p>赋值、逻辑运算，逗号运算均会调用 <code>GetValue()</code> 方法，返回的并不是 Reference 类型，而是真正的值，所以不满足第二步判断，进而 this 指向 undefined（在非严格模式下，this 的值为 undefined 时将会隐式转换为全局对象）</p></blockquote><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><blockquote><p>MDN 对于闭包的定义：闭包是指那些能够访问自由变量的函数</p><p>自由变量：指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量</p><p>闭包 = 函数 + 函数能够访问的自由变量</p></blockquote><p>如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a)</span><br><span class="line">&#125;</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>foo 函数可以访问变量 a，但 a 既不是 foo 函数的局部变量，也不是 foo 函数的参数，所以 a 就是自由变量，所以理论上函数 foo + foo 函数访问的自由变量 a 就构成了一个闭包。</p><p>上面描述的是理论上的闭包，还有一个实践角度的闭包：</p><p>ECMAScript 中，闭包指：</p><ol><li>从理论角度：所有的函数（在函数中访问全局变量就相当于是在访问自由变量）</li><li>从实践角度：<ol><li>即使创建它的上下文已经销毁，它依然存在（如内部函数从父函数中返回）</li><li>在代码中引用了自由变量</li></ol></li></ol><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> scope = <span class="string">&#x27;global scope&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkscope</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> scope = <span class="string">&#x27;local scope&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> scope</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> foo = checkscope()</span><br><span class="line">foo()</span><br></pre></td></tr></table></figure><p>执行过程：</p><ol><li>进入全局代码，创建全局执行上下文，全局执行上下文压入执行上下文栈；</li><li>全局执行上下文初始化；</li><li>执行 checkscope 函数，创建 checkscope 函数执行上下文，checkscope 执行上下文被压入执行上下文栈；</li><li>checkscope 执行上下文初始化，创建变量对象、作用域链、this 等；</li><li>checkscope 函数执行完毕，checkscope 执行上下文从执行上下文栈中弹出；</li><li>执行 f 函数，创建 f 函数执行上下文，f 执行上下文被压入执行上下文栈；</li><li>f 执行上下文初始化，创建变量对象、作用域链、this 等；</li><li>f 函数执行完毕，f 执行上下文从执行上下文栈中弹出。</li></ol><p>f 之所以可以访问到 checkscope 作用域中的值，是因为 f 执行上下文维护了一个作用域链：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fContext = &#123;</span><br><span class="line"><span class="attr">Scope</span>: [AO, checkscopeContext.AO, globalContext.VO]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当 f 函数引用了 <code>checkscopeContext.AO</code> 中的值时，即使 <code>checkscopeContext</code> 被销毁了，但 JavaScript 仍会让 <code>checkscopeContext.AO</code> 存活在内存中，f 函数依然可以通过其自身的作用域链访问。</p><h3 id="立即执行函数"><a href="#立即执行函数" class="headerlink" title="立即执行函数"></a>立即执行函数</h3><p>指被立即调用的函数表达式（Immediately-Invoked Function Expression，IIFE）</p><p>括号出现在函数周边的规则：</p><ul><li>当圆括号出现在匿名函数的末尾想要想要调用函数时，它会默认将函数当成是函数声明</li><li>当圆括号包裹函数时，它会默认将函数作为表达式去解析，而不是函数声明</li></ul><p>所以有以下两种 IIFE 的写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;())</span><br><span class="line"><span class="comment">// 或</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;)()</span><br></pre></td></tr></table></figure><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p><code>typeof</code> 一般被用于判断一个变量的类型，可以判断 <code>number</code>、<code>string</code>、<code>object</code>、<code>boolean</code>、<code>function</code>、<code>undefined</code>、<code>symbol</code> 七种类型，返回值为<strong>字符串</strong>类型。</p><p>在判断不是 object 类型的数据时，<code>typeof</code> 能比较清楚的返回具体是什么类型，但无法细分判断是那种 object 类型。</p><p>原理：</p><p>js 在底层存储变量时，会在变量的机器码的低位1-3位存储其类型信息：</p><ul><li>000：对象</li><li>010：浮点数</li><li>100：字符串</li><li>110：布尔值</li><li>1：整数</li></ul><p>对于 null 和 undefined 来说，这两个值的信息存储特殊：</p><ul><li>null：所有机器码均为 0</li><li>undefined：用 <code>-2^30</code> 整数来表示</li></ul><p>所以，<code>typeof</code> 在判断 null 时就会把 null 当为 object 来看待。</p><blockquote><p>避免使用 typeof 判断 null，也可以使用 <code>Object.prototype.toString.call()</code> 判断。</p></blockquote><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p><code>instanceof</code> 用于：</p><ul><li>判断对象的具体类型</li><li>判断一个实例是否属于某种类型</li><li>判断一个实例是否是其父类型或祖先类型的实例</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> nicole = <span class="keyword">new</span> person()</span><br><span class="line">nicole <span class="keyword">instanceof</span> person <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">new_instance_of</span> (<span class="params">leftValue, rightValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> rightProto = rightValue.prototype</span><br><span class="line">  leftValue = leftValue.__proto__</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (leftValue === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (leftValue === rightProto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    leftValue = leftValue.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型继承原理：</p><p><code>Object instanceof Object</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">leftValue = <span class="built_in">Object</span>.__proto__ = <span class="built_in">Function</span>.prototype</span><br><span class="line">rightValue = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// 第一次判断</span></span><br><span class="line">leftValue !== rightValue</span><br><span class="line">leftValue = <span class="built_in">Function</span>.prototype.__proto__ = <span class="built_in">Object</span>.prototype</span><br><span class="line"><span class="comment">// 第二次判断</span></span><br><span class="line">leftValue === rightValue</span><br><span class="line"><span class="comment">// 返回 true</span></span><br></pre></td></tr></table></figure><p><code>Function instanceof Funciton</code> 和 <code>Function instanceof Object</code> 同理。</p><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call apply"></a>call apply</h3><p>共同点：都能改变函数执行时的上下文，将一个对象交给另一个对象来执行，且立即执行。</p><h4 id="call"><a href="#call" class="headerlink" title="call"></a>call</h4><p>call 在使用一个指定的 this 值和若干个指定的参数值的前提下调用某个函数或方法。</p><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.call(object[, param1 [, param2[, ... [, paramN]]]])</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>调用者必须是函数 Function</li><li>call 的第一个参数是一个对象，Function 的调用者将会指向这个对象，不传则默认为 window</li><li>第二个参数开始可以接收任意个参数</li></ul><p>使用场景：</p><ol><li>对象的继承</li><li>借用方法：比如类数组借用数组原型链上的方法</li></ol><p>模拟实现：</p><ol><li>将函数设置为对象的属性；</li><li>执行该函数；</li><li>删除该函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myCall = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> args = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">    args.push(<span class="string">&#x27;arguments[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h4><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.apply(object[, argArray])</span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>调用者必须是函数 Function</li><li>最多接受两个参数，第一个参数于 call 一致</li><li>第二个参数必须是数组或者类数组，会被转换为类数组，传入 Function 中，并映射到 Function 对应的参数上</li></ul><blockquote><p>类数组：具备与数组特征类似的对象，可以通过角标调用，具有长度属性 length，可以通过 for 循环进行遍历；无法使用 forEach、splice、push 等数组原型链上的方法。</p></blockquote><p>使用场景：</p><ol><li><p><code>Math.max</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取数组中最大的一项</span></span><br><span class="line"><span class="keyword">let</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array)</span><br><span class="line"><span class="comment">// 获取数组中最小的一项</span></span><br><span class="line"><span class="keyword">let</span> min = <span class="built_in">Math</span>.min.apply(<span class="literal">null</span>, array)</span><br></pre></td></tr></table></figure></li><li><p>数组合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2)</span><br></pre></td></tr></table></figure></li></ol><p>模拟实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myApply = <span class="function"><span class="keyword">function</span> (<span class="params">context, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> context = context || <span class="built_in">window</span></span><br><span class="line">  context.fn = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> result</span><br><span class="line">  <span class="keyword">if</span> (!arr) &#123;</span><br><span class="line">    result = context.fn()</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> args = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">      args.push(<span class="string">&#x27;arr[&#x27;</span> + i + <span class="string">&#x27;]&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    result = <span class="built_in">eval</span>(<span class="string">&#x27;context.fn(&#x27;</span> + args + <span class="string">&#x27;)&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">delete</span> context.fn</span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><p><code>bind()</code> 方法会创建一个新函数。当这个函数被调用时，bind 的第一个参数将作为它运行时的 this，之后的一序列参数将会在传递的实参前传入作为它的参数。</p><p>写法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.bind(thisArg[, arg1[, arg2[, ...]]])</span><br></pre></td></tr></table></figure><p>模拟实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.myBind = <span class="function"><span class="keyword">function</span> (<span class="params">context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Function.prototype.bind - what is trying to be bound is not callable.&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> self = <span class="built_in">this</span></span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fNOP = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> fBound = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> bindArgs = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> self.apply(<span class="built_in">this</span> <span class="keyword">instanceof</span> fNOP ? <span class="built_in">this</span> : context, args.conact(bindArgs))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fNOP.prototype = <span class="built_in">this</span>.prototype</span><br><span class="line">  fBound.prototype = <span class="keyword">new</span> fNOP()</span><br><span class="line">  <span class="keyword">return</span> fBound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h3><p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 执行 add 函数，需一次传入两个参数</span></span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一个 curry 函数可以做到柯里化</span></span><br><span class="line"><span class="keyword">var</span> addCurry = curry(add)</span><br><span class="line">addCurry(<span class="number">1</span>)(<span class="number">2</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h4><p>避免重复调用函数时的参数冗余，精简代码</p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub_curry</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = [].slice.call(<span class="built_in">arguments</span>, <span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, args.concat([].slice.call(<span class="built_in">arguments</span>)))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, length</span>) </span>&#123;</span><br><span class="line">  length = length || fn.length</span><br><span class="line">  <span class="keyword">var</span> slice = <span class="built_in">Array</span>.prototype.slice</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">var</span> combined = [fn].concat(slice.call(<span class="built_in">arguments</span>))</span><br><span class="line">      <span class="keyword">return</span> curry(sub_curry.apply(<span class="built_in">this</span>, combined), length - <span class="built_in">arguments</span>.length)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, <span class="built_in">arguments</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">curry(fn)</span><br><span class="line">fn()()</span><br></pre></td></tr></table></figure><p><code>sub_curry</code> 的作用就是用函数包裹原函数，然后给原函数传入之前的参数，当执行 <code>fn()()</code> 时，执行包裹函数，返回原函数，然后再调用 <code>sub_curry</code> 包裹原函数，然后将新的参数混合旧的参数再传入原函数，知道函数参数的数目达到要求为止。</p><h4 id="易懂实现"><a href="#易懂实现" class="headerlink" title="易懂实现"></a>易懂实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, args</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = fn.length</span><br><span class="line">  args = args || []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = args.slice(<span class="number">0</span>),</span><br><span class="line">        arg, i</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">      arg = <span class="built_in">arguments</span>[i]</span><br><span class="line">      _args.push(arg)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_args.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, _args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>增加占位符功能：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, args, holes</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = fn.length</span><br><span class="line">  args = args || []</span><br><span class="line">  holes = holes || []</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _args = args.slice(<span class="number">0</span>),</span><br><span class="line">        _holes = holes.slice(<span class="number">0</span>),</span><br><span class="line">        argsLen = args.length,</span><br><span class="line">        holesLen = holes.length,</span><br><span class="line">        arg, i, index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, len = <span class="built_in">arguments</span>.length; i &lt; len; i++) &#123;</span><br><span class="line">      arg = <span class="built_in">arguments</span>[i]</span><br><span class="line">      <span class="comment">// 处理类似 fn(1, _, _, 4)(_, 3) 这种情况</span></span><br><span class="line">      <span class="keyword">if</span> (arg === _ &amp;&amp; holesLen) &#123;</span><br><span class="line">        index++</span><br><span class="line">        <span class="keyword">if</span> (index &gt; holesLen) &#123;</span><br><span class="line">          _args.push(arg)</span><br><span class="line">          _holes.push(argsLen - <span class="number">1</span> + index - holesLen)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (arg === _) &#123;</span><br><span class="line">        _args.push(arg)</span><br><span class="line">        _holes.push(argsLen + i)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (holesLen) &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= holesLen) &#123;</span><br><span class="line">          _args.push(arg)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          _args.splice(_holes[index], <span class="number">1</span>, arg)</span><br><span class="line">          _holes.splice(index, <span class="number">1</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        _args.push(arg)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (_holes.length || _args.length &lt; length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry.call(<span class="built_in">this</span>, fn, _args, _holes)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="built_in">this</span>, _args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _ = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = curry(<span class="function"><span class="keyword">function</span> (<span class="params">a, b, c, d, e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log([a, b, c, d, e])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出均为 [1, 2, 3, 4, 5]</span></span><br><span class="line">fn(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">fn(_, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)(<span class="number">1</span>)</span><br><span class="line">fn(<span class="number">1</span>, _, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)(<span class="number">2</span>)</span><br><span class="line">fn(<span class="number">1</span>, _, <span class="number">3</span>)(_, <span class="number">4</span>)(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line">fn(<span class="number">1</span>, _, _, <span class="number">4</span>)(_, <span class="number">3</span>)(<span class="number">2</span>)(<span class="number">5</span>)</span><br><span class="line">fn(_, <span class="number">2</span>)(_, _, <span class="number">4</span>)(<span class="number">1</span>)(<span class="number">3</span>)(<span class="number">5</span>)</span><br></pre></td></tr></table></figure><blockquote><p>在这个实现中，实现了一个强大的 curry 函数，不仅可以传入一个参数，还可以一次传入两个参数甚至更多，这更像是一个柯里化（curry）和偏函数（partial application）的综合应用。</p></blockquote><h4 id="简易实现"><a href="#简易实现" class="headerlink" title="简易实现"></a>简易实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> curry = <span class="function"><span class="params">fn</span> =&gt;</span></span><br><span class="line">judge = <span class="function">(<span class="params">...args</span>) =&gt;</span></span><br><span class="line">args.length === fn.length</span><br><span class="line">? fn(...args)</span><br><span class="line">: <span class="function"><span class="params">arg</span> =&gt;</span> judge(...args, arg)</span><br></pre></td></tr></table></figure><h3 id="V8-垃圾回收"><a href="#V8-垃圾回收" class="headerlink" title="V8 垃圾回收"></a>V8 垃圾回收</h3><h4 id="为何垃圾回收"><a href="#为何垃圾回收" class="headerlink" title="为何垃圾回收"></a>为何垃圾回收</h4><p>V8 执行 JavaScript 代码时，当遇到函数时，会为其创建一个执行上下文环境并添加到调用堆栈的栈顶，函数的作用域中包含了该函数中声明的所有变量，当函数执行完后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的变量也会统一释放并被自动回收。</p><p>若不进行回收，将会持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕后应还给操作系统以保证内存的重复利用。</p><p>JavaScript 作为一门高级编程语言，并不需要像 C 语言或 C++ 语言中手动地申请分配和释放内存，V8 引擎已经自动进行了内存的分配和管理。</p><h4 id="V8-引擎的内存限制"><a href="#V8-引擎的内存限制" class="headerlink" title="V8 引擎的内存限制"></a>V8 引擎的内存限制</h4><p>默认情况下，V8 引擎在 64 位系统下最多只能使用约 1.4GB 的内存，在 32 位系统下最多只能使用约 <code>0.7GB</code> 的内存，这将会导致在 Node 中无法直接操作大内存对象。</p><p>限制原因：</p><ol><li>V8 引擎设计之初只是作为浏览器端 JavaScript 的执行环境，在浏览器中很少会遇到使用大量内存的情况，因此不必将最大内存设置得过高；</li><li>JS 是单线程机制，意味着执行的代码必须按顺序执行，在同一时间只能处理一个任务，这意味着在 V8 执行垃圾回收时，程序中的其他逻辑都要进入暂停等待阶段，直到垃圾回收完成后才会再次执行 JS 逻辑；</li><li>垃圾回收本身也是一件非常耗时的操作，做一次小的垃圾回收需要 50ms 以上，而做一次非增量回收甚至需要 1s 以上，在这时间内，浏览器一直处于等待的状态，同时会失去对用户的响应，会造成动画的卡顿掉帧情况，严重影响应用程序的性能。</li></ol><p>基于以上几点，V8 为了减少对应用性能造成的影响，就直接限制了堆内存的大小。</p><p>解决：</p><p>但在 node 端，涉及到的 <code>I/O</code> 操作可能会不够用，因此 V8 提供了可配置项来手动调整内存大小：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看 node 中可用的 v8 引擎的选项及其含义</span></span><br><span class="line">node --v8-options</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125213324542.png" class title="node V8 选项"><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最小值，单位 MB</span></span><br><span class="line">node --min-semi-space-size=1024 xxx.js</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置新生代内存中单个半空间的内存最大值，单位 MB</span></span><br><span class="line">node --max-semi-space-szie=1024 xxx.js</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置老生代内存最大值，单位 MB</span></span><br><span class="line">node --max-old-space-size=2048 xxx.js</span><br></pre></td></tr></table></figure><p>通过上面的方法可以手动放宽 V8 引擎的内存使用限制，node 中提供了 <code>process.memoryUsage()</code> 方法来查看当前 node 进程中占用的实际内存大小。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125214633666.png" class title="process.memoryUsage"><p>上图中字段含义如下（单位均为字节）：</p><ul><li><p><code>rss</code>（resident set size）：表示驻留集大小，即给这个 node 进程分配了多少物理内存（包括堆、栈和代码片段）</p><blockquote><p>当使用  <code>Worker</code> 线程时，<code>rss</code> 是对整个进程都有效的值，其他字段只涉及当前线程</p></blockquote></li><li><p><code>heapTotal</code>：表示 V8 当前申请到的堆内存总大小</p></li><li><p><code>heapUsed</code>：表示当前内存使用量</p></li><li><p><code>external</code>：表示 V8 内部的 C++ 对象所占用的内存</p></li><li><p><code>arrayBuffers</code>：指为 <code>ArrayBuffer</code> 和 <code>SharedArrayBuffer</code> 分配的内存，包括所有 Node Buffer，包含在 <code>external</code> 值中</p></li></ul><h4 id="V8-垃圾回收策略"><a href="#V8-垃圾回收策略" class="headerlink" title="V8 垃圾回收策略"></a>V8 垃圾回收策略</h4><h5 id="内存结构"><a href="#内存结构" class="headerlink" title="内存结构"></a>内存结构</h5><p>V8 的内存结构主要由以下几个部分组成：</p><ul><li><code>新生代(new_space)</code>：大多数的对象开始都会被分配在这个区域，此区域相对较小，但回收特别频繁；该区域被分为两半，一半用来回收内存，一半用于在垃圾回收时复制需要保留的对象；</li><li><code>老生代(old_space)</code>：新生代中的对象在存活一段时间后就会<strong>晋升</strong>到老生代内存区，相对于新生代该区域垃圾回收的频率较低；老生代分为：<ul><li> <code>老生代指针区</code>：包含大多数可能存在指向其他对象的指针的对象；</li><li><code>老生代数据区</code>：只保存原始数据对象，这些对象没有指向其他对象的指针；</li></ul></li><li><code>大对象区(large_object_space)</code>：存放体积超越其他区域大小的对象，每个对象都会有自己的内存，垃圾回收不会移动大对象区；</li><li><code>代码区(code_space)</code>：代码对象分配区域，唯一拥有执行权限的内存区域；</li><li><code>map 区(map_space)</code>：存放 Cell 和 Map，每个区域都是存放相同大小的元素.</li></ul><h5 id="新生代"><a href="#新生代" class="headerlink" title="新生代"></a>新生代</h5><p>新生代主要用于存放存活时间较短的对象。新生代内存由两个 <code>semispace(半空间)</code> 构成，内存最大值在 64 位和 32 位系统默认分别为 <code>32MB</code> 和 <code>16MB</code>，在新生代的垃圾回收过程中主要采用了 <code>Scavenge</code> 算法。</p><p>Scavenge 算法：典型的牺牲空间换时间的算法，主要过程是<u>将存活对象在 <code>From</code> 空间和 <code>To</code> 空间之间进行复制，同时完成两个空间之间的角色互换</u>。</p><h5 id="对象晋升"><a href="#对象晋升" class="headerlink" title="对象晋升"></a>对象晋升</h5><p><u>当一个对象在经过多次复制之后依旧存活，那么它会被认为是一个生命周期较长的对象，在下一次进行垃圾回收时，该对象会被直接转移到老生代中</u>，即为 <strong>晋升</strong>。</p><p>晋升条件（两者满足其一）：</p><ol><li>对象是否经历过一次 <code>Scavenge</code> 算法</li><li><code>To</code> 空间的内存占比是否已经超过 <code>25%</code> </li></ol><h5 id="老生代"><a href="#老生代" class="headerlink" title="老生代"></a>老生代</h5><p>老生代中采用 <code>Mark-Sweep(标记清除)</code> 和 <code>Mark-Compact(标记整理)</code> 算法进行管理。</p><p><code>Mark-Sweep</code> 分为 <strong>标记</strong> 和 <strong>清除</strong> 两个阶段，<u>在标记阶段遍历堆中所有的对象，标记活着的对象，在清除对象，会将死亡的对象进行清除</u>，具体步骤如下：</p><ol><li>垃圾回收器在内部构建一个根列表，从根节点出发去寻找那些可以被访问到的变量（比如 window 全局对象可以看成一个根节点）；</li><li>垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，将其标记为活动的，未到达的即为非活动的；</li><li>最后，释放所有非活动的内存块，归还给操作系统。</li></ol><p>在 <code>Mark-Sweep</code> 之后，内存空间会出现大量不连续的状态，就会出现内存碎片的问题，可能导致后面无法分配大对象而提前触发垃圾清理，但其实毫无必要，所以需进行 <code>Mark-Compact</code>，来解决内存的碎片化问题，具体步骤：</p><p>在将死亡对象全部清除后，在整理过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存。</p><p>至此完成了一次老生代垃圾回收的全部过程，之前提到由于 JS 的单线程机制，垃圾回收的过程会阻碍主线程同步任务的执行，待执行完垃圾回收后才会恢复执行主任务的逻辑，也就是 <strong>全停顿</strong>。</p><p>于是 V8 引擎引入了 <code>Incremental Marking(增量标记)</code> 的概念：<u>将原本需要一次性遍历堆内存的操作改为增量标记的方式，先标记堆内存中的一部分对象，然后暂停，将执行权重新交给 JS 主线程，待主线程任务执行完毕后再从原来暂停标记的地方继续标记，直到标记完整个堆内存</u>。</p><p>尽可能少地影响主线程的任务，避免应用卡顿，提升应用性能。</p><p>V8 还引入了 <code>Lazy Sweeping(延时清理)</code> 和 <code>Incremental Compation(增量式整理)</code>，使得清理和整理的过程也变为增量式的。</p><h4 id="避免内存泄漏"><a href="#避免内存泄漏" class="headerlink" title="避免内存泄漏"></a>避免内存泄漏</h4><ol><li><p>尽可能少地创建全局变量；</p></li><li><p>手动清除定时器：<code>clearInterval(timer)</code>、<code>clearTimeout(timer)</code>；</p></li><li><p>少用闭包；</p></li><li><p>清除 DOM 引用：使用 <code>document.body.removeChild(document.getElementById(&#39;button&#39;))</code>；</p></li><li><p>弱引用：<code>WeakMap</code> 和 <code>WeakSet</code>。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220125230318519.png" class title="弱引用"></li></ol><h3 id="浮点数精度"><a href="#浮点数精度" class="headerlink" title="浮点数精度"></a>浮点数精度</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>ECMAScript 中 Number 类型使用 IEEE754 标准（IEEE 二进制浮点数算数标准）来表示整数和浮点数。</p><p>其中规定了四种表示浮点数值的方式：</p><ol><li>单精确度（32 位）</li><li>双精确度（64 位）：ECMAScript 采用的就是双精确度。</li><li>延伸单精确度</li><li>延伸双精确度</li></ol><h4 id="浮点数转二进制"><a href="#浮点数转二进制" class="headerlink" title="浮点数转二进制"></a>浮点数转二进制</h4><p>1020 用十进制表示：</p><blockquote><p>1020 = 1 * 10^3 + 0 * 10^2 + 2 * 10^1 + 0 * 10^0</p></blockquote><p>1030 用二进制表示：</p><blockquote><p>1020 = 1 * 2^9 + 1 * 2^8 + 1 * 2^7 + 1 * 2^6 + 1 * 2^5 + 1 * 2^4 + 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0</p></blockquote><p>也就是 <code>1111111100</code> </p><hr>0.75 用二进制表示：<blockquote><p>0.75 = a * 2^-1 + b * 2^-2 + c * 2^-3 + d * 2^-4 + …</p></blockquote><p>两边同时乘 2：</p><blockquote><p>1 + 0.5 = a * 2^0 + b * 2^-1 + c * 2^-2 + d * 2^-3 + … (所以 a = 1)</p><p>0.5 = b * 2^-1 + c * 2^-2 + d * 2^-3 + …</p></blockquote><p>再同时乘 2：</p><blockquote><p>1 + 0 = b * 2^0 + c * 2^-2 + d * 2^-3 + … (所以 b = 1)</p></blockquote><p>所以 0.75 就是 <code>0.11</code></p><hr>但一些小数计算会一直循环，如 0.1 用二进制表示就是 `0.00011001100110011......` <h4 id="浮点数的存储"><a href="#浮点数的存储" class="headerlink" title="浮点数的存储"></a>浮点数的存储</h4><p>IEEE 754 认为，一个浮点数（Value）可以这样表示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value = sign * exponent * fraction</span><br></pre></td></tr></table></figure><p>也就是科学计数法，如 -1020 用科学计数法表示就是：</p><blockquote><p>-1 * 10^3 * 1.02</p></blockquote><p>对于 0.1 的二进制 <code>0.00011001100110011......</code> 来说，可以表示为：</p><blockquote><p>1 * 2^-4 * 1.1001100110011……</p></blockquote><p>只做二进制可续计数法的表示时， Value 的表示可以更具体：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Value = (-<span class="number">1</span>)^S * (<span class="number">1</span> + Fraction) * <span class="number">2</span>^E</span><br></pre></td></tr></table></figure><ul><li><code>(-1)^S</code> 表示符号位，当 S = 0，V 为正数；S = 1，V 为负数；</li><li><code>(1 + Fraction)</code>：因为所有的浮点数都可以表示为 <code>1.xxx * 2^xxx</code> 的形式，前面也一定是 <code>1.xxx</code>，故存储 Fraction 为 1 后面的 xxx；</li><li><code>2^E</code>：用 8 位来存储 E 这个数，只有正数则范围是 0 ~ 254，但由于有负值，所以值的范围是 -127 ~ 127。取值时，再减去 127，所以不是直接存储 E 而是 E + bias，bias 也就是 127。</li></ul><p>所以，要存储一个浮点数，我们存 S 和 Fraction 和 E + bias 三个值即可</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/68747470733a2f2f67772e616c6963646e2e636f6d2f7466732f5442315666564579755432674b306a535a46765858586e465858612d3739302d3230352e6a7067.jpeg" class title="IEEE754"><ul><li>使用 1 位存储 S，0 表示正数，1 表示负数；</li><li>用 11 位存储 E + bias，对于 11 位来说，bias 的值是 <code>2^(11-1) - 1</code> 也就是 <code>1023</code>；</li><li>用 52 位存储 Fraction</li></ul><p>比如，0.1 的对应二进制是 <code>1 * 1.1001100110011...... * 2^-4</code>，Sign 是 1，E + bias 是 -4 + 1023 = 1019 也就是 <code>1111111011</code>，Fraction 是 1001100110011……</p><p>所以 0.1 对应 64 位的完整表示就是：</p><blockquote><p>0 | 01111111011 | 1001100110011001100110011001100110011001100110011010</p></blockquote><p>同理 0.2 的完整表示是：</p><blockquote><p>0 | 01111111100 | 1001100110011001100110011001100110011001100110011010</p></blockquote><p>所以当 0.1 存下来的时候，就已经发生了精度的丢失，再使用浮点数进行计算时，使用的其实是精度丢失后的数</p><h4 id="浮点数的运算"><a href="#浮点数的运算" class="headerlink" title="浮点数的运算"></a>浮点数的运算</h4><p>浮点数运算一般由五个步骤完成：对阶、尾数运算、规格化、舍入处理、溢出判断。</p><p>以 0.1 + 0.2 为例：</p><p>首先进行对阶，也就是把阶码调整为相同，0.1 是 <code>1 * 1.1001100110011...... * 2^-4</code>，阶码是 -4，而 0.2 是 <code>1.10011001100110...* 2^-3</code>，阶码是 -3，调整原则为 <strong>小阶对大阶</strong>，也就是 0.1 调整为 <code>0.11001100110011…… * 2^-3</code>；</p><p>接下来是尾数计算：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  0.1100110011001100110011001100110011001100110011001101</span><br><span class="line">+ 1.1001100110011001100110011001100110011001100110011010</span><br><span class="line">————————————————————————————————————————————————————————</span><br><span class="line"> 10.0110011001100110011001100110011001100110011001100111</span><br></pre></td></tr></table></figure><p>结果为：<code>10.0110011001100110011001100110011001100110011001100111</code>；</p><p>将结果进行规格化：<code>1.0011001100110011001100110011001100110011001100110011(1) * 2^-2</code>（括号里的 1 表示超出了范围，所以舍弃）；</p><p>然后进行舍入：四舍五入对应到二进制中，就是 0 舍 1 入，因为要把括号中的 1 舍弃，所以需要进 1，结果变为：<code>1.0011001100110011001100110011001100110011001100110100 * 2^-2</code>；</p><p>此处不涉及溢出判断，所以最终结果存成 64 位就是：</p><blockquote><p>0 | 01111111101 | 0011001100110011001100110011001100110011001100110100</p></blockquote><p>转换为 10 进制数就得到 <code>0.30000000000000004440892098500626</code> </p><p>因为两次存储时的精度丢失加上一次运算时的精度丢失，最终导致 <code>0.1 + 0.2 !== 0.3</code> </p><h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 十进制转二进制</span></span><br><span class="line"><span class="number">0.1</span>.toString(<span class="number">2</span>)</span><br><span class="line">=&gt; <span class="string">&quot;0.0001100110011001100110011001100110011001100110011001101&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二进制转十进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">1100100</span>, <span class="number">2</span>)</span><br><span class="line">=&gt; <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 以指定精度返回该数值对象的字符串表示</span></span><br><span class="line">(<span class="number">0.1</span> + <span class="number">0.2</span>).toPrecision(<span class="number">21</span>)</span><br><span class="line">=&gt; <span class="string">&quot;0.300000000000000044409&quot;</span></span><br><span class="line">(<span class="number">0.3</span>).toPrecision(<span class="number">21</span>)</span><br><span class="line">=&gt; <span class="string">&quot;0.299999999999999988898&quot;</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126001804188.png" class title="浮点数相关方法"><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><p>new 运算符创建一个用户定义的对象类型的实例或具有构造函数的内置对象类型之一。</p><p>模拟实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  obj.__proto__ = Constructor.prototype</span><br><span class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> ? ret : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟使用</span></span><br><span class="line"><span class="keyword">var</span> person = objectFactory(Perosn, <span class="string">&#x27;agoni&#x27;</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意点：若构造函数中手动返回了一个对象，则 new 构造出的实例中只能访问返回对象中的属性，但如果返回一个基本类型的值，则默认相当于无返回值处理</p></blockquote><blockquote><p>此处 <code>new Object()</code> 若使用 <code>Object.create(null)</code> 代替，则创建出的实例中的 <code>__proto__</code> 会有差别，后者只是将 <code>__proto__</code> 当成了一个属性，并非去修改原型。</p></blockquote><p>可以优化：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">objectFactory</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  Constructor = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">var</span> ret = Constructor.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line">  <span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(Constructor.prototype)</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> ret === <span class="string">&#x27;object&#x27;</span> &amp;&amp; ret !== <span class="literal">null</span> ? ret : obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h3><h4 id="执行栈与事件队列"><a href="#执行栈与事件队列" class="headerlink" title="执行栈与事件队列"></a>执行栈与事件队列</h4><p>当调用一个方法时，js 会产生一个与这个方法对应的执行环境（context），即执行上下文。而当一系列方法被调用时，因为 js 时单线程的，同一时间只能执行一个方法，于是这些方法会被排队在一个单独的地方，就是 <strong>执行栈</strong>。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-2f761eb83b50f53d741e6aa1f15a9db1_b.webp" class title="执行栈"><p>一个方法执行时会向执行栈中加入这个方法的执行环境，在这个执行环境中还可以调用其他方法，甚至是自己，也就会在执行栈中再添加一个执行环境，此过程可以是无限循环的，除非发生了栈溢出。</p><p>以上均是在说同步代码的执行，当一个异步代码执行后，实现就需要依赖 js 的另一大特点 —— 非阻塞，关键在于—— 事件队列（Task Queue）</p><p>js 在遇到一个异步任务后并不会一直等待其返回结果，而是将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js 会将这个事件加入并一个队列 —— 事件队列，放入其中不会立刻执行其回调，而是等当前执行栈中的所有任务都执行完毕，主线程处于闲置状态后，主线程才会去查看事件队列中是否有任务，如果有，则取出排在第一位的事件，将对应回调放入执行栈，然后执行其中的同步代码，如此反复，这个过程就叫 <strong>事件循环（Event Loop）</strong>。</p><h4 id="marco-task-与-mirco-task"><a href="#marco-task-与-mirco-task" class="headerlink" title="marco task 与 mirco task"></a>marco task 与 mirco task</h4><p>因为异步任务之间并不相同，因此执行优先级也有区别，不同的异步任务分为两类：</p><ul><li>微任务（mirco task）<ul><li><code>Promise.resolve().then()</code> </li><li><code>new MutationObserver()</code> </li></ul></li><li>宏任务（macro task）<ul><li><code>setInterval()</code> </li><li><code>serTimeout()</code> </li></ul></li></ul><p>在一个事件循环中，异步事件返回结果后会被放到相对应的宏任务队列或者微任务队列中，在当前执行栈为空时，<u>主线程会先查看微任务队列中是否有事件存在，为空后再去查看宏任务队列</u>。</p><h4 id="node-环境中事件循环"><a href="#node-环境中事件循环" class="headerlink" title="node 环境中事件循环"></a>node 环境中事件循环</h4><h5 id="libuv-引擎"><a href="#libuv-引擎" class="headerlink" title="libuv 引擎"></a>libuv 引擎</h5><p>node 中事件循环的实现是依靠 libuv 引擎，node 使用 chrome V8 作为 js 解释器，V8 引擎在将 js 代码分析后去调用相应的 node api，这些 api 最后由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。</p><h5 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h5><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126134544019.png" class title="libuv 事件模型"><p>外部输入数据 ——&gt; 轮询阶段（poll）——&gt; 检查阶段（check）——&gt; 关闭时间回调阶段（close callbacks）——&gt; 定时器检测阶段（timer）——&gt; I/O 事件回调阶段（I/O callbacks）——&gt; 闲置阶段（idle, prepare）——&gt; 轮询阶段 ……</p><p>阶段大致功能：</p><ul><li>poll：等待新的 I/O 事件，node 在某些特殊情况下会阻塞此处；</li><li>check：执行 <code>setImmediate()</code> 的回调；</li><li>close callbacks：如 <code>socket.on(&#39;close&#39;, ...)</code> 这种 close 事件的回调；</li><li>timers：这个阶段执行定时器队列中的回调：<code>setTimeout()</code> 和 <code>setInterval()</code>；</li><li>I/O callbacks：这个阶段执行除 close 事件、定时器和 <code>setImmediate()</code> 的回调之外所有的回调；</li><li>idle, prepare：仅在内部使用。</li></ul><h5 id="poll"><a href="#poll" class="headerlink" title="poll"></a>poll</h5><p>先查看 poll queue 中是否有事件，有任务就按先进先出的顺序依次执行回调，若为空，则检查是否有 setImmediate() 的 callback，如果有就进入 check 阶段执行，同时也会检查是否有到期的 timer，如果有就把这些到期的 timer 的 callback 按调用顺序放到 timer queue 中。</p><p>收到代码运行环境的影响，如果两者的 queue 均为空，则 loop 会在 poll 阶段停留，直到有一个 I/O 事件返回，进入 I/O callback 阶段并立即执行这个事件的 callback。</p><p>poll 阶段在执行 poll queue 中的回到时并不会无限的执行下去：</p><ol><li>所有回调执行完毕；</li><li>执行数超过了 node 的限制</li></ol><p>两者其一则会终止执行 poll queue 中的下一个回调。</p><h5 id="check"><a href="#check" class="headerlink" title="check"></a>check</h5><p>专门用来执行 <code>setImmediate()</code> 方法的回调，当 poll 阶段进入空闲状态，并且 setImmediate queue 中有callback时，事件循环进入此阶段。</p><h5 id="close"><a href="#close" class="headerlink" title="close"></a>close</h5><p>当一个 socket 连接或者一个 handle 被突然关闭时（如调用了 <code>socket.destroy()</code> 方法），close 事件会被发送到这个阶段执行回调，否则事件会用 <code>process.nextTick()</code> 方法发送出去。</p><h5 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h5><p>以先进先出的方式执行所有到期的 timer 加入 timer queue 里的 callback。</p><p>一个 timer 指的是一个通过 setTimeout 或 setInterval 函数设置的回调函数</p><h5 id="I-O-callback"><a href="#I-O-callback" class="headerlink" title="I/O callback"></a>I/O callback</h5><p>主要执行大部分 I/O 事件的回调，包括一些为操作系统执行的回调。</p><h5 id="process-nextTick"><a href="#process-nextTick" class="headerlink" title="process.nextTick()"></a>process.nextTick()</h5><p>node 中存在一个特殊的队列，即 nextTick queue，这些事件会在每一个阶段执行完毕后准备进入下一个阶段前优先执行。</p><p>与执行 poll queue 的区别在于这个操作在队列清空前是不会停止的，所以错误的使用 <code>process.nextTick()</code> 会导致 node 进入一个死循环，直到内存泄漏。</p><h5 id="setTimeout-和-setImmediate"><a href="#setTimeout-和-setImmediate" class="headerlink" title="setTimeout 和 setImmediate"></a>setTimeout 和 setImmediate</h5><p><code>setTimeout()</code> 方法是定义一个回调，在所指定的时间间隔后第一时间去执行，受到操作系统和当前执行任务的诸多影响，该回调并不会在预期时间间隔后精准的执行，会存在一定的偏差。</p><p><code>setImmediate()</code> 方法从意义上是立刻执行的意思，但其实是在一个固定的阶段才会执行回调，即 poll 阶段之后。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出顺序不一定，这取决于这段代码的运行环境。</span></span><br></pre></td></tr></table></figure><p>但下面的输出顺序是确定的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.readFile(__filename, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;timeout&#x27;</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">  setImmediate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;immediate&#x27;</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// immediate</span></span><br><span class="line"><span class="comment">// timeout</span></span><br></pre></td></tr></table></figure><p>因为在 I/O 事件的回调中，setImmediate 方法的回调永远在 timer 的回调前执行。</p><h3 id="promise"><a href="#promise" class="headerlink" title="promise"></a>promise</h3><p>Promise 只有三种状态：等待（Pending）、执行（Fulfilled）、拒绝（Rejected）。一旦 Promise 被 resolve 或 reject，不能再迁移至其他任何状态（即状态 immutable）</p><h4 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(&#123; <span class="attr">test</span>: <span class="number">1</span> &#125;)</span><br><span class="line">    resolve(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">    reject(&#123; <span class="attr">test</span>: <span class="number">2</span> &#125;)</span><br><span class="line">  &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;result1&#x27;</span>, data) <span class="comment">// &#x27;result1&#x27;, &#123; test: 1 &#125;</span></span><br><span class="line">&#125;,<span class="function">(<span class="params">data1</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;result2&#x27;</span>,data1)</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;result3&#x27;</span>, data) <span class="comment">// &#x27;result3&#x27;, undefined</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol><li>Promise 可以进行链式调用，且每次 then 返回了新的 Promise；</li><li>只输出第一次 resolve 的内容，即状态不可逆；</li><li>then 中注册的回调仍然是属于上一个 Promise 的</li></ol><p>模拟实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span>,</span><br><span class="line">      value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 将新 Promise 的 resolve 方法放到前一个 promise 的回调对象中</span></span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">        reject</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> callback.onFulfilled : callback.onRejected</span><br><span class="line">    <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span> callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> ret = cb(value) <span class="comment">// 处理回调</span></span><br><span class="line">    next(ret) <span class="comment">// 处理下一个 promise 的 resolve</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = newValue</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          <span class="comment">// newValue 为新产生的 Promise，此时 resolve 为上个 promise 的 resolve</span></span><br><span class="line">          <span class="comment">// 相当于调用了新产生 Promise 的 then 方法，注入了上个 promise 的 resolve 为其回调</span></span><br><span class="line">          then.call(newValue, resolve)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      state = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      value = newValue</span><br><span class="line">      handleCb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">if</span> (error &amp;&amp; (<span class="keyword">typeof</span> error === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> error === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;funciton&#x27;</span>) &#123;</span><br><span class="line">          then.call(error, reject)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      value = error</span><br><span class="line">      handleCb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleCb</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (callbacks.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fn(resolve, reject)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><p>异常通常是指在执行成功/失败回调时代码出错产生的错误，使用 try-catch 来捕获异常，并将 Promise 设为 rejected 状态即可。</p><p>对 handle 函数进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span>,</span><br><span class="line">      value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> ret = cb(value)</span><br><span class="line">      next(ret)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加 catch 方法来处理错误</span></span><br><span class="line">  <span class="built_in">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onError</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 增加 finally 用于执行最后的操作</span></span><br><span class="line">  <span class="built_in">this</span>.finally = <span class="function"><span class="keyword">function</span> (<span class="params">onDone</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.then(onDone, onDone)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="resolve-和-reject"><a href="#resolve-和-reject" class="headerlink" title="resolve 和 reject"></a>resolve 和 reject</h4><p>实际应用中，可以使用 <code>Promise.resolve</code> 和 <code>Promise.reject</code> 方法将非 Promise 实例包装为 Promise 实例，传入的参数可能有：</p><ul><li>无参数</li><li>普通数据参数</li><li>一个 Promise 实例</li><li>一个 thenable 对象（指具有 then 方法的对象）</li></ul><p>模拟实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">const</span> &#123; then &#125; = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          then(resolve)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve())</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">this</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      reject(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">      <span class="keyword">var</span> remaining = args.length</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">res</span> (<span class="params">i, val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; then &#125; = val</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              then.call(cal, <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] = val</span><br><span class="line">          <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="built_in">this</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="完整模型"><a href="#完整模型" class="headerlink" title="完整模型"></a>完整模型</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Promise</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> state = <span class="string">&#x27;pending&#x27;</span>,</span><br><span class="line">      value = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">const</span> callbacks = []</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.then = <span class="function"><span class="keyword">function</span> (<span class="params">onFulfilled, onRejected</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      handle(&#123;</span><br><span class="line">        onFulfilled,</span><br><span class="line">        onRejected,</span><br><span class="line">        resolve,</span><br><span class="line">reject</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.catch = <span class="function"><span class="keyword">function</span> (<span class="params">onError</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(<span class="literal">null</span>, onError)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.finally = <span class="function"><span class="keyword">function</span> (<span class="params">onDone</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.then(onDone, onDone)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.resolve = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value) &#123;</span><br><span class="line">      <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="built_in">Promise</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> value</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> value.then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = value</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">          then(resolve)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve())</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.reject = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      rejecy(value)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = <span class="built_in">Array</span>.prototype.slice.call(arr)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (args.length === <span class="number">0</span>) <span class="keyword">return</span> resolve([])</span><br><span class="line">      <span class="keyword">let</span> remaining = args.length</span><br><span class="line">      </span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">res</span> (<span class="params">i ,val</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (val &amp;&amp; (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> val === <span class="string">&#x27;function&#x27;</span>)) &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; then &#125; = val</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">              then.call(val, <span class="function"><span class="params">val</span> =&gt;</span> &#123;</span><br><span class="line">                res(i, val)</span><br><span class="line">              &#125;, reject)</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          args[i] = val</span><br><span class="line">          <span class="keyword">if</span> (--remaining === <span class="number">0</span>) &#123;</span><br><span class="line">            resolve(args)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">          reject(ex)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = args.length; i &lt; len; i++) &#123;</span><br><span class="line">        res(i, args[i])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">this</span>.race = <span class="function"><span class="keyword">function</span> (<span class="params">values</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = values.length; i &lt; len; i++) &#123;</span><br><span class="line">        values[i].then(resolve, reject)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (state === <span class="string">&#x27;pending&#x27;</span>) &#123;</span><br><span class="line">      callbacks.push(callback)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> cb = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.onFulfilled : callback.onRejected</span><br><span class="line">    <span class="keyword">const</span> next = state === <span class="string">&#x27;fulfilled&#x27;</span> ? callback.resolve : callback.reject</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!cb) &#123;</span><br><span class="line">      next(value)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> ret</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      ret = cb(value)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      callback.reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">    callback.resolve(ret)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">resolve</span> (<span class="params">newValue</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (newValue &amp;&amp; (<span class="keyword">typeof</span> newValue === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> newValue === <span class="string">&#x27;funciton&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = newValue</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          then.call(newValue, resolve, reject)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">&#x27;fulfilled&#x27;</span></span><br><span class="line">      value = newValue</span><br><span class="line">      handleCb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reject</span> (<span class="params">error</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> fn = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (state !== <span class="string">&#x27;pending&#x27;</span>) <span class="keyword">return</span></span><br><span class="line">      <span class="keyword">if</span> (error &amp;&amp; (<span class="keyword">typeof</span> error === <span class="string">&#x27;object&#x27;</span> || <span class="keyword">typeof</span> error === <span class="string">&#x27;funciton&#x27;</span>)) &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; then &#125; = error</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">          then.call(error, resolve, reject)</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      state = <span class="string">&#x27;rejected&#x27;</span></span><br><span class="line">      value = error</span><br><span class="line">      handleCb()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">setTimeout</span>(fn, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleCb</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (callbacks.length) &#123;</span><br><span class="line">      <span class="keyword">const</span> fn = callbacks.shift()</span><br><span class="line">      handle(fn)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    fn(resolve, reject)</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">    reject(ex)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="generator"><a href="#generator" class="headerlink" title="generator"></a>generator</h3><p>实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">example</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> iter = example()</span><br><span class="line">iter.next() <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 2, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line">iter.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure><p>上述代码定义了一个生成器函数，调用时并非立即执行该函数，而是返回一个生成器对象。每当调用生成器函数的 <code>next()</code> 方法时，函数将运行到下一个 yield 表达式，返回表达式结果并暂停自身执行。</p><p>与普通函数的区别：</p><ul><li>普通函数使用 <code>function</code> 声明，生成器函数使用 <code>function*</code> 声明；</li><li>普通函数使用 <code>return</code> 返回值，生成器函数使用 <code>yield</code> 返回值；</li><li>普通函数是 <code>run to completion</code> 模式，即开始执行后会一直执行到该函数的所有语句完成，在此期间其他代码语句不会执行；生成器函数是 <code>run pause run</code> 模式，即可以在函数运行中被暂停一次或多次，并在后面再恢复执行，暂停期间允许其他代码语句被执行。</li></ul><p>js 执行引擎是一个基于事件循环的单线程环境，当生成器运行时，会在一个叫 caller 的同一个线程中运行，执行的顺序是有序、确定的，并且永远不会发生并发。</p><h3 id="ES6-新特性"><a href="#ES6-新特性" class="headerlink" title="ES6 新特性"></a>ES6 新特性</h3><h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><h3 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h3><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>盒模型又称框模型（Box Model），包含了元素内容（content）、内边距（padding）、边框（border）、外边距（margin）四个要素。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069519.png" class title="盒模型示意图"><h4 id="标准模型和-IE-模型"><a href="#标准模型和-IE-模型" class="headerlink" title="标准模型和 IE 模型"></a>标准模型和 IE 模型</h4><p>由于 IE 模型的怪异模式，导致 IE 模型和标准模型的内容计算方式不同：</p><p><strong>IE 模型元素宽度 width = content + padding + border</strong>，高度计算相同：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069520.png" class title="IE模型宽度计算示意图"><p><strong>标准模型元素宽度 width = content</strong>，高度计算相同：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069521.png" class title="标准模型计算示意图"><h4 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h4><p>通过 CSS3 新增的属性 <code>box-sizing: content-box | border-box</code> 分别设置盒模型为标准模型（content-box） 和 IE 模型（border-box）。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">5px</span> solid red;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">15px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content-box</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: content-box;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.border-box</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>content-box</code> 设置为标准模型，元素宽度 <code>wight = 100px</code>；</p><p><code>border-box</code> 设置为 IE 模型，元素宽度为 <code>width = content + 2 * padding + 2 * border = 75px + 2 * 10px + 2 * 5px = 100px</code>。</p><h4 id="js-获取盒模型宽高"><a href="#js-获取盒模型宽高" class="headerlink" title="js 获取盒模型宽高"></a>js 获取盒模型宽高</h4><ol><li><code>dom.style.width/height</code>：只能获取到行内样式的宽和高，style 标签中和 link 外链中的样式取不到；</li><li><code>dom.currentStyle.width/height</code>：取到的是最终渲染后的宽和高，只有 IE 支持此属性；</li><li><code>window.getComputedStyle(dom).width/height</code>：取到的也是最终渲染的宽和高，多数浏览器支持（IE9 以上支持）；</li><li><code>dom.getBoundingClientRect().eidth/height</code>：得到渲染后的宽和高，大多数浏览器支持（IE9 以上支持），同时可以取到相对于视窗的上下左右的距离。</li></ol><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220126170517922.png" class title="js 获取 dom 宽高"><blockquote><p>前三位取到的结果都是带单位的字符串类型值，第四种方法得到的是数字类型的值。</p></blockquote><h4 id="外边距重叠"><a href="#外边距重叠" class="headerlink" title="外边距重叠"></a>外边距重叠</h4><p>当两个垂直外边距相遇时，它们将合并为一个外边距，合并后的外边距高度等于两者较大者。</p><blockquote><p>注意：只有普通文档流中块级元素的垂直外边距才会发生外边距合并，行内元素、浮动元素或绝对定位之间的外边距不会合并。</p></blockquote><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/1460000013069524.png" class title="外边距重叠"><h3 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h3><p>BFC（Block Formatting Context）：块级格式化上下文。</p><p>BFC 决定了元素如何对其内容进行定位，以及与其他元素的关系和相互作用。当设计到可视化布局时，BFC 提供了一个环境，HTML 元素在这个环境中按照一定的规则进行布局。一个环境中的元素不会影响到其他环境中的布局。</p><blockquote><p>IE 下为 Layout，可以通过 <code>zoom: 1</code> 触发。</p></blockquote><h4 id="原理-渲染规则"><a href="#原理-渲染规则" class="headerlink" title="原理(渲染规则)"></a>原理(渲染规则)</h4><ul><li>BFC 内部的 Box 会在垂直方向一个接一个的放置</li><li>BFC 元素垂直方向的距离由 margin 决定，同属一个 BFC 的两个相邻 Box 的 margin 会发生重叠，若属于不同 BFC 则不会重叠</li><li>BFC 区域不会与浮动元素的布局重叠</li><li>BFC 元素是一个独立的容器，里外的元素不会相互影响</li><li>计算 BFC 高度时，浮动元素也会参数计算</li><li>文字层不会被浮动层覆盖，而是环绕于周围</li></ul><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><ol><li>根元素</li><li><code>overflow</code> 不为 <code>visible</code> </li><li><code>float</code> 不为 <code>none</code> </li><li><code>position</code> 不为 <code>static | relative</code> </li><li><code>display</code> 为 <code>inline-block | table | table-cell | table-caption | flex | inline-flex</code> </li></ol><blockquote><p>注意：由于子元素浮动而引起的父元素高度丢失，可以通过在父元素创建 BFC 就可以使浮动子元素也参与高度计算。</p></blockquote><h3 id="IFC"><a href="#IFC" class="headerlink" title="IFC"></a>IFC</h3><p>IFC（Inline Formatting Context）：内联格式化上下文</p><h4 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h4><ul><li>块级元素中仅包含内联级别元素</li></ul><blockquote><p>需要注意当 IFC 中有 块级元素插入时，会产生两个匿名块将父元素分割开来，产生两个 IFC。</p></blockquote><h4 id="布局规则"><a href="#布局规则" class="headerlink" title="布局规则"></a>布局规则</h4><ul><li>子元素水平方向横向排列，并且垂直方向起点为元素顶部（即默认从左上开始从左到右依次排列）</li><li>子元素只会计算横向样式空间，垂直方向样式空间不会被计算（指垂直方向的 padding、border、margin）</li><li>在垂直方向上，子元素会以不同形式来对齐（vertical-align）</li><li>能把在一行上的子元素全部包含进去的一个矩形边框，叫做该行的行框（line box）。其宽度取决于包含块以及其中的浮动来决定的</li><li>IFC 中的 line box 一般左右贴紧其包含块，但 float 元素会优先排列</li><li>IFC 中的 line box 的高度由 CSS 行高计算规则来确定，同个 IFC 下的多个 line box 高度可能不同</li><li>当 inline box 中子元素的总宽度少于包含它们的 inline box 时，其水平渲染规则由 text-align 属性值决定</li><li>当一个 inline box 超过父元素的宽度时，会被分割成多个 boxes，并分布在多个 line box 中；如果子元素未设置强制换行，则 inline box 将不可被分割而溢出父元素</li></ul><h3 id="层叠上下文"><a href="#层叠上下文" class="headerlink" title="层叠上下文"></a>层叠上下文</h3><p>层叠上下文（stacking context），是 HTML 中一个三维的概念。</p><p>如果一个元素含有层叠上下文，可以理解为这个元素在 z 轴 上就高人一等，离用户更近。</p><h4 id="层叠水平"><a href="#层叠水平" class="headerlink" title="层叠水平"></a>层叠水平</h4><p>层叠水平（stacking level），决定了同一个层叠上下文中元素在 z 轴上的显示顺序。</p><p>普通元素的层叠水平优先由层叠上下文决定，因此层叠水平的比较只有在当前层叠上下文元素中才有意义。</p><blockquote><p>注意：不可以把层叠水平和 CSS 的 z-index 属性混为一谈，某些情况下 z-index 确实可以影响层叠水平，但只限于定位元素以及 flex 盒子的子元素，而层叠水平所有的元素都存在。</p></blockquote><h4 id="层叠顺序"><a href="#层叠顺序" class="headerlink" title="层叠顺序"></a>层叠顺序</h4><p>层叠顺序（stacking order），表示当元素发生层叠时有着特定的垂直显示顺序，上面的层叠上下文和层叠水平是概念，而层叠顺序是规则。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214173741026.png" class title="层叠顺序"><ol><li>位于最低水平的 <code>border/background</code> 指层叠上下文元素的边框和背景，每一个层叠顺序规则适用于一个完整的层叠上下文元素；</li><li><code>z-index: auto</code> 和 <code>z-index: 0</code> 单纯从层叠水平上看，是可以认为是一样的，但实际上两者在层叠上下文领域有着根本性的差异。</li></ol><h4 id="层叠准则"><a href="#层叠准则" class="headerlink" title="层叠准则"></a>层叠准则</h4><p>当元素发生层叠时，其覆盖关系遵循以下两个准则：</p><ol><li><strong>谁大谁上</strong>：当具有明显的层叠水平标示时（如 z-index 值），在同一个层叠上下文领域，层叠水平值大的那一个覆盖小的那一个；</li><li><strong>后来居上</strong>：当元素的层叠水平一致、层叠顺序相同时，在 DOM 流中处于后面的元素覆盖前面的元素。</li></ol><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ul><li>层叠上下文的层叠水平要比普通元素高；</li><li>层叠上下文可以阻断元素的混合模式；</li><li>层叠上下文可以嵌套，内部层叠上下文及其所有子元素均受限于外部的层叠上下文；</li><li>每个层叠上下文和兄弟元素独立，也就是进行层叠变化或渲染时，只需要考虑后代元素；</li><li>每个层叠上下文是自成体系的，当元素发生层叠时，整个元素被认为是在父层叠上下文的层叠顺序中。</li></ul><h4 id="创建-2"><a href="#创建-2" class="headerlink" title="创建"></a>创建</h4><p>根层叠上下文：页面根元素 <code>&lt;html&gt;</code> 天生具有层叠上下文；</p><p>传统层叠上下文：</p><p>对于包含有 <code>position: relative</code> / <code>position: absolute</code> 的定位元素，以及 FireFox/IE 浏览器下含有 <code>position: fixed</code> 声明的定位元素，当其 <code>z-index</code> 值不是 <code>auto</code> 的时候就会创建层叠上下文；</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mm1.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute; z-index:2;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position:relative; z-index:auto;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mm2.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:relative; z-index:1;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上面的效果为 mm1 覆盖在 mm2 上面，因为两者处于同一个层叠上下文中，且 mm1 图片的 z-index 更大；</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mm1.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute; z-index: 2;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; z-index: 0;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;mm2.jpg&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: relative; z-index: 1;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>稍作修改，效果就会反转，mm1 被 mm2 覆盖，因为两个 div 的 z-index 不再是 auto 而是数值，所以分别创建了层叠上下文，故两张图片不在同一个层叠上下文中，层叠顺序相同，层叠准则遵循后来居上。</p><p>其他 CSS3 属性：</p><ul><li><code>z-index</code> 不为 <code>auto</code> 的 <code>flex</code> 项（父元素 <code>display: flex|inline-flex</code>）；</li><li>元素的 <code>opacity</code> 值不是 1；</li><li>元素的 <code>transform</code> 值不是 <code>none</code>；</li><li>元素的 <a href="http://www.zhangxinxu.com/wordpress/2015/05/css3-mix-blend-mode-background-blend-mode/"><code>mix-blend-mode</code></a> 值不是 <code>normal</code>；</li><li>元素的 <code>filter</code> 值不是 <code>none</code>；</li><li>元素的 <a href="http://www.zhangxinxu.com/wordpress/?p=5155"><code>isolation</code></a> 值不是 <code>isolate</code>；</li><li><a href="http://www.zhangxinxu.com/wordpress/2015/11/css3-will-change-improve-paint/"><code>will-change</code> </a>指定的属性值为上面的任意一个；</li><li>元素的 <code>-webkit-overflow-scrolling</code> 设为 <code>touch</code>。</li></ul><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>一旦普通元素具有了层叠上下文，其层叠顺序就会变高，层叠顺序与 <code>z-index: 0</code> 同一位置：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220214182400866.png" class title="层叠顺序"><p>定位元素层叠在普通元素上的根本原因在于：元素一旦成为定位元素，其 <code>z-index</code> 就会生效，此时其 <code>z-index</code> 就是默认的 <code>auto</code> 也就是 0 级别，也就会覆盖 <code>inline</code> 或 <code>block</code> 或 <code>float</code> 元素。</p><blockquote><p>CSS3 的 fadeIn 淡入 animation 效果本质上就是元素 <code>opacity</code> 透明度的变化，而当 <code>opacity</code> 的值不是 1 的时候，是具有层叠上下文的。</p></blockquote><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>选择器是 CSS 规则的一部分，处于 CSS 声明块前。</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>简单选择器（Simple selectors）：通过 <strong>元素类型</strong>、<strong>class</strong> 或 <strong>id</strong> 匹配一个或多个元素</li><li>属性选择器（Attribute selectors）：通过 <strong>属性/属性值</strong> 匹配一个或多个元素</li><li>伪类（Pseudo-classes）：匹配处于确定状态的一个或多个元素，比如被鼠标指针悬停的元素…</li><li>伪元素（Pseudo-elements）：匹配处于相关的确定位置的一个或多个元素，例如每个段落的第一个字…</li><li>组合器（Combinators）：以有效的方式组合两个或更多的选择器用于非常特定的选择的方法</li><li>多用选择器（Multiple selectors）：将以逗号分隔开的多个选择器放在一个 CSS 规则下面，以将一组声明应用于由这些选择器选择的所有元素</li></ul><h4 id="简单选择器"><a href="#简单选择器" class="headerlink" title="简单选择器"></a>简单选择器</h4><p><strong>类型选择器（元素选择器）</strong> </p><p>一个选择器名和指定的 HTML 元素名的不区分大小写的匹配。</p><p><strong>类选择器（Class selectors）</strong> </p><p>类选择器由一个点 <code>.</code> 以及后面的类名组成。类名是在 HTML 文档元素属性 class 中没有空格的任何值。</p><ul><li>文档中的多个元素可以具有相同的类名</li><li>单个元素可以由多个类名，用空格做间隔</li></ul><p><strong>ID 选择器</strong> </p><p>ID 选择器由一个哈希/磅符号 <code>#</code> 以及后面的 ID 名称组成。</p><ul><li>任何元素都可以使用 id 属性设置唯一的 ID 名称</li><li>这是选择单一元素最有效的方法</li></ul><blockquote><p>注意：一个 ID 名称必须在文件中是唯一的，在一些浏览器中只是第一个实例会计算，其余的将被忽略。</p></blockquote><p><strong>通用选择器</strong> </p><p>通用选择 <code>*</code> 允许选择在一个页面中的所有元素。</p><blockquote><p>注意：因为它适用于所有的元素，所以在大型页面使用可能对性能有明显的影响。</p></blockquote><h4 id="组合器"><a href="#组合器" class="headerlink" title="组合器"></a>组合器</h4><p>在 CSS 中，组合器允许将多个选择器组合在一起，四种可用的类型是：</p><ul><li>后代选择器 —— 空格 —— 选择嵌套在一个元素中的某些元素（不一定是直系子代）</li><li>子选择器 —— <code>&gt;</code> —— 选择一个元素的直接子元素</li><li>相邻兄弟选择器 —— <code>+</code> —— 选择一个元素之后直接相连的兄弟元素（同层的相邻元素）</li><li>通用兄弟元素 —— <code>~</code> —— 选择一个元素之后的所有兄弟元素（同层的所有其他元素）</li></ul><blockquote><p>注意：相邻兄弟选择器和通用兄弟选择器只会向后选择，DOM 结构靠前的兄弟元素不在选择范围内。</p></blockquote><h4 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h4><p>根据元素的属性和属性值来匹配元素，通用语法由 <code>[]</code> 组成，其中包含属性名称，后可跟可选条件一匹配属性的值。</p><p>可根据其匹配属性值的方式分为：</p><p><strong>存在和值（Presence and value）选择器</strong> </p><p>尝试匹配精确的属性值：</p><ul><li><code>[attr]</code>：选择包含 attr 属性的所有元素，不论 attr 的值是什么</li><li><code>[attr=val]</code>：仅选择 attr 属性被赋值为 val 的所有元素</li><li><code>[attr~=val]</code>：仅选择 attr 属性的值中包含 val 值的所有元素（多个值用空格做间隔）</li></ul><p><strong>子串值（Substring value）属性选择器</strong> </p><p>也被称为“伪正则选择器”，提供类似 regular expression 的灵活匹配方式：</p><ul><li><code>[attr|=val]</code>：选择 attr 属性的值 以 val 或 val- 开头的元素</li><li><code>[attr^=val]</code>：选择 attr 属性的值 以 val 开头的元素</li><li><code>[attr$=val]</code>：选择 attr 属性的值 以 val 结尾的元素</li><li><code>[attr*=val]</code>：选择 attr 属性的值中包含字符串 val 的元素</li></ul><blockquote><p>均包含 attr 属性就是 val 的情况。</p></blockquote><h4 id="伪类和伪元素"><a href="#伪类和伪元素" class="headerlink" title="伪类和伪元素"></a>伪类和伪元素</h4><p><strong>伪类（Pseudo-class）</strong> </p><p>一个 CSS 伪类是一个以冒号 <code>:</code> 作为前缀的关键词。</p><p>当你需要样式在特定状态下才被呈现到指定的元素时，可以往元素的选择器后面加上对应的伪类。</p><p>伪类有：</p><table><thead><tr><th>伪类</th><th>作用</th></tr></thead><tbody><tr><td>:link</td><td>超链接点击之前的样式</td></tr><tr><td>:visited</td><td>超链接点击过后的样式</td></tr><tr><td>:hover</td><td>鼠标移上的样式</td></tr><tr><td>:actived</td><td>鼠标按下的样式</td></tr><tr><td>:focus</td><td>表单元素获取焦点的样式</td></tr><tr><td>:blur</td><td>表单元素失去焦点的样式</td></tr><tr><td>:checked</td><td>表单元素被选中的样式</td></tr><tr><td>:not(E)</td><td>匹配所有除 E 以外的元素</td></tr><tr><td>:last-child</td><td>最后一个元素</td></tr><tr><td>:nth-child(n)</td><td>n 表示具体的第几个，可以传入 odd/2n+1、even/2n 等</td></tr><tr><td>:only-child</td><td>本层级唯一的元素</td></tr><tr><td>:nth-last-child(n)</td><td>倒数第 n 个元素</td></tr><tr><td>:first-of-type</td><td>第一个同级兄弟元素</td></tr><tr><td>:last-of-type</td><td>最后一个同级兄弟元素</td></tr><tr><td>:only-of-type</td><td>唯一的一个兄弟元素</td></tr><tr><td>:nth-of-type(n)</td><td>第 n 个同级的兄弟元素</td></tr><tr><td>:nth-last-of-type(n)</td><td>倒数第 n 个同级的兄弟元素</td></tr><tr><td>:empty</td><td>空内容</td></tr><tr><td>:lang(language)</td><td>匹配使用某种语言的元素</td></tr><tr><td>:target</td><td>匹配页面的 URI 中某个标识符的目标元素</td></tr><tr><td>:enabled</td><td>未使用的表单元素</td></tr><tr><td>:disabled</td><td>不可用的表单元素</td></tr><tr><td>:root</td><td>匹配文档所有的根元素</td></tr></tbody></table><p><strong>伪元素（Pesudo-element）</strong> </p><p>以两个冒号 <code>::</code> 作为前缀的关键词，同样是添加到指定某个元素选择器的后面。</p><p>伪元素有：</p><table><thead><tr><th>伪元素</th><th>作用</th></tr></thead><tbody><tr><td>::after</td><td>可在元素的内容之后插入新内容，默认是一个行内元素<br>可使用属性 display 改变这一点</td></tr><tr><td>::before</td><td>与 ::after 类似，插入位置为内容之前</td></tr><tr><td>::first-letter</td><td>用于向文本的首字母设置特殊样式，只能用于块级元素</td></tr><tr><td>::first-line</td><td>用于向文本的首行设置特殊样式，只能用于块级元素</td></tr><tr><td>::selection</td><td>用于匹配突出显示的文本，浏览器默认情况下是深蓝背景白色字</td></tr><tr><td>::backdrop</td><td>任何处于全屏模式的元素下的即时渲染的盒子</td></tr></tbody></table><blockquote><p>大多数浏览器支持伪元素使用一个冒号或两个冒号两种表示方式。但 <code>::selection</code> 只能以两个冒号开头。</p></blockquote><h3 id="定位"><a href="#定位" class="headerlink" title="定位"></a>定位</h3><p>定位允许从正常的文档流布局中取出元素，让他们具有不同的行为，使用 <code>position</code> 属性。</p><h4 id="position"><a href="#position" class="headerlink" title="position"></a>position</h4><p><code>position</code> 属性用来指定一个元素在网页上的位置，一共有五种定位方式：</p><ul><li>static</li><li>relative</li><li>fixed</li><li>absolute</li><li>sticky（2017 年支持）</li></ul><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><p><code>static</code> 是 <code>position</code> 属性的默认值，此时浏览器会按照源码的顺序，决定每个元素的位置，称为“正常的页面流”（normal flow）。</p><p>每个块级元素占据自己的区块（block），元素与元素之间不会重叠，这个位置就是元素的默认位置。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111720.jpg" class title="static"><blockquote><p>static 定位所导致的元素位置是浏览器自主决定的，此时 top、bottom、left、right 四个属性无效。</p></blockquote><h4 id="relative-absolute-fixed"><a href="#relative-absolute-fixed" class="headerlink" title="relative absolute fixed"></a>relative absolute fixed</h4><p>这三个属性值都是相对于某个基点的定位，不同之处在于基点不同</p><p><strong>relative</strong> </p><p><code>relative</code> 表示，相对于默认位置（即 <code>static</code> 定位时的位置）进行偏移，即定位基点是元素的默认位置。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111721.jpg" class title="relative"><p>可以搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 四个属性一起使用，用来指定偏移的方向和距离。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111723.jpg" class title="relative"><p><strong>absolute</strong> </p><p><code>absolute</code> 表示，相对于上级元素（一般是父元素）进行偏移，即定位基点是父元素。</p><p>限制条件：定位基点不能是 <code>static</code> 定位，否则定位基点就会变为整个页面的根元素 <code>html</code> 。</p><p>也需要搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111801.jpg" class title="absolute"><blockquote><p><code>absolute</code> 定位的元素会被“正常页面流”忽略，即在“正常页面流”中，该元素所占空间为零，周边元素不受影响。</p></blockquote><p><strong>fixed</strong> </p><p><code>fixed</code> 表示，相对于视口（viewport，浏览器窗口）进行偏移，即定位基点是浏览器窗口，会导致元素的位置不会随页面滚动而变化，好像固定在网页上一样。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bg2019111802.jpg" class title="fixed"><p>一般搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 使用，表示元素的初始位置是基于视口计算的，否则初始位置就是元素的默认位置。</p><h4 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h4><p><code>sticky</code> 和之前四个属性值不一样，它会产生动态效果，很像 <code>relative</code> 和 <code>fixed</code> 的结合：一些时候是 <code>relative</code> 定位（定位基点是自身默认位置），另一些时候自动变成 <code>fixed</code> 定位（定位基点是视口）。</p><p><code>sticky</code> 生效的前提是必须搭配 <code>top</code>、<code>bottom</code>、<code>left</code>、<code>right</code> 一起使用，不能省略，否则等同于 <code>relative</code> 定位，不产生动态固定的效果。</p><p>具体规则：当页面滚动，父元素开始脱离视口时（即部分不可见），只要与 <code>sticky</code> 元素的距离达到生效门槛，<code>relative</code> 定位自动切换为 <code>fixed</code> 定位；等到父元素完全脱离视口时（即完全不可见），<code>fixed</code> 定位自动切换回 <code>relative</code>。</p><blockquote><p>除 IE 外，其他浏览器均支持 sticky，但 Safari 浏览器需要加上前缀 <code>-webkit-</code>。</p></blockquote><p>应用场景：</p><ul><li>堆叠效果：（stacking）指的是页面滚动时，下方的元素覆盖上方的元素；</li><li>表格的表头锁定。</li></ul><blockquote><p>注意：表头锁定时 <code>sticky</code> 需要设在 <code>&lt;th&gt;</code> 元素上，不能设在 <code>&lt;thead&gt;</code> 和 <code>&lt;tr&gt;</code> 元素上，因为这两个元素没有 <code>relative</code> 定位，所以无法产生 <code>sticky</code> 效果</p></blockquote><h3 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h3><p>Flexible Box 模型，通常被称为 flexbox，是一种一维的布局模型。给 flexbox 的子元素之间提供了强大的空空间分布和对齐能力。</p><h4 id="主轴和交叉轴"><a href="#主轴和交叉轴" class="headerlink" title="主轴和交叉轴"></a>主轴和交叉轴</h4><p>flex 布局中有两根轴线 —— 主轴和交叉轴。</p><p>主轴由 <code>flex-direction</code> 定义，可取值：</p><ul><li><code>row</code>：主轴沿着 inline 方向延伸</li><li><code>row-reverse</code>：沿着 inline 方向逆向延伸</li></ul><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics1.png" class title="flex:row"><ul><li><code>column</code>：主轴沿着 block 排列的方向延伸</li><li><code>column-reverse</code>：于 column 相逆</li></ul><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics2.png" class title="flex:column"><p>交叉轴垂直于主轴：</p><ul><li><code>flex-direction</code> (主轴) 设成了 <code>row</code> 或 <code>row-reverse</code>，则交叉轴的方向沿着列向下；</li><li>主轴方向设成了 <code>column</code> 或者 <code>column-reverse</code>，交叉轴就是水平方向</li></ul><h4 id="起始线和终止线"><a href="#起始线和终止线" class="headerlink" title="起始线和终止线"></a>起始线和终止线</h4><p>如果 <code>flex-direction</code> 是 <code>row</code>，书写英文时，则主轴的起始线是左边，终止线是右边：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics5.png" class title="row英文"><p>若书写阿拉伯文，则主轴起始线是右边，终止线是左边：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/Basics6.png" class title="row阿拉伯文"><p>在这两种情况下，交叉轴的起始线是flex容器的顶部，终止线是底部，因为两种语言都是水平书写模式。</p><h4 id="Flex-容器"><a href="#Flex-容器" class="headerlink" title="Flex 容器"></a>Flex 容器</h4><p>文档中使用了 flexbox 的区域就叫做 flex 容器，创建 flex 容器需要将其 <code>display</code> 属性值改为 <code>flex</code> 或 <code>inline-flex</code>，容器中的直系子元素就会变为 flex 元素，flex 容器中的所有 flex 元素都会有下列默认行为：</p><ul><li>元素排列为一行（<code>flex-direction</code> 属性的初始值是 <code>row</code>）</li><li>元素从主轴的起始线开始</li><li>元素不会在主维度方向拉伸，但是可以缩小</li><li>元素被拉伸来填充交叉轴大小</li><li><code>flex-basis</code> 属性为 <code>auto</code> </li><li><code>flex-wrap</code> 属性为 <code>nowrap</code> </li></ul><h5 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h5><p>在 flex 容器中添加 <code>flex-direction</code> 属性可以更改 flex 元素的排列方向。</p><p><code>-reverse</code> 会让元素沿着 <code>row</code> 或 <code>column</code> 的方向显示，但起始线和终止线位置会交换。</p><h5 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h5><p>需要实现多行效果可以为属性 <code>flex-wrap</code> 添加一个属性值 <code>wrap</code>，项目的子元素若超出容器最大宽度则会换行显示。</p><ul><li><code>nowrap</code>：默认值，规定 flex 元素不拆行或不拆列；</li><li><code>wrap</code>：规定 flex 元素在必要的时候进行拆行或拆列；</li><li><code>wrap-reverse</code>：规定 flex 元素在必要的时候以相反的顺序进行拆行或拆列；</li><li><code>initial</code>：设置属性为默认值；</li><li><code>inherit</code>：从父元素继承该属性。</li></ul><h5 id="flex-flow"><a href="#flex-flow" class="headerlink" title="flex-flow"></a>flex-flow</h5><p>可以将 <code>flex-direction</code> 和 <code>flex-wrap</code> 属性组合为简写属性 <code>flex-flow</code>，该属性第一个指定的值为 <code>flex-direction</code>，第二个指定的值为 <code>flex-wrap</code>。</p><h5 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h5><p><code>align-items</code> 属性可以使元素在<strong>交叉轴方向对齐</strong>，初始值为 <code>stretch</code>，所有 flex 元素会默认被拉伸到最高元素的高度 —— 最高的元素定义了容器的高度。</p><p>可选值有：</p><ul><li><code>stretch</code>：默认值，拉伸；</li><li><code>flex-start</code>：按 flex 容器的交叉轴起始线对齐；</li><li><code>flex-end</code>：按 flex 容器的交叉轴终止线对齐；</li><li><code>center</code>：按交叉轴居中对齐；</li><li><code>baseline</code>：按元素在容器的基线对齐。</li></ul><h5 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h5><p><code>justify-content</code> 属性使元素在<strong>主轴方向对齐</strong>，即通过 <code>flex-direction</code> 设置的方向。初始值为 <code>flex-start</code>，元素从主轴起始线排列。</p><p>可选值有：</p><ul><li><code>stretch</code>：拉伸；</li><li><code>flex-start</code>：默认值，按主轴起始线对齐；</li><li><code>flex-end</code>：按主轴终止线对齐；</li><li><code>center</code>：按主轴居中对齐；</li><li><code>space-around</code>：将可用空间平均分配为元素间的间隔后居中对齐，包括两侧（两侧所占比例为中间间隔的一半）；</li><li><code>space-between</code>：同 <code>space-around</code>，但不包括两侧；</li><li><code>space-evenly</code>：将可用空间平均分配为元素间的间隔后居中对齐，包括两侧，两侧所占比例与元素间间隔相等。</li></ul><h4 id="flex-元素"><a href="#flex-元素" class="headerlink" title="flex 元素"></a>flex 元素</h4><p>为了更好地控制 flex 属性，有三个属性可以作用于它们：</p><ul><li><code>flex-grow</code> </li><li><code>flex-shrink</code> </li><li><code>flex-basis</code> </li></ul><h5 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h5><p><code>flex-basis</code> 用于设置或检索弹性盒伸缩<strong>基准值</strong>。</p><p><code>flex-basis</code> 定义了该元素的空间大小，flex 容器中除了元素所占的空间以外的富余空间就是可用空间，该属性的默认值为 <code>auto</code>。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: number | auto | initial | inherit;</span><br></pre></td></tr></table></figure><p>如果没有给元素设定尺寸，<code>flex-basis</code> 的值采用元素内容（content）的尺寸。</p><h5 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h5><p><code>flex-grow</code> 用于设置或检索弹性盒子的<strong>扩展比率</strong>。</p><p><code>flex-grow</code> 若被赋值为一个正整数，flex 元素会以 <code>flex-basis</code> 为基础，沿主轴方向增长尺寸。这会使该元素扩展，并占据该方向轴上的可用空间。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-grow</span>: number | initial | inherit;</span><br></pre></td></tr></table></figure><p>若有多个 flex 元素设定了 <code>flex-grow</code> 属性值，则它们将按照属性值的比例平分对应的可用空间。</p><h5 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h5><p><code>flex-shrink</code> 属性定义了 flex 元素的收缩规则。若 flex 容器中没有足够排列 flex 元素的空间，则可以把 flex 元素的 <code>flex-shrink</code> 属性设置为正整数来缩小它所占空间到 <code>flex-basis</code> 以下。</p><p>flex 元素仅在默认宽度之和大于容器的时候才会发生收缩，收缩的大小根据 flex-shrink 的值，如果元素不是弹性盒对象的元素，则 flex-shrink 不起作用。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-shrink</span>: number | initial | inherit;</span><br></pre></td></tr></table></figure><h5 id="flex-1"><a href="#flex-1" class="headerlink" title="flex"></a>flex</h5><p>以上三个属性很少单独使用，而是混合写在 <code>flex</code> 简写形式中:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: flex-grow flex-shrink flex-basis | auto | none | initial | inherit;</span><br></pre></td></tr></table></figure><p>预定义：</p><ul><li><code>flex: initial</code>：把 flex 元素重置为 flexbox 的初始值，相当于 <code>flex: 0 1 auto</code>；<ul><li><code>flex-grow</code> 的值为 0，所以 flex 元素不会超过它们 <code>flex-basis</code> 的尺寸；</li><li><code>flex-shrink</code> 的值为 1，所以可以缩小 flex 元素来防止它们溢出；</li><li><code>flex-basis</code> 的值为 auto，flex 元素尺寸可以是在主维度上设置也可以是根据内容自动得到。</li></ul></li><li><code>flex: auto</code>：等同于 <code>flex: 1 1 auto</code>，基本于 <code>initial</code> 相同，但此种在需要的时候既可以拉伸也可以收缩；</li><li><code>flex: none</code>：可以把 flex 元素设置为不可伸缩，等同于 <code>flex: 0 0 auto</code>，元素不能拉伸或收缩，但是元素会按具有 <code>flex-basis: auto</code> 属性的 flexbox 进行布局。</li></ul><blockquote><p>常见的 <code>flex: 1</code> 等等，相当于 <code>flex: 1 1 0</code>，元素可以在 <code>flex-basis</code> 为 0 的基础上伸缩。</p></blockquote><h3 id="权重"><a href="#权重" class="headerlink" title="权重"></a>权重</h3><ol><li>决定了 css 规则怎样被浏览器解析直到生效；</li><li>当多个相同样式被应用到同一个元素上时，权重是一个决定哪种样式生效，或者决定优先级的过程；</li><li>每个选择器都有自己的权重；</li><li>两个选择器同时作用到一个元素上，权重高者生效。</li></ol><p><strong>从 0 开始，一个行内样式  + 1000，一个 id 选择器 + 100，一个属性、伪类或者 class 选择器 + 10，一个元素或者伪元素选择器 + 1，通配符 + 0</strong> 。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/v2-b1a9fedf320754acb1d7766c6548d5f6_720w.jpg" class title="css权重值"><ol><li>同样权重，样式重复多写则后写的覆盖前面的；</li><li>不同权重，则权重高者生效。</li></ol><h4 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h4><p><code>!important</code> 的作用是提升样式优先级，若加上则此条样式优先级变为最高。</p><ol><li>同个样式都使用了 <code>!important</code> 样式则权重高者优先；</li><li>若 <code>!important</code> 作用于简写的样式属性，则此条简写样式所代表的子属性都会被作用上 <code>!important</code>。<ul><li>比如 <code>flex</code>、<code>background</code>、<code>border</code>…</li></ul></li></ol><h4 id="行内-外联-内联"><a href="#行内-外联-内联" class="headerlink" title="行内 外联 内联"></a>行内 外联 内联</h4><ul><li>行内样式始终要比外联或者内联的优先级高</li><li>内联样式和外联样式的优先级和加载顺序有关</li><li><code>!important</code> &gt; 行内样式 &gt; 内联外联样式</li></ul><blockquote><p>补充：样式作用于非目标标签上时，则离目标接近者优先</p></blockquote><h3 id="圣杯-amp-双飞翼"><a href="#圣杯-amp-双飞翼" class="headerlink" title="圣杯&amp;双飞翼"></a>圣杯&amp;双飞翼</h3><p>圣杯布局和双飞翼布局从字面上的意思是：一个像圣杯或者像展翅的禽类这样的布局，就是<strong>左右两栏固定宽度，中间部分自适应的三栏布局</strong>。</p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ol><li>首先将 left、middle、right 都放出来；</li><li>给三个元素设置 <code>float: left; position: relative;</code>，脱离文档流；</li><li>给三个元素的父元素 container 设置 <code>overflow: hidden;</code> 形成 BFC 防止浮动塌陷；</li><li>left 设置 <code>margin-left: -100%;</code>，right 设置 <code>margin-right: -rightWidth;</code>；</li><li>middle 设置 <code>width: 100%;</code>；</li><li>left 设置 <code>left: -leftWidth;</code>，right 设置 <code>right: -rightWidth;</code>；</li><li>containter 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>，防止左右内容遮挡 middle 的内容。</li></ol><p>代码实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">padding</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">position</span>: relative;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      <span class="attribute">min-height</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">word-break</span>: break-all;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">right</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">      middle</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">      left</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">      right</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129122542330.png" class title="圣杯布局"><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><p>双飞翼布局和圣杯布局很类似，就是在 middle 的 div 里又插入一个 div，通过调整内部 div 的 margin 值，实现中间栏自适应。</p><ol><li>middle 中增加 inner；</li><li>left 设置 <code>margin-left: -100%;</code>，right 设置 <code>margin-right: -rightWidth;</code>；</li><li>container 设置 <code>padding: 0 rightWidth 0 leftWidth;</code>。</li></ol><p>代码实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-class">.container</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">overflow</span>: hidden;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: red;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span>,</span></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">      <span class="attribute">min-height</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">word-break</span>: break-all;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.left</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.right</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin-left</span>: -<span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.middle</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">width</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">height</span>: <span class="number">100%</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: green;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.inner</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">margin</span>: <span class="number">0</span> <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">min-height</span>: <span class="number">130px</span>;</span></span><br><span class="line"><span class="css">      <span class="attribute">background</span>: blue;</span></span><br><span class="line"><span class="css">      <span class="attribute">word-break</span>: break-all;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;middle&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;inner&quot;</span>&gt;</span></span><br><span class="line">        middle - inner</span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left&quot;</span>&gt;</span></span><br><span class="line">      left</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;right&quot;</span>&gt;</span></span><br><span class="line">      right</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220129124500728.png" class title="双飞翼布局"><ul><li>圣杯布局在DOM结构上显得更加直观和自然；</li><li>双飞翼布局省去了很多css，而且由于不用使用定位，可以获得比圣杯布局更小最小宽度。</li></ul><blockquote><p>由于双飞翼布局会一直随着浏览器可视区域宽度减小从而不断挤压中间部分宽度，所以需要设置给页面一个 <code>min-width &gt; LeftWidth + RightWidth</code> </p></blockquote><h3 id="CSS3-新特性"><a href="#CSS3-新特性" class="headerlink" title="CSS3 新特性"></a>CSS3 新特性</h3><h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4><p>CSS3 过渡是元素从一种样式逐渐改变为另一种样式的效果，必须指定的两项内容：要添加过渡的 CSS 属性以及效果的持续时间。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition</span>: CSS属性, 花费时间, 效果曲线(默认ease), 延迟时间;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 宽度从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s，0.2s 后执行过渡 */</span></span><br><span class="line"><span class="attribute">transition</span>: width, .<span class="number">5s</span>, ease, .<span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* 所有属性从原始值到指定值的过渡，运动曲线 ease，运动时间 0.5s */</span></span><br><span class="line"><span class="attribute">transition</span>: all, .<span class="number">5s</span>;</span><br></pre></td></tr></table></figure><p>也可以分开写各个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: width;</span><br><span class="line"><span class="attribute">transition-duration</span>: <span class="number">1s</span>;</span><br><span class="line"><span class="attribute">transition-timing-function</span>: linear;</span><br><span class="line"><span class="attribute">transition-delay</span>: <span class="number">2s</span>;</span><br></pre></td></tr></table></figure><p>效果曲线可选值：</p><ul><li>linear：从开始到结束匀速；</li><li>ease：慢速开始，变快，然后慢速结束；</li><li>ease-in：仅慢速开始；</li><li>ease-out：仅慢速结束；</li><li>ease-in-out：以慢速开始和结束；</li><li>cubic-bezier(n, n, n, n)：函数，可选值为 0 ~ 1 。</li></ul><h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation</span>: 动画名称 一个周期时间 运动曲线(默认ease) 动画延迟(默认<span class="number">0</span>) 播放次数(默认<span class="number">1</span>) 是否反向播放动画(默认normal) fill-mode 是否暂停动画(默认running);</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span></span><br><span class="line"><span class="attribute">animation</span>: logo-line <span class="number">2s</span> linear;</span><br><span class="line"><span class="comment">/* 2s 后执行一次 logo-line 动画，运动时间 2s，运动曲线为 linear */</span></span><br><span class="line"><span class="attribute">animation</span>: logo-line <span class="number">2s</span> linear <span class="number">2s</span>;</span><br><span class="line"><span class="comment">/* 无限执行 logo-line 动画，每次运动时间 2s，运动曲线为 linear，并且执行反向动画 */</span></span><br><span class="line"><span class="attribute">animation</span>: logo-line <span class="number">2s</span> linear alternate infinite;</span><br></pre></td></tr></table></figure><ul><li><code>animation-name</code>：要绑定的动画名称；</li><li><code>animation-duration</code>：动画指定需要多少秒或者毫秒完成；</li><li><code>animation-timing-function</code>：设置动画的效果曲线函数，默认 case；</li><li><code>animation-delay</code>：动画启动前的延迟间隔，默认 0；</li><li><code>animation-iteration-count</code>：定义动画的播放次数，默认 1；</li><li><code>animation-direction</code>：指定是否应该轮流反向播放动画，默认 normal；</li><li><code>animation-fill-mode</code>：规定动画不播放时，要应用到元素的样式；</li><li><code>animation-play-state</code>：指定动画是否正在运行或已暂停，默认 running。</li></ul><p>还有一个重要属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-fill-mode</span>: none | forwards | backwards | both | initial | inherit;</span><br></pre></td></tr></table></figure><ul><li>none：不改变默认行为；</li><li>forwards：当动画完成后，保持最后一个属性值（在最后一个关键帧中定义）；</li><li>backwards：在 animation-delay 所指定的一段时间内，在动画显示之前，应用开始属性值（在第一个关键帧中定义）；</li><li>both：向前和向后填充模式都被应用。</li></ul><p>通过 <code>@keyframes</code> 规则来创建动画：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> animationname &#123;</span><br><span class="line">  keyframes-selector &#123; css-styles; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>animationname</code>：必需，定义动画的名称；</li><li><code>keyframs-selector</code>：必需，动画持续事件的百分比，0 ~ 100%、from(0%)、to(100%)，可以定义多个；</li><li><code>css-styles</code>：必需，一个或多个合法的 CSS 样式属性。</li></ul><h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><p>分为 2D 转换 和 3D 转换</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: 适用于<span class="number">2</span>D或者<span class="number">3</span>D变换的元素;</span><br><span class="line"><span class="attribute">transform-origin</span>: 转换元素的位置转换元素的位置。默认(x,y,z):(<span class="number">50%</span>,<span class="number">50%</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate</span>(<span class="number">30deg</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">translate</span>(<span class="number">30px</span>, <span class="number">30px</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">scale</span>(.<span class="number">8</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">skew</span>(<span class="number">10deg</span>, <span class="number">10deg</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateX</span>(<span class="number">180deg</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotateY</span>(<span class="number">180deg</span>);</span><br><span class="line"><span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(<span class="number">10</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">90deg</span>);</span><br></pre></td></tr></table></figure><h4 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h4><p>CSS3 提供了一些新的选择器：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd2d.png" class title="CSS3选择器"><h4 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h4><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: 水平阴影的位置 垂直阴影的位置 模糊距离 阴影的大小 阴影的颜色 阴影开始方向（默认从里往外）;</span><br></pre></td></tr></table></figure><ul><li><code>h-shadow</code>：必需，水平阴影的位置，可负；</li><li><code>v-shadow</code>：必需，垂直阴影的位置，可负；</li><li><code>blur</code>：可选，模糊距离；</li><li><code>spread</code>：可选，阴影的颜色；</li><li><code>inset</code>：可选，从外层的阴影改变阴影内侧阴影。</li></ul><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: <span class="number">10px</span> <span class="number">10px</span> <span class="number">5px</span> <span class="number">#888</span>;</span><br></pre></td></tr></table></figure><h4 id="边框"><a href="#边框" class="headerlink" title="边框"></a>边框</h4><p><strong>边框图片</strong>：</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: 图片url 图像边界向内偏移 图像边界的宽度（默认为边框的宽度） 用于指定字啊边框外部绘制偏移的量（默认<span class="number">0</span>） 铺满方式（默认拉伸，repeat 重复、stretch 拉伸 或 round 铺满）;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">15px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-image</span>: <span class="built_in">url</span>(<span class="string">border.png</span>);</span><br><span class="line">  <span class="attribute">border-image-slice</span>: <span class="number">30</span>;</span><br><span class="line">  <span class="attribute">border-image-repeat</span>: round;</span><br><span class="line">  <span class="attribute">border-image-outset</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>边框圆角</strong>：</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: 左上 右上 右下 左下;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">25px</span> <span class="number">0</span> <span class="number">25px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><h5 id="background-clip"><a href="#background-clip" class="headerlink" title="background-clip"></a>background-clip</h5><p>制定背景绘制（显示）区域，默认从边框（border-box）开始绘制。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqt.png" class title="border-box"><p>从 padding 开始绘制，不算 border：<code>background-clip: padding-box;</code> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqv.png" class title="padding-box"><p>只在内容区绘制，不算 padding 和 border：<code>background-clip: content-box;</code> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTeqy.png" class title="content-box"><h5 id="background-origin"><a href="#background-origin" class="headerlink" title="background-origin"></a>background-origin</h5><p><code>background-origin</code> 属性指定 <code>background-position</code> 属性应该是相对位置。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">10px</span> dashed black;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">35px</span>;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;logo.png&#x27;</span>) no-repeat, <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">background-position</span>: <span class="number">0px</span> <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVZGAM.jpeg" class title="background-origin"><h5 id="background-size"><a href="#background-size" class="headerlink" title="background-size"></a>background-size</h5><p>制定背景的大小。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgk7.png" class title="background-size"><h5 id="多张背景图"><a href="#多张背景图" class="headerlink" title="多张背景图"></a>多张背景图</h5><p>实例:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">background</span>: <span class="built_in">url</span>(<span class="string">&#x27;test.png&#x27;</span>) no-repeat left, <span class="built_in">url</span>(<span class="string">&#x27;logo.png&#x27;</span>) no-repeat right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTglS.png" class title="多张背景图"><h4 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h4><p>也可以说是倒影。</p><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-box-reflect: 方向[ above-上 | below-下 | right-右 | left-左 ], 偏移量, 遮罩图片;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 下倒影 */</span></span><br><span class="line">-webkit-box-reflect: below;</span><br><span class="line"><span class="comment">/* 右倒影同时有偏移 */</span></span><br><span class="line">-webkit-box-reflect: right <span class="number">10px</span>;</span><br><span class="line"><span class="comment">/* 下阴影渐变 */</span></span><br><span class="line">-webkit-box-reflect: below <span class="number">0</span> <span class="built_in">linear-gradient</span>(transparent, white);</span><br><span class="line"><span class="comment">/* 下阴影图片遮罩 */</span></span><br><span class="line">-webkit-box-reflect: below <span class="number">0</span> <span class="built_in">url</span>(<span class="string">shou.png</span>);</span><br></pre></td></tr></table></figure><h4 id="文字"><a href="#文字" class="headerlink" title="文字"></a>文字</h4><h5 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h5><p>语法：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-break</span>: normal | break-all | keep-all;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgo9.png" class title="word-break"><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-wrap</span>: normal | break-word;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220130163149441.png" class title="word-wrap"><h5 id="超出省略号"><a href="#超出省略号" class="headerlink" title="超出省略号"></a>超出省略号</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">400px</span>;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid <span class="number">#ccc</span>;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">  <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  -webkit-line-camp: <span class="number">2</span>;</span><br><span class="line">  -webkit-box-orient: vertical;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTd6V.png" class title="文字多行超出省略号"><h5 id="阴影-1"><a href="#阴影-1" class="headerlink" title="阴影"></a>阴影</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: 水平阴影 垂直阴影 模糊距离 阴影颜色;</span><br></pre></td></tr></table></figure><h4 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h4><p>CSS3 提供了新的颜色表示方法。</p><h5 id="rgba"><a href="#rgba" class="headerlink" title="rgba"></a>rgba</h5><p>rgb 为颜色值，a 为透明度（0 ~ 1）</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">rgba</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">5</span>);</span><br></pre></td></tr></table></figure><h5 id="hsla"><a href="#hsla" class="headerlink" title="hsla"></a>hsla</h5><p>h：色相，s：饱和度，l：亮度，a：透明度</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">color</span>: <span class="built_in">hsla</span>(<span class="number">112</span>, <span class="number">72%</span>, <span class="number">33%</span>, .<span class="number">68</span>);</span><br><span class="line"><span class="attribute">background-color</span>: <span class="built_in">hsla</span>(<span class="number">49</span>, <span class="number">65%</span>, <span class="number">60%</span>, .<span class="number">68</span>);</span><br></pre></td></tr></table></figure><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><p>CSS3 提供了线性渐变，径向渐变，圆锥渐变。</p><h4 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h4><p>CSS3 滤镜（Filter）</p><p>实例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 黑白色 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">grayscale</span>(<span class="number">100%</span>);</span><br><span class="line"><span class="comment">/* 褐色 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">sepia</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 饱和度 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">saturate</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 色相反转 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">hue-rotate</span>(<span class="number">90deg</span>);</span><br><span class="line"><span class="comment">/* 反色 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">invert</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">/* 透明度 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">opacity</span>(.<span class="number">5</span>);</span><br><span class="line"><span class="comment">/* 亮度 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">brightness</span>(.<span class="number">5</span>);</span><br><span class="line"><span class="comment">/* 对比度 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">contrast</span>(<span class="number">2</span>);</span><br><span class="line"><span class="comment">/* 模糊 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">blur</span>(<span class="number">3px</span>);</span><br><span class="line"><span class="comment">/* 阴影 */</span></span><br><span class="line"><span class="attribute">filter</span>: <span class="built_in">drop-shadow</span>(<span class="number">5px</span> <span class="number">5px</span> <span class="number">5px</span> <span class="number">#000</span>);</span><br></pre></td></tr></table></figure><h4 id="弹性布局-amp-栅格布局"><a href="#弹性布局-amp-栅格布局" class="headerlink" title="弹性布局 &amp; 栅格布局"></a>弹性布局 &amp; 栅格布局</h4><p>也就是 Flex 和 grid</p><h4 id="多列布局"><a href="#多列布局" class="headerlink" title="多列布局"></a>多列布局</h4><p>使用 <code>column-count</code> 设定分列列数，<code>colum-rule</code> 设定分隔样式。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  -webkit-<span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  -moz-<span class="attribute">column-count</span>: <span class="number">3</span>;</span><br><span class="line">  <span class="attribute">column-rule</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  -webkit-<span class="attribute">column-rule</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">  -moz-<span class="attribute">column-rule</span>: <span class="number">2px</span> solid <span class="number">#000</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgRx.png" class title="多列布局"><h4 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h4><p>监听屏幕尺寸的变化，在不同尺寸的时候显示不同的样式。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">960px</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: darkgoldenrod;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">480px</span>) &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">body</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">background-color</span>: lightgreen;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>重置浏览器窗口查看效果！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 960 px ，背景颜色将改变。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>如果媒体类型屏幕的可视窗口宽度小于 480 px ，背景颜色将改变。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/bVTgPW.gif" class title="监听屏幕尺寸改变样式"><h4 id="混合模式"><a href="#混合模式" class="headerlink" title="混合模式"></a>混合模式</h4><p>CSS3 的混合模式，有两种写法：<code>background-blend-mode</code> 和 <code>mix-blend-mode</code>。</p><p>区别在于 <code>background-blend-mode</code> 是用于同一个元素的背景图片和背景颜色的。</p><h3 id="CSS模块化"><a href="#CSS模块化" class="headerlink" title="CSS模块化"></a>CSS模块化</h3><p>书写 CSS 的几个阶段：</p><ol><li>手写原生 CSS；</li><li>使用预处理器 Sass/Less；</li><li>使用后处理器 PostCSS；</li><li>使用 css modules；</li><li>使用 css in js。</li></ol><h4 id="手写原生-CSS"><a href="#手写原生-CSS" class="headerlink" title="手写原生 CSS"></a>手写原生 CSS</h4><p>写 CSS 的几种情况：</p><ul><li>行内样式：直接在 html 元素的  style 属性中编写 css 代码；</li><li>内嵌样式：在 head 中的 style 标签内编写；</li><li>导入样式：在内联样式中通过 @import 方法，导入其他样式；</li><li>外部样式：使用 html 的 link 标签加载样式。</li></ul><blockquote><p>使用行内样式的缺点：</p><ul><li>样式不能复用；</li><li>样式权重过高，样式不好覆盖；</li><li>表现层与结构层没有分离；</li><li>不能进行缓存，影响加载效率。</li></ul></blockquote><p>不建议使用导入样式的原因：</p><ol><li>在 IE6-8 下，@import 声明指向的样式表并不会与页面其他资源并发加载，而是等页面所有资源加载完成后才开始下载；</li><li>如果在 link 标签中去 @import 其他 css，页面会等到所有资源加载完成后，才开始解析 link 标签中 @import 的 css。</li></ol><blockquote><p>使用导入样式的缺点：</p><ul><li>导入样式，只能放在 style 标签的第一行，放其他行会无效；</li><li>@import 声明的样式不能充分利用浏览器并发请求资源的行为，其加载行为往往会延后触发或被其他资源加载挂起；</li><li>由于 @import 样式表的延后加载，可能会导致页面样式闪烁。</li></ul></blockquote><h4 id="预处理器-Sass-Less"><a href="#预处理器-Sass-Less" class="headerlink" title="预处理器 Sass/Less"></a>预处理器 Sass/Less</h4><p>预处理器主要是强化了 css 的语法，弥补了原生 css 不支持变量、嵌套、父选择器种种问题，但打包出来的结果和原生的 css 是一样的。</p><h4 id="后处理器-PostCSS"><a href="#后处理器-PostCSS" class="headerlink" title="后处理器 PostCSS"></a>后处理器 PostCSS</h4><p>PostCSS 可以称作为 CSS 界的 babel，实现原理是通过 ast 去分析 css 代码，然后将分析的结果进行处理。</p><p>常用的 PostCSS 使用场景有：</p><ol><li>配合 stylelint 校验 css 语法；</li><li>自动增加浏览器前缀 autoprefixer；</li><li>编译 css next 的语法</li></ol><h4 id="CSS-模块化实现方式"><a href="#CSS-模块化实现方式" class="headerlink" title="CSS 模块化实现方式"></a>CSS 模块化实现方式</h4><h5 id="BEM-命名规范"><a href="#BEM-命名规范" class="headerlink" title="BEM 命名规范"></a>BEM 命名规范</h5><p>BEM 的意思就是 块（block）、元素（element）、修饰符（modifier），是由 Yandex 团队提出的一种前端命名方法论。</p><p>命名规则如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 块即是通常所说的 Web 应用开发中的组件或模块，每个块在逻辑上和功能上都是相互独立的。 */</span></span><br><span class="line"><span class="selector-class">.block</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 元素是块中的组成部分。元素不能离开块来使用。BEM 不推荐在元素中嵌套其他元素。 */</span></span><br><span class="line"><span class="selector-class">.block__element</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 修饰符用来定义块或元素的外观和行为。同样的块在应用不同的修饰符之后，会有不同的外观。 */</span></span><br><span class="line"><span class="selector-class">.block--modifier</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过 BEM 的命名规范，可以让我们的 css 代码层次结构清晰，通过严格的命名也可以也解决命名冲突的问题，但无法完全避免。</p><h4 id="CSS-Modules"><a href="#CSS-Modules" class="headerlink" title="CSS Modules"></a>CSS Modules</h4><p>指像 import js 一样去引入 css 代码，代码中的每一个类名都是引入对象的一个属性，通过这种方式，即可在使用时明确指定所引用的 css 样式。</p><p>并且 CSS Modules 在打包的时候会自动将类名转换成 hash 值，完全杜绝 css 类名冲突的问题。</p><h4 id="CSS-in-JS"><a href="#CSS-in-JS" class="headerlink" title="CSS in JS"></a>CSS in JS</h4><p>CSS in JS，意思就是使用 js 语言写 css，完全不需要写单独的 css 文件，所有的 css 代码全部放在组件内部，以实现 css 的模块化。</p><p>CSS in JS 其实是一种编写思想，有很多方案的实现，最出名的是 <code>styled-components</code> </p><p>除此之外，还有：<code>emotion</code>、<code>radium</code>、<code>glamorous</code>…</p><h3 id="CSS-性能优化"><a href="#CSS-性能优化" class="headerlink" title="CSS 性能优化"></a>CSS 性能优化</h3><p>提高新能的方法：</p><ol><li>合并 css 文件，如果页面加载 10 个 css 文件，每个文件 1k，那么也要比只加载一个 100k 的 css 文件慢；</li><li>减少 css 嵌套，最好不要嵌套三层以上；</li><li>不要在ID选择器前面进行嵌套，ID本来就是唯一的而且权限值大，嵌套完全是浪费性能；</li><li>建立公共样式类，把相同样式提取出来作为公共类使用；</li><li>减少通配符 <code>*</code> 或者类似 <code>[hidden=&quot;true&quot;]</code> 这类选择器的使用，挨个查找所有性能很差；</li><li>巧妙运用 css 的继承机制，如果父节点定义了，子节点就无需定义；</li><li>拆分出公共 css 文件，对于比较大的项目可以将大部分页面的公共结构样式提取出来放到单独 css 文件里，这样一次下载 后就放到缓存里，当然这种做法会增加请求，具体做法应以实际情况而定；</li><li>不用 css 表达式，表达式只会让代码显得更加酷炫，但是对性能的浪费特别大；</li><li>少用 css rest，可能会觉得重置样式是规范，但是其实其中有很多操作是不必要不友好的，有需求有兴趣，可以选择 normolize.css；</li><li>cssSprite，合成所有icon图片，用宽高加上 <code>background-position</code> 的背景图方式显现 icon 图，这样很实用，减少了http请求；</li><li>善后工作，css 压缩(在线压缩工具 YUI Compressor)；</li><li>GZIP 压缩，是一种流行的文件压缩算法。</li></ol><blockquote><p> 避免使用 @import，外部的 css 文件中使用 @import 会使得页面在加载时增加额外的延迟；</p></blockquote><blockquote><p>避免过分重排；</p></blockquote><ul><li>浏览器为了重新渲染部分或整个页面，重新计算页面元素位置和几何结构的进程叫做重排 reflow；</li><li>浏览器根据定义好的样式来计算，并将元素放到该出现的位置上，就是重排 reflow；</li><li>页面上任何一个节点触发 reflow，会导致它的子节点和祖先节点重新渲染；</li><li>导致 reflow发生的情况有：<ol><li>改变窗口的大小；</li><li>改变文字的大小；</li><li>增加、删除样式表；</li><li>内容的改变，输入框输入内容也会；</li><li>伪类的激活；</li><li>操作 class 属性；</li><li>脚本操作 dom，js 改变 css 类；</li><li>计算 offsetWidth 和 offsetHeight；</li><li>设置 style 属性；</li><li>改变元素的内外边距。</li></ol></li><li>常见重排元素：<ul><li>大小有关的 width,height,padding,margin,border-width,border,min-height</li><li>布局有关的 display,top,position,float,left,right,bottom</li><li>字体有关的 font-size,text-align,font-weight,font-family,line-height,white-space,vertical-align</li><li>隐藏有关的 overflow,overflow-x,overflow-y</li></ul></li><li>减少 reflow 对性能影响的建议：<ol><li>不要一条一条的修改 dom 的样式，预先定义好 class，然后修改 dom 的 classname；</li><li>不要修改范围比较大的 dom；</li><li>为动画元素使用绝对定位；</li><li>不要 table 布局，因为一个很小的改动会造成整个 table 重新布局；</li><li>避免设置大量的 style 属性，最好使用 class 属性；</li><li>如果 css 里面有计算表达式，每次都会重新计算一遍，触发一次 reflow。</li></ol></li></ul><blockquote><p>repaint - 重绘</p></blockquote><ol><li>当一个元素的外观被改变，但是布局没有改变的情况；</li><li>当元素改变的时候，不影响元素在页面中的位置，浏览器仅仅会用新的样式重绘此元素</li><li>常见的重绘元素<ul><li>颜色 color,background</li><li>边框样式 border-style,outline-color,outline,outline-style,border-radius,box-shadow,outline-width</li><li>背景有关 background,backgound-image,background-position,background-repeat,background-size</li></ul></li></ol><blockquote><p>CSS 动画</p></blockquote><ol><li>css 动画启用 GPU 加速，应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成：<ul><li>canvans 2D、布局合成、CSS3 转换、CSS 3D变换、webGL、视频…</li></ul></li></ol><blockquote><p>文件压缩</p></blockquote><p>文件的大小会直接影响到浏览器的加载速度，这一点在网络较差时表现尤为明显，构建工具 webpack，gulp/grunt，rollup 压缩之后能够明显减少，可以大大降低浏览器的加载时间。</p><blockquote><p>去除无用 CSS</p></blockquote><ol><li>不同元素或者其他情况下的重复代码；</li><li>整个页面内没有生效的CSS代码</li></ol><blockquote><p>有选择地使用选择器</p></blockquote><p>CSS 选择器的匹配是从右往左进行的，原因：css中更多的选择器是不会匹配的，所以在考虑性能问题时，需要考虑的是如何在选择器不匹配时提升效率，从右向左匹配就是为了达成这一目的的，通过这一策略能够使得css选择器在不匹配的时候效率更高。</p><p>在使用选择器时，尽量要遵循：</p><ol><li>保持简单，不要使用嵌套过多过于复杂的选择器；</li><li>通配符和属性选择器效率最低，需要匹配的元素最多，要尽量避免使用；</li><li>不要使用 类选择器 和 ID 选择器 修饰元素标签，如：<code>h3#markdown-content</code>，这多此一举，还会降低效率；</li><li>不要为了追求速度而放弃可读性和可维护性。</li></ol><blockquote><p>减少使用昂贵的属性</p></blockquote><p>应该尽量减少使用昂贵属性，如：box-shadow, border-radius, filter, 透明度, :nth-child …</p><p>有其他方案可以选择的时候，可以优先选择没有昂贵属性或昂贵属性更少的方案，这一网站的性能会在不知不觉中得到一定的提升。</p><blockquote><p>硬件加速的好坏</p></blockquote><ol><li>仅仅依靠 GPU 还是不行的，许多动画还是需要 CPU 的介入，连接 CPU 和 GPU 的总带宽不是无限的，所以需要注意数据在 CPU 和 GPU 之间的传输，尽量避免造成通道的拥挤，要一直注意像素的传输；</li><li>要了解创建的合成层的数量，每一个层都对应来一个GPU纹理，太多的层会消耗很多内存；</li><li>每一个 dom 元素的合成层都会被标记一个额外的边框，这一就可以验证是否有了很多层；</li><li>另一个重点是保持 GPU 和 CPU 之间传输量达到最小值，也就是说，层的更新数量最好是一个理想的常量，每次层更新的时候，一堆新的像素就可能需要传输给 GPU；</li><li>动画开始之后避免层的更新，避免动画进行中其他层一直更新导致拥堵；</li><li>尽量使用这些 css 属性来实现动画：transformation, opacity, filter；</li><li>使用性能工具检测优化的合理性，timeline 检测优化是否合理，还需要实现自动操作来做性能回归测试；</li></ol><h3 id="div-居中"><a href="#div-居中" class="headerlink" title="div 居中"></a>div 居中</h3><h4 id="div-水平垂直居中"><a href="#div-水平垂直居中" class="headerlink" title="div 水平垂直居中"></a>div 水平垂直居中</h4><h5 id="flex-布局实现-已知宽"><a href="#flex-布局实现-已知宽" class="headerlink" title="flex 布局实现(已知宽)"></a>flex 布局实现(已知宽)</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: flex;</span></span><br><span class="line"><span class="css">    <span class="attribute">justify-content</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">align-items</span>: center;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> <span class="selector-class">.a</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: deeppink;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;a&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="position-已知宽"><a href="#position-已知宽" class="headerlink" title="position(已知宽)"></a>position(已知宽)</h5><p>父元素设置为：<code>position: relative</code>；</p><p>子元素设置为：<code>position: absolute</code>；</p><p>据离上面 50%，距离下面 50%，然后减去元素自身宽度的一半距离就可以实现。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: blue;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">margin</span>: -<span class="number">50px</span> <span class="number">0</span> <span class="number">0</span> -<span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="position-transform-未知宽"><a href="#position-transform-未知宽" class="headerlink" title="position transform(未知宽)"></a>position transform(未知宽)</h5><p>将上面例子中的 <code>margin: -50px 0 0 -50px;</code> 替换为 <code>transfrom: translate(-50%, -50%);</code>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translate</span>(-<span class="number">50%</span>, -<span class="number">50%</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="position-margin-已知宽"><a href="#position-margin-已知宽" class="headerlink" title="position margin(已知宽)"></a>position margin(已知宽)</h5><p>left、right、top、bottom 为 0，<code>margin: auto</code> 即可：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;            </span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此情况下，如果子元素不设置宽度和高度，将会铺满整个父盒子（应用：模态框）</p><h5 id="table-cell"><a href="#table-cell" class="headerlink" title="table-cell"></a>table-cell</h5><p>table 实现垂直居中，子集元素可以是块元素，也可以不是块元素</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: pink;</span><br><span class="line">  <span class="attribute">display</span>: table-cell;</span><br><span class="line">  <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.box</span> <span class="selector-class">.a</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">  <span class="attribute">background-color</span>: deeppink;</span><br><span class="line">  <span class="attribute">margin-left</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="内容水平垂直居中"><a href="#内容水平垂直居中" class="headerlink" title="内容水平垂直居中"></a>内容水平垂直居中</h4><h5 id="table-cell-1"><a href="#table-cell-1" class="headerlink" title="table-cell"></a>table-cell</h5><ul><li><code>text-align: center</code>：给元素的父级加，可以使文本或者行级元素水平居中；</li><li><code>line-height</code>：值为元素的高度，可以使元素的文本内容垂直居中；</li><li><code>margin: 0 auto</code>：父级元素宽度可有可无，子级元素必须是块元素，而且要有宽度（否则继承父级）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.box</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">300px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">background-color</span>: pink;</span></span><br><span class="line"><span class="css">    <span class="attribute">display</span>: table-cell;</span></span><br><span class="line"><span class="css">    <span class="attribute">text-align</span>: center;</span></span><br><span class="line"><span class="css">    <span class="attribute">vertical-align</span>: middle;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span>AgoniLay<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>给父级设置 <code>display: table</code>，子集设置 <code>display: tablecell</code>，子集会充满全屏。</p><h3 id="浮动"><a href="#浮动" class="headerlink" title="浮动"></a>浮动</h3><h4 id="浮动元素"><a href="#浮动元素" class="headerlink" title="浮动元素"></a>浮动元素</h4><p>浮动元素同时处于常规流内和流外的元素。其中块级元素认为浮动元素不存在，而浮动元素会影响行内元素的布局，间接影响包含块的布局。</p><p>浮动元素的摆放包含如下原则：</p><ul><li>尽量靠上靠左，且一个挨着一个；</li><li>不能超出包含块，除非元素比包含块更宽；</li><li>不能超出所在行的最高点；</li><li>不能超过它前面浮动的元素的最高点；</li><li>行内元素绕着浮动元素摆放：左浮动元素的右边和右浮动元素的左边会出浮动元素。</li></ul><blockquote><p>注意：浮动元素不能撑起包含块，所以需要消除浮动</p></blockquote><h4 id="消除浮动"><a href="#消除浮动" class="headerlink" title="消除浮动"></a>消除浮动</h4><ul><li><p>父元素开启 BFC，或者直接设置高度；</p></li><li><p>伪元素：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"> <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包含块也浮动；</p></li><li><p>添加额外标签：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;parent&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加额外标签并设置 clear 属性为 both --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;clear: both;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 也可以添加一个 br 标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><h3 id="块级和行内元素"><a href="#块级和行内元素" class="headerlink" title="块级和行内元素"></a>块级和行内元素</h3><h4 id="罗列"><a href="#罗列" class="headerlink" title="罗列"></a>罗列</h4><p>行内元素（内联元素，inline element）：</p><ul><li>a - 锚点</li><li>abbr - 缩写</li><li>acronym - 首字</li><li>b - 粗体</li><li>bdo - 文本方向</li><li>big - 大字体</li><li>br - 换行</li><li>cite - 引用</li><li>code - 计算机代码</li><li>dfn - 定义字段</li><li>em - 强调</li><li>font - 字体设定</li><li>i - 斜体</li><li>img - 图片</li><li>input - 输入框</li><li>kbd - 定义键盘文本</li><li>label - 表格标签</li><li>q - 短引用</li><li>s - 中划线</li><li>strong - 粗体强调</li><li>sub - 下标</li><li>sup - 上标</li><li>textarea - 多行文本输入框</li><li>tt - 电传文本</li><li>u - 下划线</li><li>var - 定义变量</li></ul><p>块级元素（block element）：</p><ul><li>address - 地址</li><li>blockquote - 块引用</li><li>center - 居中对齐块</li><li>div - 常用块级元素</li><li>dl - 定义列表</li><li>fieldset - 表单控制组</li><li>form - 交互表单</li><li>h1 ~ h6 - 标题</li><li>hr - 水平分割线</li><li>isindex - 单行文本输入框</li><li>menu - 菜单列表</li><li>noframes - frames 可选内容（对于不支持 frame 的浏览器显示此区块内容）</li><li>noscript - 可选脚本内容（对于不支持 script 的浏览器显示此内容）</li><li>ol - 排序表单</li><li>p - 段落</li><li>pre - 格式化文本</li><li>table - 表格</li><li>ul - 无序列表</li></ul><p>可变元素：可变元素根据上下文语境决定该元素为块元素或者行内元素。</p><ul><li>applet - java applet（已不支持，使用 object 代替）</li><li>button - 按钮</li><li>del - 删除文本</li><li>iframe - 内联框架</li><li>ins - 插入的文本</li><li>map - 图片区块</li><li>object - object 对象</li><li>script - 客户端脚本</li></ul><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ol><li><p>块级元素会独占一行，其宽度自动填满其父元素宽度；</p><p>行内元素不会独占一行，相邻的行内元素会排列在同一行里，直到一行排列不下，才会换行，其宽度随元素的内容的宽度而变化</p></li><li><p>块级元素可以设置 width height 属性（即使设置了 width，也仍是独占一行的）；</p><p>行内元素设置 width height 无效</p></li><li><p>块级元素可以设置 margin padding 属性；</p><p>行内元素的竖直方向的 margin 不会产生边距效果（竖直方向的 padding 在 ie6 中不起作用），水平方向的正常</p></li><li><p>块级元素可以包含行内元素和块级元素；</p><p>行内元素不能包含块级元素</p></li></ol><blockquote><p>注意：p 标签中不能包含 div 标签。</p></blockquote><h3 id="DOM-树"><a href="#DOM-树" class="headerlink" title="DOM 树"></a>DOM 树</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>从网络传给渲染引擎的 HTML 文件字节流是无法直接被渲染引擎理解的，所以需要将其转化为渲染引擎能够理解的内部结构，这个结构就是 DOM，DOM 提供了对 HTML 文档结构化的表述，DOM 有三个层面的作用：</p><ul><li>页面的视角：DOM 是生成页面的基础数据结构；</li><li>从 JavaScript 脚本视角来看：DOM 提供给 JavaScript 脚本操作的接口，从而可以对 DOM 结构进行访问，进而改变文档的结构、样式和内容；</li><li>从安全视角来看：DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就可以拦截。</li></ul><p>简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤掉部分不安全的内容。</p><h4 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h4><p>在渲染引擎中，有一个叫 HTML 解析器（HTMLParser）的模块，其职责就是负责将 HTML 字节流转换为 DOM 结构。</p><p>HTML 解析器并不是等整个文档加载完成之后再解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据：</p><ul><li>网络进程接收到响应头后，会根据响应头中的 <code>content-type</code> 字段来判断文件的类型，然后为该请求选择或者创建一个渲染进程；</li><li>然后网络进程和渲染进程之间就会建立一个共享数据的管道，网络进程将接收到的数据放在此管道中，而渲染进程则从管道的另一端不断地读取数据，并同时传给 HTML 解析器，将其动态实时解析为 DOM。</li></ul><p>DOM 生成流程：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232307492.png" class title="字节流 -&gt; DOM"><p><strong>第一个阶段，通过分词器将字节流转换为 Token</strong>；</p><p>V8 编译 JavaScript 过程中的第一步是做词法分析，将 JavaScript 先分解为一个一个 Token；解析 HTML 也同理，需要通过分词器将字节流转换成一个一个 Token，分为 <code>Tag Token</code> 和 <code>文本 Token</code>：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223232646991.png" class title="Token 示意图"><p>其中，Tag Token 又分为 StartTag 和 EndTag。</p><p><strong>后续的二和三阶段是同步进行的，需要将 Token 解析为 DOM 阶段，并将 DOM 节点添加到 DOM 树中</strong>。</p><p>HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段生成的 Token 会依次压到这个栈中，处理规则如下：</p><ol><li><p>HTML 解析器开始工作时，会默认创建了一个根为 document 的空 DOM 结构，同时将一个 StartTag document 压入栈中，并同时创建一个 html 的 DOM 节点，将其加入到 DOM 树中。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223233942311.png" class title="初始化阶段"></li><li><p>若压入的是 StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，父节点就是栈中相邻的那个元素生成的节点；</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234022765.png" class title="startTag Token"></li><li><p>若分词器解析到的是 文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 无需压入到栈中，父节点就是当前栈顶 Token 所对应的 DOM 节点；</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234041536.png" class title="文本 Token"></li><li><p>若解析到的是 EndTag 标签，HTML 解析器会查看 Token 栈顶的元素是否与之对应，是，则将对应的 StartTag Token 从栈中弹出，表示该节点解析完成；</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234106295.png" class title="EndTag"></li><li><p>以此反复，直到分词器将所有字节流分词完成。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220223234125004.png" class title="解析完成"></li></ol><h4 id="JS-影响-DOM"><a href="#JS-影响-DOM" class="headerlink" title="JS 影响 DOM"></a>JS 影响 DOM</h4><p>内嵌式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>agoni<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span></span><br><span class="line"><span class="javascript">      div1.innerText = <span class="string">&#x27;AgoniLay&#x27;</span></span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>lay<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在遇到 <code>script</code> 标签之前，所有的解析流程不变，但是当解析到 <code>script</code> 标签时，渲染引擎会判断到这是一段内嵌脚本，此时 HTML 解析器就会暂停 DOM 的解析（因为 JS 中可能会修改当前已经生成的 DOM 结构），JavaScript 引擎介入，并执行 <code>script</code> 标签中的脚本，在执行脚本完成之后，脚本中所修改的 DOM 节点相关内容就已经改变，此时 HTML 解析器恢复解析过程，继续解析后续节点，直至生成最终的 DOM 树。</p><p>引入式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// demo.js</span></span><br><span class="line"><span class="keyword">let</span> div1 = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>]</span><br><span class="line">div1.innerText = <span class="string">&#x27;AgoniLay&#x27;</span></span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>agoni<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;demo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>lay<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>整个执行流程和上面是一样的，但在执行 JavaScript 之前需要先下载这段 JavaScript 代码；</p><blockquote><p>下载过程会阻塞 DOM 解析，且通常会十分耗时，Chorme 浏览器做了许多优化，如预解析操作：当渲染引擎收到字节流后，会首先开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。</p></blockquote><p>可以采用一些相关的策略来规避：</p><ul><li><p>使用 CDN 来加速 JavaScript 文件的加载；</p></li><li><p>压缩 JavaScript 文件的体积；</p></li><li><p>若某 JavaScript 文件中未进行操作 DOM 相关代码，可以通过 <code>async</code> 或 <code>defer</code> 标记来将该 JavaScript 脚本设置为异步加载：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">async</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;demo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">或</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">defer</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&#x27;demo.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>async 和 defer 的差异：</p><ul><li>使用 async 标记的脚本文件一旦加载完成，会立即执行；</li><li>而使用 defer 标记的脚本文件，需要在 <code>DOMContentLoaded</code> 事件之前执行。</li></ul></blockquote><p>CSSOM 相关：</p><p>JavaScript 脚本中出现了操作 CSSOM 的代码，在执行 JavaScript 之前需要先解析 JavaScript 语句之上所有的 CSS 样式，若代码引用了外部的 CSS 文件，那么还需再执行 JavaScript 代码之前等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象后，才能执行脚本。</p><p>JavaScript 引擎再解析 JavaScript 之前是不知道其中是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时不管是否操纵了 CSSOM，都会执行 CSS 文件下载、解析操作，再执行 JavaScript 脚本。</p><blockquote><p>CSSOM 有关文章：<a href="https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html">https://blog.poetries.top/browser-working-principle/guide/part5/lesson23.html</a></p></blockquote><h3 id="HTML5-新特性"><a href="#HTML5-新特性" class="headerlink" title="HTML5 新特性"></a>HTML5 新特性</h3><p>浏览器支持：最新版本的 Safari、Chrome、Firefox 和 Opera 均支持 HTML5 特性，IE 从 9 开始支持。</p><blockquote><p>IE9 以下版本浏览器兼容 HTML5 的办法：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- [if lt IE 9]&gt;</span></span><br><span class="line"><span class="comment">&lt;script src=&quot;http://cdn.static.runoob.com/libs/html5shiv/3.7/html5shiv.min.js&quot;&gt;&lt;/script&gt;</span></span><br><span class="line"><span class="comment">&lt;![endif] --&gt;</span></span><br></pre></td></tr></table></figure><p>载入后初始化新标签的 CSS：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">article</span>,<span class="selector-tag">aside</span>,dialog,<span class="selector-tag">footer</span>,<span class="selector-tag">header</span>,<span class="selector-tag">section</span>,<span class="selector-tag">nav</span>,<span class="selector-tag">figure</span>,<span class="selector-tag">menu</span> &#123; <span class="attribute">display</span>: block &#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="新元素"><a href="#新元素" class="headerlink" title="新元素"></a>新元素</h4><p><strong>新多媒体元素</strong>：</p><ul><li><code>&lt;audio&gt;</code>：定义音频内容</li><li><code>&lt;video&gt;</code>：定义视频（video 或 movie）</li><li><code>&lt;source&gt;</code>：定义多媒体资源（video 和 audio）</li><li><code>&lt;embed&gt;</code>：定义嵌入的内容，如插件</li><li><code>&lt;track&gt;</code>：为诸如 video 和 audio 元素之类的媒介规定外部文本轨道</li></ul><p><strong>新表单元素</strong>：</p><ul><li><code>&lt;datalist&gt;</code>：定义选项列表，与 input 元素配合使用该元素，来定义 input 可能的值</li><li><code>&lt;keygen&gt;</code>：规定用于表单的密钥对生成器字段</li><li><code>&lt;output&gt;</code>：定义不同类型的输出，如脚本</li></ul><p><strong>新的语义和结构元素</strong>：</p><ul><li><code>&lt;article&gt;</code>：定义页面独立的内容区域</li><li><code>&lt;aside&gt;</code>：定义页面的侧边栏内容</li><li><code>&lt;dialog&gt;</code>：定义对话框，比如提示框</li><li><code>&lt;header&gt;</code>：定义了文档的头部区域</li><li><code>&lt;footer&gt;</code>：定义 section 或 document 的页脚</li><li><code>&lt;section&gt;</code>：定义文档中的节（section、区段）</li><li><code>&lt;nav&gt;</code>：定义导航链接的部分</li><li><code>&lt;figure&gt;</code>：规定独立的流内容（图像、图标、照片、代码等）</li></ul><p>以上为 <strong>HTML5 新添加的 8 个块级的语义化标签</strong>。</p><ul><li><code>&lt;figcaption&gt;</code>：定义 figure 元素的标题</li><li><code>&lt;bdi&gt;</code>：允许设置一段文本，使其脱离器父元素的文本方向设置</li><li><code>&lt;command&gt;</code>：定义命令按钮，比如单选按钮、复选框或按钮</li><li><code>&lt;details&gt;</code>：用于描述文档或文档某个部分的细节</li><li><code>&lt;summary&gt;</code>：定义 details 元素的标题</li><li><code>&lt;mark&gt;</code>：定义带有记号的文本</li><li><code>&lt;meter&gt;</code>：定义度量衡，仅用于一直最大值和最小值的度量</li><li><code>&lt;progress&gt;</code>：定义任何类型的任务的进度</li><li><code>&lt;ruby&gt;</code>：定义 ruby 注释（中文注音或字符）</li><li><code>&lt;rt&gt;</code>：定义字符（中文注音或字符）的解释或发音</li><li><code>&lt;rp&gt;</code>：定义 ruby 注释中使用，定义不支持 ruby 元素的浏览器所显示的内容</li><li><code>&lt;time&gt;</code>：定义日期或时间</li><li><code>&lt;wbr&gt;</code>：规定在文本中的何处适合添加换行符</li></ul><p><strong>已移除元素</strong>：</p><p>以下的 HTML 4.01 元素在 HTML5 中已经被删除：</p><ul><li><code>&lt;acronym&gt;</code> </li><li><code>&lt;applet&gt;</code> </li><li><code>&lt;basefont&gt;</code> </li><li><code>&lt;big&gt;</code> </li><li><code>&lt;center&gt;</code> </li><li><code>&lt;dir&gt;</code> </li><li><code>&lt;font&gt;</code> </li><li><code>&lt;frame&gt;</code> </li><li><code>&lt;frameset&gt;</code> </li><li><code>&lt;noframes&gt;</code> </li><li><code>&lt;strike&gt;</code> </li><li><code>&lt;tt&gt;</code> </li></ul><h4 id="Canvas"><a href="#Canvas" class="headerlink" title="Canvas"></a>Canvas</h4><p><code>&lt;canvas&gt;</code> 标签定义图形，比如图表和其他图像，必须使用脚本（通常是 JavaScript）来绘制图形。</p><h5 id="创建-3"><a href="#创建-3" class="headerlink" title="创建"></a>创建</h5><p>一个画布在网页中是一个矩形框，通过 <code>&lt;canvas&gt;</code> 元素来绘制，默认情况下没有边框和内容，通常需要指定一个 id 属性，width 和 height 属性定义画布的大小。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h5><p>canvas 元素本身是没有绘图能力的，所有的绘制工作必须在 JavaScript 内部完成：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取到 canvas 元素</span></span><br><span class="line"><span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建 context 对象</span></span><br><span class="line"><span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>)</span><br><span class="line"><span class="comment">// 绘制一个红色的矩形</span></span><br><span class="line">ctx.fillStyle = <span class="string">&#x27;#FF0000&#x27;</span></span><br><span class="line">ctx.fillRext(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">75</span>)</span><br><span class="line"><span class="comment">// fillStyle 属性可以是 CSS 颜色、渐变或图案，默认为 #000000</span></span><br><span class="line"><span class="comment">// fillRect(x, y, width, height) 定义当前矩形当前的填充方式</span></span><br></pre></td></tr></table></figure><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220422211955611.png" class title="canvas 矩形"><blockquote><p>canvas 是一个二维网络，左上角的坐标为 <code>(0, 0)</code>。</p></blockquote><h5 id="绘制实例"><a href="#绘制实例" class="headerlink" title="绘制实例"></a>绘制实例</h5><p>画线：</p><ol><li><code>moveTo(x, y)</code>：定义线条开始坐标；</li><li><code>lineTo(x, y)</code>：定义线条结束坐标；</li><li>还需要用到 ink 方法，如 <code>stroke()</code>。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.moveTo(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">ctx.lineTo(<span class="number">200</span>, <span class="number">200</span>)</span><br><span class="line">ctx.stroke()</span><br></pre></td></tr></table></figure><p>画圆：</p><ol><li><code>arc(x, y, r, start, stop)</code>：<ul><li>r：半径</li><li>start：起始角，正上方为 0</li><li>stop：终止角</li><li>角度从正上方开始计算，如需绘制圆形则 stop 设置为 <code>2 * Math.PI</code> </li></ul></li><li>使用 ink 的 <code>fill()</code> 或者 <code>stroke()</code> 方法</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ctx.arc(<span class="number">100</span>, <span class="number">50</span>, <span class="number">20</span>, <span class="number">0</span>, <span class="built_in">Math</span>.PI * <span class="number">2</span>)</span><br><span class="line">ctx.fill()</span><br></pre></td></tr></table></figure><p>写字：</p><ol><li>使用 font 定义字体</li><li><code>fillText(text, x, y)</code>：绘制实心文本</li><li><code>strokeText(text, x, y)</code>：绘制空心文本</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ctx.font = <span class="string">&#x27;30px Arial&#x27;</span></span><br><span class="line">ctx.fillText(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br><span class="line">ctx.strokeText(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">10</span>, <span class="number">50</span>)</span><br></pre></td></tr></table></figure><p>渐变：</p><p>渐变可以填充在矩形、圆形、线条、文本等等：</p><ol><li><code>createLinearGradient(x, y, x1, y1)</code>：创建线性渐变；</li><li><code>createRadialGradient(x, y, r, x1, y1, r1)</code>：创建径向/圆渐变。</li><li>使用渐变对象必须使用两种或两种以上的停止颜色：<code>addColorStop()</code> 指定停止颜色，参数使用坐标来描述，可以是 0 至 1；</li><li>使用渐变设置 fillStyle 或 strokeStyle 的值为渐变，然后绘制形状即可。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建线性渐变</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createLinearGradient(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">0</span>)</span><br><span class="line">grd.addColorStop(<span class="number">0</span>, <span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">grd.addColorStop(<span class="number">1</span>, <span class="string">&#x27;deeppink&#x27;</span>)</span><br><span class="line"><span class="comment">// 创建径向渐变</span></span><br><span class="line"><span class="keyword">var</span> grd = ctx.createRadialGradient(<span class="number">100</span>, <span class="number">100</span>, <span class="number">150</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">100</span>)</span><br><span class="line">grd.addColorStop(<span class="number">0</span>, <span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">grd.addColorStop(<span class="number">1</span>, <span class="string">&#x27;deeppink&#x27;</span>)</span><br><span class="line"><span class="comment">// 填充渐变</span></span><br><span class="line">ctx.fillStyle = grd</span><br><span class="line">ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span><br></pre></td></tr></table></figure><p>图像：</p><p>将一幅图像放置到画布上，使用 <code>drawImage(image, x, y, width, height)</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Image to use:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">&quot;scream&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://img2.baidu.com/it/u=881613137,505928115&amp;fm=253&amp;fmt=auto&amp;app=138&amp;f=JPEG?w=500&amp;h=500&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Canvas:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">style</span>=<span class="string">&quot;border: 1px solid #000;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> c = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;myCanvas&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> ctx = c.getContext(<span class="string">&#x27;2d&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> img = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;scream&#x27;</span>)</span></span><br><span class="line"><span class="javascript">  img.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, <span class="number">200</span>, <span class="number">200</span>)</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="SVG"><a href="#SVG" class="headerlink" title="SVG"></a>SVG</h4><p>SVG（Scalable Vector Grapgics）指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，是万维网联盟的标准。</p><h5 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h5><ul><li>SVG 图像可以通过文本编辑器来创建和修改；</li><li>SVG 图像可以被搜索、索引、脚本化或压缩；</li><li>SVG 是可伸缩的，且在改变尺寸的情况下图形质量不会有损失；</li><li>可以在任何分辨率下被高质量地打印。</li></ul><h5 id="嵌入-HTML"><a href="#嵌入-HTML" class="headerlink" title="嵌入 HTML"></a>嵌入 HTML</h5><p>在 HTML5 中，可以直接将 SVG 元素嵌入 HTML 页面中：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.orgs/2000/svg&quot;</span> <span class="attr">version</span>=<span class="string">&quot;1.1&quot;</span> <span class="attr">height</span>=<span class="string">&quot;190&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">polygon</span> <span class="attr">points</span>=<span class="string">&quot;100,10 40,180 190,68 10,68 160,180&quot;</span></span></span><br><span class="line"><span class="tag">             <span class="attr">style</span>=<span class="string">&quot;fill: pink; stroke: purple; stroke-width: 5; fill-rule: odd;&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="SVG-与-Canvas"><a href="#SVG-与-Canvas" class="headerlink" title="SVG 与 Canvas"></a>SVG 与 Canvas</h5><p>区别：</p><ul><li>SVG 是通过 XML 描述 2D 图形的语言；Canvas 通过 JavaScript 来绘制 2D 图形；</li><li>SVG 基于 XML 意味着 SVG DOM 中的每个元素都是可用的，可以为其中的某个元素添加 JavaScript 事件处理器；而 Canvas 是逐像素进行渲染的，一旦图形被绘制完成将不会继续得到浏览器的关注，若其位置发生改变，则整个场景都需要重新绘制；</li></ul><p>比较：</p><table><thead><tr><th>Canvas</th><th>SVG</th></tr></thead><tbody><tr><td>依赖分辨率<br>不支持事件处理器<br>文本渲染能力较弱<br>能够以 .jpg 或 .png 格式保存结果图像<br>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</td><td>不依赖分辨率<br>支持事件处理器<br>最适合带有大型渲染区域的应用程序（比如谷歌地图）<br>复杂度高，会减慢渲染速度（任何过渡使用 DOM 的应用都不快）<br>不适合游戏应用</td></tr></tbody></table><h4 id="MathML"><a href="#MathML" class="headerlink" title="MathML"></a>MathML</h4><p>MathML，数学标记语言，是一种基于 XML 的标准，用来在互联网上书写数学符号和公式的置标语言。</p><p>实例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">math</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/TR/2010/REC-MathML3-20101021/&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mrow</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">msup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mi</span>&gt;</span>a<span class="tag">&lt;/<span class="name">mi</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo</span>&gt;</span>+<span class="tag">&lt;/<span class="name">mo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">msup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mi</span>&gt;</span>b<span class="tag">&lt;/<span class="name">mi</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mo</span>&gt;</span>=<span class="tag">&lt;/<span class="name">mo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">msup</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mi</span>&gt;</span>c<span class="tag">&lt;/<span class="name">mi</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">mn</span>&gt;</span>2<span class="tag">&lt;/<span class="name">mn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">msup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">mrow</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">math</span>&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性一般：最新版的 FireFox 和 Safari 浏览器支持。</p><h4 id="Drap-Drop"><a href="#Drap-Drop" class="headerlink" title="Drap Drop"></a>Drap Drop</h4><p>拖放（Drag 和 Drop）是 HTML5 标准的组成部分，即抓取对象后拖到另一个位置；</p><p>在 HTML5 中，拖放是标准的一部分，任何元素都能够拖放。</p><h5 id="draggable-属性"><a href="#draggable-属性" class="headerlink" title="draggable 属性"></a>draggable 属性</h5><p>如果网页中某元素的 draggable 属性为 true，则此元素就是可以拖动的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span>&gt;</span>Draggable Div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在大多数浏览器中，a 元素和 img 元素默认就是可以拖放的。</p></blockquote><h5 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h5><ul><li><code>dragstart</code>：开始拖动触发</li><li><code>drag</code>：被拖动的元素在拖动过程中持续触发</li><li><code>dragenter</code>：被拖动的元素进入目标元素时触发，在目标元素监听</li><li><code>dragleave</code>：被拖动的元素离开目标元素时触发，在目标元素监听</li><li><code>dragover</code>：被拖动元素停留在目标元素之中时触发。在目标元素监听</li><li><code>drop</code>：被拖动元素或从文件系统中选中的文件拖放落下时触发</li><li><code>dragend</code>：拖动结束触发</li></ul><h4 id="Video"><a href="#Video" class="headerlink" title="Video"></a>Video</h4><p><code>&lt;video&gt;</code> 元素提供了播放、暂停和音量控件来控制视频。</p><ul><li>通过 width 和 height 属性控制视频的尺寸；</li><li>可以通过给 video 标签之间插入内容来在不支持 video 的浏览器显示；</li><li>支持多个 source 元素，source 元素可以链接不同的视频文件，浏览器将使用第一个可识别的格式；</li><li>支持三种视频格式：MP4，WebM 和 Ogg.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">width</span>=<span class="string">&quot;420&quot;</span> <span class="attr">height</span>=<span class="string">&quot;350&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;../a.mp4&quot;</span> <span class="attr">type</span>=<span class="string">&quot;video/mp4&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 HTML5 video 标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Audio"><a href="#Audio" class="headerlink" title="Audio"></a>Audio</h4><ul><li>controls 属性供添加播放、暂停和音量控件；</li><li>标签内可插入浏览器不支持的元素提示文本；</li><li>支持多个 source 元素，可以链接不同的音频文件，浏览器将使用第一个支持的音频文件；</li><li>支持三种音频格式：MP3、Wav、Ogg.</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">controls</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;../a.ogg&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/ogg&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;../a.mp3&quot;</span> <span class="attr">type</span>=<span class="string">&quot;audio/mpeg&quot;</span>&gt;</span></span><br><span class="line">  您的浏览器不支持 HTML5 audio 标签</span><br><span class="line"><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="Input-类型"><a href="#Input-类型" class="headerlink" title="Input 类型"></a>Input 类型</h4><p>HTML5 新增了多个新的表单输入类型，提供了更好的输入控制和验证。</p><ul><li>date、datetime、datetime-local</li><li>month、week、time</li><li>email、number、tel、url</li><li>color、range、search</li></ul><h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><p>HTML5 提供了新的表单元素：</p><ul><li><code>&lt;datalist&gt;</code> </li><li><code>&lt;keygen&gt;</code> </li><li><code>&lt;output&gt;</code> </li></ul><p><strong>datalist</strong>：</p><p><code>&lt;datalist&gt;</code>  元素规定输入域的选项列表，规定 form 或 input 应该拥有自动完成功能，使用 input 元素的列表属性与 datalist 元素绑定：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">list</span>=<span class="string">&quot;browsers&quot;</span> <span class="attr">name</span>=<span class="string">&quot;browser&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">datalist</span> <span class="attr">id</span>=<span class="string">&quot;browsers&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Internet Explorer&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Firefox&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Chrome&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Opera&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;Safari&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">datalist</span>&gt;</span></span><br></pre></td></tr></table></figure><p>兼容性：IE9 及以下 和 Safari 不支持 datalist 元素。</p><p><strong>keygen</strong>：</p><p><code>&lt;keygen&gt;</code> 元素的作用是提供一种验证用户的可靠方法。</p><ul><li>规定用于表单的密钥对生成器字段；</li><li>在提交表单时，会生成两个键，一个是私钥，另一个是密钥：私钥存储于客户端，公钥则被发送到服务器，可用于之后验证用户的客户端证书</li></ul><p>兼容性：IE 不支持。</p><p><strong>output</strong>：</p><p><code>&lt;output&gt;</code> 元素用于不同类型的输出，比如计算或脚本。</p><p>兼容性：Edge12 及更早的 IE 不支持 output 元素。</p><h4 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h4><p>form：</p><ul><li>autocomplete</li><li>novalidate</li></ul><p>input：</p><ul><li>autocomplete、autofocus</li><li>form、formaction、formenctype、formmethod、formnovalidate、formtarget</li><li>height、width</li><li>list、multiple、patten(regexp)</li><li>max、min</li><li>placeholder、required、step</li></ul><h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><h3 id="跨页面通信"><a href="#跨页面通信" class="headerlink" title="跨页面通信"></a>跨页面通信</h3><h4 id="同源页面间通信"><a href="#同源页面间通信" class="headerlink" title="同源页面间通信"></a>同源页面间通信</h4><h5 id="Broadcast-Channel"><a href="#Broadcast-Channel" class="headerlink" title="Broadcast Channel"></a>Broadcast Channel</h5><p>Broadcast Channel 可以创建一个用于广播的通信频道。当所有的页面都监听同一频道的消息时，其中的某一个页面通过它发送的消息就会被其他所有页面收到。</p><p>创建 ：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bc = <span class="keyword">new</span> BroadcastChannel(<span class="string">&#x27;AgoniLay&#x27;</span>)</span><br></pre></td></tr></table></figure><p>监听：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.data</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.msg + <span class="string">&#x27; -- tab &#x27;</span> + data.from</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[Broadcast Channel] receive message:&#x27;</span>, text)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广播：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bc.postMessage(myData)</span><br></pre></td></tr></table></figure><h5 id="Service-Worker"><a href="#Service-Worker" class="headerlink" title="Service Worker"></a>Service Worker</h5><p>Service Worker 是一个可以长期运行在后台的 Worker，能够实现与页面的双向通信。多页面共享间的 Sercvice Worker 可以共享，将 Service Worker 作为消息的处理中心即可实现广播效果。</p><blockquote><p>Service Worker 是 <a href="https://juejin.cn/post/6844903588691443725">PWA</a> 中的核心技术之一。</p></blockquote><p>首先在页面中注册 Service Worker：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.register(<span class="string">&#x27;../util.sw.js&#x27;</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Service Worker 注册成功&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>../util.sw.js</code> 是对应的 Service Worker 脚本，Service Worker 本身并不具备广播通信的功能，需要进行改造：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../util.sw.js Service Worker 逻辑</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;service worker receive message&#x27;</span>, e.data)</span><br><span class="line">  e.waitUntil(</span><br><span class="line">    self.clients.matchAll().then(<span class="function"><span class="keyword">function</span> (<span class="params">clients</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (!clients || clients.length === <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">      clients.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">client</span>) </span>&#123;</span><br><span class="line">        client.postMessage(e.data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在 Service Worker 中监听了 <code>message</code> 事件，获取页面发送的信息。然后通过 <code>self.clients.matchAll()</code> 获取当前注册了该 Service Worker 的所有页面，通过调用每个 Client 的 <code>postMessage</code> 方法，向页面发送信息，从而达到广播效果。</p><p>然后再页面中监听 Service Worker 发送来的消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.data</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.msg + <span class="string">&#x27; -- tab &#x27;</span> + data.from</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[Service Worker] receive message:&#x27;</span>, text)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>需要同步消息时，调用 Service Worker 的 <code>postMessage</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.serviceWorker.controller.postMessage(mydata)</span><br></pre></td></tr></table></figure><h5 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h5><p>当 LocalStorage 变化时，会触发 <code>storage</code> 事件，利用这个特性，可以在发送消息时把消息写入到某个 LocalStorage 中，然后在各个页面内监听 storage 事件即可收到通知。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;storage&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (e.key === <span class="string">&#x27;AgoniLay&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> data = <span class="built_in">JSON</span>.parse(e.newValue)</span><br><span class="line">    <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.msg + <span class="string">&#x27; -- tab &#x27;</span> + data.from</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;[Storage I] receive message:&#x27;</span>, text)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送消息使用 <code>setItem</code> 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mydata.st = +(<span class="keyword">new</span> <span class="built_in">Date</span>)</span><br><span class="line"><span class="built_in">window</span>.localStorage.setItem(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="built_in">JSON</span>.stringify(mydata))</span><br></pre></td></tr></table></figure><blockquote><p>注意：此处在 <code>mydata</code> 上添加了一个取当前毫秒时间戳的 <code>st</code> 属性，这是因为 <code>storage</code> 事件只有在值真正发生改变时才会触发。设置 <code>st</code> 属性可以保证每次调用时一定会触发 <code>storage</code> 事件。</p></blockquote><h5 id="Shared-Worker"><a href="#Shared-Worker" class="headerlink" title="Shared Worker"></a>Shared Worker</h5><p>普通的 Worker 之间是独立运行、数据互不相通的；而多个 Tab 注册的 Shared Worker 则可以实现数据共享。</p><p>首先，在页面中启动一个 Shared Worker：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shareWorker = <span class="keyword">new</span> SharedWorker(<span class="string">&#x27;../util.shared.js&#x27;</span>, <span class="string">&#x27;AgoniLay&#x27;</span>)</span><br><span class="line"><span class="comment">// 第二个参数是名称，可以留空</span></span><br></pre></td></tr></table></figure><p>然后在该 Shared Worker 中支持 get 与 post 形式的消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ../util.shared.js: Shared Worker 代码</span></span><br><span class="line"><span class="keyword">let</span> data = <span class="literal">null</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;connect&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> port = e.ports[<span class="number">0</span>]</span><br><span class="line">  port.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// get 指令返回存储的消息数据</span></span><br><span class="line">    <span class="keyword">if</span> (event.data.get) &#123;</span><br><span class="line">      data &amp;&amp; port.postMessage(data)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则存储该消息数据</span></span><br><span class="line">      data = event.data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  port.start()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>之后，页面定时发送 get 指令的消息给 Shared Worker，轮询最新的消息数据，并在页面监听时返回：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定时轮询，发送 get 指令的消息</span></span><br><span class="line"><span class="built_in">setInterval</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  sharedWorker.port.postMessage(&#123; <span class="attr">get</span>: <span class="literal">true</span> &#125;)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听 get 消息的返回数据</span></span><br><span class="line">sharedWorker.port.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.data</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.msg + <span class="string">&#x27; -- tab &#x27;</span> + data.from</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[Shared Worker] receive message:&#x27;</span>, text)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line">sharedWorker.port.start()</span><br></pre></td></tr></table></figure><p>需要跨页面通信时，给 Shared Worker <code>postMessage</code> 即可：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sharedWorker.port.postMessage(mydata)</span><br></pre></td></tr></table></figure><h5 id="IndexedDB"><a href="#IndexedDB" class="headerlink" title="IndexedDB"></a>IndexedDB</h5><p>还可以使用一些“全局性”的存储方案，例如 IndexedDB 或 cookie，思路与 Shared Worker 类似：消息发送方将消息存至 IndexedDB 中，接收方则通过轮询去获取最新的消息。</p><h5 id="window-open-window-opener"><a href="#window-open-window-opener" class="headerlink" title="window.open + window.opener"></a>window.open + window.opener</h5><p>当使用 <code>window.open</code> 打开页面时，方法会返回一个被打开页面 <code>window</code> 的引用，而在未指定 <code>noopener</code> 时，被打开的页面可以通过 <code>window.opener</code> 获取到打开它的页面的引用 —— 通过这种方式可以在页面之间建立联系（一种树形结构）。</p><p>首先，把 <code>window.open</code> 打开的页面的 <code>window</code> 对象收集起来：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> childWins = []</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>).addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> win = <span class="built_in">window</span>.open(<span class="string">&#x27;./some/sample&#x27;</span>)</span><br><span class="line">  childWins.push(win)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>发送消息时，同时通知它打开的页面和打开它的页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤掉已经关闭的窗口</span></span><br><span class="line">childWins = childWins.filter(<span class="function"><span class="params">w</span> =&gt;</span> !w.closed)</span><br><span class="line"><span class="keyword">if</span> (childWins.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">  mydata.fromOpenner = <span class="literal">false</span></span><br><span class="line">  childWins.forEach(<span class="function"><span class="params">w</span> =&gt;</span> w.postMessage(mydata))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.opener &amp;&amp; !<span class="built_in">window</span>.opener.closed) &#123;</span><br><span class="line">  mydata.fromOpenner = <span class="literal">true</span></span><br><span class="line"><span class="built_in">window</span>.opener.postMessage(mydata)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收到消息的页面再进行传递：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.data</span><br><span class="line">  <span class="keyword">const</span> text = <span class="string">&#x27;[receive] &#x27;</span> + data.msg + <span class="string">&#x27; —— tab &#x27;</span> + data.from</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;[Cross-document Messaging] receive message:&#x27;</span>, text)</span><br><span class="line">  <span class="comment">// 避免消息回传</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.opener &amp;&amp; !<span class="built_in">window</span>.opener.closed &amp;&amp; data.fromOpenner) &#123;</span><br><span class="line">    <span class="built_in">window</span>.opener.postMessage(data)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 过滤掉已经关闭的窗口</span></span><br><span class="line">  childWins = childWins.filter(<span class="function"><span class="params">w</span> =&gt;</span> !w.closed)</span><br><span class="line">  <span class="comment">// 避免消息回传</span></span><br><span class="line">  <span class="keyword">if</span> (childWins &amp;&amp; !data.fromOpenner) &#123;</span><br><span class="line">    childWins.forEach(<span class="function"><span class="params">w</span> =&gt;</span> w.postMessage(data))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>在这种 “口口相传” 模式下，如果页面不是通过在另一个页面内的 <code>window.open</code> 打开的（比如直接在地址栏输入，或从其他网站链接过来），就无法做到消息传递。</p></blockquote><h4 id="非同源页面之间的通信"><a href="#非同源页面之间的通信" class="headerlink" title="非同源页面之间的通信"></a>非同源页面之间的通信</h4><p>可以使用一个用户不可见的 iframe 作为桥。由于 iframe 与父页面间可以通过指定 <code>origin</code> 来忽略同源限制，因此可以在每个页面中嵌入一个 iframe，这些 iframe 由于使用的是同一个 url，因此属于同源页面，就可以使用同源页面间的通信方式。</p><p>首先，在页面中监听 iframe 发来的消息，做相应的业务处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;message&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... do something</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当页面要与其他同源或非同源页面通信时，会先给 iframe 发送消息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.frame[<span class="number">0</span>].window.postMessage(mydata, <span class="string">&#x27;...&#x27;</span>) <span class="comment">// ... 可以设为 ifrmae 的 URL</span></span><br></pre></td></tr></table></figure><p>iframe 收到消息后，使用某种同源跨页面通信技术在所有 iframe 间同步消息，其他 iframe 收到通知后，则会将该消息同步给所属的页面：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bc.onmessage = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span>.parent.postMessage(e.data, <span class="string">&#x27;*&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>同源跨页面通信的方式：</p><ul><li>前三种都是 “广播模式”，一个页面将消息通知给一个“中央站”，在由“中央站”通知给各个页面，中央站可以是一个 Broadcast Cannel 实例，一个 Service Worker 或是 LocalStorage；</li><li>Shared Worker 和 IndexedDB、cookie 等是 “共享存储+长轮询” 模式，但有时不一定非要长轮询；</li><li>最后 window.open + window.opener 是 “口口相传” 模式。</li><li>还有一种做法是通过 WebSocket 这类的 “<a href="https://juejin.cn/post/6844903618043183111">服务器推</a>” 技术来进行同步，好比将 “中央站” 从前端移动到了后端，还有：Comet / SSE 等。</li></ul><p>非同源页面则可以通过嵌入同源 iframe 作为 “桥”，将非同源页面通信转化为同源页面通信。</p><h3 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h3><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li>当浏览器地址变化时，切换页面；</li><li>当点击前进后退时，网页内容跟随变化；</li><li>刷新浏览器，网页加载当前路由对应内容。</li></ol><h4 id="实现方式"><a href="#实现方式" class="headerlink" title="实现方式"></a>实现方式</h4><ul><li>hash 模式：监听浏览器地址 hash 值变化，执行相对应的 js 切换网页</li><li>history 模式：利用 history API 实现 url 地址改变，网页内容改变</li></ul><p>最大的区别在于 hash 模式下会在浏览器地址后面增加 <code>#</code> 号，而 history 可以自定义地址</p><h4 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a>hash 模式</h4><p>使用 <code>window.location.hash</code> 属性及窗口的 <code>onhashchange</code> 事件，可以实现监听浏览器地址 hash 值变化，执行相应的 js 切换界面：</p><ol><li>hash 指的是地址中 <code>#</code> 号以及之后的字符，也称为散列值；hash 也称作锚点，本身用来做页面跳转定位：<ul><li>如 <code>http:/localhost/index.html#abc</code> 中的 <code>#abc</code> 就是 hash；</li></ul></li><li>散列值是不会随请求发送到服务器端的，所以改变 hash 不会重新加载页面；</li><li>监听 window 的 hashchange 事件，当散列值改变时，可以通过 location.hash 来获取和设置 hash 值；</li><li>location.hash 值的变化会直接反映到浏览器地址栏。</li></ol><p>触发 <code>hashchange</code> 事件的情况：</p><ul><li>浏览器地址栏散列值变化（包括浏览器的前进、后退）会触发 <code>window.location.hash</code> 值的变化，从而触发 <code>onhashchange</code> 事件；</li><li>当浏览器地址栏中 URL 包含 hash 时访问，浏览器发送请求至服务器，请求完毕后设置散列值，从而触发 <code>onhashchange</code> 事件；</li><li>只改变浏览器地址栏 URL 的哈希部分后访问，不会发送请求至服务器，只是设置散列值，并触发 <code>onhashchange</code> 事件；</li><li>html 中 a 标签的 href 属性可以设置为页面的元素 ID 如 <code>#top</code>，当点击该 a 链接时页面跳转至该 id 元素所在区域，同时浏览器自动设置 <code>window.location.hash</code> 属性，地址栏中的哈希值也会发生改变，并触发 <code>onhashchange</code> 事件。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置 URL 的 hash，会在当前 url 后加上 #abc</span></span><br><span class="line"><span class="built_in">window</span>.location.hash = <span class="string">&#x27;abc&#x27;</span></span><br><span class="line"><span class="keyword">let</span> hash = <span class="built_in">window</span>.location.hash <span class="comment">// &#x27;#abc&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">&#x27;hashchange&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 监听 hash 变化，点击浏览器的前进后退会触发</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a>history 模式</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><ul><li><code>window.history</code> 属性指向 History 对象，表示当前窗口的浏览历史。发生改变时只会改变页面的路径，不会刷新页面；</li><li>History 对象保存了当前窗口访问过的所有页面地址。通过 <code>history.length</code> 可以得到当前窗口一共访问过几个网址；</li><li>浏览器不允许脚本读取这些地址，但是允许在地址之间导航；</li><li>浏览器工具栏的前进后退其实就是对 History 对象进行操作。</li></ul><h5 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h5><p><code>History.length</code>：当前窗口访问过的网址数量</p><p><code>History.state</code>：History 堆栈最上层的状态值，通常为 <code>undefined</code>（未设置）</p><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键；</p><p><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键；</p><p><code>History.go()</code>：接受一个整数为参数，以当前网页为基准，移动到参数指定的网页：</p><ul><li>为 1，则相当于 <code>history.forward()</code>；为 -1，则相当于 <code>history.back()</code>；</li><li>若为 0，相当于刷新页面；</li><li>若超出实际存在的网址范围，该方法无效果。</li></ul><blockquote><p>注意：移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新请求服务器发送新的网页。</p></blockquote><p><code>History.pushState(object, title, url)</code>：在历史中添加一条记录：</p><ul><li><code>object</code>：一个对象，通过 pushState 方法可以将该对象内容传递到新页面中，若不需要此对象则可以填 <code>null</code>；</li><li><code>title</code>：指标题，几乎没有浏览器支持该参数，传空即可；</li><li><code>url</code>：新的网址，必须与当前页面处在同一个域。不指定则默认为当前的路径，若设置了一个跨域网址，则会报错。</li></ul><blockquote><p>注意：如果 pushState 的 URL 参数设置了一个新的锚点值（即 hash），并不会触发 hashchange 事件。</p></blockquote><p><code>History.replaceState(object)</code>：修改 History 对象的当前记录，用法与 pushState() 方法一样；</p><p><code>popstate</code> 事件：每当 history 对象出现变化时，就会触发 popstae 事件：</p><ul><li>调用 pushState() 或 replaceState() 方法，并不会触发该事件；</li><li>只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用 <code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code> 方法时才会触发；</li><li>该事件只针对同一个文档，如果浏览器历史的切换导致加载不同的文档，也不会触发；</li><li>页面第一次加载的时候，浏览器不会触发 <code>popstate</code> 事件。</li></ul><h3 id="事件模型-1"><a href="#事件模型-1" class="headerlink" title="事件模型"></a>事件模型</h3><p>事件的本质是程序各个组成之间的一种通信方式，也是异步编程的一种体现。</p><h4 id="EventTarget-接口"><a href="#EventTarget-接口" class="headerlink" title="EventTarget 接口"></a>EventTarget 接口</h4><p>DOM 的事件操作（监听和触发）都定义在 <code>EventTarget</code> 接口，所有的节点对象都部署了这个接口，其他一些需要事件通信的了浏览器内置对象（如：<code>XMLHttpRequest</code>、<code>AudioNode</code>、<code>AudioContext</code>）也部署了这个接口。</p><p><code>EventTarget</code> 接口主要提供三个实例方法：</p><ul><li><code>addEventListener</code>：绑定事件的监听函数；</li><li><code>removeEventListener</code>：移除事件的监听函数；</li><li><code>dispatchEvent</code>：触发事件</li></ul><h5 id="addEventListener"><a href="#addEventListener" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p><code>EventTarget.addEventListener()</code> 用于在当前节点或对象上，定义一个特定事件的监听函数，一旦事件发生就会执行监听函数，无返回值。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(type, listener[, useCapture])</span><br><span class="line"><span class="comment">// 例子：</span></span><br><span class="line"><span class="keyword">var</span> button = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line">button.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello AgoniLay!&#x27;</span>)</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><ul><li><code>type</code>：事件名称，大小写敏感；</li><li><code>listener</code>：监听函数，也可以是一个具有 <code>handleEvent</code> 方法的对象；</li><li><code>useCapture</code>：布尔值，表示监听函数是否在捕获阶段（capture）触发，默认为 <code>false</code>，参数可选；第三个参数也可以是一个属性配置对象：<ul><li>capture：布尔值，默认 false，表示该事件是否在捕获阶段触发监听函数；</li><li>once：布尔值，默认 false，表示监听函数是否只触发一次，随后就自动移除；</li><li>passive：布尔值，默认 false，表示监听函数不会调用事件的 preventDefault 方法，若监听函数调用了浏览器将会忽略并在控制台输出警告</li></ul></li></ul><p>注意：</p><ol><li><p><code>addEventListener</code> 方法可以为针对当前对象的同一个事件添加多个不同的监听函数，并按顺序触发（先添加先触发）；</p></li><li><p>如果为同一个事件多次添加同一个监听函数，则只会绑定一个，其余的将会自动被去除；</p></li><li><p>可以用匿名函数包装监听函数达到向监听函数传参的目的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> el = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;div1&#x27;</span>)</span><br><span class="line">el.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; print(<span class="string">&#x27;Hello AgoniLay!&#x27;</span>) &#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure></li><li><p>监听函数内部的 <code>this</code> 指向当前事件所在的对象。</p></li></ol><h5 id="removeEventListener"><a href="#removeEventListener" class="headerlink" title="removeEventListener()"></a>removeEventListener()</h5><p><code>EventTarget.removeEventListener()</code> 方法用来移除 <code>addEventListener</code> 方法添加的事件监听函数，无返回值。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>)</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, listener, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>参数和 <code>addEventListener</code> 方法的参数完全一致，<code>removeEventListener</code> 方法移除的监听函数必须是 <code>addEventListener</code> 方法添加的那个监听函数，且在同一个元素节点，且第三个参数也必须完全相同，例如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>)</span><br><span class="line">div.removeEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><p>上面代码中，<code>removeEventListener</code> 方法无效，因为监听函数不是同一个函数</p><h5 id="dispatchEvent"><a href="#dispatchEvent" class="headerlink" title="dispatchEvent()"></a>dispatchEvent()</h5><p><code>EventTarget.dispatchEvent()</code> 方法在当前节点上触发指定事件，从而触发监听函数的执行。返回值为一个布尔值：只要有一个监听函数调用了 <code>Event.preventDefault()</code>，则返回值为 <code>false</code>，反之为 <code>true</code>。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">target.addEventListener(<span class="string">&#x27;click&#x27;</span>, hello, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">var</span> event = <span class="keyword">new</span> Event(<span class="string">&#x27;click&#x27;</span>)</span><br><span class="line">target.dispatchEvent(event)</span><br></pre></td></tr></table></figure><ul><li>参数是一个 <code>Event</code> 对象的实例。</li></ul><h4 id="监听函数"><a href="#监听函数" class="headerlink" title="监听函数"></a>监听函数</h4><h5 id="HTML-on-属性"><a href="#HTML-on-属性" class="headerlink" title="HTML on 属性"></a>HTML on 属性</h5><p>HTML 语言允许在元素的属性中直接定义某些事件的监听代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;触发点击事件&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>元素的事件监听属性，都是 <code>on + 事件名</code>，这些属性的值时将会执行的代码，而不是一个函数，且只会在冒泡阶段触发：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 正确 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething()&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 错误 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">&quot;doSomething&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>直接设置 on 属性与通过元素节点的 <code>setAttribute</code> 方法设置 on 属性的效果是一样的：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">el.setAttribute(<span class="string">&#x27;onclick&#x27;</span>, <span class="string">&#x27;doSomething()&#x27;</span>)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// &lt;Element onclick=&quot;doSomething()&quot; /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="元素节点的事件属性"><a href="#元素节点的事件属性" class="headerlink" title="元素节点的事件属性"></a>元素节点的事件属性</h5><p>元素节点对象的事件属性，同样可以指定监听函数，也是只在冒泡阶段触发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = doSomething</span><br><span class="line"></span><br><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;触发点击事件&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与 HTML on 属性的区别在于，此方式的值是函数本身或函数名，而不是可执行代码。</p><h5 id="addEventListener-1"><a href="#addEventListener-1" class="headerlink" title="addEventListener()"></a>addEventListener()</h5><p>所有 DOM 节点实例都有 <code>addEventListener</code> 方法，用来为该节点定义事件的监听函数。</p><h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>第一种 HTML 的 on 属性：违反了 HTML 与 JavaScript 代码相分离的原则，不利于代码分工，不推荐使用；</p><p>第二种 元素节点的事件属性缺点在于同一个事件只能定义一个监听函数，因此也不推荐使用；</p><p>故推荐使用第三种 <code>EventTarget.addEventListener</code> 方法：</p><ol><li>同一个事件可以添加多个监听函数；</li><li>能够指定在那个阶段（冒泡或捕获）触发监听函数；</li><li>除了 DOM 节点，其他一些对象也有此接口。</li></ol><h4 id="事件传播"><a href="#事件传播" class="headerlink" title="事件传播"></a>事件传播</h4><p>当一个事件发生后，会在子元素和父元素之间传播，分为三个阶段：</p><ol><li>从 window 对象传导到目标节点（从上层传到底层），称为 “捕获阶段”（capture phase）；</li><li>在目标节点上触发，称为 “目标阶段”（target phase）；</li><li>从目标节点传导回 window 对象（从底层传回上层），称为 “冒泡阶段”（bubbling phase）</li></ol><p>事件传播的最上层对象是 <code>window</code>，接着依次是 <code>document</code>、<code>html</code>（<code>document.documentElement</code>）和 <code>body</code>（<code>document.body</code>）。</p><h4 id="事件代理"><a href="#事件代理" class="headerlink" title="事件代理"></a>事件代理</h4><p>由于事件会在冒泡阶段向上传播到父节点，所以可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，也就是事件的代理（delegation）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;ul&#x27;</span>)</span><br><span class="line">ul.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target.tagName.toLowerCase() === <span class="string">&#x27;li&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>如果希望事件到某个节点为止不在传播，可以使用事件对象的 <code>stopPropagation</code> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 事件传播到 p 元素后，就不再向下传播</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;, <span class="literal">true</span>)</span><br><span class="line"><span class="comment">// 事件冒泡到 p 元素后，就不再向上冒泡</span></span><br><span class="line">p.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  event.stopPropagation()</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure><blockquote><p>注意：<code>stopPropagation</code> 方法只会阻止事件的传播，不会阻止该事件触发已到达节点的其他监听函数，若需要彻底阻止事件传播，包括不再触发后面所有的监听函数，可以使用 <code>stopImmediatePropagation</code> 方法。</p></blockquote><h4 id="Event"><a href="#Event" class="headerlink" title="Event"></a>Event</h4><p>事件发生后会产生一个事件对象作为参数传给监听函数。</p><p>浏览器原生提供一个 <code>Event</code> 对象，所有的事件都继承了 <code>Event.prototype</code> 对象。</p><p><code>Event</code> 对象本身就是一个构造函数，可以用来生成新的实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ev = <span class="keyword">new</span> Event(</span><br><span class="line">  <span class="string">&#x27;look&#x27;</span>,</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="string">&#x27;bubbles&#x27;</span>: <span class="literal">true</span>, <span class="comment">// 如若不显式指定为 true，则默认捕获</span></span><br><span class="line">    <span class="string">&#x27;cancelable&#x27;</span>: <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">document</span>.dispatchEvent(ev) <span class="comment">//触发该事件</span></span><br></pre></td></tr></table></figure><ul><li><code>type</code>：字符串，表示事件的名称；</li><li><code>options</code>：对象，表示事件对象的配置：<ul><li>bubbles：布尔值，可选，默认为 false，表示事件对象是否冒泡；</li><li>cancelable：布尔值，可选，默认为 false，表示事件是否可以被取消（<code>Event.parentDefault()</code>）</li></ul></li></ul><p><strong>实例属性</strong>：</p><ul><li><code>Event.bubbles</code> 属性返回一个布尔值，表示当前事件是否会冒泡，只读，默认不冒泡；</li><li><code>Event.eventPhase</code> 属性返回一个整数变量，表示事件当前所处的阶段，只读：<ul><li>0：事件当前未发生</li><li>1：事件目前处于捕获阶段，从祖先节点向目标节点的传播过程中</li><li>2：事件到达目标节点，即 Event.target 指向的节点</li><li>3：事件处于冒泡阶段，从目标节点向祖先节点的反向传播过程中</li></ul></li><li><code>Event.cancelable</code> 属性返回一个布尔值，表示事件是否可以取消，只读：<ul><li>大多数浏览器的原生事件是可以取消的；</li><li>除非显式声明，<code>Event</code> 构造函数生成的事件，默认是不可以取消的；</li><li>此属性为 true 时，调用 <code>Event.preventDefault()</code> 就可以取消这个事件，阻止浏览器对该事件的默认行为；为 false 则没有效果；</li></ul></li><li><code>Event.cancelBubble</code> 属性返回一个布尔值，若设为 <code>true</code>，则相当于执行 <code>Event.stopPropagation()</code>，可以阻止事件的传播；</li><li><code>Event.defaultPrevented</code> 属性返回一个布尔值，表示该事件是否调用过 <code>Event.preventDefault</code> 方法，只读；</li><li><code>Event.currentTarget</code> 属性返回事件当前所在的节点，即当前执行的监听函数所绑定的节点；</li><li><code>Event.target</code> 属性返回原始触发事件的那个节点，即事件最初发生的节点；</li><li><code>Event.type</code> 属性返回一个字符串，表示事件类型，只读；</li><li><code>Event.timeStamp</code> 属性返回一个毫秒时间戳，表示事件发生的时间，相对于网页加载成功开始计算的：<ul><li>可能是整数，也可能是小数（高精度时间戳），取决于浏览器的设置；</li></ul></li><li><code>Event.isTrusted</code> 属性返回一个布尔值，表示该事件是否由真实的用户行为产生；</li><li><code>Event.detail</code> 属性只有浏览器的 UI 事件才有，返回一个数值，表示事件的某种信息：<ul><li>比如 <code>click</code> 和 <code>dbclick</code> 事件中，指鼠标按下的次数；</li><li>鼠标滚轮事件中，表示滚轮滚动的距离（正向和负向，总为 3 的倍数）；</li></ul></li></ul><p><strong>实例方法</strong>：</p><ul><li><code>Event.preventDefault()</code> 方法取消浏览器对当前事件的默认行为，前提是事件对象的 <code>cancelable</code> 属性为 <code>true</code>；</li><li><code>Event.stopPropagation()</code> 方法阻止事件再 DOM 中的继续传播，不包括在当前节点上的其他事件监听函数；</li><li><code>Event.stopImmediatePropagation()</code> 方法阻止同一个事件的其他监听函数继续调用，阻止事件的传播，比 <code>Event.stopPropagation()</code> 更彻底；</li><li><code>Event.composedPath()</code> 方法返回一个数组，成员是事件的最底层节点和一次冒泡经过的所有上层节点；</li></ul><h4 id="CustomEvent-接口"><a href="#CustomEvent-接口" class="headerlink" title="CustomEvent 接口"></a>CustomEvent 接口</h4><p><code>CustomEvent</code> 接口用于生成自定义的事件实例。如果需要在触发事件的同时，传入指定的数据，可以使用 CustomEvent 接口生成的自定义事件对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CustomEvent(type, options)</span><br></pre></td></tr></table></figure><ul><li><code>type</code>：字符串，表示事件的名字，必须；</li><li><code>options</code>：事件的配置对象，可选：<ul><li>除了接受 Event 事件的配置属性，只有一个 detail 属性表示事件的附带数据，默认为 <code>null</code>；</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myEvent = <span class="keyword">new</span> CustomEvent(<span class="string">&#x27;myevent&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">detail</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">bubbles</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">cancelable</span>: <span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">el.addEventListener(<span class="string">&#x27;myevent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;Hello &#x27;</span> + event.detail.name)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">el.dispatchEvent(myEvent)</span><br></pre></td></tr></table></figure><h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>浏览器的缓存机制就是 HTTP 缓存机制，是根据 HTTP 报文的缓存标识进行的。</p><h4 id="HTTP-报文"><a href="#HTTP-报文" class="headerlink" title="HTTP 报文"></a>HTTP 报文</h4><p>HTTP 报文分为两种：</p><ul><li><p>HTTP 请求(Request)报文，报文格式为：<code>请求行 - HTTP头(通用信息头、请求头、实体头) - 请求报文主体(POST才有)</code>；</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000219031.png" class title="HTTP请求报文"></li><li><p>HTTP 响应(Response)报文，报文格式为：<code>状态行 - HTTP头(通用信息头、响应头、实体头) - 响应报文主体</code>；</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301000341773.png" class title="HTTP响应报文"></li></ul><blockquote><p>注意：</p><ol><li>通用信息头指的是请求和响应报文都支持的头域，包括：<ul><li>Cache-Control、Connection、Date、Pragma、Transfer-Encoding、Upgrade、Via；</li></ul></li><li>实体头则是实体信息的实体头域，分别为：<ul><li>Allow、Content-Base、Content-Encoding、Content-Language、Content-Length、Content-Location、Content-MD5、Content-Range、Content-Type、Etag、Expires、Last-Modified、extension-header.</li></ul></li></ol></blockquote><h4 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h4><p>浏览器与服务器通信的方式为应答模式：浏览器发起 HTTP 请求 - 服务器响应该请求。浏览器第一次向服务器发起该请求后拿到请求结果，会根据请求报文中 HTTP 头中的缓存标识决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301001224385.png" class title="浏览器第一次发起HTTP请求"><ul><li>浏览器每次发起请求都会先在浏览器缓存中查找该请求的结果以及缓存标识；</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中。</li></ul><h4 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h4><p>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程，强制缓存的情况主要有三种：</p><ol><li>不存在缓存结果和缓存标识，强制缓存失败，直接向服务器发起请求（与首次一致）；</li><li>存在该缓存结果和缓存标识，但结果已失效，强制缓存失败，使用协商缓存；</li><li>存在该缓存结果和缓存标识，且尚未失效，强制缓存生效，直接返回该结果。</li></ol><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中 <code>Cache-Control</code> 的优先级更高。</p><h5 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h5><p><code>Expires</code> 是 HTTP/1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，再次请求时间小于该缓存值，直接使用缓存结果。</p><blockquote><p>到了 HTTP/1.1，<code>Expires</code> 已经被 <code>Cache-Control</code> 替代，原因：Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，但如果两者因某些原因发生误差，那么强制缓存则会直接失效。</p></blockquote><h5 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h5><p>在 HTTP/1.1 中，<code>Cache-Control</code> 是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li><code>public</code>：所有内容都将被缓存（客户端和代理服务器都可缓存）</li><li><code>private</code>：所有内容只有客户端可以缓存，默认为此值</li><li><code>no-cache</code>：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li><code>no-store</code>：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li><li><code>max-age=xxx (xxx is numeric)</code>：缓存内容将在 xxx 秒后失效</li></ul><p>例如：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301003329024.png" class title="expires 和 cache-control"><ul><li>HTTP 响应报文中 expires 的时间值是一个绝对值，而 cache-control 的值是相对值；</li><li>无法确定客户端是否与服务端的时间同步的情况下，cache-control 比 expires 是更好的选择。</li></ul><p>在浏览器中，状态码为灰色的请求代表使用了强制缓存，对应的 Size 值代表了则代表该缓存存放的位置，分别为：</p><ul><li><code>from memory cache</code>：内存缓存，代表使用内存中的缓存，先读取此项；</li><li><code>from disk cache</code>：硬盘缓存，代表使用硬盘中的缓存。</li></ul><p>硬盘缓存与内存缓存：</p><ol><li>内存缓存具有快速读取和时效性（进程关闭则内存清空）两个特点；</li><li>硬盘缓存是直接将缓存写入硬盘文件中，读取时需进行 I/O 操作，读取复杂，速度比内存缓存慢。</li></ol><p>在浏览器中，会在 js 和图片等文件解析执行后直接存入内存缓存中，当刷新页面时只需直接从内存中读取（from memory cache）；而 css 文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存（from disk cache）。</p><h4 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h4><p>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程，主要由两种情况：</p><ol><li><p>协商缓存生效，返回 304：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005038564.png" class width="304"></li><li><p>协商缓存失效，返回 200 和请求结果：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301005110494.png" class title="协商缓存"></li></ol><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified</code> / <code>If-Modified-Since</code> 和 <code>Etag</code> / <code>If-None-Match</code>，后者优先级更高。</p><h5 id="Last-Modified-If-Modified-Since"><a href="#Last-Modified-If-Modified-Since" class="headerlink" title="Last-Modified/If-Modified-Since"></a>Last-Modified/If-Modified-Since</h5><p><code>Last-Modified</code> 是服务器响应请求时，返回该资源文件在服务器最后被修改的时间；</p><p><code>If-Modified-Since</code> 是客户端再次发起该请求时，携带上次请求返回的 <code>Last-Modified</code> 值，以此做对比决定是 200 还是 304；</p><h5 id="Etag-If-None-Match"><a href="#Etag-If-None-Match" class="headerlink" title="Etag/If-None-Match"></a>Etag/If-None-Match</h5><p><code>Etag</code> 是服务器响应请求时，返回当前资源文件的一个唯一标识（由服务器生成）；</p><p><code>If-None-Match</code> 是客户端再次发起该请求时，携带上次请求返回的唯一标识 <code>Etag</code> 值，以此做判断。</p><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p>强制缓存优先于协商缓存进行，若协商缓存生效则直接使用缓存，若不生效则进行协商缓存（<code>Last-Modified/If-Modified-Since</code> 和 <code>Etag/If-None-Match</code>），协商缓存由服务器决定是否使用缓存，若协商缓存失效，代表该请求的缓存失效，则重新获取请求结果再存入浏览器缓存中；生效则返回 304，继续使用缓存：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301010337843.png" class title="浏览器缓存策略"><h3 id="浏览器架构"><a href="#浏览器架构" class="headerlink" title="浏览器架构"></a>浏览器架构</h3><h4 id="CPU-与-GPU"><a href="#CPU-与-GPU" class="headerlink" title="CPU 与 GPU"></a>CPU 与 GPU</h4><p>CPU 与 GPU 作为计算机中最重要的两个计算单元直接决定了计算性能。</p><ul><li>CPU（Center Processing Unit）：CPU 是计算机的大脑，负责处理各种不同的任务，过去大多数 CPU 是单芯片的，核心被安置再同一个芯片上，较新的 CPU 可以支持多核心，运算能力大大加强；</li><li>GPU（Graphics Processing Unit）：GPU 更擅长利用多核心同时处理单一的任务，最初被用来处理图像，这也是 GPU 可以更快、更流畅的渲染页面内容。</li></ul><h4 id="计算机架构"><a href="#计算机架构" class="headerlink" title="计算机架构"></a>计算机架构</h4><p>可以把计算机自下而上分为三层：硬件（Machine Hardware）、操作系统（Operating System）和应用（Application），有了操作系统的存在，上层应用可以使用操作系统提供的能力使用硬件资源而不是直接访问硬件资源。</p><h4 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h4><p>一个进程（Process）是应用正在运行的程序，而线程（Thread）是进程中更小的一部分；</p><ul><li>当应用被启动，进程就被创建出来。程序可以创建线程来帮助其工作；</li><li>操作系统会为进程分配私有的内存空间以供使用，当关闭程序时，私有内存就会被释放；</li><li>还有比进程更小的存在：协程，是运行再线程中更小的单位。</li></ul><h4 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h4><p>一个进程可以让操作系统开启另一个进程处理不同的任务。当两个进程需要通信时，可以使用 IPC（Inter Process Communcation），好处在于当一个进程给另一个进程发消息而并没有回应时，并不影响当前进程继续工作。</p><h4 id="浏览器架构-1"><a href="#浏览器架构-1" class="headerlink" title="浏览器架构"></a>浏览器架构</h4><p>借助进程和线程，浏览器可以被设计成但 单进程-多线程架构，或者利用 IPC 实现 多进程-多线程架构。</p><p>Chrome 就是采用了多进程架构，浏览器进程作为 Chrome 最核心的进程管理这其他进程，而 Renderer 则负责渲染不同的站点：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220301160300551.png" class title="Chorme 多进程"><h5 id="进程工作内容"><a href="#进程工作内容" class="headerlink" title="进程工作内容"></a>进程工作内容</h5><ul><li><strong>浏览器进程（Browser process）</strong>：负责管理 Chrome 应用本身，包括地址栏、书签、前进和后退按钮。同时也负责不可见的功能，如网络请求、文件访问等，也负责其他进程的调度；</li><li><strong>渲染进程（Renderer process）</strong>：负责站点的渲染，其中也包括 JavaScript 代码的运行，web worker 的管理；</li><li><strong>插件进程（Plugin process）</strong>：负责为浏览器提供各种额外的插件功能，如 flash；</li><li><strong>GPU 进程（GPU process）</strong>：负责提供成像的功能；</li><li>还有负责扩展进程、工具进程等的其他进程</li></ul><h5 id="多进程架构好处"><a href="#多进程架构好处" class="headerlink" title="多进程架构好处"></a>多进程架构好处</h5><p>当访问一个站点时，渲染进程会负责运行站点的代码，渲染站点的页面，同时响应用户的交互动作，当在 Chrome 中打开多个页签同时访问三个站点时，如果其中一个无响应，同样可以正常使用其他的页签：</p><p>因为 Chrome 为每个站点均创建了独立的渲染进程，专门负责当前站点的渲染工作；若所有页面运行在同一个进程中，当有一个页面无响应时，则其他页面均无法使用。</p><p>借助操作系统对进程安全的控制，浏览器可以将页面放置在沙箱中，站点的代码可以运行在隔离的环境中，保证核心进程的安全。</p><p>但同样由于进程独享自己的私有内存，为了节省内存，Chrome 限制了最大进程数，取决于硬件的能力，且使用多个页签访问相同的站点时浏览器不会创建新的渲染进程。</p><h5 id="面向服务架构"><a href="#面向服务架构" class="headerlink" title="面向服务架构"></a>面向服务架构</h5><p>Chrome 将架构从多进程模型转变成面向服务。浏览器将功能以服务的方式实现，以解决多进程架构中的问题。</p><p>当 Chrome 运行在硬件强大的计算机上时，会将一个服务以多个进程的方式实现，提供稳定性，当计算机硬件资源紧张时，则可以将多个服务放在一个进程中节省资源。</p><h5 id="浏览器进程"><a href="#浏览器进程" class="headerlink" title="浏览器进程"></a>浏览器进程</h5><p>浏览器进程负责处理除了渲染外的大部分工作，包括以下线程：</p><ul><li>UI 线程负责绘制工具栏中的按钮、地址栏等；</li><li>网络线程负责从网络中获取数据；</li><li>存储线程负责文件等功能。</li></ul><h4 id="访问过程"><a href="#访问过程" class="headerlink" title="访问过程"></a>访问过程</h4><ol><li><p>输入处理：当在地址栏输入时，UI 线程会先判断输入的内容是要搜索的内容还是要访问一个站点；</p></li><li><p>访问开始：按下回车或开始访问时，UI 线程将借助网络线程访问站点资源，浏览器页签的标题会出现加载中的图标，同时网络线程会根据适当的网络协议，如 DNS lookup 和 TLS 为此次请求建立连接，当服务器返回给浏览器重定向请求时，网络线程会通知 UI 线程需要重定向，然后会以新的地址开始请求资源；</p></li><li><p>处理响应数据：当网络线程收到来自服务器的数据时，会试图从数据中的前面一些字节得到数据的类型（<code>Content-Type</code>），以试图了解数据的格式：</p><ul><li>当返回的数据类型时 HTML 时，会将数据传递给渲染进程做进一步的渲染工作；</li><li>数据类型时 zip 文件或者其他文件格式时，会将数据传递给下载管理器做进一步的文件预览或下载工作；</li></ul><blockquote><p>注意：在开始渲染之前，网络进程会先检查数据的安全性，这也是浏览器保证安全的地方，如果返回的数据来自一些恶意的站点，网络进程会显示警告的页面；与此同时，Cross Origin Read Blocking（CORB）策略也会确保跨域的敏感数据不会被传递给渲染进程。</p></blockquote></li><li><p>渲染过程：当所有的检查结束后，网络进程确信浏览器可以访问该站点时，网络进程通知 UI 线程数据准备完毕，UI 线程根据当前站点找到一个渲染进程完成接下来的渲染工作；</p><blockquote><p>在访问开始时，UI 线程将请求地址传递给网络线程时，UI 线程就已经知道了要访问的站点，就会开始查找或启动一个渲染进程，这与网络进程下载数据是同时的，会减少渲染所需要的时间，提高效率。</p></blockquote></li><li><p>提交访问：浏览器进程会通过 IPC 向渲染进程提交这次访问，同时也会保证渲染进程可以通过为了进程继续获取数据；此时地址栏显示出表明安全的图标，同时显示出站点的信息，访问历史中也会加入当前的站点信息；</p></li><li><p>加载完毕：当访问被提交给渲染进程，渲染进程会继续加载页面资源并且渲染页面；当渲染进程结束渲染工作（页面及其中所有子页面结束加载，也就是 onLoad 事件触发后发送），会给浏览器进程发送消息，UI 线程则会隐藏页签标题上的加载图标，表明页面加载完毕。</p></li></ol><p>当输入另外一个地址时，浏览器进程会重复上面的过程，但在开始新的访问前，会确认当前站点是否关心 <code>beforeunload</code> 事件：可以提醒用户是否要访问新的站点或者关闭此页签，若用户拒绝则新的访问或关闭会被阻止。</p><p>如果一次访问是从一个渲染进程中发起的，如用户点击一个链接或者运行 JavaScript 代码 <code>location = &#39;xxx&#39;</code> 时，渲染进程会首先检查 <code>beforeunload</code>，然后再执行和浏览器进程初始化访问同样的操作。</p><h4 id="Service-worker"><a href="#Service-worker" class="headerlink" title="Service worker"></a>Service worker</h4><p><code>Service worker</code> 是一种可以 web 开发者控制缓存的技术，它的代码是运行在渲染进程中的。</p><p>当访问开始时，网络线程会根据域名检查是否有 Service worker 会处理当前地址的请求，若有，则 UI 线程会找到对应的渲染进程去执行 Service worker 的代码，而 Service worker 可以让开发者决定此请求从本地缓存还是从网络中获取数据。</p><h4 id="渲染进程"><a href="#渲染进程" class="headerlink" title="渲染进程"></a>渲染进程</h4><p>渲染进程负责所有发生在浏览器页签中的事情，在一个渲染进程中，主线程负责解析、编译或运行代码等工作，当使用 Worker 时，Worker 线程会负责运行一部分代码。合成线程和关栅线程也是运行在渲染进程中的，负责更高效和顺畅的渲染页面。</p><p>渲染进程最重要的工作就是将 HTML、CSS 和 JavaScript 代码转换为一个可以与用户产生交互的页面。</p><h4 id="解析过程"><a href="#解析过程" class="headerlink" title="解析过程"></a>解析过程</h4><h5 id="DOM-的创建"><a href="#DOM-的创建" class="headerlink" title="DOM 的创建"></a>DOM 的创建</h5><p>当渲染进程接收到来自浏览器进程提交访问的消息后就开始接受 HTML 数据，主线程开始解析 HTML 文本字符串，并将其转化成 <strong>Document Object Model（DOM）</strong>。</p><p>当预加载扫描（Preload Scanner）在分析器分析 HTML 的过程中发现了类似 img 或 link 这样的标签时，就会发送请求给浏览器进程的网络线程，而主线程会根据这些额外资源是否会阻塞转化过程而决定是否等待资源加载完毕。</p><p>当 HTML 分析器发现 <code>script</code> 标签时，会暂停接下来的 HTML 转化工作，然后加载、解析并且运行 JavaScript 代码（因为其中可能会操作 DOM 或 CSSOM）。</p><blockquote><p>如果 JavaScript 代码并不需要改变 DOM，可以为 <code>script</code> 标签添加 <code>async</code> 或 <code>defer</code> 属性从而达到异步加载这些资源而不阻塞 HTML 转化过程的目的。</p></blockquote><h5 id="样式计算"><a href="#样式计算" class="headerlink" title="样式计算"></a>样式计算</h5><p>主线程会解析样式并决定每个 DOM 元素的样式（Style calculation）。</p><h5 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h5><p>完成样式计算后，渲染进程已经知道了 DOM 的结构和每个节点的样式，还需要确定节点在页面上的位置。</p><p>布局（layout）是为元素指定几何信息的过程，主线程遍历 DOM 结构中的元素及其样式，同时创建出带有坐标和元素尺寸信息的<strong>布局树（Layout tree）</strong>：</p><ul><li>布局树的结构与 DOM 树的结构非常类似，但只包含将会在页面中显示的元素；</li><li>元素样式设置为 <code>display: none</code> 时，不会出现在布局树中，但样式设置为 <code>visibility: hidden</code> 的元素会出现在布局树中；</li><li>一个包含内容的伪元素不会出现在 DOM 树中，但会出现在布局树中。</li></ul><h5 id="绘制-1"><a href="#绘制-1" class="headerlink" title="绘制"></a>绘制</h5><p>有了 DOM、样式和布局之后，还需要知道 <strong>绘制（Paint）</strong>的顺序（层叠上下文相关）。</p><p>在这个阶段，主线程遍历布局树并创建绘制记录：一系列由绘制步骤组成的流程。</p><h5 id="合成"><a href="#合成" class="headerlink" title="合成"></a>合成</h5><p>完成了上述的步骤，浏览器已经知道了文档结构、每一个元素的样式、几何信息以及绘制的顺序，将这些信息转化成屏幕上像素的过程叫做 <strong>光栅化</strong>，光栅化时图形学的范畴。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/9ed512afc63c664458faf1bd42247cc0.gif" class title="传统做法"><p>传统的做法是将可视区域的内容进行光栅化，随着用户滚动页面，不断的光栅化更多的区域；现代的浏览器有着更为复杂的过程：<strong>合成</strong>：</p><p>合成是一种将页面拆分成多层的技术，合成线程可以将各个层在不同线程中光栅化，再组成一个页面。当滚动时，如果层已经被光栅化，则会使用已经存在的层来合成新的帧，动画则可以通过移动层来实现：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/ae1b6d19e8aeb45841f04bbfa72760dd.gif" class title="合成"><p><strong>层（Layer）</strong>：</p><p>为了决定层包含哪些元素，主线程需要遍历布局树以找到需要生成的部分。对于开发者来说，当某一部分需要使用独立的层来渲染，可以使用 <code>will-change</code> 让浏览器创建层。</p><p><strong>栅格线程</strong>和<strong>合成线程</strong>：</p><p>当布局树和绘制顺序确定后，主线程会将这些信息提交给合成线程，合成线程会光栅化每个层。一个层包含的内容可能是一个完整的页面，也可能只是页面的一部分，所以合成线程将层拆分成许多块，并发送给栅格线程，栅格线程光栅化这些块并将它们存储再 GPU 缓存中。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/371b5fa654d59f0c8ccb2f4f0658c20a.png" class title="栅格化"><p>合成线程可以决定栅格线程光栅化的优先级，以此来确保用户能看到的部分优先光栅化；一个层也会包含多种块以支持类似缩放这样的功能，当块被光栅化后，合成线程会使用 <code>draw quads</code> 收集这些信息并创建合成帧（Compositor frame）。</p><ul><li><strong>Draw quads</strong>：存储在缓存中，包换类似块位置的信息，用于描述如何使用块合成页面；</li><li><strong>Compositor frame</strong>：用于存储表现页面一帧中包含哪些 Draw quads 的集合。</li></ul><p>然后一个合成帧被提交给浏览器进程，这时如果浏览器 UI 有变化，或者插件的 UI 有变化时，另一个合成帧就会被创建出来。每当有交互发生时，合成线程就会创建更多的合成帧然后通过 GPU 将新的部分渲染出来。</p><p>好处在于：其独立于主线程，合成线程不需要等待样式计算和 JavaScript 代码的运行。</p><h4 id="事件相关"><a href="#事件相关" class="headerlink" title="事件相关"></a>事件相关</h4><p>对于浏览器来说，输入事件意味着所有用户动作（如鼠标滚轮滚动或屏幕触摸等）。</p><p>当用户与页面发生交互时，浏览器进程首先接受到事件，但只关心事件发生位置，将事件类型和位置信息等发送给负责当前页签的渲染进程，渲染进程会找到事件发生的元素并触发事件监听器。</p><p><strong>合成线程对事件的处理</strong>：</p><p>当页面被合成线程合成过，合成线程会标记那些有事件监听的区域，当事件发生在响应的区域时，合成线程就会将事件发送给主线程处理；如果在非事件监听区域，则渲染进程直接创建新的帧而不关心主线程。</p><p><strong>事件代理引发的问题</strong>：</p><p>在事件代理中，利用事件冒泡，可以在目标元素的上层元素中监听事件，可以更高效的监听事件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但从浏览器角度来看，此时整个页面都会标记成 “慢滚动” 区域，意味着页面中某些部分并不需要事件监听，但合成线程依然需要在每次交互发生后等待主线程处理事件，造成效率降低。</p><p>解决：可以在事件代理时传入 <code>passive: true</code> 选项参数，告诉渲染进程，依然需要将事件发送给主线程处理，但不需要等待：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="params">event</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (event.target === area) &#123;</span><br><span class="line">    event.preventDefault()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123; <span class="attr">passive</span>: <span class="literal">true</span> &#125;)</span><br></pre></td></tr></table></figure><p><strong>浏览器动画事件优化</strong>：</p><p>类似 <code>touchmove</code> 这样的事件每秒向主线程发送 120 次可能会造成主程序执行时间过长而影响性能：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/6101cc07df5e744efb2a88208f1d1e52.png" class title="img"><p>为了减少发送给主线程的事件数量，Chrome 合并了连续的事件，类似：<code>wheel</code>、<code>mousewheel</code>、<code>mousemove</code>、<code>pointermove</code>、<code>touchmove</code> 等这样的事件会被延迟到下一次 <code>requestAnimationFrame</code> 前触发：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/53005a8114a736ca071a333946664ffd.png" class title="img"><p>而其他任何的离散时间，类似：<code>keydown</code>、<code>keyup</code>、<code>mouseup</code>、<code>touchstart</code>、<code>touchend</code> 等都会立即被发送给主线程处理。</p><h3 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h3><p>目前主流的浏览器有五个：</p><ul><li>Internet Explorer（Trident）</li><li>FireFox（Gecko）</li><li>Safari（webkit）</li><li>Chrome（webkit -&gt; Blink）</li><li>Opera（Presto -&gt; webkit -&gt; Blink）</li></ul><p>其他常用浏览器：</p><ul><li>360 浏览器、猎豹浏览器（IE + Chrome 双内核）</li><li>搜狗、遨游、QQ 浏览器（Trident(兼容模式) + webkit(高速模式)）</li><li>百度浏览器、世界之窗：IE 内核</li><li>2345 浏览器：IE 内核 -&gt; IE + Chrome 双内核</li></ul><h4 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h4><p>浏览器的主要功能就是向服务器发出请求，在浏览器窗口中展示请求的网络资源，一般为 HTML 文档，也可以是 PDF、图片或其他的类型，资源的位置由用户使用 UPI（统一资源标示符）指定。</p><h4 id="高层结构"><a href="#高层结构" class="headerlink" title="高层结构"></a>高层结构</h4><p>浏览器的主要组件为：</p><ul><li>用户界面：包括地址栏、前进/后退按钮、书签菜单等，除了浏览器主窗口显示的页面外，其他显示的各个部分都属于用户界面；</li><li>浏览器引擎：在用户界面和呈现引擎之间传送指令；</li><li>呈现引擎：负责显示请求的内容；</li><li>网络：用于网络调用，比如 HTTP 请求；</li><li>用户界面后端：用于绘制基本的窗口小部件，不如组合框和窗口；</li><li>JavaScript 解释器：用于解析和执行 JavaScript 代码；</li><li>数据存储：持久层</li></ul><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/layers.png" class title="浏览器的主要组件"><p>呈现引擎主流程（webkit 引擎）：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webkitflow.png" class title="webkit 引擎"><h3 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h3><h4 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h4><p>在硬件级别上，计算机内存由大量触发器组成，每个触发器包含几个晶导管，能够存储一个位；单个触发器可以通过唯一标识符寻址，可与进行读取与覆盖操作（可以把整个计算机内存看作是一个巨大的可读写的位数组）</p><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>分配器：分配所需要的内存；</li><li>使用期：使用分配到的内存（读写）；</li><li>释放期：不需要时将其释放并归还</li></ul><p>内存分配 -&gt; 内存使用 -&gt; 内存释放</p><h5 id="内存泄漏-1"><a href="#内存泄漏-1" class="headerlink" title="内存泄漏"></a>内存泄漏</h5><blockquote><p>在计算机科学中，内存泄漏指由于疏忽或错误造成程序未能释放已经不再使用的内存；内存泄漏并非物理上的消失，而是应用程序分配某段内存后，由于设计错误，导致在释放该内存之前就失去了对该段内存的控制，从而造成了内存的浪费。</p></blockquote><p>如果内存不再需要时，没有经过生命周期的释放期，那么就存在内存泄漏。</p><p>简单来说：无用的内存还在占用，得不到释放和归还。</p><h4 id="JS-内存管理机制"><a href="#JS-内存管理机制" class="headerlink" title="JS 内存管理机制"></a>JS 内存管理机制</h4><p>JavaScript 是在创建变量时自动进行了分配内存，并在不使用它们时自动释放（垃圾回收）。</p><p>JS 不需要程序员手动分配内存，绝大部分情况下也不需要手动释放内存，只需要直接使用内存即可</p><ul><li>内存分配：JS 定义变量就会自动分配内存，无需了解过深；</li><li>内存使用：使用值的过程实际上是对分配内存进行读取和写入的操作；</li><li>内存回收：一般称为垃圾内存回收（Garbage Collection）。</li></ul><p>内存泄漏一般都是发生在这一步，JavaScript 的内存回收机制虽然能回收绝大部分的垃圾内存，但是还是存在回收不了的情况，那么就需要手动清理内存。</p><h5 id="引用计数垃圾收集"><a href="#引用计数垃圾收集" class="headerlink" title="引用计数垃圾收集"></a>引用计数垃圾收集</h5><p>最初级的垃圾收集算法，把 “对象是否不在需要” 简化定义为 “对象有没有其他对象引用到它”；如果没有引用指向该对象，对象将被垃圾回收机制回收。</p><p>ES6 中把引用分为强引用和弱引用：</p><ul><li>强引用才会有引用计数叠加，只有引用计数为 0 的对象的内存才会被回收，所以一般需要手动回收内存（前提是标记清除还没有执行）；</li><li>弱引用没有触发引用计数叠加，只要引用计数为 0，弱引用就会自动消失，无需手动回收内存。</li></ul><h5 id="标记清除法"><a href="#标记清除法" class="headerlink" title="标记清除法"></a>标记清除法</h5><p>当变量进入执行环境时标记为 “进入环境”，当变量离开执行环境时则标记为 “离开环境”；被标记为 “进入环境” 的变量不能被回收，因为正在被使用；标记为 “离开环境” 的变量则可以被回收。</p><p>环境可以理解为作用域，但全局作用域的变量只有在页面关闭时才会销毁。</p><h4 id="泄漏场景"><a href="#泄漏场景" class="headerlink" title="泄漏场景"></a>泄漏场景</h4><p><strong>意外的全局变量</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在全局作用域下定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">number</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// count 相当于 window.count = 2</span></span><br><span class="line">  count = <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> count + number</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>被遗忘的计时器</strong>：</p><p>组件销毁时，<code>setInterval</code> 还是在运行的，里面涉及的内存都是无法回收的，需要在组件销毁时清除计时器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.refreshInterval = setInterval(() =&gt; &#123;</span><br><span class="line">        // 轮询获取数据</span><br><span class="line">        this.refresh()</span><br><span class="line">      &#125;, 2000)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy () &#123;</span><br><span class="line">      clearInterval(this.refreshInterval)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      refresh () &#123;</span><br><span class="line">        // 获取一些数据</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>被遗忘的事件监听器</strong>：</p><p>组件销毁时，一些事件（如 resize）依然会在监听中，其涉及的内存无法回收，需要在组件销毁时移除相关的事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      this.resize = () =&gt; &#123;</span><br><span class="line">        // 这里做一些操作</span><br><span class="line">      &#125;</span><br><span class="line">      window.addEventListener(&#x27;resize&#x27;, this.resize)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy () &#123;</span><br><span class="line">      window.removeEventListener(&#x27;resize&#x27;, this.resize)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>被遗忘的 ES6 Set</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Set</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;AgoniLay&#x27;</span> &#125;</span><br><span class="line">map.add(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 若不进行 delete 操作，则 obj 相关内存无法清除</span></span><br><span class="line">map.delete(obj)</span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>也可以使用 WeakSet，WeakSet 的成员是弱引用，内存回收不会考虑此引用是否存在。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">name</span>: <span class="string">&#x27;AgoniLay&#x27;</span> &#125;</span><br><span class="line">map.add(obj)</span><br><span class="line"></span><br><span class="line">obj = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p><strong>被遗忘的 ES6 Map 键名</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="keyword">let</span> key = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>)</span><br><span class="line">map.set(key, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 与 Set 同理，不进行 delete 操作则无法进行回收</span></span><br><span class="line">map.delete(key)</span><br><span class="line">key = <span class="literal">null</span></span><br></pre></td></tr></table></figure><p>也可以使用 WeakMap，与 WeakSet 同理。</p><p><strong>被遗忘的订阅发布事件监听器</strong>：</p><p>当组件销毁时，自定义事件依然在监听中，其涉及到的内存无法回收，需要在组件销毁时移除相关的事件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">&lt;div @click=&quot;onClick&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import customEvent from &#x27;event&#x27;</span><br><span class="line"></span><br><span class="line">  export default &#123;</span><br><span class="line">    mounted () &#123;</span><br><span class="line">      customEvent.on(&#x27;test&#x27;, data =&gt; &#123;</span><br><span class="line">        // 一些逻辑</span><br><span class="line">        console.log(data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;,</span><br><span class="line">    beforeDestroy () &#123;</span><br><span class="line">      customEvent.off(&#x27;test&#x27;)</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line">      onClick () &#123;</span><br><span class="line">        customEvent.emit(&#x27;test&#x27;, &#123; type: &#x27;click&#x27; &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p><strong>被遗忘的闭包</strong>：</p><p>闭包在带来便利的同时，有可能会带来内存的泄漏：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">closure</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> name = <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> name</span><br><span class="line">      .split(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">      .reverse()</span><br><span class="line">      .join(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> reverseName = closure()</span><br><span class="line"><span class="comment">// name 不是必须的，但还是占用了内存，也无法被回收</span></span><br></pre></td></tr></table></figure><p><strong>脱离 DOM 的引用</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.elements = &#123;</span><br><span class="line">      <span class="attr">button</span>: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#button&#x27;</span>),</span><br><span class="line">      <span class="attr">div</span>: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#div&#x27;</span>),</span><br><span class="line">      <span class="attr">span</span>: <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#span&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  removeButton () &#123;</span><br><span class="line">    <span class="built_in">document</span>.body.removeChild(<span class="built_in">this</span>.elements.button)</span><br><span class="line">    <span class="comment">// 需要手动释放内存</span></span><br><span class="line">    <span class="comment">// this.elements.button = null</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> Test()</span><br><span class="line">a.removeButton()</span><br></pre></td></tr></table></figure><h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h2><h3 id="性能指标-RAIL"><a href="#性能指标-RAIL" class="headerlink" title="性能指标 RAIL"></a>性能指标 RAIL</h3><p>RAIL 是一个以用户为中心的性能模型，把用户的体验拆分成几个关键点，并制定了每一个的性能指标：</p><ul><li>Response</li><li>Animation</li><li>Idle</li><li>Load</li></ul><h4 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h4><p>用户的输入到响应的时间不超过 100ms，事件处理最好在 50ms 内完成。</p><p>优化方案：</p><ul><li>考虑到 idle task 的情况，事件会排队，等待时间大概在50ms。适用于click，toggle，starting animations 等，不适用于 drag 和 scroll；</li><li>复杂的 js 计算尽可能放在后台，如 web worker，避免对用户输入造成阻塞；</li><li>超过 50ms 的响应，一定要提供反馈，比如倒计时、进度百分比等。</li></ul><blockquote><p>idle task：除了要处理输入事件，浏览器还有其它任务要做，这些任务会占用部分时间，一般情况会花费50ms的时间，输入事件的响应则排在其后。</p></blockquote><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><p>产生每一帧的时间不要超过 10ms，旨在视觉上的平滑，用户对于帧率变化感知很敏感。</p><p>优化方案：</p><ul><li>在一些高压节点上，比如动画，不要去挑战 CPU，尽可能的少做事；</li><li>在渲染性能上，针对不同的动画做一些特定优化。</li></ul><blockquote><p>动画不只是 UI 的视觉效果，以下行为都属于：</p><ul><li>视觉动画：如渐隐渐显，tweens，loading 等；</li><li>滚动，包含弹性滚动，松开手指后，滚动会持续一段距离；</li><li>拖拽，缩放等等。</li></ul></blockquote><h4 id="Idle"><a href="#Idle" class="headerlink" title="Idle"></a>Idle</h4><p>最大化空闲时间，以增大 50ms 内响应用户输入的几率。</p><p>优化方案：</p><ul><li>用空闲时间来完成一些延后的工作：<ul><li>比如先加载页面可见的部分，然后利用空闲时间加载剩余部分（可以使用 <code>requestIdleCallback API</code>）；</li></ul></li><li>在空闲时间内执行的任务尽量控制在 50ms 以内，如果更长的话，会影响 input handle 的 pending 时间；</li><li>如果用户在空闲时间任务进行时进行交互，必须以此为最高优先级，并暂停空闲时间的任务。</li></ul><h4 id="Load"><a href="#Load" class="headerlink" title="Load"></a>Load</h4><p>根据设备网络等条件优化加载速度，在一个中配 3G 网络手机打开时间不超过 5s，对于第二次打开不超过 2s。</p><p>优化方案：</p><ul><li>在手机设备上测试加载性能，选用中配的3G网络（400kb/s，400ms RTT），可以使用 <a href="https://link.juejin.cn/?target=https://www.webpagetest.org/easy">WebPageTest</a> 来测试；</li><li>要考虑到丢包或者网络波动等情况导致比预期加载慢；</li><li>禁用渲染阻塞的资源，延后加载；</li><li>可以采用 lazy load，code-splitting 等其他优化手段，是第一次加载的资源更少</li></ul><h4 id="分析工具使用"><a href="#分析工具使用" class="headerlink" title="分析工具使用"></a>分析工具使用</h4><ul><li><a href="https://link.juejin.cn/?target=https://developers.google.com/web/tools/chrome-devtools">Chrome DevTools</a></li><li><a href="https://link.juejin.cn/?target=https://web.dev/measure/">Lighthouse</a></li><li><a href="https://link.juejin.cn/?target=https://webpagetest.org/easy">WebPageTest</a></li></ul><h4 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h4><ul><li>聚焦用户</li><li>100ms 内响应用户的输入</li><li>10ms 内产生 1 帧，在滚动或者动画执行时</li><li>最大化主线程的空闲时间</li><li>5s 内让网页变得可交互</li></ul><h3 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h3><blockquote><p>资源来自文档：<a href="https://alienzhou.com/projects/fe-performance-journey/">https://alienzhou.com/projects/fe-performance-journey/</a></p><p>雅虎性能优化35条规则：<a href="https://github.com/creeperyang/blog/issues/1">https://github.com/creeperyang/blog/issues/1</a></p></blockquote><p>性能优化广义上包含前端优化和后端优化。后端优化的关注点更多是在增加资源利用率、降低资源成本以及提高稳定性上；前端性能优化会更直接与用户的体验相关。</p><h4 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h4><h5 id="本地数据存储"><a href="#本地数据存储" class="headerlink" title="本地数据存储"></a>本地数据存储</h5><p>对于一些请求，可以直接在业务代码侧进行缓存处理，缓存方式包括：<code>localStorage</code>、<code>sessionStorage</code>、<code>indexedDB</code>；从前端视角看，这是一种本地存储，但从整个系统的维度来看，其实也是缓存链条上重要的一环，对于一些特殊的、轻量级的业务数据，可以考虑使用本次存储作为缓存。</p><h5 id="内存缓存-Memory"><a href="#内存缓存-Memory" class="headerlink" title="内存缓存(Memory)"></a>内存缓存(Memory)</h5><p>当访问一个页面及其子资源时，又是会出现一个资源被使用多次，如图标。由于该资源已经在内存中，再次请求没有必要，浏览器内存则是最近、最快的响应场所。</p><h5 id="Cache-API"><a href="#Cache-API" class="headerlink" title="Cache API"></a>Cache API</h5><p>在未命中内存缓存后，发送请求前会来到 Cache API 中，通常是和 Service Worker 配合使用的。</p><p>Service Worker 是一个后台运行的独立线程，可以在代码中启用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  navigator.serviceWorker.register(<span class="string">&#x27;./sw.js&#x27;</span>).then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 注册成功</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后处理一些 Service Worker 的生命周期时间，在其中设置请求拦截：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sw.js</span></span><br><span class="line">self.addEventListener(<span class="string">&#x27;fetch&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 如果有 cache 则直接返回，否则通过 fetch 请求</span></span><br><span class="line">  e.respondWith(</span><br><span class="line">    caches.match(e.request).then(<span class="function"><span class="params">cache</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> cache || fetch(e.request)</span><br><span class="line">    &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(err)</span><br><span class="line">      <span class="keyword">return</span> fetch(e.request)</span><br><span class="line">    &#125;)</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>以上会拦截所有的网络请求，查看是否有缓存的请求内容，如果有则返回缓存，否则会继续发送请求。</p><p>与内存缓存不同，Cache API 的缓存可认为是 “永久性” 的。关闭浏览器或离开页面之后，下次访问仍可以使用。</p><blockquote><p>Service Worker 相关文章：<a href="https://juejin.cn/post/6844903588691443725">https://juejin.cn/post/6844903588691443725</a></p></blockquote><h5 id="HTTP-缓存"><a href="#HTTP-缓存" class="headerlink" title="HTTP 缓存"></a>HTTP 缓存</h5><p>如果 Service Worker 中也没有缓存的请求信息，那么就会真正到 HTTP request 的阶段了，HTTP 缓存大致可以分为强缓存与协商缓存：</p><p>在强缓存的情况下，浏览器不会向服务器发送请求，而是直接从本地缓存中读取内容，一般就是来源于硬盘，也就是在 Chrome Devtools 上经常看到的 <code>disk cache</code>。</p><p>相关的响应头是 <code>Expires</code> 和 <code>Cache-Control</code>，具体可以查看之前的浏览器缓存策略。</p><h5 id="Push-Cache"><a href="#Push-Cache" class="headerlink" title="Push Cache"></a>Push Cache</h5><p>这是最后一个缓存检查，是 HTTP/2 的 Push 功能带来的，在你请求一个资源的同时，服务器可以为你推送一些其他相关的资源，以此来避免浏览器收到响应、解析到相应位置是才会请求所带来的延后。</p><p>HTTP/2 Push Cache 是比较底层的网络特性，与其他的缓存有很多不同：</p><ul><li>在匹配上时，并不会再额外检查资源是否过期；</li><li>存活时间很短（Chrome 中约为 5min 左右）；</li><li>只会被使用一次；</li><li>HTTP/2 链接断开将直接失效。</li></ul><h4 id="发送请求"><a href="#发送请求" class="headerlink" title="发送请求"></a>发送请求</h4><h5 id="避免多余重定向"><a href="#避免多余重定向" class="headerlink" title="避免多余重定向"></a>避免多余重定向</h5><p>重定向是一个比较常用的技术手段，分为 301 永久重定向和 302 临时重定向，需要贴合语义使用。</p><p>每次重定向都是由请求耗时的，要避免多余的重定向。</p><h5 id="DNS-预解析"><a href="#DNS-预解析" class="headerlink" title="DNS 预解析"></a>DNS 预解析</h5><p>访问远程服务时，不会直接使用服务的出口 IP，而是使用域名，所以请求需要进行域名解析。</p><p>DNS 服务本省是一个树状层级结构，其解析是一个递归与迭代的过程（github.com）：</p><ol><li>先检查本地 hosts 文件中是否有映射，有则使用；</li><li>查找本地 DNS 缓存，有则返回；</li><li>根据配置在 TCP/IP 参数中设置 DNS 查询服务器，并向其进行查询，这里先称为本地 DNS；</li><li>如果该服务器无法解析域名（没有缓存），且不需要转发，则会向根服务器请求；</li><li>根服务器根据域名类型判断对应的顶级域名服务器（.com），返回给本地 DNS，然后重复该过程，直到找到该域名；</li><li>当然，如果设置了转发，本地 DNS 会将请求逐级转发，直到转发服务器返回或者也不能解析。</li></ol><p>要知道：</p><ul><li>DNS 解析流程可能会很长，耗时很高，所以整个 DNS 服务，包括客户端都会有缓存机制，这个作为前端不好涉入；</li><li>在 DNS 解析上，前端还是可以通过浏览器提供的其他手段来“加速”的：</li></ul><p>DNS Prefetch 就是浏览器提供的一个 API，是 Resource Hint 的一部分，会预解析网页中可能之后会访问的域名。</p><h5 id="预先建立连接"><a href="#预先建立连接" class="headerlink" title="预先建立连接"></a>预先建立连接</h5><p>建立连接不仅需要 DNS 查询，还需要进行 TCP 协议握手，有些还会有 TLS/SSL 协议，都将会导致连接的耗时。</p><p>可以使用 Preconnect 告诉浏览器：之后有些资源会用到某个源（origin），然后预先建立连接。</p><p>根据规范，使用 Preconnect 时，浏览器做了如下处理：</p><ol><li>解析 Preconnect 的 url；</li><li>根据当前 link 元素中的属性进行 cors 的设置；</li><li>默认先将 credential 设为 true，如果 cors 位 Anonymous 并且存在跨域，则将 credential 设置为 false，随后进行连接。</li></ol><p>使用 preconnect 只需要将 <code>rel</code> 属性设为 <code>preconnect</code> 即可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//agonilay.top&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 也可以设置 crossorigin --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preconnect&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//agonilay.top&quot;</span> <span class="attr">corssorigin</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="使用-CDN"><a href="#使用-CDN" class="headerlink" title="使用 CDN"></a>使用 CDN</h5><p>当实际把网络包发向我们的目标地址时，肯定希望越快到达目的地越好（对应的，也会希望越快获得响应）。而网络传输是有极限的，同样一个北京的用户，访问北京的服务器显然要比广州快很多。同时，服务的负载也会影响响应的速度。</p><p>对于静态资源，可以考虑通过 CDN 来降低时延。</p><blockquote><p>对于使用 CDN 的资源，DNS 解析会将 CDN 资源的域名解析到 CDN 服务的负载均衡器上，负载均衡器可以通过请求的信息获取用户对应的地理区域，从而通过负载均衡算法，在背后的诸多服务器中，综合选择一台地理位置近、负载低的机器来提供服务。例如为北京联通用户解析北京的服务器 IP。这样，用户在之后访问 CDN 资源时都是访问北京服务器，距离近，速度快。</p></blockquote><p>发送请求的流程：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302172517397.png" class title="发送请求流程"><h4 id="服务器响应"><a href="#服务器响应" class="headerlink" title="服务器响应"></a>服务器响应</h4><p>主要针对于 NodeJS 讨论</p><h5 id="使用流进行响应"><a href="#使用流进行响应" class="headerlink" title="使用流进行响应"></a>使用流进行响应</h5><p>目前，现代浏览器都支持根据流的返回形式来逐步进行页面内容的解析、处理。这就意味着，即使请求的响应没有完全结束，浏览器也可以从手里已有的响应结果中进行页面的解析与渲染。</p><h5 id="业务聚合"><a href="#业务聚合" class="headerlink" title="业务聚合"></a>业务聚合</h5><p>使用 NodeJS 的 BFF 层来进行后端服务的聚合。</p><h5 id="避免代码问题"><a href="#避免代码问题" class="headerlink" title="避免代码问题"></a>避免代码问题</h5><ul><li><code>async</code> <code>await</code> 的不当使用导致并行请求被串行化了；</li><li>频繁地 <code>JSON.parse</code> 和 <code>JSON.stringify</code> 大对象；</li><li>正则表达式的灾难性回溯；</li><li>闭包导致的内存泄漏；</li><li>CPU 密集型任务导致事件循环 delay 严重；</li><li>未捕获的异常导致进程频繁退出，守护进程（pm2/supervisor）又将进程重启，这种频繁的启停也会比较消耗资源。</li></ul><h4 id="页面解析与处理"><a href="#页面解析与处理" class="headerlink" title="页面解析与处理"></a>页面解析与处理</h4><p>此阶段浏览器需要处理的包括：</p><ul><li>页面 DOM 的解析；</li><li>页面静态资源的加载，包括了页面引用的 JavaScript/CSS/图片/字体等；</li><li>静态资源的解析与处理，像是 JavaScript 的执行、CSSOM 的构建与样式合成等；</li></ul><h5 id="注意资源在页面文档中的位置"><a href="#注意资源在页面文档中的位置" class="headerlink" title="注意资源在页面文档中的位置"></a>注意资源在页面文档中的位置</h5><p>HTML 解析为 DOM Tree，CSS 解析为 CSSOM，两者再合成 Render Tree，JavaScript 会阻塞 DOM 构建，而 CSSOM 的构建又会阻塞 JavaScript 的执行。</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302173153721.png" class title="image-20220302173153721"><p>所以这就是推荐把 CSS 样式表放在 <code>&lt;head&gt;</code> 之中（即页面的头部），把 JavaScript 脚本放在 <code>&lt;body&gt;</code> 的最后（即页面的尾部）的原因。</p><h5 id="使用-defer-和-async"><a href="#使用-defer-和-async" class="headerlink" title="使用 defer 和 async"></a>使用 defer 和 async</h5><p>可以使用 <code>defer</code> 或 <code>async</code> 属性。两者都会防止 JavaScript 脚本的下载阻塞 DOM 构建。但是两者也有区别，最直观的表现如下：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220302173717303.png" class title="image-20220302173717303"><p>根据它们的特点，推荐在一些与主业务无关的 JavaScript 脚本上使用 <code>async</code>，例如统计脚本、监控脚本、广告脚本等，这些脚本一般都是一份独立的文件，没有外部依赖，不需要访问 DOM，也不需要有严格的执行时机限制。在这些脚本上使用 <code>async</code> 可以有效避免这些非核心功能的加载影响页面解析速度。</p><h5 id="页面文档压缩"><a href="#页面文档压缩" class="headerlink" title="页面文档压缩"></a>页面文档压缩</h5><p>HTML 的文档大小也会极大影响响应体下载的时间，一般会进行 HTML 内容压缩（uglify）的同时，使用文本压缩算法（例如 gzip）进行文本的压缩。</p><h4 id="页面静态资源"><a href="#页面静态资源" class="headerlink" title="页面静态资源"></a>页面静态资源</h4><h5 id="总体"><a href="#总体" class="headerlink" title="总体"></a>总体</h5><ol><li>减少不必要的请求：</li></ol><p>核心是尽量减少请求的数量，因为浏览器对同源请求有并发上限的限制（例如 Chrome 是6），所以在 HTTP/1.1 下，请求过多可能会导致请求被排队了。</p><p>同时，TCP/IP 的拥塞控制也使其传输有慢启动（slow start）的特点，连接刚建立时包体传输速率较低，后续会渐渐提速。</p><p>所以要减少不必要的请求：</p><ul><li>对于不需要使用的内容，不要请求；</li><li>对于可以延迟加载的内容，在需要使用之前再加载；</li><li>对于可以合并的资源，可以进行资源合并。</li></ul><ol start="2"><li>减少包体大小</li></ol><p>包体大小对性能也是有直接影响的。显然同样速率下，包体越小，传输耗时越低，整体页面加载与渲染的性能也会更好：</p><ul><li>使用适合当前资源的压缩技术；</li><li>删除响应包体中无关紧要的内容。</li></ul><ol start="3"><li>降低应用资源时的消耗</li></ol><p>在 JavaScript 执行了一段 CPU 密集的计算，或者进行频繁的 DOM 操作，这些都会让 JavaScript 的执行变成影响性能的一大问题；另外像是 CSS 选择器匹配、图片的解析与处理等，都是要消耗 CPU 和内存的。</p><ol start="4"><li>利用缓存</li></ol><h5 id="JavaScript-1"><a href="#JavaScript-1" class="headerlink" title="JavaScript"></a>JavaScript</h5><ol><li>代码拆分与按需加载：</li></ol><p>在访问一个页面时，并不需要把其他页面的组件也全部加载过来，完全可以等到访问其他页面时，再按需去动态加载；</p><p>代码拆分一般会配合构建工具一起使用。以 webpack 为例，在日常使用时，最常见的方式就是通过 <a href="https://github.com/tc39/proposal-dynamic-import">dynamic import</a> 来告诉 webpack 去做代码拆分；如果不使用 webpack 之类的构建工具，也可以选择一个 AMD 模块加载器（例如 <a href="https://requirejs.org/">RequireJS</a>）来实现前端运行时上的异步依赖加载。</p><ol start="2"><li>代码合并</li></ol><p>在很多流行的构建工具中（webpack/Rollup/Parcel），是默认会把依赖打包到一起的；但当使用其他一些工具时，就要注意打包。例如使用 <a href="https://fis.baidu.com/fis3/docs/pack.html">FIS3</a> 时，就需要通过配置声明，将一些 common 库或 npm 依赖进行打包合并；又或者使用 Gulp 这样的工具，也需要注意进行打包。</p><ol start="3"><li>代码压缩</li></ol><p>JavaScript 代码压缩比较常见的做法就是使用 <a href="http://lisperator.net/uglifyjs/">UglifyJS</a> 做源码级别的压缩。它会通过将变量替换为短命名、去掉多余的换行符等方式，在尽量不改变源码逻辑的情况下，做到代码体积的压缩。基本已经成为了前端开发的标配。</p><p>在 webpack 的 production 模式下是默认开启的；而在 Gulp 这样的任务流管理工具上也有 <a href="https://github.com/terinjokes/gulp-uglify">gulp-uglify</a> 这样的功能插件。</p><p>另一个代码压缩的常用手段是使用一些文本压缩算法，gzip 就是常用的一种方式。</p><ol start="4"><li>Tree Shaking</li></ol><p>其本质是通过检测源码中不会被使用到的部分，将其删除，从而减小代码的体积。</p><ol start="5"><li>优化 polyfill 的使用</li></ol><p>前端技术的一大特点就是需要考虑兼容性，而 polyfill 用于在非兼容浏览器上也能使用新特性的 API。</p><p>但 polyfill 的使用也增加了代码体积，可以通过 <a href="https://github.com/browserslist/browserslist">browserslist</a> 来帮忙；</p><p>其次，在 Chrome Dev Summit 2018 上还介绍了一种 <a href="https://youtu.be/reztLS3vomE?t=1254">Differential Serving</a> 的技术，通过浏览器原生模块化 API 来尽量避免加载无用 polyfill：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;main.mjs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">nomodule</span> <span class="attr">src</span>=<span class="string">&quot;legacy.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样，在能够处理 <code>module</code> 属性的浏览器（具有很多新特性）上就只需加载 <code>main.mjs</code>（不包含 polyfill）；而在老式浏览器下，则会加载 <code>legacy.js</code>（包含 polyfill）。</p><ol start="6"><li>webpack</li></ol><p>webpack 现在已经成为很多前端应用的构建工具，但其中的无用包也不容小觑。</p><ol start="7"><li>JS 的解析耗时</li></ol><p>一个 JavaScript 文件，即使内部没有所谓的“立即执行函数”，JavaScript 引擎也是需要对其进行解析和编译的；删除不必要的代码，对于降低 Parse 与 Compile 的负载也是很有帮助的。</p><ol start="8"><li>避免 Long Task</li></ol><p>对于一些单页应用，在加载完核心的 JavaScript 资源后，可能会需要执行大量的逻辑，如果处理不好，可能会出现 JavaScript 线程长时间执行而阻塞主线程的情况。</p><ol start="9"><li>框架的使用与否</li></ol><p>并不是说不要使用框架/类库，只是希望不要拘泥于某个思维定式</p><h5 id="CSS-1"><a href="#CSS-1" class="headerlink" title="CSS"></a>CSS</h5><ol><li><p>关键 CSS：CRP（Critical Rendering Path，关键渲染路径） 是指优先显示与当前用户操作有关的内容。由于 CSS 会“间接”阻塞页面的解析，所以在这个过程中的 CSS 也被称为关键 CSS，识别出当前业务中的关键 CSS，优先下载与解析它，将会更好地降低延迟：将关键 CSS 的内容通过 <code>&lt;style&gt;</code> 标签内联到 <code>&lt;head&gt;</code> 中，然后异步加载其他非关键 CSS（骨架屏就是此思路的一个延展）</p></li><li><p>按需加载</p></li><li><p>合并文件</p></li><li><p>慎用 <code>@import</code>：CSS 提供了一个 <code>@import</code> 语法来加载外部的样式文件。然而，这会把你的请求变得串行化。</p></li><li><p>压缩文件以及选择合适的兼容性</p></li><li><p>简化选择器</p></li><li><p>避免使用昂贵的属性：</p><ul><li>border-radius</li><li>box-shadow</li><li>opacity</li><li>transform</li><li>filter</li><li>position: fixed</li></ul></li><li><p>使用先进的布局方式：使用新版的 flex 进行布局比我们用的一些“老式”方法性能更好（例如基于 float 的浮动布局）。 flex 在移动端具有不错的兼容性，很多移动场景下已经大规模使用 flex 进行页面布局，但 flex 有兼容性的要求（对于 IE）</p></li><li><p>利用缓存</p></li></ol><h5 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h5><ol><li>优化请求数：<ul><li>雪碧图（Sprite）；</li><li>懒加载（尽量只加载用户正在浏览或者即将要浏览到的图片）：<ul><li>首屏可以不需要懒加载，对首屏图片也使用懒加载会延迟图片的展示。</li><li>设置合理的占位图，避免图片加载后的页面“抖动”。</li><li>虽然目前基本所有用户都不会禁用 JavaScript，但还是建议做一些 JavaScript 不可用时的 backup</li></ul></li><li>CSS 中图片懒加载：使用 <code>background-url</code> 属性设置，如果未使用到具体的元素，浏览器并不会去下载；</li><li>内联 base64：将将图片转为 base64 字符串，并将其内联到页面中返回，缺点在于相比使用二进制体积会增大 33% 且会在页面请求中串行进行（常用于首屏加载 CRP 或者骨架图上的一些小图标）</li></ul></li><li>减少图片大小：<ul><li>使用合适的图片格式：<ol><li>WebP 格式：在有损与无损压缩上，它的表现都会优于传统（JPEG/PNG）格式；</li><li>SVG 应对矢量图：在一些需要缩放与高保真的情况，或者用作图标的场景下，使用 SVG 这种矢量图非常不错；</li><li>使用 video 替代 GIF：通过静音(muted)的 video 来代替 GIF，相同的效果下，GIF 比视频(MPEG-4)大 5~20 倍；</li><li>渐进式 JPEG：基线 JPEG (baseline JPEG) 会从上往下逐步呈现，而 <a href="https://www.zhangxinxu.com/wordpress/2013/01/progressive-jpeg-image-and-so-on/">渐进式 JPEG (progressive JPEG)</a> 则会从模糊到逐渐清晰，使人的感受上会更加平滑，但渐进式的解码速度会稍慢；</li></ol></li><li>图片质量的权衡：图片的压缩一般可以分为有损压缩（lossy compression）和无损压缩（lossless compression），处理图片压缩可以使用 <a href="https://github.com/imagemin/imagemin">imagemin</a> 这样的工具；</li><li>使用合适的大小和分辨率；</li><li>删除冗余的图片信息：可以使用像 <a href="https://imageoptim.com/versions">imageOptim</a> 这样的工具来移除隐私与非关键的元信息；</li><li>SVG 压缩：<a href="https://github.com/svg/svgo">SVGGO</a> 是一个可以集成到构建流中的 NodeJS 工具，可以进行 SVG 的优化；</li></ul></li><li>缓存</li></ol><h5 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h5><p>有些时候，内置的字体并不能满足需求，一般会使用 <code>@font-face</code> 来加载字体文件：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">     <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题在于：在字体加载期间，浏览器页面是默认不展示文本内容的，也就是 FOIT（Flash of Invisible），会带来糟糕的用户体验。</p><ol><li><p>font-display：可以在 <code>@font-face</code> 中设置 <code>font-display: swap</code>，让 FOIT 的默认行为变为 FOUT (Flash of Unstyled Text)，先会使用默认的字体样式展示文本，加载完毕后再将文本的字体样式进行替换：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">/static/samplefont.woff2</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>),</span><br><span class="line">     <span class="built_in">url</span>(<span class="string">/static/samplefont.woff</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff&#x27;</span>);</span><br><span class="line">  <span class="attribute">font-display</span>: swap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>font-display 的取值包括 <code>auto|block|swap|fallback|optional</code>，不过有兼容性问题</p></li><li><p>内联字体：将字体文件转为 base64 的字符串，设置到 <code>@font-face</code> 里的 <code>src</code> 属性上，避免异步加载字体时的 FOIT 或 FOUT：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">&#x27;Samplefont&#x27;</span>;</span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">&#x27;data:application/x-font-woff;charset=utf-8;base64...&#x27;</span>) <span class="built_in">format</span>(<span class="string">&#x27;woff2&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>局限性：在一个 <code>@font-face</code> 中只能加载一种字体类型，也会将本可以并行请求的数据量变为串行；</p></li><li><p>使用 CSS Font Loading API：兼容性欠佳，可以使用 <a href="https://github.com/bramstein/fontfaceobserver">Font Face Observer</a> 库；</p></li><li><p>FOFT：在需要加载同一字体的粗体、斜体时，FOFT (Flash of Faux Text) 方法会非常有效。</p></li></ol><h5 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h5><ol><li><p>使用合适的视频格式：不同的视频编码格式，其数据大小也大都不同。目前在 HTML5 Video 中常用的格式为 MPEG-4，除了 MPEG-4 之外，还支持一种叫 WebM 的新的视频格式。<br>WebM(VP9) 相较于 MPEG-4(x264) 来说会更小，但兼容性也较差；</p></li><li><p>视频压缩：</p><ul><li><a href="https://handbrake.fr/">HandBrake</a></li><li><a href="https://www.freemake.com/free_video_converter/">Freemake</a></li><li><a href="http://www.selur.de/">Hybrid</a></li><li><a href="https://sourceforge.net/projects/megui/">MeGUI</a></li></ul></li><li><p>移除不必要的音轨信息：在不需要声音的情况下，将 <code>&lt;video&gt;</code> 设置为 <code>muted</code>；</p></li><li><p>使用流：尝试让浏览器使用“流”或者小分片的方式来播放你的视频，例如常用的 HLS (HTTP Live Streaming) 技术；</p><blockquote><p>使用 HLS 技术，会包含一个 <code>.m3u8</code> 的索引文件和一系列包含播放内容的 <code>.ts</code> 分片。浏览器通过不断下载一小段的分片来进行视频播放，避免了完整视频下载的流量消耗。</p></blockquote></li><li><p>移除不必要的视频：比如在小屏幕上，可以通过媒体查询来避免下载视频：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@media</span> screen <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">650px</span>) &#123;</span><br><span class="line">  <span class="selector-id">#hero-video</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="运行时"><a href="#运行时" class="headerlink" title="运行时"></a>运行时</h4><h5 id="强制同步布局"><a href="#强制同步布局" class="headerlink" title="强制同步布局"></a>强制同步布局</h5><ul><li>尝试使用 RAF（<code>requestAnimationFrame API</code>） 避免强制同步布局，将布局查询的操作放在 <code>requestAnimationFrame</code> 中；</li><li>批量化操作：批量化是计算机程序优化中的重要手段之一，对于元素布局的查询操作，可以将这些操作批量化存储下来，等到下一次 <code>requestAnimationFrame</code> 触发时一起执行</li></ul><h5 id="长列表优化"><a href="#长列表优化" class="headerlink" title="长列表优化"></a>长列表优化</h5><ol><li>实现 Virtual List：Virtual List 是一种用来优化长列表的技术。它可以保证在列表元素不断增加，或者列表元素很多的情况下，依然拥有很好的滚动、浏览性能；</li><li>原生的 Virtual Scroller：不建议在生产环境使用；</li></ol><h5 id="避免-JS-运行时间过长"><a href="#避免-JS-运行时间过长" class="headerlink" title="避免 JS 运行时间过长"></a>避免 JS 运行时间过长</h5><p>屏幕的刷新频率决定了每帧之间留给 JavaScript 执行的时间“并不多”。也正是由于渲染线程和 JavaScript 线程之间互斥，所以 JavaScript 执行占用时间过长会导致无法及时渲染，即出现所谓的“掉帧”。</p><ol><li>任务分解：长时间的运行会导致渲染阻塞，那么把任务拆成一个个持续时间更短的小任务，分散到各个帧中执行；也可以使用浏览器 API <code>requestIdleCallback</code> 在浏览器空闲时间执行注册的回调函数；</li><li>延迟执行：<ol><li>懒执行，当需要时才去计算；</li><li>延后执行，即利用 <code>setTimeout</code>、<code>requestIdleCallback</code> 这样的方法把计算放到后续的事件循环或空闲时刻。</li></ol></li><li>并行计算：可以使用 Web Worker 启用并行程序；</li></ol><h5 id="善用-Composite"><a href="#善用-Composite" class="headerlink" title="善用 Composite"></a>善用 Composite</h5><p>当合成层更新时，浏览器会将布局调整限制在该层中，做到尽可能小的布局变动。</p><p>合成层在性能优化上的优点在于：</p><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快；</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层；</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint。</li></ul><h5 id="滚动事件的性能优化"><a href="#滚动事件的性能优化" class="headerlink" title="滚动事件的性能优化"></a>滚动事件的性能优化</h5><ul><li><a href="https://github.com/lessfish/underscore-analysis/issues/22">节流(underscore)</a></li><li><a href="https://github.com/lessfish/underscore-analysis/issues/21">防抖(debounce)</a></li></ul><h5 id="Passive-event-listeners"><a href="#Passive-event-listeners" class="headerlink" title="Passive event listeners"></a>Passive event listeners</h5><p>浏览器不执行完监听回调里的代码，就不会知道开发者有没有禁止默认事件，当添加触摸、滚轮的事件监听后，每次触发该事件，浏览器都会先花费时间执行完你的回调，然后根据结果来判断是否需要滚动页面，就会导致性能问题。</p><p>所以需要告诉浏览器默认行为没有被禁用，而不用确认监听函数，就需要使用 <a href="https://github.com/WICG/EventListenerOptions/blob/gh-pages/explainer.md">Passive event listeners</a>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&#x27;touchstart&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// do something</span></span><br><span class="line">&#125;, &#123;<span class="attr">passive</span>: <span class="literal">true</span>&#125;)</span><br></pre></td></tr></table></figure><p>在监听函数的第三个参数中传入 <code>&#123; passive: true &#125;</code> 即可。</p><h4 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h4><p>预加载相当于是快用户一步，在空闲的时候就把用户即将用到的资源加载完，等用户实际需要使用时，资源已经存在在本地，自然就跳过了整个加载的等待时间。</p><h5 id="预加载技术"><a href="#预加载技术" class="headerlink" title="预加载技术"></a>预加载技术</h5><h6 id="Resource-Hints"><a href="#Resource-Hints" class="headerlink" title="Resource Hints"></a>Resource Hints</h6><p><a href="https://www.w3.org/TR/resource-hints/">Resource Hints</a> 是一种预加载相关的标准，它告诉浏览器哪些源下的资源 Web 应用需要获取，哪些资源在之后的操作或浏览时需要被使用，从而让浏览器能够进行一些预先连接或预先加载操作。</p><p>Resource Hints 标准包括 DNS Prefetch、Preconnect、Prefetch 与 Prerender，此外，还有一个与 Resource Hints 类似的 Preload：</p><ul><li><p>Prefetch：资源预获取，as 属性用于制定资源的类型：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prefetch&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/prefetch.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Prerender：预获取并预执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;prerender&quot;</span> <span class="attr">href</span>=<span class="string">&quot;//sample.com/nextpage.html&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>Preload：立刻进行预获取并将结果放在内存里，不会影响页面 parse 与 load 事件的触发，直到再次遇到该资源的使用标签时，才会执行：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">href</span>=<span class="string">&quot;./nextpage.js&quot;</span> <span class="attr">as</span>=<span class="string">&quot;script&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="基于-JS-的预加载"><a href="#基于-JS-的预加载" class="headerlink" title="基于 JS 的预加载"></a>基于 JS 的预加载</h6><p>可以使用一些 JavaScript 中的功能来“巧妙”地进行预加载。</p><p>例如图片：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">&#x27;/static/img/prefetch.jpg&#x27;</span></span><br></pre></td></tr></table></figure><p>上述代码会触发浏览器加载图片，然后等到用户需要浏览时，再将其插入到页面即可。</p><p>对于 JavaScript 和 CSS 可以动态添加 <code>&lt;script&gt;</code> 和 <code>&lt;link&gt;</code> 标签，不过要注意它们只有在添加到页面时浏览器才会加载（少数老式浏览器上这块表现会不太一样），由于添加到页面后加载完会执行该资源，所以要避免产生不需要的副作用（否则就不是预加载了）</p><h5 id="视频预加载"><a href="#视频预加载" class="headerlink" title="视频预加载"></a>视频预加载</h5><h6 id="为视频添加-preload-属性"><a href="#为视频添加-preload-属性" class="headerlink" title="为视频添加 preload 属性"></a>为视频添加 preload 属性</h6><p>使用 <code>preload</code> 属性可以让浏览器预加载相应的内容：</p><ul><li>none：不预加载视频</li><li>meta：载入元数据（时长、尺寸、文字轨道）</li><li>auto：预加载整个视频</li></ul><p>还可以设置 <code>poster</code> 属性来规定视频下载时或用户点击播放按钮前播放器上显示的图像。</p><p>推荐的方式是设置 <code>poster</code> 与 <code>preload: meta</code>，为用户提供一定的播放预览信息的同时避免过多的预加载流量；</p><h6 id="使用-Preload-Link"><a href="#使用-Preload-Link" class="headerlink" title="使用 Preload Link"></a>使用 Preload Link</h6><p>可以使用：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;preload&quot;</span> <span class="attr">as</span>=<span class="string">&quot;video&quot;</span> <span class="attr">href</span>=<span class="string">&quot;/static/sample.mp4&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>进行资源的预加载</p><h6 id="使用-JS-进行自定义的-Buffer-操作"><a href="#使用-JS-进行自定义的-Buffer-操作" class="headerlink" title="使用 JS 进行自定义的 Buffer 操作"></a>使用 JS 进行自定义的 Buffer 操作</h6><p>可以通过 HTTP <code>Range</code> 请求头来获取开始的一小段视频数据，然后使用 <code>MediaSource</code> API 来进行视频媒体数据的暂存与播放（具体代码查看：<a href="https://alienzhou.com/projects/fe-performance-journey/7-preload/#_2-%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD%EF%BC%89">https://alienzhou.com/projects/fe-performance-journey/7-preload/#_2-%E8%A7%86%E9%A2%91%E9%A2%84%E5%8A%A0%E8%BD%BD）</a></p><h5 id="预加载的策略"><a href="#预加载的策略" class="headerlink" title="预加载的策略"></a>预加载的策略</h5><p>预加载一般都会面临一些矛盾：</p><ul><li>预加载资源过多，可能导致流量消耗过大，占用正常请求的通道；</li><li>预加载资源过少，可能导致覆盖率太低，对于大部分资源用户无法享受到预加载效果。</li></ul><p><strong>quicklink</strong> </p><p><a href="https://github.com/GoogleChromeLabs/quicklink">quicklink</a> 是 GoogleChromeLabs 推出的轻量级库，使用 Resource Hints 进行预加载，对于不支持的浏览器会回退到 XHR 模式；核心就是：当链接进入到视口后，会对其进行预加载。</p><p><strong>Guess.js</strong> </p><p><a href="https://github.com/guess-js/guess">Guess.js</a> 则是一个更为完备的工具包。它会结合前端访问与打点的数据进行统计，甚至应用一些机器学习的模型，来提供一个更精细化、更准确的预加载策略。</p><h3 id="重绘重排"><a href="#重绘重排" class="headerlink" title="重绘重排"></a>重绘重排</h3><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4><p>在页面的生命周期中，网页生成时至少会 <strong>渲染</strong> 一次，在用户访问的过程中，还会不断触发 <strong>重排(reflow)</strong> 和 **重绘(repaint)**，而重绘和重排都会影响性能。</p><p><strong>重绘不一定导致重排，但重排一定会导致重绘</strong>。</p><h4 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h4><p>当 DOM 的变化影响了元素的集合信息（位置、尺寸和大小），浏览器需要重新计算元素的几何属性，以安放在页面的正确位置，此过程叫重排（也叫回流），也就是重新生成布局，重新排列元素。</p><p>触发条件：</p><ul><li>页面初始渲染，开销最大的一次渲染</li><li>添加删除可见的 DOM 元素</li><li>改变元素位置</li><li>改变元素尺寸，如：边距、填充、边框、宽度和高度等</li><li>改变元素内容，如：文字数量、图片大小等</li><li>改变元素字体大小</li><li>改变浏览器窗口尺寸，如：resize 事件发生时</li><li>激活 CSS 伪类</li><li>设置 style 属性的值</li><li>查询某些属性或调用某些方法，如：offsetWidth、offsetHeight、getComputedStyle()、currentStyle() 等</li></ul><p>常见的引起重排的属性和方法：</p><ul><li>width、height、margin、padding</li><li>display、border-width、border、position</li><li>overflow、font-size、vertical-align、min-height</li><li>clientWidth、clientWidth、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollTo()、getComputedStyle()、getBoundingClientRect()、scrollIntoViewIfNeeded()</li></ul><p>影响范围：</p><p>由于浏览器渲染界面是基于流式布局模型的，所以触发重排时会对周围 DOM 重新排列：</p><ul><li>全局范围：从根节点 html 开始对整个渲染树进行重新布局</li><li>局部范围：对渲染树的某一部分或某一个渲染对象进行重新布局</li></ul><h4 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h4><p>当一个元素的外观发生改变，但没有改变布局，重新把元素外观绘制出来的过程，叫做重绘。</p><p>常见的引起重绘的属性：</p><ul><li>color、border-style、visibility、background</li><li>background-size、background-image、background-position、background-reqeat</li><li>outline-color、outline、outline-style、outline-width</li><li>text-decoration、border-radius、box-shadow</li></ul><h4 id="优化建议"><a href="#优化建议" class="headerlink" title="优化建议"></a>优化建议</h4><p>减小重排范围：</p><ul><li>尽可能在低层级的 DOM 节点上触发重排，而不是全局范围；</li><li>尽量不要使用 table 布局，很小的改动都会造成整个 table 的重新布局，在必须要使用的情况下可以设置 <code>table-layout: auto</code> 或者 <code>table-layout: fixed</code> 使 table 一行一行的渲染来限制 reflow 的影响范围；</li></ul><p>减少重排次数：</p><ul><li>不要频繁的操作样式，要修改类名而不是修改样式；</li><li>DOM 的多个读操作（或者写操作）应该放在一起，不要混杂着使用；</li><li>使 DOM 离线，也就是不在当前的 DOM 树上做修改：<ul><li>使用 <code>display: none</code>，元素将不在 DOM 树中，在其中的操作也不会触发重绘重排，之后通过 <code>display</code> 属性显示，可以达到减少重绘重排次数的目的；另外，<code>visibility: hidden</code> 的元素只会触发重绘；</li><li>通过 <code>documentFragment</code> 创建一个 DOM 碎片进行批量操作，再添加到文档中，这样只会触发一次重排；</li><li>复制节点在副本上进行操作；</li></ul></li><li>使用 absolute 或 fixed 脱离文档流：使用绝对对位会使改元素单独成为渲染树中 body 的一个子元素，重排开销较小，不会给其他节点造成较大影响；</li><li>优化动画：<ul><li>可以将动画效果应用到 <code>position</code> 属性为 <code>absolute</code> 或 <code>fixed</code> 的元素上来减少对其他元素的影响；</li><li>启用 GPU 加速：包括 Canvas2D、布局合成、CSS3 转换(transitions)、CSS3 3D变换(transforms)、WebGL 和 视频(video)；</li></ul></li></ul><h4 id="查看页面渲染时间"><a href="#查看页面渲染时间" class="headerlink" title="查看页面渲染时间"></a>查看页面渲染时间</h4><p>打开开发者工具，点击 Performance 选项卡中左上角的小圆点，点击刷新页面会录制整个页面加载的时间的分配情况：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220303220841426.png" class title="页面渲染时间"><ul><li>蓝色：网络通信和HTML解析</li><li>黄色：JavaScript执行</li><li>紫色：样式计算和布局，即重排</li><li>绿色：重绘</li></ul><p>点击 Event Log：单独勾选 Loading 项会显示 html 和 css 的加载时间：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220303221208169.png" class title="Event Log"><h3 id="白屏时间"><a href="#白屏时间" class="headerlink" title="白屏时间"></a>白屏时间</h3><p>白屏时间指用户点击一个链接或打开浏览器输入 URL 地址后，从屏幕空白到显示第一个画面的时间。</p><blockquote><p>白屏时间的长短将会直接影响用户对该网站的第一印象。</p></blockquote><h4 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h4><ol><li>DNS Lookup：即浏览器从 DNS 服务器中进行域名查询；浏览器会先对页面进行域名解析，获取到服务器的 IP 地址后，进而和服务器进行通信；</li><li>建立 TCP 请求连接：基于 TCP/IP 协议，通过三次握手建立连接，并提供可靠的数据传输服务；</li><li>服务器端请求处理响应；</li><li>客户端下载解析渲染显示页面；</li></ol><h4 id="白屏性能优化"><a href="#白屏性能优化" class="headerlink" title="白屏性能优化"></a>白屏性能优化</h4><p>其实就是针对白屏过程，在每一个步骤做相应的性能优化措施</p><h3 id="图片加载"><a href="#图片加载" class="headerlink" title="图片加载"></a>图片加载</h3><p>图片加载面临的问题：</p><ol><li>启动页面时加载过多图片；</li><li>部分图片体积过大；</li></ol><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><ol><li>判断图片是否是首屏内图片</li></ol><p>可以通过 getBoundingClientRect 方法，获取到图片的位置信息，判断其是否在 viewport 内部：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inViewport = <span class="function"><span class="params">el</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> rect = el.getBoundingClientRect()</span><br><span class="line">  <span class="keyword">return</span> rect.top &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; rect.bottom &lt; <span class="built_in">window</span>.innerHeight</span><br><span class="line">  &amp;&amp; rect.left &gt; <span class="number">0</span></span><br><span class="line">  &amp;&amp; rect.right &lt; <span class="built_in">window</span>.innerWidth</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但上述方法的前提是元素插入到了 DOM 树中才可以进行判断，另一种方式：</p><p>使用 Vue 中的自定义指令 <code>v-img</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promises = [] <span class="comment">// 用来存储优先加载的图片  </span></span><br><span class="line">Vue.directive(<span class="string">&#x27;img&#x27;</span>, &#123;</span><br><span class="line">  bind (el, binding, vnode) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span> (!defer) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  inserted (el, binding, vnode) &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123; defer &#125; = binding.value</span><br><span class="line">    <span class="keyword">if</span> (!defer) <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> (inViewport(el)) &#123;</span><br><span class="line">      promises.push(update(el, binding, vnode))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Vue.nextTick(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">Promise</span>.all(promises)</span><br><span class="line">          .then(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">          promises.length = <span class="number">0</span></span><br><span class="line">          update(el, binding, vnode)</span><br><span class="line">        &#125;).catch(<span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ol start="2"><li><p>图片体积过大，导致下载时间过长，可以在保证一定清晰度的情况下尽量使用体积较小的图片：</p><blockquote><p>一张 <code>100px * 100px</code> 像素的图片，其包含该 <code>100 * 100 = 10000</code> 个像素点，而每个像素点通过 <code>RGBA</code> 颜色值进行存储，<code>R\G\B\A</code> 每个色道都有 0~255 个取值，也就是 2^8 = 256。正好是 8 位 1byte。而每个像素点有四个色道，每个像素点需要 4bytes。因此该图片体积为：<code>10000 * 4bytes = 40000bytes = 39KB</code>。</p></blockquote><ul><li>减少单位像素所需要的字节数</li><li>减少一张图片的总像素个数</li></ul></li></ol><h4 id="总结-5"><a href="#总结-5" class="headerlink" title="总结"></a>总结</h4><ol><li>首屏图片优先加载，等首屏图片加载完全后再去加载非首屏图片；</li><li>对大部分图片，特别是轮播广告中的图片进行按设备尺寸裁剪，减少图片体积，减少网络开销，加快下载速率。</li></ol><h3 id="动画性能"><a href="#动画性能" class="headerlink" title="动画性能"></a>动画性能</h3><h4 id="使用-CSS3-tranform"><a href="#使用-CSS3-tranform" class="headerlink" title="使用 CSS3 tranform"></a>使用 CSS3 tranform</h4><p>CSS3 的 tranform 可以旋转、缩放、倾斜，或者上传给定的元素，若属性的值不是 none，则会创建一个堆叠上下文。</p><p>示例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 对应图1 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">height</span>: <span class="number">100px</span>; <span class="attribute">transition</span>: height <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">height</span>: <span class="number">200px</span>; &#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">/* 对应图2 */</span></span><br><span class="line"><span class="selector-tag">div</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">0.5</span>); <span class="attribute">transition</span>: transform <span class="number">1s</span> linear; &#125;</span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:hover</span> &#123; <span class="attribute">transform</span>: <span class="built_in">scale</span>(<span class="number">1.0</span>); &#125;</span><br></pre></td></tr></table></figure><p>一个 height 从 100px 到 200px 的动画按如下流程图执行各种操作（橙色的比较耗时，绿色的比较快速）：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webp.webp" class title="图1"><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/webp-16463188358882.webp" class title="图2"><p>因为每一帧的变化浏览器都在进行布局、绘制、把新的位图交给 GPU 内存，而将位图加载到 GPU 内存中是相对耗时的操作，GPU 在如下方面很快：</p><ul><li>绘制位图到屏幕上</li><li>可不断的绘制相同的位图</li><li>将同一位图进行位移、旋转、缩放</li></ul><h4 id="层的引入"><a href="#层的引入" class="headerlink" title="层的引入"></a>层的引入</h4><p>以下会引起 Chrome 创建层：</p><ul><li>进行 3D 或者透视变换的 CSS 属性</li><li>使用硬件加速视频解码的 <code>&lt;video&gt;</code> 元素</li><li>具有 3D（WebGL）上下文或者硬件加速的 2D 上下文的 <code>&lt;canvas&gt;</code> 元素</li><li>组合型插件（即 Flash）</li><li>具有有 CSS 透明度动画或者使用动画式 Webkit 变换的元素</li><li>具有硬件加速的 CSS 滤镜的元素</li><li>子元素中存在具有组合层的元素的元素（就是存在具有自己的层的子元素的元素）</li><li>同级元素中有 Z 索引比其小的元素，而且该 Z 索引比较小的元素具有组合层（就是在组合层之上进行渲染的元素）</li></ul><p>提升为合成层的好处：</p><ol><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快</li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ol><p>提升合成层的方式：</p><ol><li>使用 CSS 的 will-change 属性；</li><li>使用一个 3D transform 属性：<code>transofrm: translateZ(0)</code>；</li></ol><h4 id="网页动画的渲染"><a href="#网页动画的渲染" class="headerlink" title="网页动画的渲染"></a>网页动画的渲染</h4><p>有一些 JavaScript 方法可以调节重新渲染，大幅提高网页性能：</p><ol><li><code>window.requestAnimationFrame()</code>：可以将某些代码放到下一次重新渲染时执行；</li><li><code>window.requestIdleCallback()</code>：也可以用来调节重新渲染，指定只有在下一帧的末尾有空闲时间才会执行回调函数，否则就继续向下一个空闲时间推迟，第二个参数可以用来在设定的毫秒内未执行后强制执行。</li></ol><h3 id="渲染合成层"><a href="#渲染合成层" class="headerlink" title="渲染合成层"></a>渲染合成层</h3><h4 id="形成条件"><a href="#形成条件" class="headerlink" title="形成条件"></a>形成条件</h4><ul><li>3D 或透视变换(perspective transform) CSS 属性</li><li>使用加速视频解码的 <code>&lt;video&gt;</code> 元素 拥有 3D</li><li>(WebGL) 上下文或加速的 2D 上下文的 <code>&lt;canvas&gt;</code> 元素</li><li>混合插件(如 Flash)</li><li>对自己的 opacity 做 CSS动画或使用一个动画变换的元素</li><li>拥有加速 CSS 过滤器的元素</li><li>元素有一个包含复合层的后代节点(换句话说，就是一个元素拥有一个子元素，该子元素在自己的层里)</li><li>元素有一个z-index较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul><li>合成层的位图，会交由 GPU 合成，比 CPU 处理要快<ul><li>仅仅只是合成的处理（把绘图上下文的位图输出进行组合）需要用到GPU，生成合成层的位图处理（绘图上下文的工作）是需要CPU</li></ul></li><li>当需要 repaint 时，只需要 repaint 本身，不会影响到其他的层</li><li>对于 transform 和 opacity 效果，不会触发 layout 和 paint</li></ul><blockquote><p>一般一个元素开启硬件加速后会变成合成层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能</p></blockquote><h4 id="引发问题"><a href="#引发问题" class="headerlink" title="引发问题"></a>引发问题</h4><ol><li>合成层占用内存问题</li><li>层爆炸</li></ol><p>解决：让一些不需要成为合成层的元素回归到普通渲染层，也就是取消上面的形成条件。</p><h2 id="工程化"><a href="#工程化" class="headerlink" title="工程化"></a>工程化</h2><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><h4 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h4><p>模块：将一个复杂的程序依据一定的规则（规范）封装成几个块（文件），并进行组合在一起，块的内部数据与实现是私有的，只是向外部暴露一些接口（方法）与外部其他模块通信</p><p>进化过程：</p><ul><li>全局 function 模式：将不同的功能封装成不同的全局函数；<ul><li>缺点：污染全局命名空间，容易引起命名冲突或数据不安全；</li></ul></li><li>namespace 模式：在 function 模式下进行简单的对象封装，减少了全局变量，解决命名冲突；<ul><li>缺点：会暴露所有模块成员，内部状态可以被外部改写；</li></ul></li><li>IIFE 模式：匿名函数子调用（闭包），使数据私有化，只能通过暴露的方法操作其中的数据；</li><li>IIFE 模式增强：引入依赖，保证了模块的独立性且使得模块之间的依赖关系变得明显。</li></ul><p>好处：</p><ul><li>避免命名冲突（减少命名空间污染）</li><li>更好的分离，按需加载</li><li>高复用性和高维护性</li></ul><p>多个模块出现的问题：</p><ol><li>请求过多</li><li>依赖模糊</li><li>难以维护</li></ol><h4 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h4><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>Node 应用有模块构成，采用 CommonJS 模块规范，每个文件就是一个模块，在一个文件里面定义的变量、函数、类都是私有的，对其他文件不可见。</p><p>在服务器端，模块的加载时运行时同步加载的；在浏览器端，模块需要提前编译打包处理。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>所有代码都运行在模块作用域，不会污染全局作用域；</li><li>模块可以多次加载，但只会在第一次加载时运行一次，之后在加载会直接读取缓存结果；</li><li>模块加载的顺序，按照其在代码中出现的顺序</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 暴露模块</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;&#125;</span><br><span class="line"><span class="built_in">exports</span>.xxx = value</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="built_in">require</span>(xxx)</span><br><span class="line"><span class="comment">// xxx：第三方模块则为模块名，自定义模块则为文件路径</span></span><br></pre></td></tr></table></figure><p>CommonJS 规范规定，每个模块内部，module 变量代表当前模块（值为一个对象），它的 exports 属性（即 module.exports）是对外的接口。<strong>加载某个模块，其实是加载该模块的 module.exports 属性</strong>。</p><p><code>require</code> 命令用于加载模块，读入并执行一个 JavaScript 文件，然后返回该模块的 exports 对象。</p><h5 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h5><p>输入的是被输出值的拷贝，一旦输出一个值，模块内部的变化就不会影响到这个值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="number">3</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">incCounter</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  counter++</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">counter</span>: counter,</span><br><span class="line">  <span class="attr">incCounter</span>: incCounter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">var</span> counter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).counter</span><br><span class="line"><span class="keyword">var</span> incCounter = <span class="built_in">require</span>(<span class="string">&#x27;./lib&#x27;</span>).incCounter</span><br><span class="line"><span class="built_in">console</span>.log(counter) <span class="comment">// 3</span></span><br><span class="line">incCounter()</span><br><span class="line"><span class="built_in">console</span>.log(counter) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><h4 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h4><p>CommonJS 规范加载模块是同步的，只有加载完成才可以执行后面的操作。AMD 规范则是非同步加载模块，允许指定回调函数。</p><p>AMD模块定义的方法非常清晰，不会污染全局环境，能够清楚地显示依赖关系，通常使用第三方库 <code>require.js</code>。</p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define([module1, module2], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> 模块</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line"><span class="built_in">require</span>([module1, module2], <span class="function"><span class="keyword">function</span> (<span class="params">m1, m2</span>) </span>&#123;</span><br><span class="line">  使用模块</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD 规范专门用于浏览器端，模块的加载是异步的，模块使用时才会加载，CMD 规范整合了 CommonJS 和 AMD 的特点，通常使用第三方库 <code>sea.js</code>。</p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义没有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">  <span class="built_in">module</span>.exports = value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 定义有依赖的模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span>, <span class="built_in">exports</span>, <span class="built_in">module</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 引入依赖的模块（同步）</span></span><br><span class="line">  <span class="keyword">var</span> module2 = <span class="built_in">require</span>(<span class="string">&#x27;./module2&#x27;</span>)</span><br><span class="line">  <span class="comment">// 引入依赖的模块（异步）</span></span><br><span class="line">  <span class="built_in">require</span>.async(<span class="string">&#x27;./module3&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">m3</span>) </span>&#123;&#125;)</span><br><span class="line">  <span class="comment">// 暴露模块</span></span><br><span class="line">  <span class="built_in">exports</span>.xxx = value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入模块</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span> (<span class="params"><span class="built_in">require</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m1 = <span class="built_in">require</span>(<span class="string">&#x27;./module1&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h4><p>ES6 模块的设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量，通常依赖第三方库：<code>babel</code>、<code>browserify</code>、<code>babel-preser-es2015</code>。</p><h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义模块 math.js</span></span><br><span class="line"><span class="keyword">var</span> basicNum = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> add = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> &#123; basicNum, add &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引用模块</span></span><br><span class="line"><span class="keyword">import</span> &#123; basicNum, add &#125; <span class="keyword">from</span> <span class="string">&#x27;./math&#x27;</span></span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure><h5 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h5><p>ES6 与 CommonJS 模块化的差异：</p><ol><li>CommonJS 输出的是一个值的拷贝，ES6 输出的是值的引用；</li><li>CommonJS 是运行时加载，ES6 是编译时输出接口；</li><li>ES6 模块是动态引用，不会缓存值；</li></ol><h3 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h3><p>可以理解为通过工具“摇”JS 文件，将其中用不到的代码“摇”掉，属于性能优化的范畴。</p><p>支持 tree-shaking 的构建工具有：Rollup、Webpack2、Closure compiler</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>Tree-shaking 的本质是消除无用的 JS 代码，无用代码消除广泛存在于传统的编程语言编译器中，编译器可以判断出哪些代码根部不影响输出，然后消除这些代码，即为 DCE（dead code elmination）。</p><p>Tree-shaking 是 DCE 的一种新的实现，JavaScript 同传统的编程语言不同的是，JavaScript 绝大多数情况需要通过网络进行加载，然后执行，加载的文件越小，整体执行时间更短，所以去除无用代码来减少文件体积，对 JavaScript 来说更有意义。</p><h5 id="DCE"><a href="#DCE" class="headerlink" title="DCE"></a>DCE</h5><p>Dead Code 的特征：</p><ol><li>代码不会被执行，不可到达</li><li>代码执行的结果不会被用到</li><li>代码只会影响死变量（只写不读）</li></ol><p>传统编译型的语言中，都是由编译器将 Dead Code 从 AST（抽象语法树）中删除，JS 中是由代码压缩优化工具 uglify 完成。</p><h4 id="总结-6"><a href="#总结-6" class="headerlink" title="总结"></a>总结</h4><p>三大工具的 Tree-shaking 对于无用代码，无用模块的消除，都是有限的，有条件的。</p><p>其中 closure compiler 是效果最好的，但与日常的基于 node 的开发流很难兼容。</p><h3 id="Uglify-压缩-JS"><a href="#Uglify-压缩-JS" class="headerlink" title="Uglify 压缩 JS"></a>Uglify 压缩 JS</h3><h4 id="AST"><a href="#AST" class="headerlink" title="AST"></a>AST</h4><p>抽象语法树，AST（Abstract Syntax Tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。树上的每个节点都并表示源代码中的一种结构，抽象的原因是因为语法并不会表示出真实语法中出现的每个细节。</p><p>示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">foo = <span class="string">&#x27;hello AgoniLay&#x27;</span></span><br><span class="line"><span class="comment">/* AST：</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment">|  assign(=) |</span></span><br><span class="line"><span class="comment">+------------+</span></span><br><span class="line"><span class="comment"> /\</span></span><br><span class="line"><span class="comment">  +-----+ +----------------+</span></span><br><span class="line"><span class="comment">  | foo | | Hello AgoniLay |</span></span><br><span class="line"><span class="comment">  +-----+    +----------------+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (foo === <span class="literal">true</span>) &#123;</span><br><span class="line">  bar = <span class="string">&#x27;Hello AgoniLay&#x27;</span></span><br><span class="line">  alert(bar)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* AST：</span></span><br><span class="line"><span class="comment">+------+</span></span><br><span class="line"><span class="comment">|  if  |</span></span><br><span class="line"><span class="comment">+------+</span></span><br><span class="line"><span class="comment">   /   \</span></span><br><span class="line"><span class="comment">+------------++-----------+</span></span><br><span class="line"><span class="comment">  | equal(===) ||  if_body  |</span></span><br><span class="line"><span class="comment">+------------+    +-----------+</span></span><br><span class="line"><span class="comment">/      //  \</span></span><br><span class="line"><span class="comment">  +-----+ +------+ +-----------+  +---------+</span></span><br><span class="line"><span class="comment">  | foo | | true || assign(=) | | alert() |</span></span><br><span class="line"><span class="comment">  +-----+  +------++-----------+  +---------+</span></span><br><span class="line"><span class="comment">  /\  \</span></span><br><span class="line"><span class="comment">    +-----+ +----------------+   +-----+</span></span><br><span class="line"><span class="comment">  | foo | | Hello AgoniLay || bar |</span></span><br><span class="line"><span class="comment">  +-----+  +----------------++-----+</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>AST是源代码根据其语法结构，省略一些细节，抽象成树形表达。抽象语法树在计算机科学中有很多应用，比如编译器、IDE、压缩代码、格式化代码等。</p><h4 id="代码压缩原理"><a href="#代码压缩原理" class="headerlink" title="代码压缩原理"></a>代码压缩原理</h4><ol><li>将 code 转换成 AST；</li><li>将 AST 进行优化；</li><li>将优化后的 AST 再转化成 code。</li></ol><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220322145325311.png" class title="代码压缩图解"><p>使用 <code>uglify-js@2.x</code>  版本进行代码压缩示例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// npm install uglify-js@2.x</span></span><br><span class="line"><span class="keyword">var</span> UglifyJS = <span class="built_in">require</span>(<span class="string">&#x27;uglify-js&#x27;</span>)</span><br><span class="line"><span class="comment">// 原始代码</span></span><br><span class="line"><span class="keyword">var</span> code = <span class="string">`</span></span><br><span class="line"><span class="string">var a</span></span><br><span class="line"><span class="string">var x = &#123; b: 123 &#125;</span></span><br><span class="line"><span class="string">a = 123</span></span><br><span class="line"><span class="string">delete x`</span></span><br><span class="line"><span class="comment">// 通过 UglifyJS 把代码解析为 AST</span></span><br><span class="line"><span class="keyword">var</span> ast = UglifyJS.parse(code)</span><br><span class="line">ast.figure_out_scope()</span><br><span class="line"><span class="comment">// 转化为一颗更小的 AST 树</span></span><br><span class="line"><span class="keyword">var</span> compressor = UglifyJS.Compressor()</span><br><span class="line">ast = ast.transform(compressor)</span><br><span class="line"><span class="comment">// 再把 AST 转化为代码</span></span><br><span class="line">code = ast.print_to_string()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(code) <span class="comment">// var a,x=&#123;b:123&#125;;a=123,delete x;</span></span><br></pre></td></tr></table></figure><h4 id="代码压缩规则"><a href="#代码压缩规则" class="headerlink" title="代码压缩规则"></a>代码压缩规则</h4><h5 id="表达式压缩"><a href="#表达式压缩" class="headerlink" title="表达式压缩"></a>表达式压缩</h5><p><strong>表达式预计算</strong>：</p><p>将可预先计算的表达式替换成其计算结果，同时要比较原来表达式以及生成后的结果的大小，取短值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">var</span> val1 = <span class="number">1</span> + <span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> val2 = <span class="number">1</span> / <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">var</span> val1 = <span class="number">2</span></span><br><span class="line"><span class="keyword">var</span> val2 = <span class="number">1</span> / <span class="number">3</span> <span class="comment">// 计算出来的值 0.333333333333~ 比 1/3 要长，所以不取预计算的结果</span></span><br></pre></td></tr></table></figure><p><strong>优化 true 和 false</strong>：</p><p>正常情况下会把：</p><ul><li><code>true</code> 变为 <code>!0</code>，节省 2 个字符；</li><li><code>false</code> 变为 <code>!1</code>，节省 3 个字符。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">var</span> val1 = <span class="literal">true</span></span><br><span class="line"><span class="keyword">var</span> val2 = <span class="literal">false</span></span><br><span class="line"><span class="literal">true</span> == A</span><br><span class="line"><span class="literal">false</span> == A</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">var</span> val1 = !<span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> val2 = !<span class="number">1</span></span><br><span class="line"><span class="number">1</span> == A</span><br><span class="line"><span class="number">0</span> == A</span><br></pre></td></tr></table></figure><blockquote><p>在参与 <code>==</code> 或者 <code>!=</code> 计算时，可以把 <code>true</code> 变为 1，<code>false</code> 变为 0.</p></blockquote><p><strong>根据 &amp;&amp; || 短路特性压缩</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="literal">true</span> &amp;&amp; A()</span><br><span class="line"><span class="literal">false</span> &amp;&amp; A()</span><br><span class="line"><span class="literal">true</span> || A()</span><br><span class="line"><span class="literal">false</span> || A()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">A()<span class="comment">// 返回 &amp;&amp; 后的值</span></span><br><span class="line">!<span class="number">1</span><span class="comment">// 返回 &amp;&amp; 前的值</span></span><br><span class="line">!<span class="number">0</span><span class="comment">// 返回 || 前的值</span></span><br><span class="line">A()<span class="comment">// 返回 &amp;&amp; 后的值</span></span><br></pre></td></tr></table></figure><h5 id="运算符缩短"><a href="#运算符缩短" class="headerlink" title="运算符缩短"></a>运算符缩短</h5><p><strong>!== === 缩短</strong>：</p><p>对于二元运算符 <code>===</code> 以及 <code>!==</code>，其两个操作数都是 string 类型或者布尔类型的，可以缩短成 <code>==</code> 以及 <code>!=</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="string">&#x27;object&#x27;</span> === <span class="keyword">typeof</span> A</span><br><span class="line">(a, b, <span class="literal">true</span>) !== b <span class="keyword">instanceof</span> B</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="string">&#x27;object&#x27;</span> == <span class="keyword">typeof</span> A</span><br><span class="line">(a, b, <span class="literal">true</span>) != b <span class="keyword">instanceof</span> B</span><br></pre></td></tr></table></figure><p><strong>赋值表达式缩短</strong>：</p><p>详细规则：</p><ol><li>必须是 <code>=</code> 赋值语句</li><li><code>=</code> 左侧只能是变量，不能是表达式等</li><li><code>=</code> 右侧必须为二元操作表达式，并且符号是 <code>[&#39;+&#39;, &#39;-&#39;, &#39;*&#39;, &#39;/&#39;, &#39;%&#39;, &#39;&gt;&gt;&#39;, &#39;&lt;&lt;&#39;, &#39;&gt;&gt;&gt;&#39;, &#39;|&#39;, &#39;^&#39;, &#39;&amp;&#39;]</code> 中的元素</li><li><code>=</code> 右侧的二元表达式的第一个操作数必须跟 <code>=</code> 号左侧的变量一致</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line">a = a + b</span><br><span class="line">c = c &gt;&gt;&gt; d</span><br><span class="line">a = b + c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">a += b</span><br><span class="line">c &gt;&gt;&gt;= d</span><br><span class="line">a = b + c <span class="comment">// 无法进行赋值表达式压缩</span></span><br></pre></td></tr></table></figure><p><strong>! 的压缩</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line">!(a &gt;= b)</span><br><span class="line">!!!a</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">a &lt; b</span><br><span class="line">!a</span><br></pre></td></tr></table></figure><h5 id="去除无用声明"><a href="#去除无用声明" class="headerlink" title="去除无用声明"></a>去除无用声明</h5><p><strong>去除重复的指示性字符串</strong>：</p><p>对于嵌套的作用域使用了同样的指示性字符串，子作用域可以省略：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  &#x27;use strict&#x27;</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &#x27;use strict&#x27; 可省略</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>去除未使用的函数参数</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params">a, b<span class="comment">/*, c */</span></span>) </span>&#123; <span class="comment">// 此处 c 并未用到，可以去除</span></span><br><span class="line">  b++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>去除函数表达式冗余的函数名</strong>：</p><p>对于一个函数表达式，如果其函数体没有引用自身名字递归调用，那么此函数名可以去除，使之变为匿名函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">A</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  A() <span class="comment">// 此处递归调用，无法省略函数名</span></span><br><span class="line">&#125;)</span><br><span class="line">(<span class="function"><span class="keyword">function</span> /* <span class="title">B</span> */ (<span class="params"></span>) </span>&#123; <span class="comment">// 此处 B 函数名可以省略</span></span><br><span class="line">  c++</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>去除没用的块</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">while</span> (f) &#123;</span><br><span class="line">  &#123; A() &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (f) &#123;</span><br><span class="line">  &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">while</span> (f)</span><br><span class="line">  A()</span><br><span class="line"><span class="keyword">while</span> (f)</span><br><span class="line">  ;</span><br><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">  B()</span><br></pre></td></tr></table></figure><p><strong>去除未使用的 break</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (A) &#123;</span><br><span class="line">  <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">    <span class="comment">/* break */</span> <span class="comment">// 最后一项的 break 可以忽略，但如果带标签则不可忽略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>去除没有引用的 label</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="attr">label1</span>: <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="attr">label2</span>: <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">break</span> label2</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="attr">label2</span>: <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">break</span> label2</span><br></pre></td></tr></table></figure><p><strong>去除无用的 toString 函数调用</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line">(<span class="keyword">typeof</span> A).toString()</span><br><span class="line">(<span class="string">&#x27;A&#x27;</span> + <span class="string">&#x27;B&#x27;</span>).toString()</span><br><span class="line"><span class="keyword">var</span> expr = <span class="string">&#x27;str&#x27;</span>.toString()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">(<span class="keyword">typeof</span> A)</span><br><span class="line"><span class="string">&#x27;AB&#x27;</span></span><br><span class="line"><span class="keyword">var</span> expr = <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="while-压缩"><a href="#while-压缩" class="headerlink" title="while 压缩"></a>while 压缩</h5><ul><li>去除根本不会执行的 while 循环；</li><li><code>while(true)</code> 变为 <code>for(;;)</code>，可以缩短 4 个字符</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  A()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">for</span> (;;)</span><br><span class="line">  B()</span><br></pre></td></tr></table></figure><h5 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line">!cond ? yes() : no()</span><br><span class="line"><span class="literal">true</span> ? yes() : no()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">cond ? no() : yes()</span><br><span class="line">yes()</span><br></pre></td></tr></table></figure><h5 id="语句块压缩"><a href="#语句块压缩" class="headerlink" title="语句块压缩"></a>语句块压缩</h5><p><strong>连续的表达式语句可以合并成一个逗号表达式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  B()</span><br><span class="line">  C()</span><br><span class="line">  d = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  B(), C(), d = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>多个 var 声明可以压缩成一个</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">var</span> a</span><br><span class="line"><span class="keyword">var</span> b</span><br><span class="line"><span class="keyword">var</span> c</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">var</span> a, b, c</span><br></pre></td></tr></table></figure><p><strong>return 语句之后的非常量声明以及非函数声明语句可以去除</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  expr += <span class="number">1</span></span><br><span class="line">  a = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">B</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>throw、break、continue 之后的语句也适用于此规则。</p></blockquote><p><strong>合并块末尾的 return 语句及其前面的多条表达式语句</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  B()</span><br><span class="line">  C()</span><br><span class="line">  <span class="keyword">return</span> D()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> B(), C(), D()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="if-分支优化"><a href="#if-分支优化" class="headerlink" title="if 分支优化"></a>if 分支优化</h5><p><strong>去除没用的 if/else 分支</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  A()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  C()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  D()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">A()</span><br><span class="line">D()</span><br></pre></td></tr></table></figure><p><strong>去除空的 if/else 分支</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  D()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">if</span> (A)</span><br><span class="line">  B()</span><br><span class="line"><span class="keyword">if</span> (!C)</span><br><span class="line">  D()</span><br></pre></td></tr></table></figure><p><strong>尝试反转 if/else 分支</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!C) &#123;</span><br><span class="line">  A()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">if</span> (C)</span><br><span class="line">  B()</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  A()</span><br></pre></td></tr></table></figure><p><strong>可合并情况</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  <span class="keyword">if</span> (B) &#123;</span><br><span class="line">    C()</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">if</span> (A &amp;&amp; B)</span><br><span class="line">  C()</span><br></pre></td></tr></table></figure><p><strong>如果 if 最后一个语句是跳出控制语句，则可以将 else 块的内容提到 else 外</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  B()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  B()</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">C()</span><br></pre></td></tr></table></figure><p><strong>如果 if/else 中都是只有一句 return 语句，可以进行合并</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  <span class="keyword">return</span> B()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> C()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line"><span class="keyword">return</span> A ? B() : C()</span><br></pre></td></tr></table></figure><p><strong>如果if/else其中一个块为空，另一个块只有一条语句，则可以化成 || 或者 &amp;&amp; 的表达式</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 压缩前</span></span><br><span class="line"><span class="keyword">if</span> (A) &#123;</span><br><span class="line">  B()</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (C) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  D()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 压缩后</span></span><br><span class="line">A &amp;&amp; B()</span><br><span class="line">C || D()</span><br></pre></td></tr></table></figure><blockquote><p>源码可以参考此处：<a href="http://rapheal.sinaapp.com/2014/05/22/uglifyjs-squeeze/">http://rapheal.sinaapp.com/2014/05/22/uglifyjs-squeeze/</a></p></blockquote><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><h4 id="Babel-的处理流程"><a href="#Babel-的处理流程" class="headerlink" title="Babel 的处理流程"></a>Babel 的处理流程</h4><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220322164012132.png" class title="Babel 处理流程"><p>源码解析（Parsing），包含两个步骤：</p><ul><li>词法解析（Lexical Analysis）：将字符串形式的代码转换为 Tokens（令牌，可以视作是一些词法片段组成的数组）；</li><li>语法解析（Syntactic Analysis）：解析器将 Tokens 转换为 AST。</li></ul><blockquote><p>AST 是 Babel 转译的核心数据结构，后续的操作都依赖于 AST。</p></blockquote><p>接着进行转换（Transform），转换阶段会对 AST 进行遍历，在这个过程中对节点进行增删改查，如语法转换、代码压缩。</p><p>最后阶段还是要把 AST 转换回字符串形式的 JavaScript，同时生成 Source Map</p><h4 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h4><p>Babel 的核心非常小，大部分功能都是通过插件扩展实现的。</p><h5 id="核心"><a href="#核心" class="headerlink" title="核心"></a>核心</h5><p><code>@babel/core</code> 就是微内核架构中的内核，对于 Babel 来说，此内核的任务是：</p><ul><li>加载和处理配置</li><li>加载插件</li><li>调用 <code>Parser</code> 进行语法解析，生成 AST</li><li>调用 <code>Traverser</code> 遍历 AST，并使用访问者模式应用插件对 AST 进行转换</li><li>生成代码，包括 SourceMap 转换和源代码生成</li></ul><h5 id="核心周边支撑"><a href="#核心周边支撑" class="headerlink" title="核心周边支撑"></a>核心周边支撑</h5><ul><li>Parser（<code>@babel/parser</code>）：将源代码解析为 AST；</li><li>Traverser（<code>@babel/traverse</code>）：实现了访问者模式；</li><li>Generator（<code>@babel/generator</code>）：将 AST 转换为源代码，支持 SourceMap</li></ul><h3 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h3><h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ul><li>loader：能转换各类资源，并处理成对应模块的加载器，loader 间可以串行使用；</li><li>chunk：code splitting  后的产物，也就是按需加载的分块，装载了不同的 module。</li></ul><h4 id="流程总览"><a href="#流程总览" class="headerlink" title="流程总览"></a>流程总览</h4><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/TB1GVGFNXXXXXaTapXXXXXXXXXX-4436-4244.jpg" class title="webpack 流程总览"> <h4 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h4><p>Webpack 的插件机制依赖于一个核心的库，<strong>Tapable</strong>：是一个类似于 nodejs 的 EventEmitter 的库，主要是控制钩子函数的发布于订阅；Tapable 提供的 hook 机制比较全面，分为哦同步和异步两个大类（异步中又分为异步并行和异步单行），根据事件执行的终止条件，衍生出 Bail/Waterfall/Loop 类型。</p><h1 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h1><h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><h3 id="数据绑定原理"><a href="#数据绑定原理" class="headerlink" title="数据绑定原理"></a>数据绑定原理</h3><h4 id="数据初始化"><a href="#数据初始化" class="headerlink" title="数据初始化"></a>数据初始化</h4><p>Vue 源码是从 <code>_init</code> 初始化开始的，这个过程包括配置选项的合并，数据的检测代理，最后进行示例的挂载。</p><p>在示例挂载前还有一个重要的过程——数据的初始化（<code>initState(vm)</code>）：是对数据进行响应式设计的过程，针对 <code>props, nethods, data, computed, watch</code> 做数据的初始化处理，并将他们转换成响应式对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initState</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  vm._watchers = []</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options</span><br><span class="line">  <span class="comment">// 初始化 props</span></span><br><span class="line">  <span class="keyword">if</span> (opts.props) &#123; initProps(vm, opts.props) &#125;</span><br><span class="line">  <span class="comment">// 初始化 methods</span></span><br><span class="line">  <span class="keyword">if</span> (opts.methods) &#123; initMethods(vm, opts.method) &#125;</span><br><span class="line">  <span class="comment">// 初始化 data</span></span><br><span class="line">  <span class="keyword">if</span> (opts.data) &#123;</span><br><span class="line">    initData(vm)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 如果没有定义 data，则创建一个空对象，并设置为响应式</span></span><br><span class="line">    observe(vm._data = &#123;&#125;, <span class="literal">true</span> <span class="comment">/* asROotData */</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 初始化 computed</span></span><br><span class="line">  <span class="keyword">if</span> (opts.computed) &#123; initComputed(vm, opts.computed) &#125;</span><br><span class="line">  <span class="comment">// 初始化 watch</span></span><br><span class="line">  <span class="keyword">if</span> (opts.watch &amp;&amp; opts.watch !== nativeWatch) &#123;</span><br><span class="line">    initWatch(vm, opts.watch)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initProps"><a href="#initProps" class="headerlink" title="initProps"></a>initProps</h4><p>父组件通过属性的形式将数据传递给子组件，紫钻见通过 <code>props</code> 属性接收父组件传递的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父组件</span></span><br><span class="line"><span class="comment">// &lt;child :test=&quot;test&quot;&gt;&lt;/child&gt;</span></span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="string">&#x27;child&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子组件</span></span><br><span class="line">Vue.component(<span class="string">&#x27;child&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&#x27;&lt;div&gt;&#123;&#123; test &#125;&#125;&lt;/div&gt;&#x27;</span>,</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;test&#x27;</span>]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>父组件优先进行模板编译得到一个 <code>render</code> 函数，在解析过程中遇到子组件的属性，<code>:test=&quot;test&quot;</code> 会被解析成 <code>&#123; attrs: &#123;test: test&#125; &#125;</code> 并作为子组件的 <code>render</code> 函数岑在：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> () &#123; ...c_(<span class="string">&#x27;child&#x27;</span>, &#123; <span class="attr">attr</span>: &#123; <span class="string">&#x27;test&#x27;</span>: test &#125; &#125;) &#125;</span><br></pre></td></tr></table></figure><p>render 解析 VNode 的过程遇到 child 这个子占位符节点，进入创建子组件 VNode 的过程：调用 <code>createComponent</code>，最终调用 <code>new Vnode</code> 去创建子 VNode，而对于 <code>props</code> 的处理，<code>extractPropsFromVNodeData</code> 会对 <code>attrs</code> 属性进行规范校验后，最后会把校验的结果以 <code>propsData</code> 属性的形式传入 VNode 构造器中。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子组件过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// props 校验</span></span><br><span class="line">  <span class="keyword">var</span> propsData = extractPropsFromVNodeData(data, Ctor, tag)</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 创建子组件 vnode</span></span><br><span class="line">  <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    (<span class="string">&#x27;vue-component-&#x27;</span> + (Ctor.cid) + (name ? (<span class="string">&#x27;-&#x27;</span> + name) : <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; <span class="attr">Ctor</span>: Ctor, <span class="attr">propsData</span>: propsData, <span class="attr">listeners</span>: listeners, <span class="attr">tag</span>: tag, chilren, children &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="props-的命名规范"><a href="#props-的命名规范" class="headerlink" title="props 的命名规范"></a>props 的命名规范</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">extractPropsFromVNodeData</span> (<span class="params">data, Ctor, tag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Ctor 为子类构造器</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">var</span> res = &#123;&#125;</span><br><span class="line">  <span class="comment">// 子组件 props 选项</span></span><br><span class="line">  <span class="keyword">var</span> propOptions = Ctor.options.props</span><br><span class="line">  <span class="comment">// data.attrs 针对编译生成的 render 函数，data.props 针对用户自定义的 render 函数</span></span><br><span class="line">  <span class="keyword">var</span> attrs = data.attrs</span><br><span class="line">  <span class="keyword">var</span> props = data.props</span><br><span class="line">  <span class="keyword">if</span> (isDef(attrs) || isDef(props)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propOptions) &#123;</span><br><span class="line">      <span class="comment">// aB 形式转成 a-b</span></span><br><span class="line">      <span class="keyword">var</span> altKey = <span class="function"><span class="title">hyphenate</span>(<span class="params">key</span>)</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">var</span> keyInLowerCase = key.toLowerCase()</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          key !== keyInLowerCase &amp;&amp;</span><br><span class="line">          attrs &amp;&amp; hasOwn(attrs, keyInLowerCase)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// 警告</span></span><br><span class="line">          ...</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>HTML对大小写是不敏感的，所有的浏览器会把大写字符解释为小写字符，因此在使用 DOM 中的模板时，cameCase（驼峰命名法）的 <code>props</code> 名需要使用其等价的 <code>kebab-case</code>（短横线分隔命名）代替。</p><h5 id="响应式数据-props"><a href="#响应式数据-props" class="headerlink" title="响应式数据 props"></a>响应式数据 props</h5><p>子组件处理 <code>props</code> 的过程，是发生在父组件 <code>_update</code> 阶段，这个阶段是 <code>Vnode</code> 生成真实节点的过程，期间会遇到子 Vnode，调用 <code>createComponent</code> 去实例化子组件。实例化子组件的过程又回到了 <code>_init</code> 初始化，经历选项的合并，针对 <code>props</code> 选项，最终会统一成 <code>&#123; props: &#123; test: &#123; type:null &#125;&#125;&#125;</code> 的写法，接着会调用 <code>initProps</code>：将组件的 <code>props</code> 数据设置为响应式数据。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initProps</span> (<span class="params">vm, propsOptions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> propsData = vm.$options.propsData || &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> loop = <span class="function"><span class="keyword">function</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    definePeactive(props, key, value, cb)</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      proxy(vm, <span class="string">&#x27;_props&#x27;</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 遍历 props，执行 loop 设置为响应式数据</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> propsOptions) loop(key)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中 <code>proxy(vm, &#39;_props&#39;, key)</code> 为 <code>props</code> 做了一层代理，用户通过 <code>vm.XXX</code> 可以代理访问到 <code>vm._props</code> 上的值。</p><h4 id="initMethods"><a href="#initMethods" class="headerlink" title="initMethods"></a>initMethods</h4><p><code>initMethod</code> 方法和响应式没有任何的关系，实现也相对简单，主要是保证 <code>methods</code> 方法定义必须是函数，且命名不能和 <code>props</code> 重复，最终会将定义的方法都挂载到根实例上:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initMethods</span> (<span class="params">vm, methods</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> methods) &#123;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// method 必须为函数形式</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// methods 方法名 不能和 props 重复</span></span><br><span class="line">      <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 不能以 _ or $. 这些 Vue 保留标志开头</span></span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> vm) &amp;&amp; isReserved(key)) &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接挂载到示例的属性上，可以通过 vm[method] 访问</span></span><br><span class="line">    vm[key] = <span class="keyword">typeof</span> methods[key] !== <span class="string">&#x27;function&#x27;</span> ? noop : bing(methods[key], vm)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="initData"><a href="#initData" class="headerlink" title="initData"></a>initData</h4><p>data 在初始化选项合并时会生成一个函数，只有在执行函数时才会返回真正的数据，所以 <code>initData</code> 方法会先执行拿到组件的 <code>data</code> 数据，并且会对对象每个属性的命名进行校验，保证不能和 <code>props, methods</code> 重复。</p><p>最后的核心方法是 <code>observe</code>，将数据对象标记为响应式对象，并对对象的每个属性进行响应式处理，同时 <code>proxy</code> 会对 data 做一层代理，直接通过 <code>vm.XXX</code> 可以failing访问到 <code>vm._data</code> 上挂载的对象属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initData</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> data = vm.$options.data</span><br><span class="line">  <span class="comment">// 根实例时，data 是一个对象，子组件的 data 是一个函数，其中 getData 会调用函数返回 data 对象</span></span><br><span class="line">  data = vm._data = <span class="keyword">typeof</span> data === <span class="string">&#x27;function&#x27;</span> ? getData(data, vm) : data || &#123;&#125;</span><br><span class="line">  <span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(data)</span><br><span class="line">  <span class="keyword">var</span> props = vm.$options.props</span><br><span class="line">  <span class="keyword">var</span> methods = vm.$options.methods</span><br><span class="line">  <span class="keyword">var</span> i = keys.length</span><br><span class="line">  <span class="keyword">while</span> (i--) &#123;</span><br><span class="line">    <span class="keyword">var</span> key = keys[i]</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// 命名不能和方法重复</span></span><br><span class="line">      <span class="keyword">if</span> (methods &amp;&amp; hasOwn(methods, key)) &#123;</span><br><span class="line">        warn()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 命名不能与 props 重复</span></span><br><span class="line">    <span class="keyword">if</span> (props &amp;&amp; hasOwn(props, key)) &#123;</span><br><span class="line">      warn()</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isReserved(key)) &#123;</span><br><span class="line">      <span class="comment">// 数据代理，用户可直接通过 vm 实例返回 data 数据</span></span><br><span class="line">      proxy(vm, <span class="string">&#x27;_data&#x27;</span>, key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// observe data</span></span><br><span class="line">  observe(data, <span class="literal">true</span> <span class="comment">/* asRootData */</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>observe</code> 具体的行为是将数据对象添加一个不可枚举的属性 <code>__ob__</code>，标志对象是一个响应式对象，并且拿到每个对象的属性值，重写 <code>getter, setter</code> 方法，使得每个属性值都是响应式数据。</p><h4 id="initComputed"><a href="#initComputed" class="headerlink" title="initComputed"></a>initComputed</h4><p><code>initComputed</code> 是 <code>computed</code> 数据的初始化，不同之处在于：</p><ol><li><code>computed</code> 可以是对象，也可以是函数，对象必须有 <code>getter</code> 方法，所以需要进行验证；</li><li>针对 <code>computed</code> 每个属性，要创建一个监听的依赖，也就是需要实例化一个 watcher。</li></ol><p><code>initComputed</code> 也会将每个属性设置设置成响应式的数据，同样的，也会对 <code>computed</code> 的命名做检测，防止与 <code>props, data</code> 冲突。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initComputed</span> (<span class="params">vm, computed</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> computed) &#123;</span><br><span class="line">    <span class="keyword">var</span> userDef = computed[key]</span><br><span class="line">    <span class="keyword">var</span> getter = <span class="keyword">typeof</span> userDef === <span class="string">&#x27;function&#x27;</span> ? userDef : userDef.get</span><br><span class="line">    <span class="comment">// computed 属性为对象时，要保证有 getter 方法</span></span><br><span class="line">    <span class="keyword">if</span> (getter === <span class="literal">null</span>) &#123;</span><br><span class="line">      warn()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isSSR) &#123;</span><br><span class="line">      <span class="comment">// 创建 computed watcher</span></span><br><span class="line">      watchers[key] = <span class="keyword">new</span> Watcher(vm, getter || noop, noop, computedWatcherOptions)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">in</span> vm)) &#123;</span><br><span class="line">      <span class="comment">// 设置为响应式数据</span></span><br><span class="line">      defineComputed(vm, key, userDef)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 不能和 props, data 命名冲突</span></span><br><span class="line">      <span class="keyword">if</span> (key <span class="keyword">in</span> vm.$data) &#123;</span><br><span class="line">        warn()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vm.$options.props &amp;&amp; key <span class="keyword">in</span> vm.$options.props) &#123;</span><br><span class="line">        warn()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="极简响应式系统"><a href="#极简响应式系统" class="headerlink" title="极简响应式系统"></a>极简响应式系统</h4><h5 id="框架搭建"><a href="#框架搭建" class="headerlink" title="框架搭建"></a>框架搭建</h5><p>以 <code>MyVue</code> 作为类响应式框架。模拟 Vue 源码的实现思路，实例化 <code>MyVue</code> 时会传递一个选项配置，精简的代码只有一个 id 挂载元素和一个数据对象 data。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> MyVue(&#123;</span><br><span class="line">  <span class="attr">id</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>myVue.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">options</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.options = options</span><br><span class="line">    <span class="comment">// 数据的初始化</span></span><br><span class="line">    <span class="built_in">this</span>.initData(options)</span><br><span class="line">    <span class="keyword">let</span> el = <span class="built_in">this</span>.options.id</span><br><span class="line">    <span class="comment">// 挂载实例</span></span><br><span class="line">    <span class="built_in">this</span>.$mount(el)</span><br><span class="line">  &#125;</span><br><span class="line">  initData (options) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  $mount (el) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="设置响应式对象-Observer"><a href="#设置响应式对象-Observer" class="headerlink" title="设置响应式对象 - Observer"></a>设置响应式对象 - Observer</h5><p>引入一个 <code>Observer</code> 类，目的是将数据变成响应式对象，利用 <code>Object.defineProperty</code> 对数据的 <code>getter, setter</code> 方法进行改写。在数据读取 <code>getter</code> 阶段进行<strong>依赖的收集</strong>；在数据的修改 <code>setter</code> 阶段，进行<strong>依赖的更新</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  initData (options) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!options.data) <span class="keyword">return</span></span><br><span class="line">    <span class="built_in">this</span>.data = options.data</span><br><span class="line">    <span class="comment">// 将数据重置 getter, setter 方法</span></span><br><span class="line">    <span class="keyword">new</span> Observer(options.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Observer 类的定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.walk(data)</span><br><span class="line">  &#125;</span><br><span class="line">  walk (obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> keys = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">      <span class="comment">// Object.definedProperty 的处理逻辑</span></span><br><span class="line">      defineReactive(obj, keys[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="依赖本身-Watcher"><a href="#依赖本身-Watcher" class="headerlink" title="依赖本身 - Watcher"></a>依赖本身 - Watcher</h5><p>一个 <code>Watcher</code> 实例就是一个依赖，数据不管是在渲染模板时使用还是在用户计算时使用，都可以算作一个炫耀监听的依赖，<code>watcher</code> 中记录着这个依赖监听的状态，以及如何让更新操作的方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 监听的依赖</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  contructor (expOrFn, isRenderWatcher) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    <span class="comment">// Watcher.property.get 的调用会进行状态的更新</span></span><br><span class="line">    <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在渲染数据到真实 <code>DOM</code> 时可以创建 <code>watcher</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyVue</span> </span>&#123;</span><br><span class="line">  $mount (el) &#123;</span><br><span class="line">    <span class="comment">// 直接改写 innerHTML</span></span><br><span class="line">    <span class="keyword">const</span> updateView = <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">let</span> innerHtml = <span class="built_in">document</span>.querySelector(el).innerHTML</span><br><span class="line">      <span class="keyword">let</span> key = innerHtml.match(<span class="regexp">/&#123;(\w+)&#125;/</span>)[<span class="number">1</span>]</span><br><span class="line">      <span class="built_in">document</span>.querySelecter(el).innerHTML = <span class="built_in">this</span>.options.data[key]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">new</span> Watcher(updateView, <span class="literal">true</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="依赖管理-Dep"><a href="#依赖管理-Dep" class="headerlink" title="依赖管理 - Dep"></a>依赖管理 - Dep</h5><p><code>watcher</code> 理解为每个数据需要监听的依赖，那么 <code>Dep</code> 可以理解为对依赖的一种管理：将依赖进行收集，派发依赖进行更新：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uid = <span class="number">0</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dep</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = uid++</span><br><span class="line">    <span class="built_in">this</span>.subs = []</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 依赖收集</span></span><br><span class="line">  depend () &#123;</span><br><span class="line">    <span class="keyword">if</span> (dep.target) &#123;</span><br><span class="line">      <span class="comment">// Deptarget 是当前的 watcher，将当前的依赖推到 subs 中</span></span><br><span class="line">      <span class="built_in">this</span>.subs.push(Dep.target)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 派发更新</span></span><br><span class="line">  notify () &#123;</span><br><span class="line">    <span class="keyword">const</span> subs = <span class="built_in">this</span>.subs.slice()</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = subs.lenght; i &lt; l; i++) &#123;</span><br><span class="line">      <span class="comment">// 遍历 dep 中的依赖，对每个依赖执行更新操作</span></span><br><span class="line">      subs[i].update()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Dep.target = <span class="literal">null</span></span><br></pre></td></tr></table></figure><h5 id="依赖管理过程-definedReactive"><a href="#依赖管理过程-definedReactive" class="headerlink" title="依赖管理过程 - definedReactive"></a>依赖管理过程 - definedReactive</h5><p><code>Observer</code> 实例化最终会调用 <code>definedReactive</code> 重写 <code>getter, setter</code> 方法。开始会实例化一个 <code>Dep</code>，也就是创建一个数据的依赖管理。在重写的 <code>getter</code> 方法中会进行依赖的收集，即调用 <code>dep.depend</code> 方法，在 <code>setter</code> 阶段，比较两个数不同后，会调用依赖的派发更新，即 <code>dep.notify</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> defineReactive = <span class="function">(<span class="params">obj, key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> dep = <span class="keyword">new</span> Dep()</span><br><span class="line">  <span class="keyword">const</span> property = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj)</span><br><span class="line">  <span class="keyword">let</span> val = obj[key]</span><br><span class="line">  <span class="keyword">if</span> (property &amp;&amp; property.configurable === <span class="literal">false</span>) <span class="keyword">return</span></span><br><span class="line">  <span class="built_in">Object</span>.defineProperty(obj, key, &#123;</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">    get () &#123;</span><br><span class="line">      <span class="comment">// 做依赖的收集</span></span><br><span class="line">      <span class="keyword">if</span> (Dep.target) &#123;</span><br><span class="line">        dep.depend()</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> val</span><br><span class="line">    &#125;,</span><br><span class="line">    set (newVal) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newVal === val) <span class="keyword">return</span></span><br><span class="line">      <span class="comment">// 派发更新</span></span><br><span class="line">      val = newVal</span><br><span class="line">      dep.notify()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例化 <code>Watcher</code> 时会将 <code>Dep.target</code> 设置为当前的 watcher，执行完状态更新函数之后，在将 <code>Dep.target</code> 置空：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Watcher</span> </span>&#123;</span><br><span class="line">  <span class="title">constructor</span> (<span class="params">expOrFn, isRenderWatcher</span>) &#123;</span><br><span class="line">    <span class="built_in">this</span>.getter = expOrFn</span><br><span class="line">    <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">  get () &#123;</span><br><span class="line">    <span class="comment">// 当前执行的 watcher</span></span><br><span class="line">    Dep.target = <span class="built_in">this</span></span><br><span class="line">    <span class="built_in">this</span>.getter()</span><br><span class="line">    Dep.target = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br><span class="line">  update () &#123;</span><br><span class="line">    <span class="built_in">this</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="computed-和-watch"><a href="#computed-和-watch" class="headerlink" title="computed 和 watch"></a>computed 和 watch</h3><h4 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h4><p>计算属性 computed，会根据所依赖的数据动态显示新的计算结果，且计算结果在 getter 执行后会被缓存起来，当所依赖的数据发生改变的时候，就会重新调用 getter 来计算最新的结果</p><p>computed 设计的初衷是为了使模板中的逻辑运算更简单，应用场景：</p><ul><li>重复使用数据或复杂及费时的运算；</li><li>需要的数据依赖于其他的数据。</li></ul><h5 id="computed-和-methods-的区别"><a href="#computed-和-methods-的区别" class="headerlink" title="computed 和 methods 的区别"></a>computed 和 methods 的区别</h5><ol><li>computed 是基于响应性依赖来进行缓存的，只有当响应式依赖发生改变时才会重新求值；methods 方法中是每次调用，都会执行函数，且 methods 不是响应式的；</li><li>computed 中的成员可以指定一个函数作为只读属性，也可以定义 get/set 变成可读写属性，但是 methods 中不可行。</li></ol><p>缓存的存在避免了一些无谓的计算，提高了访问速度，优化了用户体验。</p><h4 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h4><p>watch 是对 data 的数据监听回调，当依赖的 data 的数据变化时，会执行回调。</p><p>使用场景：当在 data 中的某个数据发生变化时，需要进行一些操作，或者当需要在数据变化时执行异步或开销较大的操作时，使用 watch 来监听。</p><h5 id="普通监听和深度监听"><a href="#普通监听和深度监听" class="headerlink" title="普通监听和深度监听"></a>普通监听和深度监听</h5><p>watch 中有一个属性为 <code>deep</code>，含义是：是否深度监听某个对象的值，默认为 false。</p><blockquote><p>页面第一次加载默认不会触发 watch，可以添加 immediate 属性为 true 来使页面加载时先执行一次。</p></blockquote><h5 id="watch-和-computed-的区别"><a href="#watch-和-computed-的区别" class="headerlink" title="watch 和 computed 的区别"></a>watch 和 computed 的区别</h5><p>同：都是监听页面数据变化的；</p><p>异：</p><ul><li>computed 只有当依赖的数据变化时才会计算，当数据没有变化时，会读取缓存</li><li>watch 每次都需要执行函数，watch 更适合于数据变化的异步操作</li></ul><h4 id="computed-的基本原理及源码实现"><a href="#computed-的基本原理及源码实现" class="headerlink" title="computed 的基本原理及源码实现"></a>computed 的基本原理及源码实现</h4><p>// TODO:</p><h3 id="slot"><a href="#slot" class="headerlink" title="slot"></a>slot</h3><p>插槽允许以一种不同于严格的父子关系的方式组合组件，有普通插槽、具名插槽和作用域插槽。</p><h4 id="普通插槽"><a href="#普通插槽" class="headerlink" title="普通插槽"></a>普通插槽</h4><p>插槽将 <code>&lt;slot&gt;&lt;/slot&gt;</code> 作为子组件承载分发的载体。</p><h5 id="简单用法"><a href="#简单用法" class="headerlink" title="简单用法"></a>简单用法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div class=&quot;child&quot;&gt;&lt;slot&gt;&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div id=&quot;app&quot;&gt;&lt;child&gt;test&lt;/child&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 最终渲染结果</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;child&quot;&gt;test&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h5 id="组件挂载原理"><a href="#组件挂载原理" class="headerlink" title="组件挂载原理"></a>组件挂载原理</h5><p>组件渲染流程：</p><ol><li>从根实例入手进行实例的挂载，如果有手写的 <code>render</code> 函数，则直接进入 <code>$mount</code> 挂载流程；</li><li>只有 <code>template</code> 模板则需要对模板进行解析，分为将模板解析为 <code>AST</code> 树，以及根据不同平台生成执行代码；</li><li><code>$mount</code> 流程也分为两步：第一步是将 <code>render</code> 函数生成 <code>Vnode</code> 树，子组件会以 <code>vue-component-</code>  为 <code>tag</code> 标记，另一步是把 <code>Vnode</code> 渲染成真正的 DOM 节点；</li><li>创建真实节点过程中，如果遇到子的占位符组件会进行子组件的实例化过程，然后回到流程的第一步</li></ol><h5 id="父组件处理"><a href="#父组件处理" class="headerlink" title="父组件处理"></a>父组件处理</h5><p>父组件会优先于子组件进行实例的挂载，<code>createComponent</code> 执行了创建子占位节点 <code>Vnode</code> 的过程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子 Vnode 过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function"> Ctor, <span class="comment">// 子类构造器</span></span></span></span><br><span class="line"><span class="params"><span class="function"> data,</span></span></span><br><span class="line"><span class="params"><span class="function"> context, <span class="comment">// vm 实例</span></span></span></span><br><span class="line"><span class="params"><span class="function"> children, <span class="comment">// 父组件需要分发的内容</span></span></span></span><br><span class="line"><span class="params"><span class="function"> tag <span class="comment">// 子组件占位符</span></span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">...</span><br><span class="line">  <span class="comment">// 创建子 vnode，其中父保留的 children 属性会以选项的形式传递给 Vnode</span></span><br><span class="line">  <span class="keyword">var</span> vnode = <span class="keyword">new</span> VNode(</span><br><span class="line">    (<span class="string">&#x27;vue-component-&#x27;</span> + (Ctor.cid) + (name ? (<span class="string">&#x27;-&#x27;</span> + name) : <span class="string">&#x27;&#x27;</span>)),</span><br><span class="line">    data, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, context,</span><br><span class="line">    &#123; Ctor, propsData, listeners, tag, chilren &#125;,</span><br><span class="line">    asyncFactory</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Vnode 构造器</span></span><br><span class="line"><span class="keyword">var</span> VNode = <span class="function"><span class="keyword">function</span> <span class="title">VNode</span> (<span class="params">tag, data, children, text, elm, context, componentOptions, asyncFactory</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="built_in">this</span>.coomponentOptions = componentOptions <span class="comment">// 子组件的选项相关</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>createComponent</code> 函数接收的第四个参数 <code>children</code> 就是父组件需要分发的内容。在创建 <code>Vnode</code> 的过程中，会将 <code>componentOptions</code> 配置传入 <code>Vnode</code> 构造器中。<strong>最终 <code>Vnode</code> 中父组件需要分发的内容以 <code>componentOptions</code> 属性的形式存在</strong>。</p><h5 id="子组件流程"><a href="#子组件流程" class="headerlink" title="子组件流程"></a>子组件流程</h5><p>父组件的最后一个阶段是将 <code>Vnode</code> 渲染为真正的 DOM 节点，在这个过程中遇到子 <code>Vnode</code> 会优先实例化子组件并进行一系列子组件的渲染流程。</p><p>子组件初始化会先调用 <code>init</code> 方法，子组件会嗲用 <code>initInternalComponent</code> 方法拿到父组件拥有的相关配置信息，并赋值给子组件自身的配置选项。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子组件的初始化</span></span><br><span class="line">Vue.prototype._init = <span class="function"><span class="keyword">function</span> (<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (options &amp;&amp; options._isComponents) &#123;</span><br><span class="line">    initInternalComponent(vm, options)</span><br><span class="line">  &#125;</span><br><span class="line">  initRender(vm)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initInternalComponent</span> (<span class="params">vm, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> opts = vm.$options = <span class="built_in">Object</span>.create(vm.constructor.options)</span><br><span class="line">  <span class="keyword">var</span> parentVnode = options._parentVnode</span><br><span class="line">  opts.parent = options.parent</span><br><span class="line">  opts._parentVnode = parentVnode</span><br><span class="line">  <span class="comment">// componentOptions 为子 vnode 记录的相关信息</span></span><br><span class="line">  <span class="keyword">var</span> vnodeComponentOptions = parentVnode.componentOptions</span><br><span class="line">  opts.propsData = vnodeComponentOptions.propsData</span><br><span class="line">  opts._parentListeners = vnodeComponentOptions.listeners</span><br><span class="line">  <span class="comment">// 父组件需要分发的内容赋值给子选项配置的 _renderChildren</span></span><br><span class="line">  opts._renderChildren = vnodeComponentOptions.children</span><br><span class="line">  opts._componentTag = vnodeComponentOptions.tag</span><br><span class="line">  <span class="keyword">if</span> (options.render) &#123;</span><br><span class="line">    opts.render = options.render</span><br><span class="line">    opts.staticRenderFns = options.staticRenderFns</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终<strong>在子组件实例的配置中拿到了父组件保存的分发内容，记录在组件实例 <code>$options._renderChildren</code> 中</strong>。</p><p>然后是 <code>initRender</code> 阶段，在这个过程会<strong>将配置的 <code>_renderChildren</code> 属性做规范化处理，并将他赋值给子实例上的 <code>$slot</code> 属性</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initRender</span> (<span class="params">vm</span>) </span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  vm.$solts = resolveSlots(options._renderChildren, renderContext) <span class="comment">// $slots 拿到了子占位符节点的 _renderChildren（即需要分发的内容），保留作为子实例的属性</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveSlots</span> (<span class="params">children, context</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// children 是父组件需要分发到子组件的 Vnode 节点，如果不存在，则没有分发内容</span></span><br><span class="line">  <span class="keyword">if</span> (!children || !children.length) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> slots = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, l = children.length; i &lt; l; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> child = children[i]</span><br><span class="line">    <span class="keyword">var</span> data = child.data</span><br><span class="line">    <span class="comment">// remove slot attribute if the node is resolved as a Vue slot node</span></span><br><span class="line">    <span class="keyword">if</span> (data &amp;&amp; data.attrs &amp;&amp; data.attrs.slot) &#123;</span><br><span class="line">      <span class="keyword">delete</span> data.attrs.slot</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// named slots should only be respected if the vnode was rendered in the</span></span><br><span class="line">    <span class="comment">// same context.</span></span><br><span class="line">    <span class="comment">// 分支1为具名插槽的逻辑，放后分析</span></span><br><span class="line">    <span class="keyword">if</span> ((child.context === context || child.fnContext === context) &amp;&amp; data &amp;&amp; data.slot != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">var</span> name = data.slot</span><br><span class="line">      <span class="keyword">var</span> slot = (slots[name] || (slots[name] = []))</span><br><span class="line">      <span class="keyword">if</span> (child.tag === <span class="string">&#x27;template&#x27;</span>) &#123;</span><br><span class="line">        slot.push.apply(slot, child.children || [])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        slot.push(child)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 普通插槽的重点，核心逻辑是构造 &#123; default: [children] &#125; 对象返回</span></span><br><span class="line">      (slots.default || (slots.default = [])).push(child)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> slots</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>普通插槽的核心在 <code>(slots.default || (slots.default = [])).push(child)</code>，即以数组的形式赋值给 <code>default</code> 属性，并以 <code>$slot</code> 属性的形式保存在子组件的实例中。</p><p>随后子组件也会走挂载的流程，同样会经历 <code>template</code> 模板到 <code>render</code> 函数，再到 <code>Vnode</code>，最后渲染真实 <code>DOM</code> 的过程。解析 <code>AST</code> 阶段，<code>slot</code> 标签和其他普通标签处理相同，<strong>不同之处在于 <code>AST</code> 生成 <code>render</code> 函数阶段，对 <code>slot</code> 标签的处理，会使用 <code>_t函数</code> 进行包裹</strong>。</p><p>子组件渲染的大致流程：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ast 生成 render 函数</span></span><br><span class="line"><span class="keyword">var</span> code = geterate(ast, options)</span><br><span class="line"><span class="comment">// generate 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generate</span>(<span class="params">ast, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> state = <span class="keyword">new</span> CodegenState(options)</span><br><span class="line">  <span class="keyword">var</span> code = ast ? genElement(ast, state) : <span class="string">&#x27;c_(&quot;div&quot;)&#x27;</span></span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">render</span>: (<span class="string">&#x27;with (this) &#123; return &#x27;</span> + code <span class="string">&#x27;&#125;&#x27;</span>),</span><br><span class="line">    <span class="attr">staticRenderFns</span>: state.staticRenderFnc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// genElement 实现</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genElement</span> (<span class="params">el, state</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 针对 slot 标签的处理走 ```genSlot``` 分支</span></span><br><span class="line">  <span class="keyword">if</span> (el.tag === <span class="string">&#x27;slot&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> genSlot(el, state)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 核心 genSlot 原理</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genSlot</span> (<span class="params">el, state</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// slotName 记录着插槽的唯一标志名，默认为 default</span></span><br><span class="line">  <span class="keyword">var</span> slotName = el.slotName || <span class="string">&#x27;&quot;default&quot;&#x27;</span></span><br><span class="line">  <span class="comment">// 如果子组件的插槽还有子元素，则会递归调执行子元素的创建过程</span></span><br><span class="line">  <span class="keyword">var</span> children = genChildren(el, state)</span><br><span class="line">  <span class="comment">// 通过 _t 函数包裹</span></span><br><span class="line">  <span class="keyword">var</span> res = <span class="string">&#x27;_t(&#x27;</span> + slotName + (children ? <span class="string">&#x27;,&#x27;</span> + children : <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 具名插槽的其他处理</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> res + <span class="string">&#x27;)&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终子组件的 render 函数为 <code>&quot;with (this) &#123; return _c(&#39;div&#39;, &#123; staticClass: &quot;child&quot; &#125;, [_t(&quot;defailt&quot;)], 2)&#125;&quot;</code>；</p><p>接下来是<strong>将子组件渲染为 <code>Vnode</code> 的过程，render 函数执行阶段会执行 <code>_t()</code> 函数，<code>_t</code> 函数是 <code>renderSlot</code> 函数简写，它会在 Vnode 树中进行分发内容的替换</strong>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// target._t = renderSlot</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// render 函数渲染 Vnode 函数</span></span><br><span class="line">Vue.prototype._render = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _parentVnode = ref._parentVnode</span><br><span class="line">  <span class="keyword">if</span> (_parentVnode) &#123;</span><br><span class="line">    <span class="comment">// slot 的规范化处理并赋值给 $scopedSlots 属性</span></span><br><span class="line">    vm.$scopedSlots = normalizeScopeSlots(</span><br><span class="line">      _parentVnode.data.scopedSlots,</span><br><span class="line">      vm.$slots, <span class="comment">//记录父组件的插槽内容</span></span><br><span class="line">      vm.$scopedSlots</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到 <code>$scopedSlots</code> 属性后会执行真正的 <code>render</code> 函数，其中 <code>_t</code> 代码如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染 slot 组件内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">name,</span></span></span><br><span class="line"><span class="params"><span class="function"> fallback, <span class="comment">// slot 插槽后备内容</span></span></span></span><br><span class="line"><span class="params"><span class="function"> props, <span class="comment">// 子传给父的值(作用域插槽)</span></span></span></span><br><span class="line"><span class="params"><span class="function"> bindObject</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scopedSlotFn 拿到父组件插槽的执行函数，默认 slotName 为 default</span></span><br><span class="line">  <span class="keyword">var</span> scopedSlotFn = <span class="built_in">this</span>.$scopedSlots[name]</span><br><span class="line">  <span class="keyword">var</span> nodes</span><br><span class="line">  <span class="comment">// 具名插槽分支</span></span><br><span class="line">  <span class="keyword">if</span> (scopedSlotFn) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 如果父占位符组件没有插槽内容，this.$slots 不会有值，此时 vnode 节点为后备内容节点</span></span><br><span class="line">    nodes = <span class="built_in">this</span>.$slots[name] || fallback</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">var</span> target = props &amp;&amp; props.slot</span><br><span class="line">  <span class="keyword">if</span> (target) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.$createElement(<span class="string">&#x27;template&#x27;</span>, &#123; <span class="attr">slot</span>: target &#125;, nodes)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> nodes</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>renderSlot</code> 执行过程会拿到父组件需要分发的内容，最终 <code>Vnode</code> 树将父元素的插槽替换掉子组件的 <code>slot</code> 组件，最后进行<strong>子组件真实节点的渲染</strong>。</p><h4 id="具有后备内容的插槽"><a href="#具有后备内容的插槽" class="headerlink" title="具有后备内容的插槽"></a>具有后备内容的插槽</h4><p>为一个插槽设置具体的后备内容，会在没有提供内容的时候被渲染：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div class=&quot;child&quot;&gt;&lt;slot&gt;后备内容&lt;/slot&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div id=&quot;app&quot;&gt;&lt;child&gt;&lt;/child&gt;&lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 父组件没有插槽内容，子的 slot 会渲染后备内容</span></span><br><span class="line"><span class="comment">// &lt;div class=&quot;child&quot;&gt;后备内容&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><p>与普通插槽渲染流程的不同：</p><ol><li>父组件渲染该过程中没有需要分发的子节点，所以不再需要 <code>componentOptions.children</code> 属性来标记内容；</li><li>子组件也拿不到 <code>$slot</code> 属性的内容；</li><li>子组件的 <code>render</code> 函数最后在 <code>_t</code> 函数参数会携带第二个参数，该参数以数组的形式传入 <code>slot</code> 插槽的后备内容；</li><li>渲染子 <code>Vnode</code> 执行 <code>renderSlot(_t)</code> 函数时，第二个参数 fallback 有值，且 <code>this.$slots</code> 没值，<code>vnode</code> 会直接返回后备内容作为渲染对象。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">name,</span></span></span><br><span class="line"><span class="params"><span class="function"> fallback, <span class="comment">// slot 插槽的后备内容</span></span></span></span><br><span class="line"><span class="params"><span class="function"> props, <span class="comment">// 子传给父的值(作用域插槽)</span></span></span></span><br><span class="line"><span class="params"><span class="function"> bindObject</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// fallback 为后备内容</span></span><br><span class="line">    <span class="comment">// 如果父占位符组件没有插槽内容，this.$slots 不会有值，此时 vnode 节点为后备内容节点</span></span><br><span class="line">    nodes = <span class="built_in">this</span>.$slots[name] || fallback</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>父级模板里的所有内容都是在父级作用域中编译的；子模版的所有内容都是在子作用中编译的。</p></blockquote><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>可以使用 <code>&lt;slot&gt;</code> 的 <code>name</code> 属性来灵活的使用插槽进行组件的开发：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div class=&quot;child&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;header&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;slot name=&quot;footer&quot;&gt;&lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;child&gt;</span></span><br><span class="line"><span class="string">  &lt;template v-slot:header&gt;</span></span><br><span class="line"><span class="string">  &lt;span&gt;头部&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;template v-slot:footer&gt;</span></span><br><span class="line"><span class="string">  &lt;span&gt;底部&lt;/span&gt;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;/child&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>最终渲染结果：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;child&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>头部<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>底部<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="模板编译的差别"><a href="#模板编译的差别" class="headerlink" title="模板编译的差别"></a>模板编译的差别</h5><p>父组件在编译 <code>AST</code> 阶段和普通节点的过程不同，具名插槽一般会在 <code>template</code> 模板中使用 <code>v-slot:</code> 来标注指定插槽，这一阶段会在编译阶段特殊处理，最终的 <code>AST</code> 树会写道 <code>scopedSlots</code> 用来记录具名插槽的内容：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  scopedSlots: &#123;</span><br><span class="line">    footer: &#123; ... &#125;,</span><br><span class="line">    header: &#123; ... &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> _c(</span><br><span class="line">    <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line">    &#123; <span class="attr">attrs</span>: &#123; <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;app&#x27;</span> &#125; &#125;,</span><br><span class="line">    [_c(<span class="string">&#x27;child&#x27;</span>, &#123; <span class="attr">scopedSlots</span>: _u([</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&#x27;header&#x27;</span>, <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [_c(<span class="string">&#x27;span&#x27;</span>, [_v(<span class="string">&#x27;头部&#x27;</span>)])]</span><br><span class="line">      &#125;, <span class="attr">proxy</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">key</span>: <span class="string">&#x27;footer&#x27;</span>, <span class="attr">fn</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [_c(<span class="string">&#x27;span&#x27;</span>, [_v(<span class="string">&#x27;底部&#x27;</span>)])]</span><br><span class="line">      &#125;, <span class="attr">proxy</span>: <span class="literal">true</span> &#125;</span><br><span class="line">    ])&#125;)],</span><br><span class="line">    <span class="number">1</span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>父组件的插槽内容用 <code>_u</code> 函数封装成数组的形式，并赋值到 <code>scopedSlots</code> 属性中，而每一个插槽以对象形式描述，<code>key</code> 代表插槽名，<code>fn</code> 是一个返回执行结果的函数。</p><h5 id="父组件-vnode-生成阶段"><a href="#父组件-vnode-生成阶段" class="headerlink" title="父组件 vnode 生成阶段"></a>父组件 vnode 生成阶段</h5><p>照例进入父组件生成 <code>Vnode</code> 阶段，其中 <code>_u</code> 函数的原形是 <code>resolveScopedSlots</code>，其中一个参数就是插槽数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vnode 生成阶段针对具名插槽的处理 _u (target._u = resolveScopedSlots)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveScopedSlots</span> (<span class="params">fns, res, hasDynamicKeys, contentHashKey</span>) </span>&#123;</span><br><span class="line">  res = res || &#123; <span class="attr">$stable</span>: !hasDynamicKeys &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; fns.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> slot = fns[i]</span><br><span class="line">    <span class="comment">// fn 是数组需要递归处理</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(slot)) &#123;</span><br><span class="line">      resolveScopedSlots(slot, res, hasDynamicKeys)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      <span class="comment">// marker for reverse proxying v-slot without scope on this.$slots</span></span><br><span class="line">      <span class="keyword">if</span> (slot.proxy) &#123; <span class="comment">// 针对 proxy 的处理</span></span><br><span class="line">        slot.fn.proxy = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 最终返回一个对象，对象以 slotname 作为属性，以 fn 作为值</span></span><br><span class="line">      res[slot.key] = slot.fn</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (contentHashKey) &#123;</span><br><span class="line">    (res).$key = contentHashKey</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终父组件的 <code>vnode</code> 节点的 <code>data</code> 属性上多了 <code>scopedSlots</code> 数组。具名插槽和普通插槽实现上有明显的不同：</p><ul><li>普通插槽是以 <code>componentOptions.child</code> 的形式保留在父组件中；</li><li>具名插槽是以 <code>scopedSlots</code> 属性的形式存储到 <code>data</code> 属性中</li></ul><h5 id="子组件渲染-Vnode-过程"><a href="#子组件渲染-Vnode-过程" class="headerlink" title="子组件渲染 Vnode 过程"></a>子组件渲染 Vnode 过程</h5><p>子组件在解析成 <code>AST</code> 树阶段的不同，在于对 <code>slot</code> 标签的 <code>name</code> 属性的解析，而在 <code>render</code> 生成 <code>Vnode</code> 过程中，<code>slot</code> 的规范化处理针对具名插槽会进行特殊的处理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vm.$scopedSlots = normalizeScopedSlots(</span><br><span class="line">  _parentVnode.data.scopedSlots, <span class="comment">// 此时的第一个参数会拿到父组件插槽相关的数据</span></span><br><span class="line">  vm.$slots, <span class="comment">// 记录父组件的插槽内容</span></span><br><span class="line">  vm.$scopedSlots</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>最终子组件实例上的 <code>$scopedSlots</code> 属性会携带父组件插槽相关的内容。</p><h5 id="子组件渲染真实-DOM"><a href="#子组件渲染真实-DOM" class="headerlink" title="子组件渲染真实 DOM"></a>子组件渲染真实 DOM</h5><p>执行子 <code>render</code> 函数中的 <code>_t</code> 方法，最终的核心是执行 <code>nodes = scopedSlotFn(props)</code>，也就是执行 <code>function () &#123; return [_c(&#39;span&#39;, [_v(&#39;头部&#39;)])] &#125;</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渲染 slot 组件内容</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderSlot</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">name,</span></span></span><br><span class="line"><span class="params"><span class="function"> fallback, <span class="comment">// slot 插槽后备内容</span></span></span></span><br><span class="line"><span class="params"><span class="function"> props, <span class="comment">// 子传给父的值(作用域插槽)</span></span></span></span><br><span class="line"><span class="params"><span class="function"> bindObject</span></span></span><br><span class="line"><span class="params"><span class="function"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// scopedSlotFn 拿到父组件插槽的执行函数，默认 slotName 为 default</span></span><br><span class="line">  <span class="keyword">var</span> scopedSlotFn = <span class="built_in">this</span>.$scopedSlots[name]</span><br><span class="line">  <span class="keyword">var</span> nodes</span><br><span class="line">  <span class="comment">// 针对具名插槽，特点是 $scopedSlots 有值</span></span><br><span class="line">  <span class="keyword">if</span> (scopedSlotFn) &#123;</span><br><span class="line">    props = props || &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (bindObject) &#123;</span><br><span class="line"><span class="keyword">if</span> (!isObject(bindObject)) &#123;</span><br><span class="line">        warn()</span><br><span class="line">      &#125;</span><br><span class="line">      props = extend(extend(&#123;&#125;, bindObject), props)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行时将子组件传递给父组件的值传入 fn</span></span><br><span class="line">    nodes = scopedSlotFn(props) || fallback</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此子组件通过 <code>slotName</code> 找到了对应父组件的插槽内容。</p><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>可以利用作用域插槽让父组件的插槽内容访问到子组件的数据，具体就是在子组件中以属性的方式记录在子组件中父组件通过 <code>v-slot:[name]=[props]</code> 的形式拿到子组件传递的值，子组件元素上的特性称为 <strong>插槽 Props</strong>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> child = &#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div&gt;</span></span><br><span class="line"><span class="string">  &lt;slot :user=&quot;user&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;/slot&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span>,</span><br><span class="line">  data () &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">user</span>: &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;AgoniLay&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    child</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`</span></span><br><span class="line"><span class="string">  &lt;div id=&quot;app&quot;&gt;</span></span><br><span class="line"><span class="string">  &lt;child&gt;</span></span><br><span class="line"><span class="string">  &lt;template v-slot:default=&quot;slotProps&quot;&gt;</span></span><br><span class="line"><span class="string">  &#123;&#123; slotProps.user.name &#125;&#125;</span></span><br><span class="line"><span class="string">  &lt;/template&gt;</span></span><br><span class="line"><span class="string">  &lt;/child&gt;</span></span><br><span class="line"><span class="string">  &lt;/div&gt;`</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h5 id="父组件编译阶段"><a href="#父组件编译阶段" class="headerlink" title="父组件编译阶段"></a>父组件编译阶段</h5><p>与具名插槽的用法基本相同，区别在于 <code>v-slot</code> 定义了一个 <code>插槽Props</code> 的名字，生成 <code>render</code> 函数阶段 <code>fn</code> 函数会携带 <code>props</code> 参数传入。</p><h5 id="子组件渲染"><a href="#子组件渲染" class="headerlink" title="子组件渲染"></a>子组件渲染</h5><p>在子组件编译阶段，<code>:user=&quot;user&quot;</code> 会以属性的形式解析，最终在 <code>render</code> 函数生成阶段以对象参数的形式传递 <code>_t</code> 函数。</p><p>子组件渲染 Vnode 阶段，会执行 <code>renderSlot</code> 函数，对于作用域插槽的处理，集中体现在函数传入的第三个参数 <code>props</code>。</p><h5 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h5><p>子父组件之间的通信完全可以通过事件 <code>$emit, $on</code> 的形式来完成，而增加一个 <code>插槽Props</code> 的原因：</p><blockquote><p>插槽 Props 允许将插槽转换为可复用的模板，这些模板可以基于输入的 prop 渲染出不同的结果。</p></blockquote><h3 id="nextTick"><a href="#nextTick" class="headerlink" title="nextTick"></a>nextTick</h3><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>在下次 DOM 更新循环结束之后执行延迟回调，在修改数据之后立即使用这个方法，获取更新后的 DOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改数据</span></span><br><span class="line">vm.msg = <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line"><span class="comment">// DOM 还没有更新</span></span><br><span class="line">Vue.nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 作为一个 Promise 使用 (2.1.0 起新增)</span></span><br><span class="line">Vue.nextTick()</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// DOM 更新了</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="源码实现"><a href="#源码实现" class="headerlink" title="源码实现"></a>源码实现</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">Promise</span> !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; inNative(<span class="built_in">Promise</span>)) &#123;</span><br><span class="line">  <span class="keyword">const</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    p.then(flushCallbacks)</span><br><span class="line">    <span class="keyword">if</span> (isIOS) <span class="built_in">setTimeout</span>(noop)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!isIE &amp;&amp; <span class="keyword">typeof</span> MutationObserver !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; (</span><br><span class="line">  isNative(MutationObserver) ||</span><br><span class="line">  MutationObserver.toString() === <span class="string">&#x27;[Object MutationObserverConstructor]&#x27;</span></span><br><span class="line">)) &#123;</span><br><span class="line"><span class="keyword">let</span> counter = <span class="number">1</span></span><br><span class="line">  <span class="keyword">const</span> observer = <span class="keyword">new</span> MutationObserver(flushCallbacks)</span><br><span class="line">  <span class="keyword">const</span> textNode = <span class="built_in">document</span>.createTextNode(Stirng(counter))</span><br><span class="line">  observer.observe(textNode, &#123;</span><br><span class="line">    <span class="attr">characterData</span>: <span class="literal">true</span></span><br><span class="line">  &#125;)</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    counter = (counter + <span class="number">1</span>) % <span class="number">2</span></span><br><span class="line">    textNode.data = Stirng(counter)</span><br><span class="line">  &#125;</span><br><span class="line">  isUsingMicroTask = <span class="literal">true</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> setImmediate !== <span class="string">&#x27;undefined&#x27;</span> &amp;&amp; isNative(setImmediate)) &#123;</span><br><span class="line">  timerFunc = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    setImmediate(flushCallbacks)</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  timerFun = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(flushCallbacks, <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先进行条件判断:</p><ul><li>如果支持 Promise 就使用 <code>Promise</code>;</li><li>如果不支持则使用 <code>MutationObserver</code>，会在指定的 DOM 发生变化时被调用；</li><li>如果不支持则使用 <code>setImmediate</code>，但只有最新版 IE 和 node 支持；</li><li>均不支持则使用 <code>setTimeout</code>。</li></ul><h4 id="JS-运行机制"><a href="#JS-运行机制" class="headerlink" title="JS 运行机制"></a>JS 运行机制</h4><p>JS 是单线程，JS 里的任务分为两种：</p><ul><li>同步任务（synchronous）：在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务，阻塞；</li><li>异步任务（asynchronous）：不进入主线程，而进入”任务队列”（task queue）的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。</li></ul><p>JS 任务又分为宏任务和微任务：</p><ul><li>宏任务（macrotask）：setTimeout、setInterval、setImmediate、I/O、UI rendering</li><li>微任务（microtask）：promise.then、process.nextTick、MutationObserver、queueMicrotask（开启一个微任务）</li></ul><p>宏任务按顺序执行，且浏览器在每个宏任务之间渲染页面，浏览器为了能够使得 JS 内部 task 与 DOM 任务能够有序的执行，会在一个 task 执行结束后，在下一个 task 执行开始前对页面进行重新渲染（task -&gt; 渲染 -&gt; task -&gt; …）</p><p>微任务通常来说就是需要在当前 task 执行结束后立即执行的任务，只要执行栈中没有其他的 JS 代码正在执行且每个宏任务执行完毕，微任务队列就会立即执行。</p><p>在微任务执行期间微任务队列加入了新的微任务，会将新的微任务加入队列尾部，之后也会被执行。</p><blockquote><p>使用微任务的时机：晚于当前本轮事件循环的 Call Stack（调用栈）中的代码（宏任务），遭遇事件处理函数和定时器的回调函数。</p><p>原因：</p><ul><li>减少操作中用户可感知到的延迟</li><li>确保任务顺序的一致性</li><li>批量操作的优化</li></ul></blockquote><p>执行流程：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220411013615619.png" class title="JS 执行流程"><p>故 nextTick 要优先调用 <code>Promise</code> 和 <code>MutationObserver</code> 等微任务，会在执行栈空闲时立即执行，响应速度会比 setTimeout 等更快，无需等渲染。</p><h3 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>keep-alive</code> 的使用只需要在动态组件的最外层添加标签即可。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeTabs(&#x27;child1&#x27;)&quot;</span>&gt;</span>child1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;changeTabs(&#x27;child1&#x27;)&quot;</span>&gt;</span>child1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;chooseTabs&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> child1 = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;div&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;button @click=&quot;add&quot;&gt;add&lt;/button&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">    &lt;p&gt;&#123;&#123;num&#125;&#125;&lt;/p&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">  &lt;/div&gt;`</span>,</span></span><br><span class="line"><span class="javascript">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">num</span>: <span class="number">1</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      add () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.num++</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> child2 = &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`&lt;div&gt;child2&lt;/div&gt;`</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      child1,</span></span><br><span class="line"><span class="javascript">      child2</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    data () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">chooseTabs</span>: <span class="string">&#x27;child1&#x27;</span></span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      changeTabs (tab) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.chooseTabs = tab</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>动态组件在 <code>child1, child2</code> 之间来回切换，<code>child2</code> 会保留原来的数据状态。</p><h4 id="从模板生成到生成-vnode"><a href="#从模板生成到生成-vnode" class="headerlink" title="从模板生成到生成 vnode"></a>从模板生成到生成 vnode</h4><p>针对 <code>keep-alive</code> 的 <code>render</code> 函数的结果如下：</p><p><code>with(this)&#123;···_c(&#39;keep-alive&#39;,&#123;attrs:&#123;&quot;include&quot;:&quot;child2&quot;&#125;&#125;,[_c(chooseTabs,&#123;tag:&quot;component&quot;&#125;)],1)&#125;</code> </p><p>接下来从子开始到父会执行生成 <code>Vnode</code> 对象的过程，<code>_c(&#39;keep-alive&#39;...)</code> 的处理，会执行 <code>createElement</code> 生成组件 <code>Vnode</code>，调用 <code>createComponent</code> 函数去创建子组件 <code>Vnode</code>，不同之处在于 <code>keep-alive</code> 除了 <code>slot</code> 属性之外，其他属性在组件内部并没有意义，所以在 <code>Vnode</code> 层剔除掉多余的属性是有意义的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建子组件 Vnode 过程</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">Ctor, context, children, tag</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// abstract 是内置组件(抽象组件)的标志</span></span><br><span class="line">  <span class="keyword">if</span> (isTrue(Ctor.options.abstract)) &#123;</span><br><span class="line">    <span class="comment">// 只保留 slot 属性，其他标签属性都被移除，在 vnode 对象上不再存在</span></span><br><span class="line">    <span class="keyword">var</span> slot = data.slot</span><br><span class="line">    data = &#123;&#125;</span><br><span class="line">    <span class="keyword">if</span> (slot) &#123;</span><br><span class="line">      data.slot = slot</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初次渲染"><a href="#初次渲染" class="headerlink" title="初次渲染"></a>初次渲染</h4><p><code>keep-alive</code> 的特别之处在于不会重复渲染相同的组件，只会利用初次渲染保留的缓存去更新节点。</p><h5 id="流程图"><a href="#流程图" class="headerlink" title="流程图"></a>流程图</h5><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220411103331454.png" class title="keep-alive 流程图"><p>Vue 会拿到前面生成的 <code>Vnode</code> 对象执行真实节点创建的过程，也就是熟悉的 <code>patch</code> 过程，<code>patch</code> 执行阶段会调用 <code>createElm</code> 创建真实 <code>dom</code>，在创建节点途中，<code>keep-alive</code> 的 <code>vnode</code> 对象会被认定为是一个组件 <code>Vnode</code>，因此针对组件 <code>Vnode</code> 又会执行 <code>createComponent</code> 函数，会对 <code>keep-alive</code> 组件进行初始化和实例化。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createComponent</span> (<span class="params">vnode, insertedVnodeQueue, parentElm, refElm</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> i = vnode.data</span><br><span class="line">  <span class="keyword">if</span> (isDef(i)) &#123;</span><br><span class="line">    <span class="comment">// isReactivated 用来判断组件是否缓存</span></span><br><span class="line">    <span class="keyword">var</span> isReactivated = isDef(vnode.componentInstance) &amp;&amp; i.keepAlive</span><br><span class="line">    <span class="keyword">if</span> (isDef(i = i.hook) &amp;&amp; isDef(i = i.init)) &#123;</span><br><span class="line">      <span class="comment">// 执行组件初始化的内部钩子 init</span></span><br><span class="line">      i(vnode, <span class="literal">false</span> <span class="comment">/* hydrating */</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isDef(vnode.componentInstance)) &#123;</span><br><span class="line">      <span class="comment">// 其中一个作用是保留真实 dom 到 vnode 中</span></span><br><span class="line">      initComponent(vnode, insertedVnodeQueue)</span><br><span class="line">      insert(parentElm, vnode.lem, refElm)</span><br><span class="line">      <span class="keyword">if</span> (isTrue(isReactivated)) &#123;</span><br><span class="line">        reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="算法相关"><a href="#算法相关" class="headerlink" title="算法相关"></a>算法相关</h1><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><h3 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h3><p>题目：<a href="https://leetcode-cn.com/problems/fibonacci-number/">斐波那契数</a> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220424192342004.png" class title="斐波那契数"><p>解法一：递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n</span><br><span class="line"><span class="keyword">return</span> fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n<sup>2</sup>)</p><p>解法二：动态规划</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">let</span> p = <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    p = q</span><br><span class="line">    q = r</span><br><span class="line">    r = p + q</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> r</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>解法三：通项公式</p><p>利用斐波那契数列的通项公式：</p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220418170815862.png" class title="斐波那契通项公式"><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fib = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> sqrt5 = <span class="built_in">Math</span>.sqrt(<span class="number">5</span>)</span><br><span class="line">  <span class="keyword">const</span> res = <span class="built_in">Math</span>.pow((<span class="number">1</span> + sqrt5) / <span class="number">2</span>, n) - <span class="built_in">Math</span>.pow((<span class="number">1</span> - sqrt5) / <span class="number">2</span>, n)</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.floor(res / sqrt5)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：代码中使用的 pow 函数的时空复杂度与 CPU 支持的指令集相关。</p><h3 id="合并两个排序链表"><a href="#合并两个排序链表" class="headerlink" title="合并两个排序链表"></a>合并两个排序链表</h3><p>题目：<a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">合并两个排序的链表</a> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220424192239209.png" class title="合并两个排序的链表"><p>解法一：递归</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2</span><br><span class="line">  <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1</span><br><span class="line">  <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">    l1.next = mergeTwoLists(l1.next, l2)</span><br><span class="line">    <span class="keyword">return</span> l1</span><br><span class="line">  &#125;</span><br><span class="line">  l2.next = mergeTwoLists(l1, l2.next)</span><br><span class="line">  <span class="keyword">return</span> l2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：双指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTwoLists = <span class="function"><span class="keyword">function</span> (<span class="params">l1, l2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> res = <span class="keyword">new</span> ListNode(<span class="number">0</span>)</span><br><span class="line">  <span class="keyword">let</span> p = res</span><br><span class="line">  <span class="keyword">let</span> [l, r] = [l1, l2]</span><br><span class="line">  <span class="keyword">while</span> (l &amp;&amp; r) &#123;</span><br><span class="line">    <span class="keyword">if</span> (l.val &lt; r.val) &#123;</span><br><span class="line">      p.next = l</span><br><span class="line">      l = l.next</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      p.next = r</span><br><span class="line">      r = r.next</span><br><span class="line">    &#125;</span><br><span class="line">    p = p.next</span><br><span class="line">  &#125;</span><br><span class="line">  p.next = l ? l : r</span><br><span class="line">  <span class="keyword">return</span> res.next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h3><p>题目：<a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/">反转链表</a> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220424192153366.png" class title="反转链表"><p>解法一：迭代</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reverseList = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> pre = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">var</span> cur = head</span><br><span class="line">  <span class="keyword">while</span> (cur) &#123;</span><br><span class="line">    <span class="keyword">var</span> next = cur.next</span><br><span class="line">    cur.next = pre</span><br><span class="line">    pre = cur</span><br><span class="line">    cur = next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)，n 为链表的长度</p><h3 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h3><p>题目：<a href="https://leetcode-cn.com/problems/linked-list-cycle/">环形链表</a> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220424192014587.png" class title="环形链表"><p>解法一：快慢指针</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> fast = slow = head</span><br><span class="line">  <span class="keyword">while</span> (fast &amp;&amp; fast.next) &#123;</span><br><span class="line">    fast = fast.next.next</span><br><span class="line">    slow = slow.next</span><br><span class="line">    <span class="keyword">if</span> (fast == slow) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法三：哈希表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">  <span class="keyword">while</span> (head) &#123;</span><br><span class="line">    <span class="keyword">if</span> (map.has(head)) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    map.set(head, <span class="literal">true</span>)</span><br><span class="line">    head = head.next</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：JSON.stringify()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hasCycle = <span class="function"><span class="keyword">function</span> (<span class="params">head</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="built_in">JSON</span>.stringify(head)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="括号字符串"><a href="#括号字符串" class="headerlink" title="括号字符串"></a>括号字符串</h3><p>题目：<a href="https://leetcode-cn.com/problems/valid-parenthesis-string/">有效的括号字符串</a> </p><img src="/2021/08/28/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E5%A4%8D%E4%B9%A0/image-20220424191929918.png" class title="有效的括号字符串"><p>解法一：栈</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> checkVaildString = <span class="function"><span class="keyword">function</span> (<span class="params">s</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [left, star] = [[], []]</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = s.length; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (s[i] === <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">      left.push(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] === <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">      star.push(i)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (left.length) &#123;</span><br><span class="line">        left.pop()</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (star.length) &#123;</span><br><span class="line">        star.pop()</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; star.length) &#123;</span><br><span class="line">    <span class="keyword">let</span> leftIndex = left.pop()</span><br><span class="line">    <span class="keyword">let</span> starIndex = star.pop()</span><br><span class="line">    <span class="keyword">if</span> (leftIndex &gt; starIndex) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> !left.length</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(n)</p><p>解法二：贪心算法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><p>时间复杂度：O(n)</p><p>空间复杂度：O(1)</p><h2 id="编程"><a href="#编程" class="headerlink" title="编程"></a>编程</h2><h1 id="代码练习"><a href="#代码练习" class="headerlink" title="代码练习"></a>代码练习</h1><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue笔记</title>
      <link href="/2021/08/14/vue%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/14/vue%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="什么是-vue"><a href="#什么是-vue" class="headerlink" title="什么是 vue"></a>什么是 vue</h3><p>官方概念：Vue（读音 /vju:/，类似于 view），是一套用于构建用户界面的前端框架</p><ol><li>构建用户界面<ul><li>用 vue 往 html 页面中填充数据，非常的方便</li></ul></li><li>框架<ul><li>框架时一套现成的解决方案，程序员只能遵守框架的规范，去编写自己的业务功能</li><li>要学习 vue，就是在学习 vue 这个框架中规定的用法</li><li>vue 的指令、组件（是对 UI 结构的复用）、路由、Vuex、vue 组件库</li><li>只有把上面罗列的内容掌握以后，才有开发 vue 项目的能力</li></ul></li></ol><h3 id="vue-的特性"><a href="#vue-的特性" class="headerlink" title="vue 的特性"></a>vue 的特性</h3><p>vue 框架的特性，主要体现在两方面：</p><ol><li><p>数据驱动视图</p><ul><li>数据的变化<strong>会驱动视图</strong>自动更新</li><li>好处：当页面数据发生变化时，页面会自动重新渲染</li><li>数据驱动视图时单向的数据绑定</li></ul></li><li><p>双向数据绑定</p><blockquote><p>在网页中，form 表单负责<strong>采集数据</strong>，Ajax 负责<strong>提交数据</strong></p></blockquote><ul><li>在填写表单时，双向数据绑定额可以辅助开发者在不操作 DOM 的前提下，自动把用户填写的内容同步到数据源中</li><li>好处：开发者不需要手动操作 DOM 元素，来获取表单元素最新的值</li></ul></li></ol><blockquote><p>注意：数据驱动视图和双向数据绑定的底层原理是 MVVM（Model 数据源、View 视图、ViewModel 就是 vue 的实例）</p></blockquote><h4 id="MV-模式"><a href="#MV-模式" class="headerlink" title="MV* 模式"></a>MV* 模式</h4><h5 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h5><p>模型（Model）、视图（View）、控制器（Controller）</p><p>模型：代表应用程序的<strong>数据</strong>以及用于访问控制和修改这些数据的<strong>业务规则</strong>；</p><p>视图：用来组织模型的<strong>内容</strong>，发送用户的请求到控制器；</p><p>控制器：定义了应用程序的<strong>行为</strong>，将用户的请求映射到模型更新，选择视图作为请求的响应</p><h5 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h5><p>MVP（Model-View-Presenter）是由经典的 MVC 模式演变而来的，Presenter 负责逻辑的处理，Model 提供数据，View 负责显示</p><p>MVP 和 MVC 最大的区别在于：</p><ul><li>在 MVP 中 VIew 并不直接使用 Model，之间的通信通过 Presenter 进行的，所有的交互都在发生在 Presenter 内部</li><li>在 MVC 中 View 会直接从 Model 中读取数据而不是通过 Controller</li></ul><h5 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h5><p>MVVM（Model-View-ViewModel）是一种软件架构模式，是一种简化用户界面的事件驱动编程方式</p><p>核心是 <strong>数据驱动</strong> ，即 ViewModel，ViewModel 是 View 和 Model 的关系映射</p><ul><li>ViewModel 是一个值转换器（Value Converter），负责转换 Model 中的数据对象，使数据变得更加易于管理和使用</li><li>在 MVVM 中，View 和 Model 的中间 ViewModel 充当观察者的角色，两者不可直接通信</li></ul><p>核心的特性就是 <strong>数据双向绑定</strong></p><h3 id="vue-的版本"><a href="#vue-的版本" class="headerlink" title="vue 的版本"></a>vue 的版本</h3><p>当前，vue 共有 3 个大版本，其中：</p><ul><li>2.x 版本的 vue 是目前企业级项目开发中的主流版本</li><li>3.x 版本的 vue 于 2020-09-19 发布，生态还不完善，尚未在企业级项目开发中普及和推广</li><li>1.x 版本的 vue 几乎被淘汰，不再建议学习与使用</li></ul><blockquote><p>vue 作者：尤雨溪，中国人</p></blockquote><h2 id="vue-的基本使用"><a href="#vue-的基本使用" class="headerlink" title="vue 的基本使用"></a>vue 的基本使用</h2><h3 id="基本使用步骤"><a href="#基本使用步骤" class="headerlink" title="基本使用步骤"></a>基本使用步骤</h3><ol><li>导入 vue.js 的 script 脚本文件</li><li>在页面中声明一个将要被 vue 控制的 DOM 区域</li><li>创建 vm 实例对象（vue 实例对象）</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 希望 Vue 能够控制下面这个 div，帮我们在把数据填充到 div 内部 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span>&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1. 导入 Vue 的库文件，在 window 全局就有了 VUe 这个构造函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;./lib/vue-2.6.12.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 2. 创建 Vue 的实例对象 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 创建 Vue 的实例对象</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// el 是固定的写法，表示 vm 实例要控制页面上的哪个区域，接收的值是一个选择器</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// data 对象就是要渲染到页面上的数据</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">username</span>: <span class="string">&quot;zhangsan&quot;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// vm.$mount(&#x27;#app&#x27;) // 作用与 el 属性完全一样</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>使用 vue-devtools 调试：在 chrome 中 F12 调试面板中的 vue 一项</p></blockquote><h2 id="vue-的指令和过滤器"><a href="#vue-的指令和过滤器" class="headerlink" title="vue 的指令和过滤器"></a>vue 的指令和过滤器</h2><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><h4 id="概念和分类"><a href="#概念和分类" class="headerlink" title="概念和分类"></a>概念和分类</h4><p>指令（Directives）是 vue 为开发者提供的模板语法，用于辅助开发者渲染页面的基本结构。</p><p>vue 中的指令按照不同的用途可以分为如下 6 大类：</p><ul><li><p>内容渲染指令</p></li><li><p>属性绑定指令</p></li><li><p>事件绑定指令</p></li><li><p>双向绑定指令</p></li><li><p>条件渲染指令</p></li><li><p>列表渲染指令</p></li></ul><blockquote><p>注意：指令是 vue 开发中最基础、最常用、最简单的知识点</p></blockquote><h4 id="内容渲染指令"><a href="#内容渲染指令" class="headerlink" title="内容渲染指令"></a>内容渲染指令</h4><p>内容渲染指令用来辅助开发者渲染 DOM 元素的文本内容。常用的内容渲染指令有如下 3 个：</p><ul><li><code>v-text</code></li><li><code>&#123;&#123; &#125;&#125;</code></li><li><code>v-html</code></li></ul><h5 id="v-text"><a href="#v-text" class="headerlink" title="v-text"></a>v-text</h5><p>更新元素的内容文本</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;username&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-text</span>=<span class="string">&quot;gender&quot;</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">username</span>: <span class="string">&quot;zhangsan&quot;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="attr">gender</span>: <span class="string">&quot;男&quot;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意缺点：v-text 指令会覆盖元素内默认的值</p></blockquote><h5 id="插值表达式语法"><a href="#插值表达式语法" class="headerlink" title="插值表达式语法 *"></a>插值表达式语法 *</h5><p>vue 提供的 <code>&#123;&#123; &#125;&#125;</code> 语法，专门用来解决 v-text 会覆盖默认文本内容的问题。这种 <code>&#123;&#123; &#125;&#125;</code> 语法的专业名称是<strong>插值表达式</strong>（英文名为：<strong>Mustache 语法</strong>）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>姓名：&#123;&#123; username &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>性别：&#123;&#123; gender &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在实际开发中用的最多，只是内容的占位符，不会覆盖原有的内容</p><blockquote><p>在 vue 提供的模板渲染语法中，除了支持绑定简单的数据值之外，还支持 Javascript 表达式的运算</p></blockquote><h5 id="v-html"><a href="#v-html" class="headerlink" title="v-html"></a>v-html</h5><p>v-text 指令和 插值表达式 只能渲染纯文本内容</p><p>v-html 可以把带有标签的字符串，渲染成真正的 HTML 内容</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-html</span>=<span class="string">&quot;info&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">info</span>: <span class="string">&#x27;&lt;h4 style=&quot;color: red; font-weight: bold;&quot;&gt;欢迎大家来学习 vue.js&lt;/h4&gt;&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>动态渲染 HTML 是非常危险的，很容易导致 XSS 攻击，永远不要在用户提交的内容上使用 v-html</p></blockquote><h5 id="v-once"><a href="#v-once" class="headerlink" title="v-once"></a>v-once</h5><p>可以让元素或组件只渲染一次，不需要表达式。</p><p>之后再次渲染时，元素/组件及其所有的子节点将被视为静态内容并跳过，可以用于<strong>优化更新性能</strong>。</p><h5 id="v-pre"><a href="#v-pre" class="headerlink" title="v-pre"></a>v-pre</h5><p>用于跳过这个元素和它的子元素的编译过程，可以用来显示原始 Mustache 标签，不需要表达式。</p><p>对于大量没有指令的节点使用 v-pre 指令可以<strong>加快编译速度</strong>。</p><h5 id="v-cloak"><a href="#v-cloak" class="headerlink" title="v-cloak"></a>v-cloak</h5><p>这个指令保持在元素上知道关联实例编译结束，编译结束后该指令被移除，不需要表达式。</p><p>使用场景：</p><p>浏览器在加载页面时，如果网速较慢或者页面较大，那么浏览器在构造完 DOM 树后会在页面中直接显示 <code>&#123;&#123; value &#125;&#125;</code> 字样，直到 Vue 的 JS 文件加载完成，Vue 实例创建、模板编译后，才会被替换为数据对象中的内容。在这个过程中页面是有闪烁的，给用户的体验不好。</p><p>这时，CSS 规则 <code>[v-cloak] &#123; display: none &#125;</code> 配合 v-cloak 指令一起使用，就可以<strong>解决页面数据闪烁</strong>问题。</p><blockquote><p>在 Vue.js 独立版本的页面开发中，v-cloak 是非常有效的；但在较大的项目中均为模块化开发，不需要使用 v-cloak 指令</p></blockquote><h4 id="属性绑定指令"><a href="#属性绑定指令" class="headerlink" title="属性绑定指令"></a>属性绑定指令</h4><blockquote><p>注意：插值表达式只能用在元素的<strong>内容节点</strong>中，不能用在元素的<strong>属性节点</strong>中！</p></blockquote><h5 id="v-bind"><a href="#v-bind" class="headerlink" title="v-bind: | :"></a>v-bind: | :</h5><ul><li><p>在 vue 中，可以使用 <code>v-bind:</code> 指令,为元素的属性动态绑定属性值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-bind:placeholder</span>=<span class="string">&quot;Tips&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>简写是英文的 <code>:</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:placeholder</span>=<span class="string">&quot;Tips&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>动态属性名：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">v-bind:</span>[<span class="attr">attrname</span>]=<span class="string">&quot;url&quot;</span>&gt;</span>链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在使用 v-bind 属性绑定期间，如果绑定内容需要进行动态拼接，则字符串的外面应该包裹单引号，例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:title</span>=<span class="string">&quot;&#x27;box&#x27; + index&quot;</span>&gt;</span>这是一个 div<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>要避免没使用大写字符命名动态参数，浏览器会把元素的属性名全部强制值转换为小写字符</p></li></ul><h5 id="绑定-class"><a href="#绑定-class" class="headerlink" title="绑定 class"></a>绑定 class</h5><h6 id="对象语法"><a href="#对象语法" class="headerlink" title="对象语法"></a>对象语法</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">&quot;static&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">:class</span>=<span class="string">&quot;&#123; &#x27;active&#x27;: isActive, &#x27;text-danger&#x27;: hasError &#125;&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">hasError</span>: <span class="literal">false</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;static active&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以在数据属性中单独定义一个对象，然后绑定这个对象，或者考虑绑定一个返回对象的计算属性</p></blockquote><h6 id="数组语法"><a href="#数组语法" class="headerlink" title="数组语法"></a>数组语法</h6><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;[isActive ? activeClass : &#x27;&#x27;, errorClass]&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">isActive</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">activeClass</span>: <span class="string">&quot;active&quot;</span>,</span><br><span class="line">    <span class="attr">errorClass</span>: <span class="string">&quot;text-danger&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>最终渲染结果为：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;active text-danger&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>可以在数组语法中使用对象语法来简化表达式</p></blockquote><h5 id="绑定-style"><a href="#绑定-style" class="headerlink" title="绑定 style"></a>绑定 style</h5><p>对象语法 和 数组语法 依然适用</p><ul><li><p>CSS 属性名可以用 <strong>驼峰式</strong>（camelCase）或 <strong>短横线分隔</strong>（’kebab-case’，记得用<strong>引号</strong>包起来）来命名</p></li><li><p>某些样式的不同浏览器内核前缀，在使用 :style 时 Vue.js 会<strong>自动侦测并添加相应的前缀</strong></p></li><li><p>属性值可以包含多重值（一个数组），只会渲染数组中<strong>最后一个被浏览器支持的值</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; display: [&#x27;-webkit-box&#x27;, &#x27;-ms-flexbox&#x27;, &#x27;flex&#x27;] &#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="事件绑定指令"><a href="#事件绑定指令" class="headerlink" title="事件绑定指令"></a>事件绑定指令</h4><h5 id="v-on"><a href="#v-on" class="headerlink" title="v-on: | @"></a>v-on: | @</h5><p>vue 提供了 v-on 事件绑定指令，用来辅助程序员为 DOM 元素绑定事件监听</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-on:click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过 v-on 绑定的事件处理函数，需要在 <strong>methods</strong> 节点中进行声明，methods 与 data 节点同级</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">methods: &#123;</span><br><span class="line">  add () &#123;</span><br><span class="line">    <span class="built_in">this</span>.count++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>需要传参在方法名后面加括号即可</p></li><li><p>如果在方法中要修改或访问 data 中的数据，可以通过 this 访问到</p></li><li><p>简写是 <code>@</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><blockquote><p>注意：原生 DOM 对象有 onclick、oninput、onkeyup 等原生事件，替换为 vue 的事件绑定形式后，分别为：v-on:click、v-on:input、v-on:keyup</p></blockquote><h5 id="event"><a href="#event" class="headerlink" title="$event"></a>$event</h5><p>vue 提供了内置变量 <strong>$event</strong>，用来表示原生 DOM 的事件参数对象 event</p><p>$event 可以解决事件参数对象 event 被覆盖的问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>count 的值是：&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add(1, $event)&quot;</span>&gt;</span>+N<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">add</span>(<span class="params">n, e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.count += n;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (<span class="built_in">this</span>.count % <span class="number">2</span> == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">          e.target.style.backgroundColor = <span class="string">&quot;red&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          e.target.style.backgroundColor = <span class="string">&quot;&quot;</span>;</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h5><h6 id="事件修饰符"><a href="#事件修饰符" class="headerlink" title="事件修饰符"></a>事件修饰符</h6><blockquote><p>在事件处理函数中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。</p></blockquote><p>vue 提供了事件修饰符的概念，来辅助程序员更方便的对事件的触发进行控制。</p><p>常用的 5 个事件修饰符如下：</p><ul><li><p><strong>.prevent</strong> ：阻止默认行为，调用 event.preventDefault()（例如：阻止 a 连接的跳转、阻止表单的提交等）</p></li><li><p><strong>.stop</strong> ：阻止事件冒泡，调用 event.stopPropagation()</p></li><li><p>.capture ：以捕获模式触发当前的事件处理函数</p><blockquote><p>捕获：由外至内，冒泡：由内至外</p></blockquote></li><li><p>.once ：绑定的事件只触发 1 次</p></li><li><p>.self ：只有在 event.target 是当前元素自身时触发事件处理函数</p></li><li><p><strong>.native</strong> ：监听组件根元素的原生事件</p><p>解决组件根元素没有该原生事件的情况：使用 <strong>$listeners</strong> 属性，是一个对象，里面包含了作用在这个组件上的所有监听器</p><p>可以使用 v-on=”$linsteners” 将组件上的所有事件监听器转发到特定的子元素</p></li><li><p>.passive ：以 { passive: true } 模式添加监听器</p></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.baidu.com&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;show&quot;</span>&gt;</span>跳转到百度首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>修饰符可以串联一起使用，如：</p><ul><li>@click.prevent.self 会阻止所有的单击</li><li>@click.self.prevent 会阻止对元素自身的单击</li></ul></blockquote><h6 id="按键修饰符"><a href="#按键修饰符" class="headerlink" title="按键修饰符"></a>按键修饰符</h6><p>可以为键盘相关的事件添加按键修饰符，用的不多</p><ul><li><strong>.esc</strong> <strong>.enter</strong> .space .tab .delete（捕获删除键和退格键）</li><li>.up .down .left .right 方向键</li><li>.ctrl .alt .shift .meta（对应菜单键）</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.esc</span>=<span class="string">&quot;clearInput&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>注意，修饰键和常见按键并不相同，在和 keyup 事件一起使用时，事件触发时修饰键必须处于按下状态，可以使用 虚拟键代码(即按键对应的数字) 代替</p><h6 id="exact-修饰符"><a href="#exact-修饰符" class="headerlink" title=".exact 修饰符"></a>.exact 修饰符</h6><p>用于精确控制系统修饰符组合触发的事件</p><p>加上 .exact 后，当且仅当满足设置的修饰键时才会触发，如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 按下 ctrl 的同时即使按下其他键，也会触发事件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只有在按住 ctrl 键而不按其他键时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.ctrl.exact</span>=<span class="string">&quot;onCtrlClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 只有在没有按下系统键时才会触发 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.exact</span>=<span class="string">&quot;onClick&quot;</span>&gt;</span>A<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="鼠标按钮修饰符"><a href="#鼠标按钮修饰符" class="headerlink" title="鼠标按钮修饰符"></a>鼠标按钮修饰符</h6><p>.left .middle .right 分别对应鼠标的左键、中键和右键</p><h4 id="双向绑定指令"><a href="#双向绑定指令" class="headerlink" title="双向绑定指令"></a>双向绑定指令</h4><h5 id="v-model"><a href="#v-model" class="headerlink" title="v-model"></a>v-model</h5><p>只有表单元素才可以使用 v-model 指令</p><blockquote><p>比如：input 输入框、textarea、select</p></blockquote><p>v-model 会忽略所有表单元素的 value、checked、selected 属性的初始值，而总是将 Vue 实例的数据属性作为数据来源</p><ul><li>复选框单独使用，v-model 绑定的值是一个布尔值，但多个复选框一起使用时绑定的是一个数组<ul><li>在使用单个复选框时，可以使用 true-value 和 false-value 属性来设置选中和未选中时 v-model 绑定的值</li></ul></li><li>单选按钮被选中时，v-model 绑定的数据属性的值会被设置为该单选按钮的 value 值</li><li>选择框的使用与复选框类似，单选时绑定的是选项的值（option 元素 value 属性的值），多选时绑定到一个数组</li></ul><blockquote><p>value-true、false-true、true 均可以使用 v-bind 指令绑定到数据属性上</p></blockquote><h5 id="专用修饰符"><a href="#专用修饰符" class="headerlink" title="专用修饰符"></a>专用修饰符</h5><ul><li><strong>.number</strong>：自动将用户的输入值转为数值类型</li><li><strong>.trim</strong>：自动过滤用户输入的首尾空白字符</li><li><strong>.lazy</strong>：在 “change” 时而非 “input” 时更新</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;n1&quot;</span> /&gt;</span> +</span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;n2&quot;</span> /&gt;</span> = <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123; n1 + n2 &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="条件渲染指令"><a href="#条件渲染指令" class="headerlink" title="条件渲染指令"></a>条件渲染指令</h4><blockquote><p>如果需要控制多个元素的显示或隐藏、创建或删除，可以用 template 元素来包裹这些元素，然后在 template 元素上使用指令</p></blockquote><h5 id="v-show"><a href="#v-show" class="headerlink" title="v-show"></a>v-show</h5><p>原理是：动态为元素添加或移除 <code>display: none</code> 样式，来实现元素的显示和隐藏</p><ul><li>如果要频繁的切换元素的显示状态，用 v-show 性能会更好</li></ul><h5 id="v-if"><a href="#v-if" class="headerlink" title="v-if"></a>v-if</h5><p>原理是：每次动态创建或移除元素，实现元素的显示和隐藏</p><ul><li>如果刚进入页面的时候，某些元素默认不需要显示，而且后期这个元素很可能也不需要被展示出来，此时 v-if 性能更好</li></ul><blockquote><p>在实际开发中，不用考虑性能问题，直接使用 v-if 即可</p></blockquote><p>v-if 可以单独使用，或配合 v-else 指令一起使用：</p><h5 id="v-else-v-else-if"><a href="#v-else-v-else-if" class="headerlink" title="v-else v-else-if"></a>v-else v-else-if</h5><p>这两个指令均必须配合 v-if 指令一起使用，否则将并不会被识别</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;type === &#x27;A&#x27;&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;B&#x27;&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else-if</span>=<span class="string">&quot;type === &#x27;C&#x27;&quot;</span>&gt;</span>一般<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span>差<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>Vue 会尽可能高效地渲染元素，通常会复用已有元素，而不是从头开始渲染，所以有以下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;请输入你的用户名&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email：&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;请输入你的 Email&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><p>当从 用户名 切换到 Email 时，原先用户名中已输入的值还会保留，因为在切换时，vue 保留了 input 元素，仅仅替换了其 placeholder 属性值</p><p>解决：可以通过为元素添加一个具有唯一值的 <strong>key</strong> 属性</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;template v-if=&quot;loginType === &#x27;username&#x27;&quot;&gt;</span><br><span class="line">  &lt;label&gt;用户名：&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;请输入你的用户名&quot; key=&quot;username-input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;template v-else&gt;</span><br><span class="line">  &lt;label&gt;Email：&lt;/label&gt;</span><br><span class="line">  &lt;input placeholder=&quot;请输入你的 Email&quot; key=&quot;email-input&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure><h4 id="列表渲染指令"><a href="#列表渲染指令" class="headerlink" title="列表渲染指令"></a>列表渲染指令</h4><blockquote><p>如果需要控制多个元素的循环，可以用 template 元素来包裹这些元素，然后在 template 元素上使用指令</p></blockquote><h5 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h5><p>v-for 指令需要使用 <strong>item in items</strong> 形式的特殊语法，其中：</p><ul><li>items 是待循环的数组</li><li>item 是被循环的每一项</li></ul><p>指令还支持一个可选的第二个参数，即当前项的<strong>索引</strong>，语法格式为 <strong>(item, index) in items</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>索引<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>Id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">&quot;(item, index) in list&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; index &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.id &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="v-for-遍历数组"><a href="#v-for-遍历数组" class="headerlink" title="v-for 遍历数组"></a>v-for 遍历数组</h6><blockquote><p>Vue 在检测到数组变化时，并不是直接重新渲染整个列表，而是最大化地复用 DOM 元素，替换的数组中，含有相同元素的项不会被重新渲染，无需担心性能问题。</p></blockquote><p>需要注意，以下方法引起的数组变动，Vue 不能检测到：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过索引直接设置数组项</span></span><br><span class="line">vm.books[<span class="number">0</span>] = &#123; <span class="attr">title</span>: <span class="string">&quot;Java Web 开发详解&quot;</span> &#125;;</span><br><span class="line"><span class="comment">// 修改数组的长度</span></span><br><span class="line">vm.books.length = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>解决办法：</p><ul><li><p>使用 Vue 全局的 <strong>set()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(vm.books, <span class="number">0</span>, &#123; <span class="attr">title</span>: <span class="string">&quot;Java Web 开发详解&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 Vue 实例的 <strong>$set()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$set(vm.books, <span class="number">0</span>, &#123; <span class="attr">title</span>: <span class="string">&quot;Java Web 开发详解&quot;</span> &#125;);</span><br></pre></td></tr></table></figure></li><li><p>使用 数组的 <strong>splice()</strong> 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vm.books.splice(<span class="number">0</span>, <span class="number">1</span>, &#123; <span class="attr">title</span>: <span class="string">&quot;Java Web 开发详解&quot;</span> &#125;); <span class="comment">// 等同于通过索引修改数组</span></span><br><span class="line">vm.books.splice(<span class="number">1</span>); <span class="comment">// 修改数组长度</span></span><br></pre></td></tr></table></figure></li></ul><h6 id="v-for-遍历对象"><a href="#v-for-遍历对象" class="headerlink" title="v-for 遍历对象"></a>v-for 遍历对象</h6><p>格式相同，为 <strong>value in object</strong>，可以按需添加参数 <strong>(value, key, index) in object</strong></p><ul><li>value 代表属性值</li><li>key 表示属性名</li><li>index 表示索引</li></ul><p>同样需要注意，由于 JavaScript 的限制，Vue 不能检测对象属性的添加和删除</p><p>解决办法：</p><ul><li><p>使用 Vue 全局的 <strong>set()</strong> 和 <strong>delete()</strong> 方法 或 Vue 实例的 <strong>$set()</strong> 和 <strong>$delete()</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vue.set(对象名, <span class="string">&quot;属性名&quot;</span>, <span class="string">&quot;属性值&quot;</span>);</span><br><span class="line">vm.$set(对象名, <span class="string">&quot;属性名&quot;</span>, <span class="string">&quot;属性值&quot;</span>);</span><br><span class="line">Vue.delete(对象名, <span class="string">&quot;属性名&quot;</span>);</span><br><span class="line">vm.$delete(对象名, <span class="string">&quot;属性名&quot;</span>);</span><br></pre></td></tr></table></figure></li></ul><h6 id="v-for-遍历整数"><a href="#v-for-遍历整数" class="headerlink" title="v-for 遍历整数"></a>v-for 遍历整数</h6><p>v-for 指令也可以接受整数，会把模板重复对应次数</p><h5 id="key-1"><a href="#key-1" class="headerlink" title="key"></a>key</h5><p>官方建议：只要用到了 v-for 指令，那么一定要绑定一个 :key 属性，而且尽量把 id 作为 key 的值</p><p>key 值的要求：</p><ol><li><p><strong>字符串</strong>或<strong>数字</strong>类型</p></li><li><p>key 的值必须具有<strong>唯一性</strong>（即：key 的值不能重复，否则会报错）</p><blockquote><p>[Vue warn]: Duplicate keys detected: ‘ ‘.</p></blockquote></li><li><p>建议把数据项 <strong>id 属性</strong>的值作为 key 的值（因为 id 属性的值具有唯一性）</p></li><li><p><strong>使用 index 的值当作 key 的值没有任何意义</strong>（因为 index 的值不具有唯一性）</p><ul><li>当列表项发生变化时，索引可能会前向推进，单个不唯一</li></ul></li><li><p>建议使用 v-for 指令时一定要指定 key 的值（既提升性能、又防止列表状态紊乱）</p></li></ol><blockquote><p>不建议将 v-for 和 v-if 用在同一个元素上，可以用计算属性替代</p></blockquote><h3 id="filters-过滤器"><a href="#filters-过滤器" class="headerlink" title="filters 过滤器"></a>filters 过滤器</h3><blockquote><p>Vue3 中已经不可以使用内置过滤器(已删除)，Vue2 中仍可以</p></blockquote><p>过滤器（Filters）是 vue 为开发者提供的功能，常用于<strong>文本的格式化</strong>，或者数组数据的过滤与排序等。</p><p>过滤器可以用在两个地方：<strong>插值表达式</strong>和 <strong>v-bind 属性绑定</strong>；</p><p>过滤器应该被添加在 JavaScript 表达式的尾部，由 “管道符” <code>|</code> 进行调用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 在插值表达式中调用 capitalize 过滤器，对 message 的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message | capitalize &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 在 v-bind: 中调用 formatId 过滤器，对 rawId 的值进行格式化 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">v-bind:id</span>=<span class="string">&quot;rawId | formatId&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意点：</p><ul><li>在 filters 节点中定义私有过滤器，本质是一个函数</li><li>过滤器函数形参中的第一个参数，永远都是“管道符”前面的那个值，其他参数从第二个开始接收</li><li>过滤器中必须有一个 return 值</li><li>过滤器可以多个串联使用</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 过滤器函数，定义到 filters 节点之下，是私有过滤器</span></span><br><span class="line"><span class="attr">filters</span>: &#123;</span><br><span class="line">  <span class="comment">// 注意：过滤器函数形参中的 val，永远都是“管道符”前面的那个值</span></span><br><span class="line">  capitalize (val) &#123;</span><br><span class="line">    <span class="comment">// 过滤器中必须有一个返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.filter(<span class="string">&quot;capitalize&quot;</span>, <span class="function">(<span class="params">str</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> str.charAt(<span class="number">0</span>).toUpperCase() + str.slice(<span class="number">1</span>);</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>一般使用的都是全局过滤器</p><p>全局和私有过滤器名字一致，此时按照就近原则，调用的是私有过滤器</p><h2 id="directives-自定义指令"><a href="#directives-自定义指令" class="headerlink" title="directives 自定义指令"></a>directives 自定义指令</h2><p>vue 官方提供了 v-text、v-for、v-model、v-if 等常用的指令。除此之外 vue 还允许开发者自定义指令</p><ul><li><p>在使用自定义指令时，需要加上 <strong>v-</strong> 前缀</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-volor</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在 template 结构中使用自定义指令时，可以通过等号 <strong>=</strong> 的方式，为当前指令动态绑定参数值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">v-color</span>=<span class="string">&quot;color&quot;</span>&gt;</span>内容<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>私有自定义指令</li><li>全局自定义指令</li></ul><h3 id="私有自定义指令"><a href="#私有自定义指令" class="headerlink" title="私有自定义指令"></a>私有自定义指令</h3><p>在每个 vue 组件中，可以在 <strong>directives</strong> 节点下声明私有自定义指令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  <span class="attr">color</span>: &#123;</span><br><span class="line">    bind (el) &#123;</span><br><span class="line">      el.style.color = <span class="string">&#x27;pink&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全局自定义指令"><a href="#全局自定义指令" class="headerlink" title="全局自定义指令"></a>全局自定义指令</h3><p>全局共享的自定义指令通过 <strong>Vue.directive()</strong> 进行声明</p><p>接受两个参数，第一个为 指令的 ID（即名字），第二个是一个定义对象或者函数对象，指令要实现的功能在这个对象中定义</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.directive(<span class="string">&quot;name&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>一般使用自定义指令，都会定义在 全局上</p></blockquote><h3 id="钩子函数"><a href="#钩子函数" class="headerlink" title="钩子函数"></a>钩子函数</h3><h4 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h4><ul><li><strong>bind</strong>：只调用一次，当指令第一次绑定到元素时调用，当 DOM 更新时 bind 函数不会被触发。</li><li>inserted：被绑定元素插入父节点时调用</li><li><strong>update</strong>：所在的组件的 VNode 更新时调用（无论指令的值是否发生了变化），但可能发生在子 VNode 更新之前</li><li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用</li><li>unbind：只调用一次，指令与元素解绑时调用</li></ul><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><ol><li><strong>el</strong> ：指令所绑定的元素，可以用来直接操作 DOM</li><li><strong>binding</strong> ：一个对象，包含以下属性：<ul><li>name：指令名，不包含 v- 前缀</li><li><strong>value</strong>：指令的绑定值，如果是表达式则 value 的值是最后的结果</li><li>oldValue：指令绑定的前一个值，仅在 update 和 componentUpdated 钩子函数中可用</li><li>expression：字符串形式的指令表达式，与 value 不同</li><li>arg：传给指令的参数，可选</li><li>modifiers：一个包含修饰符的对象</li></ul></li><li>vnode ：Vue 编译生成的虚拟节点</li><li>oldVnode ：上一个虚拟节点，仅在 update 和 componentUpdated 钩子函数中可用</li></ol><blockquote><p>除 el 参数以外，其他参数都是只读的，不可进行修改</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  <span class="attr">color</span>: &#123;</span><br><span class="line">    bind (el, binding) &#123;</span><br><span class="line">      el.style.color = binding.value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：第二个参数中的 expression 值代表用户在 自定义指令后面输入的内容或表达式，而 value 才是可以获取到使用的值</p></blockquote><h4 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h4><p>如果 bind 和 update 函数中的逻辑完全相同，且只需要用到这两个钩子函数，则对象格式的自定义指令可以简写成函数格式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">  color (el, binding) &#123;</span><br><span class="line">    el.style.color = binding.value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">Vue.directive(<span class="string">&#x27;font-weight&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">el, binding</span>) </span>&#123;</span><br><span class="line">  el.style.fontWeight = binding.value</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="watch-监听器"><a href="#watch-监听器" class="headerlink" title="watch 监听器"></a>watch 监听器</h2><p>在 Vue 实例的选项对象的 <strong>watch</strong> 选项中定义</p><p>当需要在数据变化时执行异步或开销较大的操作时，使用监听器是最合适的</p><h3 id="方法格式的监听器"><a href="#方法格式的监听器" class="headerlink" title="方法格式的监听器"></a>方法格式的监听器</h3><p>缺点：</p><ol><li>无法在刚进到页面的时候自动触发</li><li>如果侦听的是一个对象，如果对象中的属性发生了变化，不会触发监听器</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">username</span>: <span class="string">&quot;&quot;</span> &#125;,</span><br><span class="line">  <span class="comment">// 所有的侦听器都应该被定义到 watch 节点下</span></span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 侦听器本质上是一个函数，要监视哪个数据的变化，就把数据名作为方法名即可</span></span><br><span class="line">    <span class="function"><span class="title">username</span>(<span class="params">newVal, oldVal</span>)</span> &#123;</span><br><span class="line">      <span class="comment">// ...</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果要侦听的是对象的子属性：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">  <span class="comment">// 如果要侦听的是对象的子属性，则必须包裹一层单引号</span></span><br><span class="line">  <span class="string">&#x27;info.username&#x27;</span> (newVal) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(newVal)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>优先考虑使用方法格式的，如若满足不了需求再改用对象格式的</p></blockquote><h3 id="对象格式的监听器"><a href="#对象格式的监听器" class="headerlink" title="对象格式的监听器"></a>对象格式的监听器</h3><p>好处：</p><ol><li>可以通过 <strong>immediate</strong> 选项控制自动触发一次</li><li>可以通过 <strong>deep</strong> 选项控制开启深度侦听，可以侦听到对象中子属性的变化</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">info</span>: &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">watch</span>: &#123;</span><br><span class="line">    <span class="comment">// 定义对象格式的侦听器</span></span><br><span class="line">    <span class="attr">info</span>: &#123;</span><br><span class="line">      <span class="function"><span class="title">handler</span>(<span class="params">newVal, oldVal</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// immediate 选项的默认值是 false</span></span><br><span class="line">      <span class="comment">// 作用是：控制侦听器是否自动触发一次</span></span><br><span class="line">      <span class="attr">immediate</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="comment">// deep 作用是：开启深度侦听</span></span><br><span class="line">      <span class="attr">deep</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="computed-计算属性"><a href="#computed-计算属性" class="headerlink" title="computed 计算属性"></a>computed 计算属性</h2><p>表达式的逻辑过于复杂时，都应当考虑使用计算属性</p><p>计算属性指的是通过一系列运算之后，最终得到一个属性值，这个动态计算出来的属性值可以被 模板结构 或 methods 方法使用</p><h3 id="定义使用"><a href="#定义使用" class="headerlink" title="定义使用"></a>定义使用</h3><ul><li>要定义在 computed 节点之下，与 data 同级</li><li>计算属性在定义时要定义成“方法格式”</li><li>return 的值就是计算结果</li><li>使用时与使用 data 中属性值一样</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">rgb</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="string">`rgb(<span class="subst">$&#123;<span class="built_in">this</span>.r&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.g&#125;</span>, <span class="subst">$&#123;<span class="built_in">this</span>.b&#125;</span>)`</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="计算属性缓存"><a href="#计算属性缓存" class="headerlink" title="计算属性缓存"></a>计算属性缓存</h3><p>计算属性是基于它的响应式依赖进行缓存的，只有在计算属性的相关响应式依赖发生改变时才会重新求值</p><h3 id="v-if-和-v-for-一起使用的替代方案"><a href="#v-if-和-v-for-一起使用的替代方案" class="headerlink" title="v-if 和 v-for 一起使用的替代方案"></a>v-if 和 v-for 一起使用的替代方案</h3><p>采用计算属性过滤后再遍历，好处：</p><ul><li>过滤后只会在要循环的数据发生变化时才被重新计算，过滤更高效</li><li>渲染只会遍历符合计算属性中条件的，渲染更高效</li><li>解耦渲染层的逻辑，可维护性（<strong>对逻辑的更改和扩展</strong>）更强</li></ul><h2 id="component-组件"><a href="#component-组件" class="headerlink" title="component 组件"></a>component 组件</h2><p>组件 – 对 UI 结构的复用</p><p>组件化开发 – 根据封装的思想，把页面上可重用的 UI 结构封装为组件，从而方便项目的开发和维护</p><h3 id="组成结构"><a href="#组成结构" class="headerlink" title="组成结构"></a>组成结构</h3><p>单文件组件的组成结构：</p><ul><li>template -&gt; 组件的模板结构</li><li>script -&gt; 业务逻辑区域，组件的 JavaScript 行为</li><li>style -&gt; 样式区域</li></ul><p>语法结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;!-- 这里用来定义 Vue 组件的 模板内容 --&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">// 这里用来定义 Vue 组件的 业务逻辑</span><br><span class="line">// 默认导出，这是固定写法！</span><br><span class="line">export default &#123;</span><br><span class="line">  data: () &#123; return &#123;&#125; &#125;, // 私有数据</span><br><span class="line"> method: &#123;&#125; // 处理函数</span><br><span class="line">// ... 其他业务逻辑</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;style lang=&quot;&quot;&gt;</span><br><span class="line">/* 这里用于定义Vue组件的样式 */</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure><ul><li>.vue 组件中的 data 不能像之前一样，不能指向对象，<strong>组件中的对象必须是一个函数</strong></li><li>在组件中，this 表示当前组件的实例对象</li><li>style 中 加 lang 属性可以使用指定语法编写样式，例： <code>&lt;style lang=&quot;less&quot;&gt;&lt;/style&gt;</code></li></ul><p>除了以上在 template 标签内定义 模板内容 外，还有其他两种方式：</p><ol><li><p>内联模板：在子组件上使用一个特殊的属性 inline-template，使得这个组件将使用其元素标签内容作为模板，而不是分发到子组件 solt 中</p><ul><li>inline-template 的使用会让模板的作用域变得更加难以理解，所以不推荐使用</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span> <span class="attr">inline-template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me &#123;&#123; count &#125;&#125; times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;ButtonCounter&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>X-Template：把模板的内容放到 script 元素中，在 script 元素上使用 type=”text/x-template”，并指定一个 id 值，随后在组件的 template 选项中使用 #id 的形式来引用模板</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button-counter</span>&gt;</span><span class="tag">&lt;/<span class="name">button-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/x-template&quot;</span> <span class="attr">id</span>=<span class="string">&quot;btn-counter&quot;</span>&gt;</span><span class="handlebars"><span class="xml"></span></span></span><br><span class="line"><span class="xml"><span class="handlebars">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;count++&quot;</span>&gt;</span>You clicked me </span><span class="template-variable">&#123;&#123; <span class="name">count</span> &#125;&#125;</span><span class="xml"> times.<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span></span><br><span class="line"><span class="xml"><span class="handlebars"></span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;ButtonCounter&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">count</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&quot;#btn-counter&quot;</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="使用组件的步骤"><a href="#使用组件的步骤" class="headerlink" title="使用组件的步骤"></a>使用组件的步骤</h3><h4 id="1-import-导入"><a href="#1-import-导入" class="headerlink" title="1. import 导入"></a>1. import 导入</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Left <span class="keyword">from</span> <span class="string">&quot;@/components/Left.vue&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>在 vue 中 @ 默认指向 src 根目录</p></blockquote><blockquote><p>vscode 中 @ 路径提示插件：Path Intellisense</p><p>使用步骤：</p><ol><li><p>在插件中搜索 Path Intellisense 安装并启用</p></li><li><p>在 vscode 设置文件 settings.json 中添加设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 导入文件时是否携带文件的扩展名</span></span><br><span class="line">  <span class="attr">&quot;path-autocomplete.extensionOnImport&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 配置 @ 的路径显示</span></span><br><span class="line">  <span class="attr">&quot;path-autocomplete.pathMappings&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;@&quot;</span>: <span class="string">&quot;$&#123;folder&#125;/src&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意点：要在 vue 中使用此插件，则必须保证 vscode 中打开的就是这个项目</p></blockquote><h4 id="2-注册组件"><a href="#2-注册组件" class="headerlink" title="2. 注册组件"></a>2. 注册组件</h4><p>使用 <strong>components</strong> 节点注册的是 私有子组件，只有本界面能用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    Left,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="注册全局组件"><a href="#注册全局组件" class="headerlink" title="注册全局组件"></a>注册全局组件</h5><p>通过 <strong>Vue.component()</strong> 方法，注册全局组件</p><p>接受两个参数，第一个为组件的名字，第二个是一个函数对象（使用 Vue.extend() 方法创建的组件构造器），也可以是一个选项对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;Left&quot;</span>, Left);</span><br><span class="line">Vue.component(<span class="string">&quot;name&quot;</span>, [definition]);</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;ButtonCounter&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>:</span><br><span class="line">    <span class="string">&#x27;&lt;button @click=&quot;count++&quot;&gt;You clicked me &#123;&#123; count &#125;&#125; times.&lt;/button&gt;&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>Vue.extend()</strong> 方法接受一个参数，包含组件选项的对象，也就是 Vue.component() 方法中要接受的第二个参数格式，会生成一个<strong>组件构造器</strong></p><h4 id="3-以标签形式使用"><a href="#3-以标签形式使用" class="headerlink" title="3. 以标签形式使用"></a>3. 以标签形式使用</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">Left</span>&gt;</span><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>vscode 自动闭合标签插件：Auto Close Tag，不需要配置。</p></blockquote><h3 id="prop-props"><a href="#prop-props" class="headerlink" title="prop - props"></a>prop - props</h3><p>props 是组件的自定义属性</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">zujian</span> <span class="attr">:init</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="comment">// props 是&quot;自定义属性&quot;，允许使用者通过自定义属性，为当前组件指定初始值</span></span><br><span class="line">  <span class="comment">// 自定义属性的名字，是封装者自定义的（只要名称合法即可）</span></span><br><span class="line">  <span class="comment">// props 中的数据，可以直接在模板结构中作为数据属性被使用</span></span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&#x27;属性值1&#x27;</span>, <span class="string">&#x27;属性值2&#x27;</span>, ...]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="只读性"><a href="#只读性" class="headerlink" title="只读性"></a>只读性</h4><p>props 是<strong>只读的</strong>，不能直接修改 props 的值，否则终端会报错！</p><p>要想修改 props 的值，可以</p><ol><li>把 props 的值转存到 data 中，因为 data 中的数据都是可读可写的</li><li>如果接受数据后需要转换后使用，可以使用计算属性解决</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;init&quot;</span>],</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 把 props 中的 init 值，转存到 count 上</span></span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.init,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="prop-验证"><a href="#prop-验证" class="headerlink" title="prop 验证"></a>prop 验证</h4><p>可以使用 type default required 属性添加验证，或者也可以自定义验证函数</p><h5 id="type-值类型"><a href="#type-值类型" class="headerlink" title="type 值类型"></a>type 值类型</h5><p>在声明自定义属性时，可以通过 <strong>type</strong> 来定义属性的值类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">init</span>: &#123;</span><br><span class="line">      <span class="comment">// 表示 init 的值类型必须是 Number 数字</span></span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Number</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>仅判断类型：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">init</span>: <span class="built_in">Number</span>,</span><br><span class="line">    <span class="comment">// 多种可能的类型</span></span><br><span class="line">    <span class="attr">tel</span>: [<span class="built_in">String</span>, <span class="built_in">Number</span>],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>注意：null 和 undefined 会通过任何类型验证</p></blockquote><p>验证的 type 可以是右侧的原生构造函数：String、Number、Boolean、Array、Object、Date、Function、Symbol</p><p>也可以是一个自定义的构造函数</p><h5 id="default-默认值"><a href="#default-默认值" class="headerlink" title="default 默认值"></a>default 默认值</h5><p>在声明自定义属性时，可以通过 <strong>default</strong> 来定义属性的默认值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="comment">// 自定义属性A: &#123; /* 配置选项 */ &#125;</span></span><br><span class="line">    <span class="attr">init</span>: &#123;</span><br><span class="line">      <span class="comment">// 如果外界使用 Count 组件的时候，没有传递 init 属性，则默认值生效</span></span><br><span class="line">      <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="required-必填项"><a href="#required-必填项" class="headerlink" title="required 必填项"></a>required 必填项</h5><p>在声明自定义属性时，可以通过 <strong>required</strong> 选项，将属性设置为必填项，强制用户必须传递属性的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">init</span>: &#123;</span><br><span class="line">      <span class="comment">// 必填项校验</span></span><br><span class="line">      <span class="attr">required</span>: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="非-prop-属性"><a href="#非-prop-属性" class="headerlink" title="非 prop 属性"></a>非 prop 属性</h4><p>在组件中定义的非 prop 属性：</p><ul><li>class 和 type 会合并</li><li>其他属性都是从外部提供给组件的值会替换掉组件内部设置好的值</li></ul><blockquote><p>如果不希望组件的根元素继承外部设置的属性，可以在组件的选项中设置： inheritAttrs: false</p></blockquote><h4 id="sync-修饰符"><a href="#sync-修饰符" class="headerlink" title=".sync 修饰符"></a>.sync 修饰符</h4><p>对一个组件的 prop 进行双向绑定，vue 中推荐使用 update:myPropName 模式触发事件来实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;child&quot;</span>, &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">count</span>: <span class="built_in">this</span>.val,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">val</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: Nmuber,</span><br><span class="line">      <span class="attr">default</span>: <span class="number">0</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">handleClick</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&quot;update:val&quot;</span>, ++<span class="built_in">this</span>.count);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">template</span>: <span class="string">`&lt;div&gt;</span></span><br><span class="line"><span class="string">&lt;span&gt;计数：&#123;&#123; val &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="string">&lt;button @click=&quot;handleClick&quot;&gt;增加计数&lt;/button&gt;</span></span><br><span class="line"><span class="string">&lt;/div&gt;`</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>计数器的值： &#123;&#123; counter &#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:val</span>=<span class="string">&quot;counter&quot;</span> <span class="attr">v-on:update:val</span>=<span class="string">&quot;counter = $event&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">data</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">counter</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>$event 是自定义事件的附加参数！</p></blockquote><p>.sync 的作用就是简化这个方式的书写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">child</span> <span class="attr">v-bind:val.sync</span>=<span class="string">&quot;counter&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>.sync 只是简化了上面 child 元素的 v-bind 和 v-on 指令的使用，对于子组件来说，该有的定义和事件必不可少</li><li>带有 .sync 修饰符的 v-bind 不能和表达式一起使用（类似于 v-model）</li><li>不能将 v-bind.sync 使用在一个字面量对象上，无法正常工作</li></ol><h4 id="自定义组件的-v-model"><a href="#自定义组件的-v-model" class="headerlink" title="自定义组件的 v-model"></a>自定义组件的 v-model</h4><p>默认情况下一个组件上的 v-model 会把 value 作为 prop，把 input 事件作为 event</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&#x27;MyCheckBox&#x27;</span>, &#123;</span><br><span class="line">  <span class="attr">model</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用 checked 替换 value 作为 prop</span></span><br><span class="line">    <span class="attr">prop</span>: <span class="string">&#x27;checked&#x27;</span>,</span><br><span class="line">    <span class="attr">event</span>: <span class="string">&#x27;change&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="built_in">String</span>,</span><br><span class="line">    <span class="comment">// props 中仍需声明</span></span><br><span class="line">    <span class="attr">checked</span>: &#123;</span><br><span class="line">      <span class="attr">type</span>: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="attr">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="组件之间的样式冲突问题"><a href="#组件之间的样式冲突问题" class="headerlink" title="组件之间的样式冲突问题"></a>组件之间的样式冲突问题</h3><p>默认情况下，写在 .vue 组件中的样式会<strong>全局生效</strong>，因此很容易造成多个组件之间的样式冲突问题</p><p>导致组件之间样式冲突的根本原因是：</p><ol><li>单页面应用程序中，所有组件的 DOM 结构，都是基于唯一的 index.html 页面进行呈现的</li><li>每个组件中的样式，都会影响整个 index.html 页面中的 DOM 元素</li></ol><h4 id="scoped-解决"><a href="#scoped-解决" class="headerlink" title="scoped 解决"></a>scoped 解决</h4><p>为了提高开发效率和开发体验，vue 为 style 节点提供了 <strong>scoped</strong> 属性，从而防止组件之间的样式冲突问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="comment">/* 样式 */</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原理：</p><ol><li>每个组件中的元素有特定的唯一的 data-v-xxx 属性</li><li>每个组件中的样式后面均跟上 <strong>属性选择器</strong> <code>[]</code> 即可</li></ol><h4 id="deep-样式穿透"><a href="#deep-样式穿透" class="headerlink" title="/deep/ 样式穿透"></a>/deep/ 样式穿透</h4><p>如果给当前组件的 style 节点添加了 scoped 属性，则当前组件的样式对其子组件是不生效的</p><p>如果想让某些样式对子组件生效，可以使用 <strong>/deep/</strong> 深度选择器</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  /deep/ <span class="selector-class">.title</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">color</span>: pink;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>原理：</p><ul><li>不加 /deep/ 时，生成的选择器格式为 <code>.title[data-v-xxx]</code></li><li>加上 /deep/ 时，生成的选择器格式为 <code>[data-v-xxx] .title</code></li></ul><blockquote><p>注：当使用第三方组件库时，如果有修改组件默认样式的需求，需要用到 /deep/</p></blockquote><h3 id="组件的生命周期"><a href="#组件的生命周期" class="headerlink" title="组件的生命周期"></a>组件的生命周期</h3><h4 id="生命周期-amp-生命周期函数"><a href="#生命周期-amp-生命周期函数" class="headerlink" title="生命周期 &amp; 生命周期函数"></a>生命周期 &amp; 生命周期函数</h4><p>生命周期（Life Cycle）是指一个组件从 创建 -&gt; 运行 -&gt; 销毁 的整个阶段，强调的是一个时间段</p><p>生命周期函数：是由 vue 框架提供的内置函数，会伴随着组件的生命周期，自动按次序执行</p><blockquote><p>注意：生命周期强调的是时间段，生命周期函数强调的是时间点</p></blockquote><h4 id="组件生命周期函数的分类"><a href="#组件生命周期函数的分类" class="headerlink" title="组件生命周期函数的分类"></a>组件生命周期函数的分类</h4><p>new Vue() -&gt;</p><p>组件创建阶段：beforeCreate -&gt; <strong>created</strong> -&gt; beforeMount -&gt; <strong>mounted</strong> -&gt;</p><p>组件运行阶段：beforeUpdate -&gt; <strong>updated</strong> -&gt;</p><p>组件销毁阶段：beforeDestory -&gt; destoryed</p><ul><li><p>beforeCreate：在实例初始化之后，数据观测和事件/监听器配置之前被调用。</p><ul><li>此时 Vue 实例的挂载元素 $el 和 数据对象 data 都为 undefined，还未初始化</li><li>可以在这一阶段添加 loading 事件</li></ul></li><li><p>created：在实例创建完成后立即调用</p><ul><li>数据观测、计算属性、方法、watch/event 回调 已经被配置</li><li>挂载阶段还没有开始，$el 属性目前还不可用</li><li>this.data 已经可以访问</li><li>可以在这一阶段结束 loading，请求数据为 mounted 渲染做准备</li></ul></li><li><p>beforeMount：在挂载开始之前调用，render 函数首次被调用</p><ul><li>此时 DOM 还无法操作</li><li>相较于 created 钩子，这一阶段只是多了一个 $el 属性，但其值仍是 undefined</li></ul></li><li><p>mounted：在实例被挂载后调用</p><ul><li><p>el 被新创建的 vm.$el 替换</p></li><li><p>元素已完成渲染，有依赖于 DOM 的代码可以放在这里</p></li><li><p>可以在这个钩子中项服务端发起请求，获取数据</p><blockquote><p>注意：mounted 并不保证所有的子组件已挂载，如果要等到整个视图渲染完毕，可以在 mounted 钩子中使用 vm.<strong>$nextTick</strong>（后面有介绍）</p></blockquote></li></ul></li><li><p>beforeUpdate：在修改 DOM 之前，当数据更改时调用</p><ul><li>适合在更新之前访问现有的 DOM</li><li>可以在这个钩子中进一步修改 Vue 实例的数据属性，而不会触发额外的重新渲染过程</li></ul></li><li><p>updated：在数据更改导致的虚拟 DOM 被重新渲染和修补后调用</p><ul><li><p>调用时，DOM 已经被更新</p><blockquote><p>注意：updated 并不保证所有的子组件已重新渲染，如果要等到整个视图渲染完毕，可以在 updated 钩子中使用 vm.<strong>$nextTick</strong>（后面有介绍）</p></blockquote></li></ul></li><li><p>beforeDestroy：在 Vue 实例被销毁之前调用</p><ul><li>在这一阶段，实例仍然是完全可用的</li></ul></li><li><p>destroyed：在 Vue 实例被销毁后调用</p><ul><li>Vue 实例的所有指令已解除绑定，所有的事件监听器已移除，所有的子实例已销毁</li></ul></li></ul><blockquote><p><a href="https://cn.vuejs.org/images/lifecycle.png">https://cn.vuejs.org/images/lifecycle.png</a> 生命周期图示</p></blockquote><img src="/2021/08/14/vue%E7%AC%94%E8%AE%B0/lifesycle.png" class title="lifesycle"><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul><li>activated：当 keep-alive 组件激活时调用</li><li>deactivated：当 keep-alive 组件停用时调用</li><li>errorCaptured：当捕获一个来自任何后代组件的错误时被调用<ul><li>接受三个参数：错误对象、发生错误的组件实例、一个包含错误来源信息的字符串</li><li>该钩子可以返回 false，阻止错误的进一步传播</li></ul></li></ul><h3 id="组件间的数据共享"><a href="#组件间的数据共享" class="headerlink" title="组件间的数据共享"></a>组件间的数据共享</h3><h4 id="组件间的关系"><a href="#组件间的关系" class="headerlink" title="组件间的关系"></a>组件间的关系</h4><blockquote><p>组件在被分装好之后，彼此之间是相互独立的，不存在关系</p></blockquote><p>在使用组件时，根据彼此的嵌套关系，形成了 父子关系、兄弟关系</p><h4 id="父子组件间数据共享"><a href="#父子组件间数据共享" class="headerlink" title="父子组件间数据共享"></a>父子组件间数据共享</h4><h5 id="父向子共享数据"><a href="#父向子共享数据" class="headerlink" title="父向子共享数据"></a>父向子共享数据</h5><p>父组件向子组件共享数据需要使用<strong>自定义属性</strong></p><ul><li>父组件中使用 v-bind: 传递数据</li><li>子组件中通过 props 接收数据</li></ul><h5 id="子向父共享数据"><a href="#子向父共享数据" class="headerlink" title="子向父共享数据"></a>子向父共享数据</h5><p>子组件向父组件共享数据使用<strong>自定义事件</strong></p><p>子组件使用 <strong>$emit()</strong> 方法触发事件，父组件使用 <strong>v-on</strong> 指令监听子组件的自定义事件</p><p>$emit() 方法的语法形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.$emit(eventName, [...args]);</span><br></pre></td></tr></table></figure><ul><li>eventName 是事件名</li><li>args 是附加参数，会传递给监听器的回调函数</li></ul><p>子组件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">count</span>: <span class="number">0</span> &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.count++;</span><br><span class="line">      <span class="comment">// 修改数据时，通过 $emit() 触发自定义事件</span></span><br><span class="line">      <span class="built_in">this</span>.$emit(<span class="string">&quot;numchange&quot;</span>, <span class="built_in">this</span>.count);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>父组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Son</span> @<span class="attr">numchange</span>=<span class="string">&quot;getNewCount&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Son</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123; <span class="attr">countFromSon</span>: <span class="number">0</span> &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 自定义事件的附加参数会自动传入方法</span></span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">getNewCount</span>(<span class="params">val</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.countFromSon = val;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>@click 事件是由 this.$emit(‘click’, {…}) 触发的</p></blockquote><h4 id="兄弟组件间的数据共享"><a href="#兄弟组件间的数据共享" class="headerlink" title="兄弟组件间的数据共享"></a>兄弟组件间的数据共享</h4><p>在 vue2.x 中，兄弟组件之间数据共享的方案是 <strong>EventBus</strong></p><p>使用步骤：</p><ol><li><p>创建 eventBus.js 模块，并向外共享一个 Vue 的实例对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外共享 Vue 的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vue();</span><br></pre></td></tr></table></figure></li><li><p>在数据发送方，调用 <code>bus.$emit(&#39;事件名称&#39;, 要发送的数据)</code> 方法触发<strong>自定义事件</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">&quot;./eventBus.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;hello vue.js&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">sendMsg</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      bus.$emit(<span class="string">&quot;share&quot;</span>, <span class="built_in">this</span>.msg);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在数据接收方，在 <strong>created</strong> 生命周期函数中调用 <code>bus.$on(&#39;事件名称&#39;, 事件处理函数)</code> 方法注册一个自定义事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bus <span class="keyword">from</span> <span class="string">&quot;./eventBus.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">msgFromLeft</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    bus.$on(<span class="string">&quot;share&quot;</span>, <span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">this</span>.msgFromLeft = val;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h4 id="手动监听事件"><a href="#手动监听事件" class="headerlink" title="手动监听事件"></a>手动监听事件</h4><p>除了 $emit() 以外，Vue 还提供了以下三个事件方法：</p><ul><li>$on(eventName, eventHandler) ：监听当前实例上的自定义事件，事件可由 vm.$emit 触发</li><li>$once(eventName, eventHandler) ：与 $.on 相同，但是只触发一次，一旦触发之后，监听器就会被删除</li><li>$off(eventName, eventHandler) ：删除自定义事件监听器</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">child</span>&gt;</span><span class="tag">&lt;/<span class="name">child</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;child&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    created () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 监听当前实例的 greet 事件</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$on(<span class="string">&#x27;greet&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$parent.sayHello()</span></span><br><span class="line"><span class="javascript">      &#125;)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    beforeDestroy () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 删除 greet 事件的所有监听器</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$off(<span class="string">&#x27;greet&#x27;</span>)</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      handleClick () &#123;</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 触发自定义事件 greet</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$emit(<span class="string">&#x27;greet&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">&#x27;&lt;button @click=&quot;handleClick&quot;&gt;手动监听事件&lt;/button&gt;&#x27;</span></span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> vm = <span class="keyword">new</span> VUe(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">methods</span>: &#123;</span></span><br><span class="line"><span class="javascript">      sayHello () &#123;</span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&#x27;HELLO AGONILAY&#x27;</span>)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="组件通讯的其他方式"><a href="#组件通讯的其他方式" class="headerlink" title="组件通讯的其他方式"></a>组件通讯的其他方式</h4><p>总结常用的组件通讯的方式：</p><ul><li>父组件通过 prop 向子组件传递数据</li><li>子组件通过自定义事件向父组件发起通知或进行数据传递</li><li>子组件通过 slot 元素充当占位符，获取父组件分发的内容；也可以子啊子组件的 solt 元素上使用 v-bind 指令绑定一个插槽 prop，向父组件提供数据</li></ul><p>其他方式：</p><ol><li><p><strong>$root</strong> 访问根实例：在每一个 new Vue() 实例的子组件中，都可以通过 $root 属性来访问根实例</p><ul><li>不管组件是根实例的子组件，还是更深层级的后代组件，$root 属性总是代表了根实例</li></ul></li><li><p><strong>$parent</strong> 访问父组件实例：在一个子组件中访问父组件的实例，可以代替父组件通过 prop 向子组件传数据的方式</p><ul><li>只能应用于访问父组件实例，如果父组件之上还有父组件，那么该组件通过 $parent 是访问不到的</li></ul></li><li><p><strong>$refs</strong> 访问子组件实例或子元素：为子元素或子组件添加一个 ref 属性，分配一个 引用 ID</p><ul><li>$refs 属性只在组件渲染之后生效，并且不是响应式的</li><li>要避免在模板和计算属性中访问 $refs</li></ul></li><li><p><strong>provide</strong> <strong>inject</strong> 依赖注入：</p><ul><li>provide 选项指定要提供给后代组件的数据和方法</li><li>在后代组件中使用 reject 选项来接受要添加到实例中的特定属性</li><li>缺点：<ol><li>将应用程序中的组件和它们当前的组织方式耦合起来，使重构变得更加困难</li><li>所提供的属性是非响应式的</li></ol></li></ul><blockquote><p>如果数据需要在多个组件中访问，并且能够响应更新，之后会使用真正的管理解决方案：Vuex</p></blockquote></li></ol><h3 id="slot-插槽"><a href="#slot-插槽" class="headerlink" title="slot 插槽"></a>slot 插槽</h3><h4 id="什么是插槽"><a href="#什么是插槽" class="headerlink" title="什么是插槽"></a>什么是插槽</h4><p>插槽（Slot）是 vue 为组件的封装者提供的能力。允许开发者在封装组件时，把不确定的、希望由用户指定的部分定义为插槽</p><p>可以把插槽认为是组件封装期间，为用户预留的内容的占位符</p><h4 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h4><p>在封装组件时，可以通过 <strong><slot></slot></strong> 元素定义插槽，从而为用户预留内容占位符</p><p>Left.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;left-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Left 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 声明一个插槽区域 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- vue 官方规定：每一个 slot 插槽，都要有一个 name 名称 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>App.vue</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Left</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>用户自定义的内容，会在 slot 区域展示<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Left</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>如果在封装组件时没有预留任何 slot 插槽，则用户提供的任何自定义内容都会被丢弃</p></li><li><p>封装组件时，可以为预留的 slot 插槽提供后备内容（默认内容）。如果组件的使用者没有为插槽提供任何内容，则后备内容会生效</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;default&quot;</span>&gt;</span> 后备内容 <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h4><p>如果在封装组件时需要预留多个插槽节点，则需要为每个 slot 插槽指定具体的 name 名称。这种带有具体名称的插槽叫做“具名插槽”</p><blockquote><p>注意：没有指定 name 名称的插槽， 会有隐含的名称叫做 “default”</p></blockquote><p>在向具名插槽提供内容的时候，我们可以在一个 template 元素上使用 <strong>v-slot:</strong> 指令，并以 v-slot 的参数的形式提供其名称</p><ul><li>v-slot: 指令不能直接用用在元素身上，必须用在 template 标签 或 组件元素 上</li><li>template 这个标签，它是一个虚拟的标签，只起到包裹性质的作用，但是，不会被渲染为任何实质性的 HTML 元素</li><li>简写：把参数之前的所有内容 (v-slot:) 替换为字符 <code>#</code></li><li><code>v-solt:[变量]</code> 可以定义动态的插槽名</li></ul><h4 id="作用域插槽"><a href="#作用域插槽" class="headerlink" title="作用域插槽"></a>作用域插槽</h4><p>在封装组件的过程中，可以为预留的 slot 插槽绑定 props 数据，这种带有 props 数据的 slot 叫做“<strong>作用域插槽</strong>”</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;content&quot;</span> <span class="attr">msg</span>=<span class="string">&quot;hello AgoniLay&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>接收</strong>作用域插槽对外提供的数据:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>=<span class="string">&quot;scope&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; scope.msg &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>作用域插槽对外提供的数据对象，可以使用<strong>解构赋值</strong>简化数据的接收过程</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> #<span class="attr">content</span>=<span class="string">&quot;&#123; msg : message &#125;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; message &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="动态组件"><a href="#动态组件" class="headerlink" title="动态组件"></a>动态组件</h3><p>动态组件指的是动态切换组件的显示与隐藏</p><h4 id="动态组件渲染"><a href="#动态组件渲染" class="headerlink" title="动态组件渲染"></a>动态组件渲染</h4><p>vue 提供了一个内置的 <strong><component></component></strong> 组件标签，专门用来实现动态组件的渲染</p><ol><li>component 标签是 vue 内置的，作用：组件的占位符</li><li>is 属性的值，表示要渲染的组件的名字，可以动态绑定</li><li>is 属性的值，应该是组件在 components 节点下的注册名称</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 渲染 Left 组件和 Right 组件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Left <span class="keyword">from</span> <span class="string">&quot;@/components/Left.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 表示要展示的组件的名字</span></span></span><br><span class="line"><span class="javascript">        <span class="attr">comName</span>: <span class="string">&quot;Left&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      Left,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="keep-alive"><a href="#keep-alive" class="headerlink" title="keep-alive"></a>keep-alive</h4><p>默认情况下，切换动态组件时无法保持组件的状态。此时可以使用 vue 内置的 <strong><keep-alive></keep-alive></strong> 组件保持动态组 件的状态</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;xxx&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><ul><li>当组件被缓存时，会自动触发组件的 <strong>deactivated</strong> 生命周期函数</li><li>当组件被激活时，会自动触发组件的 <strong>activated</strong> 生命周期函数</li><li>只有当组件第一次被创建时，才会触发 <strong>created</strong> 生命周期函数</li></ul><h5 id="include-amp-exclude-属性"><a href="#include-amp-exclude-属性" class="headerlink" title="include &amp; exclude 属性"></a>include &amp; exclude 属性</h5><blockquote><p>默认 keep-alive 所包含的所有组件均会被缓存！</p></blockquote><p>include 用来指定：只有名称匹配的组件会被缓存。</p><p>多个组件名之间使用 <code>,</code> 分隔</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">keep-alive</span> <span class="attr">include</span>=<span class="string">&quot;Left, Right&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">keep-alive</span>&gt;</span></span><br></pre></td></tr></table></figure><p>另外还有作用相反的 exclude 属性：表示排除</p><p>注意：include 和 exclude 不可以同时使用</p><h4 id="组件的-name-属性-扩展"><a href="#组件的-name-属性-扩展" class="headerlink" title="组件的 name 属性(扩展)"></a>组件的 name 属性(扩展)</h4><p>当给组件定义了 name 属性之后，组件的名称就是 name 属性的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;MyLeft&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>则在 include 和 exclude 中使用 components 节点中注册的名称无效，需使用 name 属性值</li><li>在调试工具中看到的也会是 name 属性值</li><li>建议开发中给所有组件定义一个专属名称，即 name 属性值</li></ul><h3 id="混入"><a href="#混入" class="headerlink" title="混入"></a>混入</h3><p>混入（mixin）提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个混入对象</span></span><br><span class="line"><span class="keyword">var</span> myMixin = &#123;</span><br><span class="line">  <span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.startMixin();</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">method</span>: &#123;</span><br><span class="line">    <span class="function"><span class="title">startMixin</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;混入实现&quot;</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 定义一个组件，使用这个混入对象</span></span><br><span class="line"><span class="keyword">var</span> Component = Vue.extend(&#123;</span><br><span class="line">  <span class="attr">mixins</span>: [myMixin],</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&quot;&lt;p&gt;Vue.js 无难事&lt;/p&gt;&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 创建根实例</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span><br><span class="line">  <span class="attr">components</span>: &#123;</span><br><span class="line">    Component,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上，组件 Component 相当于定义了一个 created 钩子函数 和一个 startMixin() 方法</p><h4 id="选项合并"><a href="#选项合并" class="headerlink" title="选项合并"></a>选项合并</h4><p>当混入对象和组件本身包含重复的选项时，将以下面的策略进行合并：</p><ol><li>数据对象进行递归合并，在发生冲突时<strong>以组件的数据优先</strong></li><li>同名的钩子函数被合并到一个数组中，因此这些函数均会被调用，且<strong>混入对象的钩子将在组件自身钩子之前调用</strong></li><li>值为对象的选项，如 methods、components、directives，将被合并为同一个对象，键名发生冲突同样<strong>优先组件的选项</strong></li><li>Vue.extend() 而言是用同样的策略进行合并</li></ol><h4 id="全局混入"><a href="#全局混入" class="headerlink" title="全局混入"></a>全局混入</h4><p>混入也可以全局注册，通过 Vue.mixin() 方法来实现</p><p>使用得当可用于为自定义选项注入处理逻辑</p><blockquote><p>很危险，会影响随后创建的每一个 Vue 实例，大多数情况只应用于自定义选项</p></blockquote><h3 id="ref-引用"><a href="#ref-引用" class="headerlink" title="ref 引用"></a>ref 引用</h3><p>ref 用来辅助开发者在不依赖于 jQuery 的情况下，获取 DOM 元素或组件的引用</p><blockquote><p><strong>ref 属性起名推荐使用 xxxRef 格式</strong></p></blockquote><h4 id="使用-ref-引用-DOM-元素"><a href="#使用-ref-引用-DOM-元素" class="headerlink" title="使用 ref 引用 DOM 元素"></a>使用 ref 引用 DOM 元素</h4><p>每个 vue 的组件实例上，都包含一个 $refs 对象，里面存储着对应的 DOM 元素或组件的引用。默认情况下， 组件的 $refs 指向一个空对象</p><p>步骤：</p><ol><li>给需要获取的 DOM 元素设置 ref 属性，一个组件内 ref 不可以重复</li><li>通过 <code>this.$refs.对应ref值</code> 获取对应 DOM 元素</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">ref</span>=<span class="string">&quot;myh3&quot;</span>&gt;</span>MyRef 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getRef&quot;</span>&gt;</span>获取 $refs 引用<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="attr">method</span>: &#123;</span></span><br><span class="line"><span class="javascript">    getRef () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过 this.$refs 访问</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.myh3.style.color = <span class="string">&#x27;red&#x27;</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="使用-ref-引用组件实例"><a href="#使用-ref-引用组件实例" class="headerlink" title="使用 ref 引用组件实例"></a>使用 ref 引用组件实例</h4><p>步骤：</p><ol><li>给相应组件设置 ref 属性</li><li>通过 <code>this.$refs.组件对应ref值</code> 获取引用组件的实例</li><li>即可调用组件中的数据及方法</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">my-counter</span> <span class="attr">ref</span>=<span class="string">&quot;counterRef&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">my-counter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;getRef&quot;</span>&gt;</span>获取 $refs 引用<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="attr">method</span>: &#123;</span></span><br><span class="line"><span class="javascript">    getRef () &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 通过 this.$refs.引用的名称 可以引用组件的实例</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 引用到组件的实例之后，就可以调用组件上的 数据 和 methods 方法</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.counterRef.add()</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$refs.counterRef.count = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="this-nextTick-cb-延迟执行"><a href="#this-nextTick-cb-延迟执行" class="headerlink" title="this.$nextTick(cb) 延迟执行"></a>this.$nextTick(cb) 延迟执行</h4><p>组件的 <strong>$nextTick(cb)</strong> 方法，会把 cb 回调推迟到<strong>下一个 DOM 更新周期之后</strong>执行</p><p>通俗的理解是：<strong>等组件的 DOM 更新完成之后，再执行 cb 回调函数</strong>。从而能保证 cb 回调函数可以操作到最新的 DOM 元素</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">  <span class="attr">type</span>=<span class="string">&quot;text&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">ref</span>=<span class="string">&quot;inputRef&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">v-if</span>=<span class="string">&quot;!inputVisible&quot;</span></span></span><br><span class="line"><span class="tag">  @<span class="attr">blur</span>=<span class="string">&quot;inputVisible = true&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">v-else</span> @<span class="attr">click</span>=<span class="string">&quot;showInput&quot;</span>&gt;</span>展示 input<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">inputVisible</span>: <span class="literal">true</span></span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript">  &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">method</span>: &#123;</span></span><br><span class="line"><span class="javascript">      showInput () &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.inputVisible = <span class="literal">false</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.$refs.inputRef.focus()</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">    &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>与 <strong>vm.$nextTick()</strong> 相对应的还有 Vue 全局上的 <strong>Vue.nextTick()</strong> 方法</p><p>区别：</p><ul><li>vm.$nextTick() 方法回调函数中的 this 会自动绑定到当前的 Vue 实例上，而不用像 Vue.nextTick() 需要使用箭头函数来绑定 this 到 Vue 实例</li></ul><h2 id="router-路由"><a href="#router-路由" class="headerlink" title="router 路由"></a>router 路由</h2><p>路由（router）就是对应关系</p><p>前端路由就是指：Hash 地址 与 组件 之间的对应关系</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; path: &#x27;#/home&#x27;, component: Home &#125;,</span><br></pre></td></tr></table></figure><blockquote><p>Hash 地址也就是 锚链接，location.hash 获取地址栏 Hash 地址</p></blockquote><h3 id="安装导入"><a href="#安装导入" class="headerlink" title="安装导入"></a>安装导入</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unpkg.com/vue-router/dist/vue-router.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router</span><br></pre></td></tr></table></figure><h3 id="工作方式"><a href="#工作方式" class="headerlink" title="工作方式"></a>工作方式</h3><ol><li>用户点击了页面上的路由链接</li><li>导致了 URL 地址栏中的 Hash 值发生了变化</li><li>前端路由监听了到 Hash 地址的变化</li><li>前端路由把当前 Hash 地址对应的组件渲染到浏览器中</li></ol><h3 id="实现简单的前端路由"><a href="#实现简单的前端路由" class="headerlink" title="实现简单的前端路由"></a>实现简单的前端路由</h3><p>步骤 1：通过 component 标签，结合 comName 动态渲染组件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">component</span> <span class="attr">:is</span>=<span class="string">&quot;comName&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;@/components/Home.vue&quot;</span>;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">comName</span>: <span class="string">&quot;Home&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">components</span>: &#123;</span></span><br><span class="line"><span class="javascript">      Home,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤 2：在 App.vue 组件中，为 <a> 链接添加对应的 hash 值</a></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/movie&quot;</span>&gt;</span>电影<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>步骤 3：在 created 生命周期函数中，通过 window.onhashchange 函数监听浏览器地址栏中 hash 地址的变化，通过 location.hash 获取到实时 hash 地址，动态切换要展示的组件的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">created</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.onhashchange = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> (location.hash) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;#/home&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.comName = <span class="string">&#x27;home&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;#/movie&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.comName = <span class="string">&#x27;movie&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> <span class="string">&#x27;#/about&#x27;</span>:</span><br><span class="line">        <span class="built_in">this</span>.comName = <span class="string">&#x27;about&#x27;</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="虚拟-DOM-和-render-函数"><a href="#虚拟-DOM-和-render-函数" class="headerlink" title="虚拟 DOM 和 render 函数"></a>虚拟 DOM 和 render 函数</h2><h3 id="虚拟-DOM"><a href="#虚拟-DOM" class="headerlink" title="虚拟 DOM"></a>虚拟 DOM</h3><p>虚拟 DOM 使用普通的 JavaScript 对象来描述 DOM 元素，在 Vue.js 中，每一个虚拟节点都是一个 VNode 的实例</p><p>例如下面的 DOM 结构：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Vue.js<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Vue.js 的虚拟 DOM 创建的 JavaScript 对象形式如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> vNode = &#123;</span><br><span class="line">  <span class="attr">tag</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&quot;app&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// VNode 的数组</span></span><br><span class="line">  <span class="attr">children</span>: &#123;</span><br><span class="line">    <span class="comment">// h1 节点</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Vue 在更新真实 DOM 前，会比较更新前后虚拟 DOM 结构中有差异的部分，然后采用异步更新队列的方式将差异部分更新到真实 DOM 中，从而减少了最终要在真实 DOM 上的操作次数，提高了页面渲染的效率</p><blockquote><p>虚拟 DOM 是普通的 JavaScript 对象，访问 JavaScript 对象自然比访问真实的 DOM 要快得多。</p></blockquote><h3 id="render-函数"><a href="#render-函数" class="headerlink" title="render 函数"></a>render 函数</h3><p>在一些场景中，需要使用 JavaScript 的编程能力，这时就可以使用 render 函数，它比模板更接近编译器。</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">anchored-heading</span> <span class="attr">:level</span>=<span class="string">&quot;3&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">name</span>=<span class="string">&quot;hello-world&quot;</span> <span class="attr">href</span>=<span class="string">&quot;#hello-world&quot;</span>&gt;</span> Hello world! <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">anchored-heading</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;anchored-heading&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> createElement(</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;h&quot;</span> + <span class="built_in">this</span>.level, <span class="comment">// 标签名称</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$slots.default <span class="comment">// 子节点数组</span></span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">level</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Number</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="slots"><a href="#slots" class="headerlink" title="$slots"></a>$slots</h4><p>用于以编程方式访问有插槽分发的内容</p><ul><li>每个命名的插槽都有其对应的属性（例如：v-slot:foo 的内容将在 vm.$slots.foo 中找到）</li><li>default 属性包含了所有未包含在命名插槽中的节点或 v-slot:default 的内容</li></ul><h4 id="createElement"><a href="#createElement" class="headerlink" title="createElement()"></a>createElement()</h4><p>createElement() 函数并不是 DOM API 中的 document.createElement() 方法，而是 Vue.js 中的一个函数，用来描述节点信息及其子节点信息的一个对象，即虚拟节点（VNode）</p><ul><li>可以带三个参数，第一个参数是必须的，形式为：<code>&#123;String | Object | Funtion&#125;</code> ，即可以是 字符串（HTML 标签名）、对象（组件选项对象）、函数对象（解析前两者之一的 async 函数）；</li><li>第二个参数是可选的，形式为：<code>&#123;Object&#125;</code> ，表示一个与模板中元素属性对应的数据对象；</li><li>第三个参数也可选，用于生成虚拟节点，形式为：<code>&#123;String | Array&#125;</code> ，字符串（文本虚拟节点）、数组（子虚拟节点的数组）</li></ul><p>createElement() 可以接受的各种参数的形式：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @returns &#123;VNode&#125;</span></span><br><span class="line">createElement &#123;</span><br><span class="line"><span class="comment">// -------------- 第一个参数，必填项 --------------</span></span><br><span class="line">  <span class="comment">// &#123;String | Object | Function&#125;</span></span><br><span class="line">  <span class="comment">// 一个 HTML 标签名、组件选项对象，或者解析前两者其一的 async 函数</span></span><br><span class="line">  <span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"><span class="comment">// -------------- 第二个参数，可选项 --------------</span></span><br><span class="line">  <span class="comment">// &#123;Object&#125;</span></span><br><span class="line">  <span class="comment">// 一个与模板中元素属性对应的数据对象</span></span><br><span class="line">  &#123;</span><br><span class="line"><span class="comment">// 与 v-bind:class 一样的 API，接收一个字符串、对象或字符串和对象的数组</span></span><br><span class="line">    <span class="string">&#x27;class&#x27;</span>: &#123;</span><br><span class="line">      <span class="attr">foo</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">bar</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 与 v-bind:style 一样的 API，接收一个字符串、对象或对象数组</span></span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">      <span class="attr">color</span>: <span class="string">&#x27;pink&#x27;</span>,</span><br><span class="line">      <span class="attr">fontSize</span>: <span class="string">&#x27;14px&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 普通的 HTML 属性</span></span><br><span class="line">    <span class="attr">attrs</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="string">&#x27;foo&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 组件 prop</span></span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">myProp</span>: <span class="string">&#x27;bar&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// DOM 属性</span></span><br><span class="line">    <span class="attr">domProps</span>: &#123;</span><br><span class="line">      <span class="attr">innerHTML</span>: <span class="string">&#x27;baz&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 在 &#x27;on&#x27; 属性内的事件监听器，但不支持如 &#x27;@keyup.enter&#x27; 这样的修饰符</span></span><br><span class="line">    <span class="attr">on</span>: &#123;</span><br><span class="line">      <span class="attr">click</span>: <span class="built_in">this</span>.clickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 仅用于组件，用于监听原生事件，而不是组件内部使用 vm.$emit 触发的自定义事件</span></span><br><span class="line">    <span class="attr">nativeOn</span>: &#123;</span><br><span class="line">      <span class="attr">click</span>: <span class="built_in">this</span>.nativeClickHandler</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 自定义指令。注意：不能对 binding 中的 oldValue 赋值，Vue 会替你跟踪它</span></span><br><span class="line">    <span class="attr">directives</span>: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;my-custom-directive&#x27;</span>,</span><br><span class="line">        <span class="attr">value</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">expression</span>: <span class="string">&#x27;1 + 1&#x27;</span>,</span><br><span class="line">        <span class="attr">arg</span>: <span class="string">&#x27;foo&#x27;</span>,</span><br><span class="line">        <span class="attr">modifiers</span>: &#123;</span><br><span class="line">          <span class="attr">bar</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="comment">// 作用域插槽的格式为</span></span><br><span class="line">    <span class="comment">// &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">    <span class="attr">scopedSlots</span>: &#123;</span><br><span class="line">      <span class="attr">default</span>: <span class="function"><span class="params">props</span> =&gt;</span> createElement(<span class="string">&#x27;span&#x27;</span>, props.text)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 如果组件是其他组件的子组件，需为插槽指定名称</span></span><br><span class="line">    <span class="attr">slot</span>: <span class="string">&#x27;name-of-slot&#x27;</span>,</span><br><span class="line">    <span class="comment">// 其他特殊顶层属性</span></span><br><span class="line">    <span class="attr">key</span>: <span class="string">&#x27;myKey&#x27;</span>,</span><br><span class="line">    <span class="attr">ref</span>: <span class="string">&#x27;myRef&#x27;</span>,</span><br><span class="line">    <span class="comment">// 如果在 render 函数中给多个元素都应用了形同的 ref 名，那么 $refs.myRef 会变成一个数组</span></span><br><span class="line">    <span class="attr">refInFor</span>: <span class="literal">true</span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="comment">// -------------- 第三个参数，可选项 --------------</span></span><br><span class="line">  <span class="comment">// &#123;String | Array&#125;</span></span><br><span class="line">  <span class="comment">// 子虚拟节点（VNode），有 createElement() 构建而成，也可以使用字符串来生成“文本虚拟节点”</span></span><br><span class="line">  [</span><br><span class="line">    <span class="string">&#x27;先写一些文本&#x27;</span>,</span><br><span class="line">    createElement(<span class="string">&#x27;h1&#x27;</span>, <span class="string">&#x27;一则头条&#x27;</span>),</span><br><span class="line">    createElement(MyComponent, &#123;</span><br><span class="line">      <span class="attr">props</span>: &#123;</span><br><span class="line">        <span class="attr">someProp</span>: <span class="string">&#x27;foobar&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>组件树中的所有 VNode 必须是唯一的，如果需要重复很多相同的元素或组件，可以使用工厂函数来实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> createElement(<span class="string">&#x27;div&#x27;</span>,</span><br><span class="line"> <span class="built_in">Array</span>.apply(<span class="literal">null</span>, &#123; <span class="attr">length</span>: <span class="number">20</span> &#125;).map(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> createElement(<span class="string">&#x27;p&#x27;</span>, <span class="string">&#x27;hi&#x27;</span>)</span><br><span class="line"> &#125;)</span><br><span class="line">)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote><h4 id="代替模板功能"><a href="#代替模板功能" class="headerlink" title="代替模板功能"></a>代替模板功能</h4><p>原先在模板中可以使用的一些功能在 render 函数中没有再提供，需自己编写 JavaScript 代码来实现</p><h5 id="v-if-amp-v-for"><a href="#v-if-amp-v-for" class="headerlink" title="v-if &amp; v-for"></a>v-if &amp; v-for</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-if</span>=<span class="string">&quot;items.length&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in items&quot;</span>&gt;</span>&#123;&#123; item.name &#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">v-else</span>&gt;</span>No items found.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 render 函数中可以使用 if/else 和 map 来实现同样的功能</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;my-component&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;items&quot;</span>],</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.items.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(</span><br><span class="line">        <span class="string">&quot;ul&quot;</span>,</span><br><span class="line">        <span class="built_in">this</span>.items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> createElement(<span class="string">&quot;li&quot;</span>, item.name);</span><br><span class="line">        &#125;)</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> createElement(<span class="string">&quot;p&quot;</span>, <span class="string">&quot;No items found.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="v-model-1"><a href="#v-model-1" class="headerlink" title="v-model"></a>v-model</h5><p>在 render 函数中没有对 v-model 直接对应的实现方案，v-model 的本质是把 value 作为 prop，同时监听 input 事件</p><p>代码实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;my-component&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">props</span>: [<span class="string">&quot;value&quot;</span>],</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> self = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&quot;input&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">domProps</span>: &#123;</span><br><span class="line">        <span class="attr">value</span>: self.value,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">on</span>: &#123;</span><br><span class="line">        <span class="attr">input</span>: <span class="function"><span class="keyword">function</span> (<span class="params">event</span>) </span>&#123;</span><br><span class="line">          self.$emit(<span class="string">&quot;input&quot;</span>, event.target.value);</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="事件和按键修饰符"><a href="#事件和按键修饰符" class="headerlink" title="事件和按键修饰符"></a>事件和按键修饰符</h5><p>对于 .passive、.capture、.once 这些事件修饰符，Vue 提供了相应的前缀可以用于 on：</p><table><thead><tr><th align="center">修饰符</th><th align="center">前缀</th><th align="center">修饰符</th><th align="center">前缀</th></tr></thead><tbody><tr><td align="center">.passive</td><td align="center">&amp;</td><td align="center">.once</td><td align="center">~</td></tr><tr><td align="center">.capture</td><td align="center">!</td><td align="center">.capture.once 或<br>.once.capture</td><td align="center">~!</td></tr></tbody></table><p>对于其他的事件和按键修饰符，不需要专有前缀，可以使用事件方法来实现相同的功能：</p><table><thead><tr><th>修饰符</th><th>处理函数中的等价操作</th></tr></thead><tbody><tr><td>.stop</td><td>event.stopPropagation()</td></tr><tr><td>.prevent</td><td>event.preventDefault()</td></tr><tr><td>.self</td><td>if (event.target !== event.currentTarget) return</td></tr><tr><td>.enter、.13</td><td>if (event.keyCode !== 13) return（对于其他的按键修饰符，修改按键码即可）</td></tr><tr><td>.ctrl、.alt、.shft、.meta</td><td>if (!event.ctrlKey) return （altKey、shiftKey、metaKey）</td></tr></tbody></table><h5 id="插槽"><a href="#插槽" class="headerlink" title="插槽"></a>插槽</h5><p>可以通过 <strong>this.$slots</strong> 访问静态插槽的内容，插槽的内容是 VNode 数组</p><p>也可以通过 <strong>this.$scopedSlots</strong> 访问作用域插槽，每个作用域插槽都是返回若干 VNode 的函数</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my-component</span> <span class="attr">:message</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">input</span>=<span class="string">&quot;&#123; text &#125;&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; text &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">my-component</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;my-component&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: [<span class="string">&quot;message&quot;</span>],</span></span><br><span class="line"><span class="javascript">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> createElement(</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;div&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$scopedSlots.input(&#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">text</span>: <span class="built_in">this</span>.message,</span></span><br><span class="line"><span class="javascript">        &#125;)</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">message</span>: <span class="string">&quot;123&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>如果要使用 render 函数将作用域擦超传递给子组件，可以利用 VNode 数据对象中的 <strong>scopedSlots</strong> 字段</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">&quot;my-component&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createElement(<span class="string">&quot;div&quot;</span>, [</span><br><span class="line">      createElement(<span class="string">&quot;child&quot;</span>, &#123;</span><br><span class="line">        <span class="comment">// 在数据对象中传递 scopedSlots</span></span><br><span class="line">        <span class="comment">// 格式为 &#123; name: props =&gt; VNode | Array&lt;VNode&gt; &#125;</span></span><br><span class="line">        <span class="attr">scopedSlots</span>: &#123;</span><br><span class="line">          <span class="attr">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params">props</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> createElement(<span class="string">&quot;span&quot;</span>, props.text);</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;),</span><br><span class="line">    ]);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="JSX"><a href="#JSX" class="headerlink" title="JSX"></a>JSX</h4><p>JSX（JavaScript XML），是一种给 JavaScript 的语法扩展，用于描述用户界面。其格式比较像是模板语法，但完全是在 JavaScript 内部实现的。</p><p>可以通过一个 Babel 插件（<a href="https://github.com/vuejs/jsx%EF%BC%89%E8%AE%A9">https://github.com/vuejs/jsx）让</a> Vue 支持 JSX 语法，从而简化 render 函数中的模板创建</p><p>格式举例：</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> AnchoredHeading <span class="keyword">from</span> <span class="string">&#x27;./AnchoredHeading.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">el</span>: <span class="string">&#x27;#demo&#x27;</span>,</span><br><span class="line">  <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">h</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="xml"><span class="tag">&lt;<span class="name">AnchoredHeading</span> <span class="attr">level</span>=<span class="string">&#123;1&#125;</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">span</span>&gt;</span> world!</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">AnchoredHeading</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>h 作为 createElement 的别名是 Vue 生态系统中的一个通用惯例，实际上也是 JSX 所要求的</li><li>Bebal 3.4.0 开始，会在以 ES6 语法声明的含有 JSX 的任何方法 和 getter 中自动注入 const h = this.$createElement ，由此也可以去掉 (h) 参数</li></ul><h4 id="函数式组件"><a href="#函数式组件" class="headerlink" title="函数式组件"></a>函数式组件</h4><p>一个组件若不管理任何状态，不监听任何传递给它的状态，也没有生命周期方法，只是一个接收一些 prop 的函数，这样就可以将这个组件标记为 <strong>functional</strong>，意味着它是无状态的（没有响应式数据），也没有实例（没有 this 上下文）</p><blockquote><p>在 2.3.0 之前的版本中，如果一个函数式组件要接收 prop，则 props 选项是必需的</p><p>在 2.3.0 及之后的版本中，可以省略 props 选项，组件节点上的所有属性会被自动隐式解析为 prop</p></blockquote><p>在 2.5.0 及之后版本中，如果使用了单文件组件，基于模板的函数式组件可以这样声明：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">functional</span>&gt;</span><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>组件需要的一切都是通过 <strong>context</strong> 参数传递，是一个包含以下字段的对象：</p><ul><li>props：提供所有的 prop 对象</li><li>children：VNode 子节点的数组</li><li>slots：一个函数，返回所有的插槽对象</li><li>scopedSlots：一个暴露传入的作用域插槽的对象，也以函数形式暴露普通插槽</li><li>data：传递给组件的整个数据对象，作为 createElement 的第二个参数传入组件</li><li>parent：对父组件的引用</li><li>listeners：一个包含了所有父组件注册的事件监听器的对象。是 data.on 的一个别名</li><li>injections：如果使用的 reject 选项，则该对象包含了被注入的属性</li></ul><blockquote><p>组件的 prop 不能使用 data 传递，要单独设置 prop 传递</p></blockquote><p>优点：</p><ol><li>函数式组件只是函数，所以渲染的开销很低</li><li>可以用作包装组件，然后程序化地在多个组件中选择一个来渲染，在将 children、props、data 传递给子组件之前可以对它们进行一些操作</li></ol><p>例子：（在 ul li 和 table 中选择使用）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">layout-menu</span> <span class="attr">:items</span>=<span class="string">&quot;menus&quot;</span> <span class="attr">kind</span>=<span class="string">&quot;table&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">layout-menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.config.productionTip = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> TableMenu = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">menus</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;table class=&quot;menu&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;tr&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;td v-for=&quot;menu in menus&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;a :href=&quot;menu.url&quot;&gt;&#123;&#123; menu.name &#125;&#125;&lt;/a&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">  &lt;/td&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">  &lt;/tr&gt;  </span></span></span><br><span class="line"><span class="string"><span class="javascript">  &lt;/table&gt;`</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">let</span> UlMenu = Vue.extend(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">menus</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">template</span>: <span class="string">`</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;ul class=&quot;menu&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;li v-for=&quot;menu in menus&quot;&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">&lt;a :href=&quot;menu.url&quot;&gt;&#123;&#123; menu.name &#125;&#125;&lt;/a&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">     &lt;/li&gt;</span></span></span><br><span class="line"><span class="string"><span class="javascript">  &lt;/ul&gt;`</span>,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&quot;layout-menu&quot;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">functional</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">      <span class="attr">items</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">required</span>: <span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">      <span class="attr">kind</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">type</span>: <span class="built_in">String</span>,</span></span><br><span class="line"><span class="javascript">        <span class="attr">default</span>: <span class="string">&quot;ul&quot;</span>,</span></span><br><span class="line"><span class="javascript">      &#125;,</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">    <span class="attr">render</span>: <span class="function"><span class="keyword">function</span> (<span class="params">createElement, context</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="keyword">function</span> <span class="title">appropriateMenuComponent</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 根据 kind 的值来选择要渲染的组件</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (context.props.kind === <span class="string">&quot;ul&quot;</span>) <span class="keyword">return</span> UlMenu;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">else</span> <span class="keyword">return</span> TableMenu;</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> createElement(</span></span><br><span class="line"><span class="javascript">        appropriateMenuComponent(),</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 将布局组件的 items prop 传给子组件的 menus prop</span></span></span><br><span class="line"><span class="javascript">        &#123;</span></span><br><span class="line"><span class="javascript">          <span class="attr">props</span>: &#123;</span></span><br><span class="line"><span class="javascript">            <span class="attr">menus</span>: context.props.items,</span></span><br><span class="line"><span class="javascript">          &#125;,</span></span><br><span class="line"><span class="javascript">          <span class="comment">// 并使用 展开运算符 将数据对象一起传进去</span></span></span><br><span class="line"><span class="javascript">          ...context.data,</span></span><br><span class="line"><span class="javascript">        &#125;,</span></span><br><span class="line"><span class="javascript">        context.children</span></span><br><span class="line"><span class="javascript">      );</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    <span class="attr">el</span>: <span class="string">&quot;#app&quot;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="attr">menus</span>: [</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">name</span>: <span class="string">&quot;新浪新闻&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;#&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">name</span>: <span class="string">&quot;网易游戏&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;#&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">          &#123; <span class="attr">name</span>: <span class="string">&quot;百度搜索&quot;</span>, <span class="attr">url</span>: <span class="string">&quot;#&quot;</span> &#125;,</span></span><br><span class="line"><span class="javascript">        ],</span></span><br><span class="line"><span class="javascript">      &#125;;</span></span><br><span class="line"><span class="javascript">    &#125;,</span></span><br><span class="line"><span class="javascript">  &#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h1><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><ul><li>State：<code>this.$store.state.xxx</code></li><li>Getter：<code>this.$store.getters.xxx</code></li><li>Mutation：<code>this.$store.commit(&#39;xxx&#39;)</code></li><li>Action：<code>this.$store.dispatch(&#39;xxx&#39;)</code></li><li>Module</li></ul><h2 id="建议"><a href="#建议" class="headerlink" title="建议"></a>建议</h2><h3 id="使用常量替代-Mutation-事件类型"><a href="#使用常量替代-Mutation-事件类型" class="headerlink" title="使用常量替代 Mutation 事件类型"></a>使用常量替代 Mutation 事件类型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mutation-types.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SOME_MUTATION = <span class="string">&quot;SOME_MUTATION&quot;</span>;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// store.js</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&quot;vuex&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; SOME_MUTATION &#125; <span class="keyword">from</span> <span class="string">&quot;./mutation-types&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123; xxx &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span></span><br><span class="line">    [SOME_MUTATION](state) &#123;</span><br><span class="line">      <span class="comment">// mutate state</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h1><p>vue-router 是 vue.js 官方给出的路由解决方案。它只能结合 vue 项目进行使用，能够轻松的管理 SPA 项目中组件的切换</p><blockquote><p>vue-router 的官方文档地址：<a href="https://router.vuejs.org/zh/">https://router.vuejs.org/zh/</a></p></blockquote><h2 id="安装和配置"><a href="#安装和配置" class="headerlink" title="安装和配置"></a>安装和配置</h2><p>步骤 1：安装 vue-router 包</p><blockquote><p>在 vue2 的项目中，安装 vue-router 的命令如下：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i vue<span class="literal">-router</span>@<span class="number">3.5</span>.<span class="number">2</span> <span class="literal">-S</span></span><br></pre></td></tr></table></figure></blockquote><p>步骤 2：创建路由模块</p><blockquote><p>在 src 源代码目录下，新建 router/index.js 路由模块，并初始化如下的代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 导入 Vue 和 VueRouter 的包</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用 Vue.use() 函数，把 VueRouter 安装为 Vue 的插件</span></span><br><span class="line"><span class="comment">// vue.use() 的作用就是：安装插件</span></span><br><span class="line">Vue.use(VueRouter);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由的实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 向外共享路由的实例对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router;</span><br></pre></td></tr></table></figure></blockquote><p>步骤 3：导入并挂载路由模块</p><blockquote><p>在 src/main.js 入口文件中配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> router <span class="keyword">from</span> <span class="string">&quot;./router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">  router,</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure></blockquote><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p>在 src/App.vue 组件中，使用 vue-router 提供的 <strong>router-link</strong> 和 <strong>router-view</strong> 声明路由链接和占位符</p><blockquote><p>使用 router-link 代替普通的 a 链接，to 属性内写 hash 地址，不需要写 #</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;app-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>App2 组件<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 1. 定义路由链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/movie&quot;</span>&gt;</span>电影<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 2. 定义路由的占位符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 src/router/index.js 路由模块中，通过 <strong>routes</strong> 数组声明路由的匹配规则</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入需要使用路由切换展示的组件</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&quot;@/components/Home&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Movie <span class="keyword">from</span> <span class="string">&quot;@/components/Movie&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&quot;@/components/About&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 在 routes 数组中，声明路由的匹配规则</span></span><br><span class="line">    <span class="comment">// path 表示要匹配的 hash 地址，component 表示要展示的路由组件</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/home&quot;</span>, <span class="attr">component</span>: Home &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/movie&quot;</span>, <span class="attr">component</span>: Movie &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>, <span class="attr">component</span>: About &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路由重定向"><a href="#路由重定向" class="headerlink" title="路由重定向"></a>路由重定向</h2><p>路由重定向指的是：用户在访问地址 A 的时候，强制用户跳转到地址 C ，从而展示特定的组件页面</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    <span class="comment">// 在 routes 数组中，声明路由的匹配规则</span></span><br><span class="line">    <span class="comment">// 重定向的路由规则：当用户访问 / 时，通过 redirect 属性跳转到 &#x27;/home&#x27; 对应的路由规则</span></span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>, <span class="attr">redirect</span>: <span class="string">&#x27;/home&#x27;</span> &#125;,</span><br><span class="line">    &#123; <span class="attr">path</span>: <span class="string">&#x27;/home&#x27;</span>, <span class="attr">component</span>: Home &#125;</span><br><span class="line">    ...</span><br><span class="line">  ]</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="通配符匹配"><a href="#通配符匹配" class="headerlink" title="通配符匹配"></a>通配符匹配</h2><p>想匹配任意路径，可以使用通配符（*）</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// 将匹配所有路径</span></span><br><span class="line">  path: &#x27;*&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">// 将匹配以 /user- 开头的任意路径</span></span><br><span class="line">  path: &#x27;/user-*&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当使用通配符路由时，要确保路由的顺序是正确的。</p><blockquote><p>含有通配符的路由应该放在最后。路由 { path: ‘*‘ } 通常用于客户端 404 错误</p></blockquote><p>当使用一个通配符时，$route.params 内会自动添加一个名为 pathMatch 的参数，包含了 URL 中通过通配符匹配的部分。</p><h2 id="嵌套路由"><a href="#嵌套路由" class="headerlink" title="嵌套路由"></a>嵌套路由</h2><p>通过路由实现组件的嵌套展示，叫做嵌套路由</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">path</span>: <span class="string">&quot;/about&quot;</span>,</span><br><span class="line">      <span class="attr">component</span>: About,</span><br><span class="line">      <span class="comment">// 重定向，直接去找 tab1 显示</span></span><br><span class="line">      <span class="attr">redirect</span>: <span class="string">&quot;/about/tab1&quot;</span>,</span><br><span class="line">      <span class="comment">// 通过 children 属性，嵌套声明子级路由规则</span></span><br><span class="line">      <span class="attr">children</span>: [</span><br><span class="line">        <span class="comment">// 子级路由不加 /</span></span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab1&quot;</span>, <span class="attr">component</span>: Tab1 &#125;,</span><br><span class="line">        &#123; <span class="attr">path</span>: <span class="string">&quot;tab2&quot;</span>, <span class="attr">component</span>: Tab2 &#125;,</span><br><span class="line">      ],</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><blockquote><p>如果 children 数组中，某个路由的 path 值为空字符串，则这条路由规则叫做 默认路由，进到 根路由 就会默认显示</p><p>重定向 和 默认子路由 根据需求随便使用一个均可</p></blockquote><p>在子组件中配置子路由链接和子路由占位符</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;about-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>About 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子级路由链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about/tab1&quot;</span>&gt;</span>tab1<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about/tab2&quot;</span>&gt;</span>tab2<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 子级路由占位符 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态路由匹配"><a href="#动态路由匹配" class="headerlink" title="动态路由匹配"></a>动态路由匹配</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>动态路由指的是：把 Hash 地址中可变的部分定义为参数项，从而提高路由规则的复用性。</p><p>在 vue-router 中使用英文的冒号 <code>:</code> 来定义路由的参数项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">path</span>: <span class="string">&#x27;/movie/:id&#x27;</span>, <span class="attr">component</span>: Movie &#125;</span><br></pre></td></tr></table></figure><h3 id="route-params-参数对象"><a href="#route-params-参数对象" class="headerlink" title="$route.params 参数对象"></a>$route.params 参数对象</h3><p>在动态路由渲染出来的组件中，可以使用 <strong>this.$route.params</strong> 对象访问到动态匹配的参数值</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Movie&#123;&#123; $route.params.id &#125;&#125; 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>$route 是路由的 参数对象</p><p>$router 是路由的 导航对象</p></blockquote><h3 id="props-传参"><a href="#props-传参" class="headerlink" title="props 传参"></a>props 传参</h3><p>为了简化路由参数的获取形式，vue-router 允许在路由规则中开启 props 传参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="attr">routes</span>: [&#123; <span class="attr">path</span>: <span class="string">&quot;/movie/:id&quot;</span>, <span class="attr">component</span>: Movie, <span class="attr">props</span>: <span class="literal">true</span> &#125;],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>在 组件 中通过 props 获取数据</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;movie-container&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Movie&#123;&#123; id &#125;&#125; 组件<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 接收 props 数据</span></span></span><br><span class="line"><span class="javascript">    <span class="attr">props</span>: [<span class="string">&quot;id&quot;</span>],</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>注意：在 hash 地址中，</p><ul><li>/ 后面的参数叫做 路径参数，使用 this.$route.params 来访问路径参数</li><li>? 后面的参数叫做 查询参数，使用 this.$route.query 来访问</li><li>在 this.$route 中，path 只是路径部分，fullPath 是完整的 hash 地址</li></ul></blockquote><h2 id="声明式导航-amp-编程式导航"><a href="#声明式导航-amp-编程式导航" class="headerlink" title="声明式导航 &amp; 编程式导航"></a>声明式导航 &amp; 编程式导航</h2><p>在浏览器中，点击链接实现导航的方式，叫做声明式导航。例如：</p><ul><li>普通网页中点击 <a> 链接、vue 项目中点击 <router-link> 都属于声明式导航</router-link></a></li></ul><p>在浏览器中，调用 API 方法实现导航的方式，叫做编程式导航。例如：</p><ul><li>普通网页中调用 location.href 跳转到新页面的方式，属于编程式导航</li></ul><h3 id="vue-中的编程式导航"><a href="#vue-中的编程式导航" class="headerlink" title="vue 中的编程式导航"></a>vue 中的编程式导航</h3><p>vue-router 提供了许多编程式导航的 API，其中最常用的导航 API 分别是：</p><ol><li><p><code>this.$router.push(&#39;hash 地址&#39;)</code></p><ul><li>跳转到指定的 hash 地址，并<strong>增加</strong>一条历史记录</li></ul></li><li><p><code>this.$router.replace(&#39;hash 地址&#39;)</code></p><ul><li>跳转到指定的 hash 地址，并<strong>替换掉</strong>当前的历史记录</li></ul></li><li><p><code>this.$router.go(数值 n)</code></p><ul><li>实现导航历史前进、后退</li><li>go(-1) 表示后退一层</li><li>如果后退的层数超过上限，则原地不动</li></ul><blockquote><p>在实际开发中，一般只会前进一层或后退一层，因此 vue-router 提供了如下两个便捷方法</p><ul><li>$router.back() ：在历史记录中，后退到上一个页面</li><li>$router.forward() ：在历史记录中，前进到下一个页面</li></ul></blockquote></li></ol><blockquote><p>在行内使用 编程式跳转 时，this 必须要省略，否则会报错</p></blockquote><h2 id="导航守卫"><a href="#导航守卫" class="headerlink" title="导航守卫"></a>导航守卫</h2><p>导航守卫可以控制路由的访问权限</p><h3 id="全局前置守卫"><a href="#全局前置守卫" class="headerlink" title="全局前置守卫"></a>全局前置守卫</h3><p>调用路由实例对象的 <strong>beforeEach()</strong> 方法，即可声明全局前置守卫</p><p>在 main.js 中配置：</p><p>全局前置守卫的回调函数中接收 3 个形参</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每次发生路由的导航跳转时，都会自动触发 fn 这个 “回调函数”</span></span><br><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// to 表示将要访问的路由信息对象</span></span><br><span class="line">  <span class="comment">// from 表示将要离开的路由信息对象</span></span><br><span class="line">  <span class="comment">// next 是一个方法，表示放行，允许这次路由导航</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>next 函数的三种调用方式</p><ul><li>当前用户<strong>拥有</strong>后台主页的访问权限，直接<strong>放行</strong>：==next()==</li><li>当前用户<strong>没有</strong>后台主页的访问权限，强制其<strong>跳转到登录页面</strong>：==next(‘/login’)==</li><li>当前用户<strong>没有</strong>后台主页的访问权限，<strong>不允许跳转</strong>到后台主页：==next(false)==</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">router.beforeEach(<span class="function">(<span class="params">to, <span class="keyword">from</span>, next</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (to.path === <span class="string">&quot;/main&quot;</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取 token 值</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="built_in">localStorage</span>.getItem(<span class="string">&quot;token&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (token) next();</span><br><span class="line">    <span class="comment">// 已登录，放行</span></span><br><span class="line">    <span class="keyword">else</span> next(<span class="string">&quot;/login&quot;</span>); <span class="comment">// 未登录，跳转到指定页面，一般为登录页</span></span><br><span class="line">  &#125; <span class="keyword">else</span> next();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="路由类型"><a href="#路由类型" class="headerlink" title="路由类型"></a>路由类型</h2><p>Hash 模式：</p><ul><li>丑，路由带有 <code>#</code> ，无法使用锚点定位</li></ul><p>History 模式</p><ul><li>需要后端配合，IE9 不兼容（可使用强制刷新处理）</li></ul><h1 id="axios"><a href="#axios" class="headerlink" title="axios"></a>axios</h1><blockquote><p>axios 是一个专注于网络请求的库！</p></blockquote><p>axios（发音：艾克 C 奥斯）是前端圈最火的库。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><ol><li>调用 axios 之后，使用 async / await 进行简化</li><li>使用解构赋值，从 axios 封装的大对象中，把 data 属性解构出来</li><li>把解构出来的 data 属性，使用 : 进行重命名，一般都重命名为 <code>&#123; data: res&#125;</code></li></ol><p>调用 axios 方法的返回值是一个 Promise 对象：</p><blockquote><p>axios 在请求到接口数据之后，在真正的数据之外，套了一层壳</p></blockquote><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  config: &#123;&#125;,</span><br><span class="line">  data: &#123;&#x27;真正的接口数据&#x27;&#125;,</span><br><span class="line">  headers: &#123;&#125;,</span><br><span class="line">  request: &#123;&#125;,</span><br><span class="line">  status: xxx,</span><br><span class="line">  statusText: &#x27;&#x27;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="发起-GET-请求"><a href="#发起-GET-请求" class="headerlink" title="发起 GET 请求"></a>发起 GET 请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 请求方式</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="comment">// 请求的地址</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// URL 中的查询参数</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以使用 <strong>axios.get</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">axios.get(<span class="string">&quot;url地址&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// GET参数</span></span><br><span class="line">  <span class="attr">params</span>: &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="发起-POST-请求"><a href="#发起-POST-请求" class="headerlink" title="发起 POST 请求"></a>发起 POST 请求</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="comment">// 请求体</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;agoni&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>也可以使用 <strong>axios.post</strong> 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">axios.post(<span class="string">&quot;url&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">/* POST请求体数据 */</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="await-和-async"><a href="#await-和-async" class="headerlink" title="await 和 async"></a>await 和 async</h3><ul><li>如果调用某个方法的返回值是 Promise 实例，则前面可以添加 await</li><li>await 只能用在被 async 修饰的方法中</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;POST&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="attr">data</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&#x27;agoni&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><blockquote><p>解构赋值的时候可以使用 : 进行重命名</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> axios(&#123;</span><br><span class="line">    <span class="attr">method</span>: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    <span class="attr">url</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="built_in">console</span>.log(res.data)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用优化"><a href="#使用优化" class="headerlink" title="使用优化"></a>使用优化</h2><h3 id="挂载在-Vue-原型"><a href="#挂载在-Vue-原型" class="headerlink" title="挂载在 Vue 原型"></a>挂载在 Vue 原型</h3><p>使用 axios 需要各页面导入 axios 才可使用，比较麻烦</p><p>可以将 axios 挂载在 Vue 的原型上：</p><ol><li><p>在 main.js 中导入 axios</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios</span></span><br></pre></td></tr></table></figure></li><li><p>配置请求根路径</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.baseURL = <span class="string">&quot;请求根路径&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>把 axios 挂载到 Vue.prototype 原型上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.prototype.$http = axios;</span><br></pre></td></tr></table></figure><blockquote><p>一般命名为 $http，今后在每个 .vue 组件中要发起请求，直接调用 this.$http 接口即可</p></blockquote></li></ol><p>缺点：</p><ul><li>不利于 api 接口的复用，所以一般不使用，了解即可</li></ul><h3 id="增强复用"><a href="#增强复用" class="headerlink" title="增强复用 *"></a>增强复用 *</h3><p>util/request.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&quot;axios&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> request = axios.create(&#123;</span><br><span class="line">  <span class="comment">// 指定请求的根路径</span></span><br><span class="line">  <span class="attr">baseURL</span>: <span class="string">&quot;https://www.escook.cn&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> request;</span><br></pre></td></tr></table></figure><p>api/articleAPI.js：</p><blockquote><p>一般以 API 命名结尾</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文章相关的 API 接口</span></span><br><span class="line"><span class="keyword">import</span> request <span class="keyword">from</span> <span class="string">&quot;@/utils/request.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 向外按需导出一个 API 函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> getArticleListAPI = <span class="function"><span class="keyword">function</span> (<span class="params">_page, _limit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> request.get(<span class="string">&quot;/articles&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      _page,</span><br><span class="line">      _limit,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Home.vue：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 按需导入 API 接口</span></span><br><span class="line"><span class="keyword">import</span> &#123; getArticleListAPI &#125; <span class="keyword">from</span> <span class="string">&quot;@/api/articleAPI.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="comment">// 页码值</span></span><br><span class="line">      <span class="attr">page</span>: <span class="number">1</span>,</span><br><span class="line">      <span class="comment">// 每页显示多少条数据</span></span><br><span class="line">      <span class="attr">limit</span>: <span class="number">8</span>,</span><br><span class="line">      <span class="comment">// 文章列表数组</span></span><br><span class="line">      <span class="attr">articleList</span>: [],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    <span class="comment">// 封装获取文章列表数据的方法</span></span><br><span class="line">    <span class="keyword">async</span> <span class="function"><span class="title">initArticleLsit</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> &#123; <span class="attr">data</span>: res &#125; = <span class="keyword">await</span> getArticleLsitAPI(<span class="built_in">this</span>.page, <span class="built_in">this</span>.limit);</span><br><span class="line">      <span class="built_in">this</span>.articleList = res;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">create</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.initArticleLsit();</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="单页面应用程序"><a href="#单页面应用程序" class="headerlink" title="单页面应用程序"></a>单页面应用程序</h1><p>单页面应用程序（Single Page Application）简称 SPA，指一个 Web 网站中只有唯一的一个 HTML 页面，所有的功能和交互都在这唯一的一个页面完成</p><p>优点：</p><ol><li>前后端分离</li><li>良好的用户体验</li><li>减轻服务器压力</li><li>共用一套后端程序代码</li></ol><p>缺点：</p><ol><li>初次加载消耗多 ———— 预渲染 Prerendering</li><li>前进后退有一定问题</li><li>SEO 难度较高 ———— 服务端渲染 SSR</li></ol><blockquote><p>Nuxt：可以解决上述两种问题</p></blockquote><h1 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p>vue-cli 是 Vue.js 开发的标准工具。简化了程序员基于 webpack 创建工程化的 Vue 项目的工程</p><p>Vue CLI 有三个组件：</p><ol><li><p>CLI（@vue/cli）</p><p>全局安装的 npm 包，提供了终端里的 vue 命令（如 vue create、vue serve、vue ui）</p></li><li><p>CLI 服务（@vue/cli-service）</p><p>CLI 服务是一个开发环境依赖。它是一个 npm 包，本地安装到 @vue/cli 创建的每个项目中。是构建于 webpack 和 webpack-dev-server 之上的，包含了：</p><ul><li>加载其他 CLI 插件的核心服务</li><li>一个为绝大部分应用优化过的内部 webpck 配置</li><li>项目内部的 vue-cli-service 命令，包含基本的 serve、build 和 inspect 命令</li></ul></li><li><p>CLI 插件</p><p>是给 Vue 项目提供可选功能的 npm 包（如：Babel/TypeScript 转译、ESLIint 集成、单元测试 和 end-to-end 测试等）</p><p>Vue CLI 中插件的名字以 @vue/cli-plugin-（用于内置插件）或 vue/cli-plugin-（用于社区插件）开头</p></li></ol><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 3.x 版本的 Vue 脚手架：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure><p>检查安装</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue -V <span class="comment">// 检查是否安装 及 版本号</span></span><br></pre></td></tr></table></figure><p>看到 显示 <code>@vue/cli 版本号</code> 即为安装成功</p><h2 id="创建-Vue-项目"><a href="#创建-Vue-项目" class="headerlink" title="创建 Vue 项目"></a>创建 Vue 项目</h2><ol><li><p>基于 <strong>交互式命令行</strong> 的方式，创建 新版 vue 项目</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue create my-project</span><br></pre></td></tr></table></figure><blockquote><p>项目名中不能有大写字母</p></blockquote><p>一般选择最后一项创建自定义</p><blockquote><p>vue create 命令有一些可选项，可以输入 vue create –help 来查看这些选项</p></blockquote></li><li><p>基于 <strong>图形化界面</strong> 的方式，创建 新版 vue 项目</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vue ui</span><br></pre></td></tr></table></figure></li><li><p>基于 2.x 的旧模板 ，创建 旧版 vue 项目（了解）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br><span class="line">vue init webpack my-project</span><br></pre></td></tr></table></figure></li></ol><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><h3 id="public-文件夹"><a href="#public-文件夹" class="headerlink" title="public 文件夹"></a>public 文件夹</h3><h4 id="index-html"><a href="#index-html" class="headerlink" title="index.html"></a>index.html</h4><p>index.html 为项目主页面</p><p>其中 一行注释，表示生成脚本文件的将自动注入这个位置</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- built files will be auto injected --&gt;</span></span><br></pre></td></tr></table></figure><p>id 属性为 app 的 div 之后将会被替换掉</p><blockquote><p>不要改动 inde.html 中的内容</p></blockquote><h4 id="favicon-ico"><a href="#favicon-ico" class="headerlink" title="favicon.ico"></a>favicon.ico</h4><p>网页的图标</p><h3 id="src-文件夹"><a href="#src-文件夹" class="headerlink" title="src 文件夹"></a>src 文件夹</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">assets 文件夹：存放项目中用到的静态资源文件，例如：css 样式表、图片资源</span><br><span class="line">components 文件夹：存放程序员封装的、可复用的组件</span><br><span class="line">main.js 是项目的入口文件。整个项目的运行，要先执行 main.js</span><br><span class="line">App.vue 是项目的根组件</span><br></pre></td></tr></table></figure><h4 id="main-js"><a href="#main-js" class="headerlink" title="main.js"></a>main.js</h4><p>将 main.js 中 render 函数指定的结构替换掉 index.html 中指定的 el 区域 <code>&lt;div id=&quot;app&quot;&gt;&lt;/div&gt;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入 vue 这个包，得到 vue 构造函数</span></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>;</span><br><span class="line"><span class="comment">// 导入 App.vue 根组件，将来要把 App.vue 中的模板结构，渲染到 HTML 页面中</span></span><br><span class="line"><span class="keyword">import</span> App <span class="keyword">from</span> <span class="string">&quot;./App.vue&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// false 是开发模式，true 是发布模式 （是否生成提示信息）</span></span><br><span class="line"><span class="comment">// 默认为 true</span></span><br><span class="line">Vue.config.productionTip = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建 Vue 的 实例对象</span></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  <span class="comment">// el: &#x27;#app&#x27;,  // 这个和 $mount 二选一使用即可</span></span><br><span class="line">  <span class="comment">// 把 render 函数指定的组件，渲染到 HTML 页面中</span></span><br><span class="line">  <span class="attr">render</span>: <span class="function">(<span class="params">h</span>) =&gt;</span> h(App),</span><br><span class="line">&#125;).$mount(<span class="string">&quot;#app&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>Vue 实例的 $mount() 方法，作用和 el 属性完全一样！</p></blockquote><h4 id="components-amp-views"><a href="#components-amp-views" class="headerlink" title="components &amp; views"></a>components &amp; views</h4><p>两个文件夹都是放组件的，区别在于：</p><ul><li>components 文件夹用来放各页面复用的组件</li><li>views 文件夹用来放 <strong>使用路由切换</strong> 的组件</li></ul><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><ul><li>.browserslistrc：配置项目目标浏览器的范围</li><li>.gitignore：配置在 git 提交项目代码时忽略哪些文件或文件夹</li><li>.eslintrc.js：ESLint 使用的配置文件</li><li>babel.config.js：Babel 使用的配置文件</li><li>postcss.config.js：PostCSS 使用的配置文件</li><li>package.json：npm 的配置文件，其中设定了脚本和项目依赖的库</li><li>package-lock.json：用于锁定项目实际安装的各个 npm 包的具体来源和版本号</li><li>README.md：项目说明文件</li></ul><h4 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h4><p>一个 JSON 格式的 npm 配置文件，定义了项目需要的各种模块，以及项目的配置信息（如名称、版本、许可证等元数据）</p><p>代码如下所示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;helloworld&quot;</span>, <span class="comment">// 项目名称</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;0.1.0&quot;</span>, <span class="comment">// 项目版本</span></span><br><span class="line">  <span class="attr">&quot;private&quot;</span>: <span class="literal">true</span>, <span class="comment">// 是否私有项目</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 值是一个对象，其中指定了项目声明周期各个环节需要执行的命令</span></span><br><span class="line">    <span class="attr">&quot;serve&quot;</span>: <span class="string">&quot;vue-cli-service serve&quot;</span>, <span class="comment">// 执行 npm run serve，运行项目</span></span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;vue-cli-service build&quot;</span>, <span class="comment">// 执行 npm run build，构建项目</span></span><br><span class="line">    <span class="attr">&quot;lint&quot;</span>: <span class="string">&quot;vue-cli-service lint&quot;</span> <span class="comment">// 执行 npm run lint，运行 ESLint 验证并格式化代码</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 配置项目依赖的模块列表</span></span><br><span class="line">    <span class="attr">&quot;vue&quot;</span>: <span class="string">&quot;^2.6.10&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="comment">// 用于开发环境的依赖，不发布到生产环境</span></span><br><span class="line">    <span class="attr">&quot;@vue/cli-plugin-babel&quot;</span>: <span class="string">&quot;^4.0.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 NPM 安装依赖的模块时，可以根据模块是否需要在生产环境下使用而选择附加 -S（–save）或者 -D（–save-dev）参数。</p><ul><li>-S：安装后在 dependencies 中写入，项目打包时，dependencies 中的依赖项也会<strong>一起</strong>打包</li><li>-D：写入 devDependencies 中，在项目打包时<strong>不会一起</strong>打包</li></ul><h2 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h2><blockquote><p>在工程化的项目中，vue 要做的事情很单纯：通过 main.js 把 App.vue 渲染到 index.html 的指定区域中</p></blockquote><ol><li>App.vue 用来编写待渲染的模板结构</li><li>index.html 中需要预留一个 el 区域</li><li>main.js 把 App.vue 渲染到了 index.html 所预留的区域中</li></ol><h1 id="UI-组件库"><a href="#UI-组件库" class="headerlink" title="UI 组件库"></a>UI 组件库</h1><p>Element UI、Ant Design Vue、iView</p><table><thead><tr><th align="center">组件库</th><th align="center">数量</th><th align="center">单测</th><th align="center">admin</th><th align="center">背景</th><th align="center">原型、设计</th></tr></thead><tbody><tr><td align="center">Element UI</td><td align="center">46</td><td align="center">81%</td><td align="center">vue-element-admin（社区）</td><td align="center">饿了么</td><td align="center">Axure、Sketch</td></tr><tr><td align="center">Ant Design Vue</td><td align="center">55</td><td align="center">87%</td><td align="center">Pro（社区）</td><td align="center">社区主导、蚂蚁金服技术支持</td><td align="center">Axure、Sketch</td></tr><tr><td align="center">iView</td><td align="center">54</td><td align="center">无</td><td align="center">iView-admin</td><td align="center">TalkingData</td><td align="center">无</td></tr></tbody></table><h1 id="开发常用工具"><a href="#开发常用工具" class="headerlink" title="开发常用工具"></a>开发常用工具</h1><h2 id="Vetur"><a href="#Vetur" class="headerlink" title="Vetur"></a>Vetur</h2><ul><li>语法高亮</li><li>标签补全、模板生成</li><li>Lint 检查</li><li>格式化</li></ul><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>一个插件化的 javascript 代码检测工具</p><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>生成 .eslintrc.js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">root</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">env</span>: &#123;</span><br><span class="line">    <span class="attr">node</span>: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">extends</span>: [<span class="string">&quot;plugin:vue/essential&quot;</span>, <span class="string">&quot;@vue/standard&quot;</span>],</span><br><span class="line">  <span class="attr">parserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">parser</span>: <span class="string">&quot;babel-eslint&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">rules</span>: &#123;</span><br><span class="line">    <span class="string">&quot;no-console&quot;</span>: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;warn&quot;</span> : <span class="string">&quot;off&quot;</span>,</span><br><span class="line">    <span class="string">&quot;no-debugger&quot;</span>: process.env.NODE_ENV === <span class="string">&quot;production&quot;</span> ? <span class="string">&quot;warn&quot;</span> : <span class="string">&quot;off&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>process.env.NODE_ENV 固定用法，获取到 webpack 的模式</li><li>在 rules 中写规则</li><li>no-console 禁用输出指令</li><li>no-debugger 禁用断点代码</li></ul><blockquote><p>想要自定义规则可以去官网上寻找</p></blockquote><h3 id="VScode-配置"><a href="#VScode-配置" class="headerlink" title="VScode 配置"></a>VScode 配置</h3><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><h5 id="ESlint-Dirk-Baeumer"><a href="#ESlint-Dirk-Baeumer" class="headerlink" title="ESlint (Dirk Baeumer)"></a>ESlint (Dirk Baeumer)</h5><p>在 settings.json 配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="comment">// ESLint 插件的配置</span></span><br><span class="line">  <span class="attr">&quot;editor.codeActionsOnSave&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;source.fixAll&quot;</span>: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prettier"><a href="#Prettier" class="headerlink" title="Prettier"></a>Prettier</h2><p>Prettier - Code formatter</p><p>在 settings.json 中配置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;prettier.configPath&quot;</span>: <span class="string">&quot;C:\\Users\\AgoniLay\\.prettierrc&quot;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="attr">&quot;eslint.alwaysShowStatus&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="comment">// 每行文字个数超出限制将会被迫换行</span></span><br><span class="line">  <span class="attr">&quot;prettier.printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="comment">// 使用单引号替换双引号</span></span><br><span class="line">  <span class="attr">&quot;prettier.singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;prettier.arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">  <span class="comment">// 设置 .vue 文件中，HTML代码的格式化插件</span></span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatter.html&quot;</span>: <span class="string">&quot;js-beautify-html&quot;</span>,</span><br><span class="line">  <span class="comment">// 忽略项目中的警告弹窗</span></span><br><span class="line">  <span class="attr">&quot;vetur.ignoreProjectWarning&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;vetur.format.defaultFormatterOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">&quot;arrowParens&quot;</span>: <span class="string">&quot;aviod&quot;</span>,</span><br><span class="line">      <span class="attr">&quot;printWidth&quot;</span>: <span class="number">300</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">&quot;js-beautify-html&quot;</span>: &#123;</span><br><span class="line">      <span class="attr">&quot;wrap_attribute&quot;</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中也包含 vetur 插件的配置设置</p><p>在本地 C 盘/用户/xxx 目录下 创建 .pretterrc 文件</p><p>在其中设置：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;semi&quot;</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">&quot;singleQuote&quot;</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">&quot;printWidth&quot;</span>: <span class="number">300</span>,</span><br><span class="line">  <span class="attr">&quot;arrowParens&quot;</span>: <span class="string">&quot;avoid&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;trailingComma&quot;</span>: <span class="string">&quot;none&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在项目中设置 .vue 和 .js 结尾的文件 格式化文档方式默认为 Pretter - Code - formatter</p><ul><li>右键选择 使用…格式化文档</li></ul><h2 id="vue-devtools"><a href="#vue-devtools" class="headerlink" title="vue-devtools"></a>vue-devtools</h2><p>Chorme 插件</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><ul><li><p>jest 或 mocha</p></li><li><p>@vue/text-utils</p></li><li><p>sinon</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i --save-dev sinon</span><br></pre></td></tr></table></figure></li></ul><p>在使用 vue-cli 脚手架时勾选 <code>Unit Testing</code> 一项即可。</p><p>演示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; mount &#125; <span class="keyword">from</span> <span class="string">&quot;@vue/test-utils&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> Counter <span class="keyword">from</span> <span class="string">&quot;@/components/Counter.vue&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> sinon <span class="keyword">from</span> <span class="string">&quot;sinon&quot;</span>;</span><br><span class="line"></span><br><span class="line">describe(<span class="string">&quot;Counter.vue&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> change = sinon.spy();</span><br><span class="line">  <span class="keyword">const</span> wrapper = mount(Counter, &#123;</span><br><span class="line">    <span class="attr">listeners</span>: &#123;</span><br><span class="line">      change,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">&quot;renders counter html&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    expect(wrapper.html()).toMatchSnapshot();</span><br><span class="line">  &#125;);</span><br><span class="line">  it(<span class="string">&quot;count++&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> button = wrapper.find(<span class="string">&quot;button&quot;</span>);</span><br><span class="line">    button.trigger(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">    expect(wrapper.vm.count).toBe(<span class="number">1</span>);</span><br><span class="line">    expect(change.called).toBe(<span class="literal">true</span>);</span><br><span class="line">    button.trigger(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">    expect(change.callCount).toBe(<span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端框架 </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2021/08/04/CSS%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/04/CSS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>Cascading Style Sheets 层叠样式表（级联样式表）</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><ul><li>降低耦合度（解耦）</li><li>让分工协作更容易</li><li>提高开发效率</li></ul><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><h4 id="内联样式"><a href="#内联样式" class="headerlink" title="内联样式"></a>内联样式</h4><p>在标签内使用 style 属性指定 css 代码</p><p>适用于属性较少时</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:red;&quot;</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内部样式"><a href="#内部样式" class="headerlink" title="内部样式"></a>内部样式</h4><p>内嵌式：在 head 标签内，定义 style 标签，style 标签的标签体内容就是 css 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-tag">div</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="外部样式"><a href="#外部样式" class="headerlink" title="外部样式"></a>外部样式</h4><p>a.css 文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="链接式-推荐使用"><a href="#链接式-推荐使用" class="headerlink" title="链接式 (推荐使用)"></a>链接式 (推荐使用)</h5><p>在 head 标签内，定义 link 标签，引入外部的资源文件</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css/a.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="导入式"><a href="#导入式" class="headerlink" title="导入式"></a>导入式</h5><p>使用 <code>@import</code> 在 style 标签内导入，必须在标签内最前面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> <span class="string">&quot;css/a.css&quot;</span>;</span></span><br><span class="line"><span class="css">  <span class="keyword">@import</span> url(<span class="string">&quot;css/a.css&quot;</span>);</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引号可以是单引号也可以是双引号，也可以省略引号</p><p>link 和 @import 的区别：</p><ul><li>link 是 html 标签；而 @import 是 css 提供的</li><li>link 在页面加载时加载；@import 在页面加载完再加载</li><li>@import IE5 以上才可识别；link 无兼容性问题</li><li>link 样式的权重高于 @import 的权重</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选择器 &#123;</span><br><span class="line">  <span class="comment">/* 样式分隔符 */</span></span><br><span class="line">  属性名<span class="number">1</span>: 属性值<span class="number">1</span>; <span class="comment">/* 这每一行叫声明 */</span></span><br><span class="line">  属性名<span class="number">2</span>: 属性值<span class="number">2</span>;</span><br><span class="line">  ...;</span><br><span class="line">&#125; <span class="comment">/* 样式分隔符 */</span></span><br></pre></td></tr></table></figure><ul><li>选择器：筛选具有相似特征的元素</li><li>每一对属性需要使用 <code>;</code> 隔开，最后一对属性可以不加</li></ul><h4 id="注释语法"><a href="#注释语法" class="headerlink" title="注释语法"></a>注释语法</h4><p>在 css 中注释使用 <code>\* 注释内容 *\</code></p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h4 id="基础选择器"><a href="#基础选择器" class="headerlink" title="基础选择器"></a>基础选择器</h4><table><thead><tr><th align="center">名称</th><th align="center">作用</th><th align="center">语法</th><th align="center">注意</th></tr></thead><tbody><tr><td align="center">id 选择器</td><td align="center">选择具体的 id 属性值的元素</td><td align="center"><code>#id属性值 &#123;&#125;</code></td><td align="center">建议在一个 html 页面中 id 值唯一</td></tr><tr><td align="center">元素选择器</td><td align="center">选择具有相同标签名称的元素</td><td align="center"><code>标签名称 &#123;&#125;</code></td><td align="center"></td></tr><tr><td align="center">类选择器</td><td align="center">选择具有相同的 class 属性值的元素</td><td align="center"><code>.class属性值 &#123;&#125;</code></td><td align="center">类选择器选择器优先级高于元素选择器</td></tr></tbody></table><h4 id="扩展选择器"><a href="#扩展选择器" class="headerlink" title="扩展选择器"></a>扩展选择器</h4><table><thead><tr><th>名称</th><th>作用</th><th>语法</th><th>注意</th></tr></thead><tbody><tr><td>通配符选择器</td><td>选择所有元素</td><td><code>* &#123;&#125;</code></td><td></td></tr><tr><td>并集选择器(分组选择器)</td><td>同时选择多个选择器</td><td><code>选择器1, 选择器2 &#123;&#125;</code></td><td>集体声明，减少代码的书写量</td></tr><tr><td>交集选择器</td><td>更精准的找到要选择的</td><td><code>标签名.class名 &#123;&#125;</code><br><code>标签名#id名</code></td><td></td></tr><tr><td>后代选择器(包含选择器)</td><td>筛选选择器 1 元素下的选择器 2 元素</td><td><code>选择器1 选择器2 &#123;&#125;</code></td><td></td></tr><tr><td>子元素选择器(子选择器)</td><td>筛选选择器 1 的子元素选择器 2</td><td><code>选择器1 &gt; 选择器2 &#123;&#125;</code></td><td>只选直系</td></tr><tr><td>相邻选择器</td><td>筛选选择器 1 的相邻元素选择器 2</td><td><code>选择器1 + 选择器2 &#123;&#125;</code></td><td>选择器 1 必须在 选择器 2 之前</td></tr><tr><td>兄弟选择器</td><td>筛选选择器 1 的所有兄弟元素选择器 2</td><td><code>选择器1 ~ 选择器2 &#123;&#125;</code></td><td></td></tr></tbody></table><h5 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h5><p>选择元素名称，属性名=属性值的元素</p><ul><li><code>元素名称[属性名] &#123;&#125;</code> ：选择带有该属性的元素</li><li><code>元素名称[属性名=&quot;属性值&quot;] &#123;&#125;</code> ：该属性的值为该属性值的 （常用）</li><li><code>元素名称[属性名^=&quot;xxx&quot;] &#123;&#125;</code> ：属性值为 xxx 开头的</li><li><code>元素名称[属性名$=&quot;xxx&quot;] &#123;&#125;</code> ：属性值为 xxx 结尾的</li><li><code>元素名称[属性名*=&quot;xxx&quot;] &#123;&#125;</code> ：属性值的任意位置带有 xxx （常用）</li><li><code>元素名称[属性名~=&quot;xxx&quot;] &#123;&#125;</code> ：属性值是一个词列表，并且以空格隔开，其中词列表中包含了 xxx</li><li><code>元素名称[属性名|=&quot;xxx&quot;] &#123;&#125;</code> ：特定属性选择器，该属性值是 value 或者以 value- 开头的值（如 zh-cn）</li></ul><p>也可以混合使用，选择多个属性多个属性值的：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-attr">[href]</span><span class="selector-attr">[title=<span class="string">&quot;link&quot;</span>]</span> &#123;</span><br><span class="line">  ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h5><p>选择一些元素具有的状态</p><p>语法： <code>E:pseudo-class &#123;property: value;&#125;</code></p><h6 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h6><ul><li>:link ：初始化的状态</li><li>:visited ：被访问过的状态</li><li>:hover ：鼠标悬浮状态（常用）</li><li>:active ：正在访问状态</li></ul><p>注意顺序： link -&gt; visited -&gt; hover -&gt; active 不可以调换</p><p>常用于自定义超链接样式</p><ul><li>:focus ：聚焦的状态</li></ul><h6 id="结构伪类"><a href="#结构伪类" class="headerlink" title="结构伪类"></a>结构伪类</h6><ul><li><p>:first-child ：首个子元素</p></li><li><p>:last-child ：最后一个子元素</p></li><li><p>:nth-child(n) ：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(length) <span class="comment">/* 参数是具体数字，表示选择第几个 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(n) <span class="comment">/* 参数是 n，n 从 0 开始算,会选中所有的子元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(n*length) <span class="comment">/* n 的倍数选择，n 从 0 开始算 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(n+length) <span class="comment">/* 选择大于等于 length 的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(-n+length) <span class="comment">/* 选择小于等于 length 的元素 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">:nth-child</span>(n*length-<span class="number">1</span>) <span class="comment">/* 表示隔几(length)选一 */</span></span><br></pre></td></tr></table></figure><ul><li>even === 2n –&gt; 偶数项</li><li>odd === 2n-1 –&gt; 奇数项</li><li>只能是字母 n，其他的没有效果</li></ul></li><li><p>:nth-last-child() ：从最后一个开始数，用法与 nth-child() 相同</p></li><li><p>:nth-of-type() ：用法类似 :nth-child()，但只计算选择器中指定的哪个元素，指定了子元素的类型</p></li><li><p>:nth-last-of-type() ：从最后一个开始计算</p></li><li><p>:first-of-type() :last-of-type() ：类似于 :first-child() 和 :last-child()</p></li><li><p>:only-child() ：表示一个元素是它的父元素的唯一一个子元素</p></li><li><p>:only-of-type() ：表示一个元素包含很多子元素，只有一种子元素是唯一的，那么就可以选中它</p></li><li><p>:empty() ：用来选择没有任何内容的元素，一个空格也没有</p></li></ul><p>注意：IE6~8 和 FF3 及其以下版本不支持以上的结构伪类选择器</p><h6 id="否定伪类"><a href="#否定伪类" class="headerlink" title="否定伪类"></a>否定伪类</h6><ul><li>:not() 否定选择器，即排除或过滤掉特定元素。</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:not</span>(<span class="selector-attr">[type=<span class="string">&quot;submit&quot;</span>]</span>) &#123;</span><br><span class="line">  <span class="comment">/* 选择除提交按钮外的其他表单元素 */</span></span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：IE6~8 及其以下版本不支持否定伪类选择器</p><h6 id="状态伪类"><a href="#状态伪类" class="headerlink" title="状态伪类"></a>状态伪类</h6><p>UI 元素（User Interface 用户界面）一般是指包含在 form 内的表单元素，其状态一般包括：可用不可用、选中未选中、获得或失去焦点、锁定、待机等</p><ul><li>:enabled() 表示匹配指定范围内所有可用 UI 元素，匹配文本框，不匹配按钮</li><li>:disabled() 表示匹配指定范围内所有不可用 UI 元素，匹配按钮，不匹配文本框</li><li>:checked() 表示匹配指定范围内所有可用 UI 元素，匹配单选按钮</li></ul><p>注意：IE6~8 及其以下版本不支持状态伪类选择器</p><h6 id="目标伪类"><a href="#目标伪类" class="headerlink" title="目标伪类"></a>目标伪类</h6><ul><li>:target ：匹配所有指定目标元素中被相关 URL 指向的（比如锚点链接指向）</li></ul><p>注意：IE6~8 及其以下版本不支持目标伪类选择器</p><h5 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h5><p>语法： <code>元素::状态 &#123;&#125;</code></p><ul><li>::first-letter ：选择第一个字</li><li>::first-line ：选择第一行</li><li>::selection ：选中文字时改变样式</li><li><code>::before &#123;content: &quot;xxx&quot;&#125;</code> ：在内部前面插入 xxx</li><li><code>::before &#123;after: &quot;xxx&quot;&#125;</code> ：在内部后面插入 xxx</li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="单位"><a href="#单位" class="headerlink" title="单位"></a>单位</h4><h5 id="绝对单位"><a href="#绝对单位" class="headerlink" title="绝对单位"></a>绝对单位</h5><ul><li>in（inch，英寸）</li><li>cm（centimerter，厘米）</li><li>mm（millimeter，毫米）</li><li>pt（point，印刷的点数）</li><li>pc（pica，1pc == 12pt）</li><li>另外，xx-small | x-small | small | medium | large | x-large | xx-large 这些关键词也是绝对单位</li></ul><h5 id="相对单位"><a href="#相对单位" class="headerlink" title="相对单位"></a>相对单位</h5><ul><li><p>px 像素</p><ul><li>根据屏幕的像素点的尺寸变化而变化，不同分辨率的屏幕所显示的像素字体大小是不同的</li><li>屏幕分辨率越大，相同像素字体就显得越小</li></ul></li><li><p>em 相对于父辈字体的大小来定义字体大小，1em 即是 父级一个字体大小</p></li><li><p>ex 相对于父辈字体的 x 高度来定义字体大小</p><ul><li>ex 单位大小既取决于字体的大小，也取决于字体类型</li><li>在固定大小的情况下，实际的 x 高度随字体类型不同而不同</li></ul></li><li><p>% 以百分比的形式定义字体大小，于 em 效果相同，相对于父辈字体大小来定义</p></li><li><p>larger 和 smaller 将以父元素的字体大小为参考进行换算</p></li></ul><h4 id="颜色表示"><a href="#颜色表示" class="headerlink" title="颜色表示"></a>颜色表示</h4><ul><li>颜色名：使用颜色名，如：red，pink，skyblue</li><li>十六进制：0~F 如： #fff，#6E6E6E，#000000</li><li>RGB：rgb(0<del>255, 0</del>255, 0~255)，其中也可以是百分比值</li></ul><p>CSS3 新支持以下三种颜色表示法：</p><ul><li><p>RGBA：在 RGB 颜色的基础上增加了 Alpha 通道，起到定义半透明的颜色，取值 0~1，越低越透明</p></li><li><p>HSL：色相(Hue)、饱和度(Saturation) 和 亮度(Lightness) 表示颜色</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hsl(&lt;length&gt;, &lt;percentage&gt;, &lt;percentage&gt;)</span><br></pre></td></tr></table></figure></li><li><p>HSLA：和 RGBA 同理，添加透明通道</p></li></ul><h4 id="渐变"><a href="#渐变" class="headerlink" title="渐变"></a>渐变</h4><h5 id="Webkit-渐变"><a href="#Webkit-渐变" class="headerlink" title="Webkit 渐变"></a>Webkit 渐变</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-webkit-gradient(&lt;type&gt;, &lt;point&gt; <span class="selector-attr">[, &lt;radius&gt;]</span>?, &lt;point&gt; <span class="selector-attr">[,&lt;radius&gt;]</span>? <span class="selector-attr">[,&lt;stop&gt;]</span>*)</span><br></pre></td></tr></table></figure><ul><li>type：定义渐变类型，包括线性渐变（linear）和 径向渐变（radial）</li><li>point：定义渐变起始点和结束点坐标，即开始应用渐变的 x 轴 和 y 轴 坐标，以及结束渐变的坐标，(0, 0)、(left, top)、top、bottom、left、right</li><li>radius：当定义径向渐变时，用来设置径向渐变的长度，为一个数值</li><li>stop：定义渐变色和步长<ul><li>from(colorvalue)：开始的颜色</li><li>to(colorvalue)：结束的颜色</li><li>color-stop(value, colorvalue)：颜色步长、包含两个参数值，第一个为数值，第二个为颜色值</li></ul></li></ul><h5 id="Gecko-渐变"><a href="#Gecko-渐变" class="headerlink" title="Gecko 渐变"></a>Gecko 渐变</h5><h6 id="线性渐变"><a href="#线性渐变" class="headerlink" title="线性渐变"></a>线性渐变</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-moz-linear-gradient(<span class="selector-attr">[&lt;point&gt; || &lt;angle&gt;,]</span>? &lt;stop&gt;, &lt;stop&gt; <span class="selector-attr">[,&lt;stop&gt;]</span>*)</span><br></pre></td></tr></table></figure><ul><li>point：定义渐变起始点</li><li>angle：定义直线渐变的角度</li><li>stop：定义步长，用法与 Webkit 的 color-stop() 函数相似</li></ul><h6 id="径向渐变"><a href="#径向渐变" class="headerlink" title="径向渐变"></a>径向渐变</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-moz-radial-gradient(<span class="selector-attr">[&lt;position&gt; || &lt;angle&gt;,]</span>? <span class="selector-attr">[&lt;shape&gt; || &lt;size&gt;,]</span>? &lt;stop&gt;, &lt;stop&gt; <span class="selector-attr">[,&lt;stop&gt;]</span>*)</span><br></pre></td></tr></table></figure><ul><li>point：定义渐变起始点</li><li>angle：定义渐变的角度</li><li>shape：定义径向渐变的形状</li><li>size：定义圆半径，或者椭圆的轴长度</li><li>stop：定义步长，用法与 Webkit 的 color-stop() 函数相似</li></ul><h5 id="W3C-渐变"><a href="#W3C-渐变" class="headerlink" title="W3C 渐变"></a>W3C 渐变</h5><p>沿袭 Gecko 引擎的渐变设计方法，语法与用法也基本相同</p><h6 id="线性渐变-1"><a href="#线性渐变-1" class="headerlink" title="线性渐变"></a>线性渐变</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">linear-gradient(<span class="selector-attr">[[angle]</span> | <span class="selector-tag">to</span>&lt;side-or-corner&gt;,]? &lt;<span class="attribute">color</span>-stop&gt;<span class="selector-attr">[, &lt;color-stop&gt;]</span>+)</span><br></pre></td></tr></table></figure><h6 id="径向渐变-1"><a href="#径向渐变-1" class="headerlink" title="径向渐变"></a>径向渐变</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">radial-gradient(<span class="selector-attr">[[&lt;shape&gt; || &lt;size&gt;]</span><span class="selector-attr">[at&lt;position&gt;]</span>?, | at&lt;<span class="attribute">position</span>&gt;, ]? &lt;<span class="attribute">color</span>-stop&gt;<span class="selector-attr">[, &lt;color-stop&gt;]</span>+)</span><br></pre></td></tr></table></figure><h4 id="字体样式"><a href="#字体样式" class="headerlink" title="字体样式"></a>字体样式</h4><h5 id="font-size-字体大小"><a href="#font-size-字体大小" class="headerlink" title="font-size 字体大小"></a>font-size 字体大小</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-size</span>: xx-small | x-small | small | medium | large | x-large | xx-large |</span><br><span class="line">  larger | normal | smaller | length;</span><br></pre></td></tr></table></figure><ul><li>前面的表示绝对字体尺寸</li><li>larger 和 smaller 表示相对的大小，根据父对象中字体尺寸进行相对增大和缩小处理</li><li>length 可以是百分数、浮点数或单位标识符组成的长度值，不可谓负值</li></ul><h5 id="font-family-字体"><a href="#font-family-字体" class="headerlink" title="font-family 字体"></a>font-family 字体</h5><ul><li>各种字体之间用 <code>,</code> 分隔开</li><li>中文字体需要加英文引号，英文字体一般不需要加引号</li><li>如果字体中包含 <code> </code>(空格) <code>#</code> <code>$</code> 等符号，则必须加引号</li><li>Unicode 编码表示字体：<ul><li><code>\5B8B\4F53</code> == SimSun –&gt; 宋体</li><li><code>\5FAE\8F6F\96C5\9ED1</code> == Microsoft YaHei –&gt; 微软雅黑</li></ul></li></ul><h5 id="font-weight-字体粗细"><a href="#font-weight-字体粗细" class="headerlink" title="font-weight 字体粗细"></a>font-weight 字体粗细</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-weight</span>: <span class="number">100</span> | <span class="number">200</span> | <span class="number">300</span> | <span class="number">400</span> | <span class="number">500</span> | <span class="number">600</span> | <span class="number">700</span> | <span class="number">800</span> | <span class="number">900</span> | normal | bold</span><br><span class="line">  | bolder | lighter;</span><br></pre></td></tr></table></figure><ul><li>可以使用数字，可选数值为 100 的整数倍， 100 ~ 900，越大越粗</li><li>normal == 400；<strong>bold</strong> === 700 &lt; 较为常用</li><li>bolder：相对于 normal 字体较粗；lighter：相对于 normal 字体较细</li></ul><h5 id="font-style-字体样式"><a href="#font-style-字体样式" class="headerlink" title="font-style 字体样式"></a>font-style 字体样式</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-style</span>: normal | italic | oblique;</span><br></pre></td></tr></table></figure><ul><li>normal：普通</li><li>italic：斜体</li><li>oblique：倾斜的字体</li></ul><p>italic 和 oblique 只能在英文等西方文字中有效</p><h5 id="color-字体颜色"><a href="#color-字体颜色" class="headerlink" title="color 字体颜色"></a>color 字体颜色</h5><p>使用相应颜色表示法即可</p><h5 id="text-decoration-字体划线效果"><a href="#text-decoration-字体划线效果" class="headerlink" title="text-decoration 字体划线效果"></a>text-decoration 字体划线效果</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-decoration</span>: normal | none | underline | blink | overline | line-through;</span><br></pre></td></tr></table></figure><ul><li>normal：默认值</li><li>none：取消划线效果</li><li>underline：下划线效果</li><li>blink：闪烁效果</li><li>line-through：贯穿线效果（即中划线）</li><li>overline：上划线效果</li></ul><p>可以多个值混合使用，如：<code>text-decoration: line-through overline underline;</code> 达到显示上中下三条划线效果</p><p>常用：取消 a 链接 默认下划线样式：<code>text-decoration: none;</code></p><h5 id="font-variant-定义小型大写字母"><a href="#font-variant-定义小型大写字母" class="headerlink" title="font-variant 定义小型大写字母"></a>font-variant 定义小型大写字母</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">font-variant</span>: normal | small-caps;</span><br></pre></td></tr></table></figure><ul><li>normal：默认值，即正常的字体</li><li>snall-caps：小型的大写字母字体</li></ul><p>仅支持以英文为代表的西文字体</p><h5 id="text-transform-单词大小写"><a href="#text-transform-单词大小写" class="headerlink" title="text-transform 单词大小写"></a>text-transform 单词大小写</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-transform</span>: none | capitalize | uppercase | lowercase;</span><br></pre></td></tr></table></figure><ul><li>none：默认值，无转换发生</li><li>capitalize：将每个单词的第一个字母转换成大写，其余无转换</li><li>uppercase：所有字母转换为大写</li><li>lowercase：所有字母转换为小写</li></ul><h5 id="font-face-自定义字体类型"><a href="#font-face-自定义字体类型" class="headerlink" title="@font-face 自定义字体类型"></a>@font-face 自定义字体类型</h5><p>能够加载服务器端的字体文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>: <span class="string">&quot;设置文本的字体名称&quot;</span>;</span><br><span class="line">    <span class="attribute">font-style</span>: 设置文本样式;</span><br><span class="line">    <span class="attribute">font-variant</span>: 设置文本是否大小写;</span><br><span class="line">    <span class="attribute">font-weight</span>: 设置文本的粗细;</span><br><span class="line">    <span class="attribute">font-stretch</span>: 设置文本是否横向的拉伸变形;</span><br><span class="line">    <span class="attribute">font-size</span>： 设置文本字体大小;</span><br><span class="line">    <span class="attribute">src</span>: 设置自定义字体的相对路径或绝对路径;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h4><h5 id="text-align-水平对齐"><a href="#text-align-水平对齐" class="headerlink" title="text-align 水平对齐 *"></a>text-align 水平对齐 *</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-align</span>: left | right | center | justify;</span><br></pre></td></tr></table></figure><ul><li>left：左对齐，默认值</li><li>rigth：右对齐</li><li>center：居中对齐</li><li>justify：两端对齐</li></ul><p>CSS3 新增四个属性：</p><ul><li>start | end | match-parent | justify-all</li><li>浏览器支持不是很好</li></ul><h5 id="vertical-align-垂直对齐"><a href="#vertical-align-垂直对齐" class="headerlink" title="vertical-align 垂直对齐 *"></a>vertical-align 垂直对齐 *</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">vertical-align</span>: auto | baseline | sub | super | top | text-top | middle | bottom</span><br><span class="line">  | text-bottom | length;</span><br></pre></td></tr></table></figure><ul><li>auto：根据 layout-flow 的值对齐对象内容</li><li>baseline：默认值，表示将支持 valign 特性的对象内容与基线对齐</li><li>sub：表示垂直对齐文本的下标</li><li>super：表示垂直对齐文本的上标</li><li>top：对象的内容与对象顶端对齐</li><li>text-top：对象的文本与对象顶端对齐</li><li>middle：对象的内容与对象中部对齐</li><li>bottom：对象的内容与对象底端对齐</li><li>text-bottom：对象的文本与对象底端对齐</li><li>length：表示由浮点数字和单位标识符组成的长度值或百分数，可为负数，定义由基线(0,0%)算起的偏移量</li></ul><h5 id="letter-spacing-字间距"><a href="#letter-spacing-字间距" class="headerlink" title="letter-spacing 字间距"></a>letter-spacing 字间距</h5><p>取值为长度值</p><h5 id="word-spacing-词间距"><a href="#word-spacing-词间距" class="headerlink" title="word-spacing 词间距"></a>word-spacing 词间距</h5><p>取值为长度值，默认值为 normal，表示默认间隔，以空格作为识别的分界线</p><h5 id="line-height-行高"><a href="#line-height-行高" class="headerlink" title="line-height 行高 *"></a>line-height 行高 *</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">line-height</span>: normal | length;</span><br></pre></td></tr></table></figure><ul><li>normal：默认值，一般为 1.2em</li><li>length 为长度值，允许为负值，可以不写单位，灵活继承父级单位</li><li>一般行高的最佳设置范围为 1.2em~1.8em</li><li>可以遵循字体越大，行高越小的原则来定义</li></ul><h5 id="text-indent-首行缩进"><a href="#text-indent-首行缩进" class="headerlink" title="text-indent 首行缩进"></a>text-indent 首行缩进</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-indent</span>: length; <span class="comment">/* (2em) */</span></span><br></pre></td></tr></table></figure><ul><li>length 为长度值，允许为负值</li><li>可以巧用：将不想显示的文本缩进出窗口外 <code>text-indent: -9999px;</code></li><li>建议以 em 为设置单位</li></ul><h5 id="text-shadow-文字阴影"><a href="#text-shadow-文字阴影" class="headerlink" title="text-shadow 文字阴影"></a>text-shadow 文字阴影</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-shadow</span>: none || 水平偏移值 垂直偏移值 阴影模糊值 阴影颜色;</span><br></pre></td></tr></table></figure><ul><li>none：无阴影</li><li>前两个参数必须写，后两个可以省略</li><li>前两个参数，正值偏右或偏下，负值相反</li><li>阴影模糊值是一个长度值，不允许为负值</li><li>模糊距离越大越虚</li><li>颜色设置可以在调换到任意位置</li><li>如未设置颜色，则继承自 color 属性的颜色</li><li>设置多个阴影效果用 <code>,</code> 分隔</li><li>可以使用在 :first-letter 和 :first-line 伪元素上</li><li>在左上和右下各补一个 1 像素错位的补色阴影，可以起到外凸内凹的效果</li></ul><h5 id="text-overflow-溢出文本"><a href="#text-overflow-溢出文本" class="headerlink" title="text-overflow 溢出文本"></a>text-overflow 溢出文本</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">text-overflow</span>: clip | ellipsis | elipsis-word;</span><br></pre></td></tr></table></figure><ul><li>clip：不显示省略标记 <code>…</code> ，简单的裁切</li><li>ellipsis：当对象文本溢出时显示省略标记 <code>…</code> ，插入位置是最后一个字符</li><li>ellipsis-word：当对象文本溢出时显示省略标记 <code>…</code> ，插入位置是最后一个词</li></ul><p>要实现已出现是省略号的效果，还需要设置两个属性：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">white-space</span>: nowrap; <span class="comment">/* 强制文本在一行内显示 */</span></span><br><span class="line"><span class="attribute">overflow</span>: hidden; <span class="comment">/* 溢出隐藏 */</span></span><br></pre></td></tr></table></figure><h5 id="word-wrap-文本换行"><a href="#word-wrap-文本换行" class="headerlink" title="word-wrap 文本换行"></a>word-wrap 文本换行</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">word-wrap</span>: normal | break-word;</span><br></pre></td></tr></table></figure><ul><li>normal：表示控制连续文本换行</li><li>break-word：内容将在边界内换行</li></ul><h5 id="content-添加动态内容"><a href="#content-添加动态内容" class="headerlink" title="content 添加动态内容"></a>content 添加动态内容</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">content</span>: normal | string | <span class="built_in">attr</span>() | <span class="built_in">uri</span>() | <span class="built_in">counter</span>() | none;</span><br></pre></td></tr></table></figure><ul><li>normal：默认值</li><li>string：插入文本内容</li><li>attr()：插入元素的属性值</li><li>uri()：插入一个外部资源，如图像、音频、视频或浏览器支持的其他任何资源</li><li>counter()：计数器，用于插入排序标识</li><li>none：无任何内容</li></ul><p>一般和 ::before 一起使用，也可以单独使用</p><h4 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h4><h5 id="border-spacing-分离单元格间距"><a href="#border-spacing-分离单元格间距" class="headerlink" title="border-spacing 分离单元格间距"></a>border-spacing 分离单元格间距</h5><ul><li>可以为一个值 或 两个值</li><li>两个值时，第一个值表示行间距，第二个值表示列间距</li></ul><h5 id="empty-cells-控制空单元格显示"><a href="#empty-cells-控制空单元格显示" class="headerlink" title="empty-cells 控制空单元格显示"></a>empty-cells 控制空单元格显示</h5><ul><li>show：显示空单元格</li><li>hide：隐藏空单元格</li><li>空单元格：指没有可视内容的单元格<ul><li>如果单元格的 visibility 属性值为 hidden，即便单元格包含内容，也认为是空单元格</li><li><code>&amp;nbsp;</code> 和 其他空白字符为可视内容</li><li>ASCII 字符中的 回车符(“\0D”)、换行符(“\0A”)、Tab 键(“\09”)和空格键(“\20”)表示不可视内容</li></ul></li></ul><p>如果表格行中所有单元格的 empty-cells 属性都为 hide，且都不包含任何可视内容，那么整行就等于设置了 display: none</p><h5 id="caption-side-表格标题位置"><a href="#caption-side-表格标题位置" class="headerlink" title="caption-side 表格标题位置"></a>caption-side 表格标题位置</h5><p>定义标题的显示位置</p><ul><li>top（表格上面） | bottom（表格底部） | left | right</li></ul><h5 id="border-collapse-合并单元格边框"><a href="#border-collapse-合并单元格边框" class="headerlink" title="border-collapse 合并单元格边框"></a>border-collapse 合并单元格边框</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-collapse</span>: collapse; <span class="comment">/* 合并单元格边框 */</span></span><br></pre></td></tr></table></figure><h4 id="显示类型"><a href="#显示类型" class="headerlink" title="显示类型"></a>显示类型</h4><h5 id="display-显示类型"><a href="#display-显示类型" class="headerlink" title="display 显示类型"></a>display 显示类型</h5><p>css2.1 中，display 属性共有 18 个选项值</p><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td><strong>block</strong></td><td>块状显示，在元素后面添加换行符，即其他元素不能在后面并列显示</td></tr><tr><td><strong>none</strong></td><td>隐藏显示，不会为被隐藏的元素保留位置，而 visibility: hidden 会<br>表示隐藏的同时取消盒模型</td></tr><tr><td><strong>inline</strong></td><td>行内显示，在元素后面删除换行符，多个元素可以在一行内并列显示</td></tr><tr><td>inline-block</td><td>行内显示，但是元素的内容以块状显示，行内其他行内元素还会显示在同一行内</td></tr><tr><td>compact</td><td>紧凑的块状显示，基于内容上的行内显示</td></tr><tr><td>marker</td><td>在容器对象之前或之后显示，必须与 :after 或 :before 伪元素一起用</td></tr><tr><td>lnline-table</td><td>具有行内特征的表格显示</td></tr><tr><td><strong>list-item</strong></td><td>具有块状特征的列表项目显示，并可以添加可选项目标志，增加了缩进和 i 项目符号</td></tr><tr><td>run-in</td><td>块状显示或基于内容之上的行内显示</td></tr><tr><td>table</td><td>具有块状特征的表格显示</td></tr><tr><td>table-caption</td><td>表格标题显示</td></tr><tr><td>table-cell</td><td>表格单元格显示</td></tr><tr><td>table-column</td><td>表格列显示</td></tr><tr><td>table-column-group</td><td>表格列组显示</td></tr><tr><td>table-row</td><td>表格行显示</td></tr><tr><td>table-row-group</td><td>表格行组显示</td></tr><tr><td>table-header-group</td><td>表格标题组显示</td></tr><tr><td>table-footer-group</td><td>表格页脚组显示</td></tr></tbody></table><p>常用显示类型都可以划分为 block 和 inline 两种类型</p><h5 id="float-浮动显示"><a href="#float-浮动显示" class="headerlink" title="float 浮动显示"></a>float 浮动显示</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">float</span>: left | right | none;</span><br></pre></td></tr></table></figure><ul><li>left：元素向左浮动</li><li>right：元素向右浮动</li><li>none：默认值，表示消除浮动</li></ul><h6 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h6><ol><li>浮动元素以块状显示，可以定义 height 和 width</li><li>浮动元素与流动元素可以混合使用，不会重叠，都遵循向上后下的显示规则，都受到文档流影响</li><li>仅能改变水平显示方式，不能改变垂直显示方式</li><li>浮动元素可以并列显示，如果包含框宽度不够，则会错行显示</li></ol><h6 id="clear-清除浮动"><a href="#clear-清除浮动" class="headerlink" title="clear 清除浮动"></a>clear 清除浮动</h6><p>不是清除浮动元素，而是清除本身，即不允许当前元素与浮动元素并列显示</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">clear</span>: left | right | both | none;</span><br></pre></td></tr></table></figure><ul><li>left：清除左边的浮动元素，如果左边存在浮动元素，则当前元素会换行显示</li><li>right：清除右边的浮动元素，如果右边存在浮动元素，则当前元素会换行显示</li><li>both：清除左右两边的浮动元素，不管哪边存在浮动对象，当前元素都会换行显示</li><li>none：默认值，允许两边都可以存在浮动元素，当前元素不会主动换行显示</li></ul><p>clear 属性是专门针对 float 属性而设计的，依次仅能够对左右两侧浮动元素有效，对于非浮动元素是无效的</p><p>在结构最后添加：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-id">#contain</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">background</span>: pink;</span></span><br><span class="line"><span class="css">  &#125; <span class="comment">/* 包含元素 */</span></span></span><br><span class="line"><span class="css">  <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">float</span>: left;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">  &#125; <span class="comment">/* 定义共同属性 */</span></span></span><br><span class="line"><span class="css">  <span class="selector-id">#span1</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">10px</span> soild blue;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-id">#span2</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">border</span>: <span class="number">10px</span> soild red;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">clear</span>: both;</span></span><br><span class="line"><span class="css">  &#125; <span class="comment">/* 定义清除类，清除浮动 */</span></span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;contain&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span1&quot;</span>&gt;</span>span 元素浮动<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">id</span>=<span class="string">&quot;span2&quot;</span>&gt;</span>span 元素浮动<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;clear&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 添加一个清除元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="position-定位显示"><a href="#position-定位显示" class="headerlink" title="position 定位显示"></a>position 定位显示</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">position</span>: static | relative | absolute | fixed;</span><br></pre></td></tr></table></figure><ul><li>static：默认值，表示不定位，元素遵循 HTML 默认的流动模型</li><li>relative：表示相对定位，通过 top bottom left right 属性确定元素在正常文档流中的偏移位置，发生偏移后元素对象原空间保留不变</li><li>absolute：表示绝对定位，叫元素从文档流中拖出来，然后使用 top bottom left right 属性相对于其最接近的一个具有定位属性的父定位包含框进行绝对定位<ul><li>如果不存在有定位的上级元素，则相对于浏览器窗口定位，层叠顺序通过 z-index 属性来定义</li></ul></li><li>fixed：表示固定定位、粘性定位，相对于视图本身固定，不会随浏览器窗口的滚动而变化，该元素会始终位于浏览器窗口内视图的某个位置，通过 top bottom left right 属性设置位置，不会受文档流动影响，与 background-attachment: fixed 属性功能相同</li></ul><p>绝对定位元素以块状显示</p><p>设置相对定位元素在可视区之外，不会出现滚动条，而绝对元素会</p><p>一般来说：子绝（absolute）父相（relative）</p><h6 id="z-index-定位层叠"><a href="#z-index-定位层叠" class="headerlink" title="z-index 定位层叠"></a>z-index 定位层叠</h6><p>通过 z-index 属性来确定定位元素的层叠等级</p><ul><li>只有在元素的 position 属性取值为 relation absolute fixed 时才可以使用</li><li>z-index 属性值越大，层叠级别就越高，如果属性值相同，则根据结构顺序层叠</li><li>未指定的默认为 0，属性值为正数的在其之上，为负数的在其之下</li><li>IE 不支持 fixed 使用 z-index</li></ul><h5 id="columns-多列布局"><a href="#columns-多列布局" class="headerlink" title="columns 多列布局"></a>columns 多列布局</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">columns</span>: column-width || column-count;</span><br></pre></td></tr></table></figure><ul><li>column-width：定义每列的宽度</li><li>column-count：定义列数</li><li>适用于不可替换的块元素、行内块元素、单元格，但是表格元素除外</li><li>Webkit 引擎支持 -webkit-columns 私有属性</li><li>Mozilla Gecko 引擎支持 -moz-columns 私有属性</li></ul><h6 id="column-width-设置列宽"><a href="#column-width-设置列宽" class="headerlink" title="column-width 设置列宽"></a>column-width 设置列宽</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-width</span>: length | auto;</span><br></pre></td></tr></table></figure><ul><li>length：长度值，不可为负值</li><li>auto：根据浏览器自动计算来设置</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-count-设置列数"><a href="#column-count-设置列数" class="headerlink" title="column-count 设置列数"></a>column-count 设置列数</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-count</span>: integer | auto;</span><br></pre></td></tr></table></figure><ul><li>integer：定义栏目的列数，取值为大于 0 的整数</li><li>auto：根据浏览器计算值自动设置</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-gap-设置列间距"><a href="#column-gap-设置列间距" class="headerlink" title="column-gap 设置列间距"></a>column-gap 设置列间距</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-width</span>: normal | length;</span><br></pre></td></tr></table></figure><ul><li>normal：根据浏览器默认设置进行解析，一般为 1em</li><li>length：长度值，不可为负值</li><li>引擎私有属性格式同 columns</li></ul><h6 id="column-rule-设置列边框样式"><a href="#column-rule-设置列边框样式" class="headerlink" title="column-rule 设置列边框样式"></a>column-rule 设置列边框样式</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-rule</span>: length | style | color | transparent;</span><br></pre></td></tr></table></figure><ul><li>length：长度值，不可为负值，功能与 column-rule-width 属性相同</li><li>style：定义列边框样式，功能与 column-rule-style 属性相同</li><li>color：定义列边框的颜色，功能与 column-rule-color 属性相同</li><li>transparent：设置边框透明显示</li><li>派生属性：column-rule-width &amp; column-rule-style &amp; olumn-rule-color</li></ul><h6 id="column-span-设置跨列显示"><a href="#column-span-设置跨列显示" class="headerlink" title="column-span 设置跨列显示"></a>column-span 设置跨列显示</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-span</span>: none | all;</span><br></pre></td></tr></table></figure><ul><li>none：只在本栏中显示</li><li>all：将横跨所有列</li></ul><h6 id="column-fill-设置列高度"><a href="#column-fill-设置列高度" class="headerlink" title="column-fill 设置列高度"></a>column-fill 设置列高度</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">column-fill</span>: auto | balance;</span><br></pre></td></tr></table></figure><ul><li>auto：各列的高度随其内容的变化而自动变化</li><li>balance：初始值，各列的高度会根据内容最多的那一列的高度进行统一</li></ul><h4 id="弹性盒模型（伸缩盒模型）"><a href="#弹性盒模型（伸缩盒模型）" class="headerlink" title="弹性盒模型（伸缩盒模型）"></a>弹性盒模型（伸缩盒模型）</h4><h5 id="display-flex-定义"><a href="#display-flex-定义" class="headerlink" title="display: flex 定义"></a>display: flex 定义</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">display</span>: box | inline-box | flexbox | inline-flexbox | flex | inline-flex;</span><br></pre></td></tr></table></figure><ul><li>box：将对象作为弹性伸缩盒显示，伸缩盒为最老版本</li><li>inline-box： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为最老版本</li><li>flexbox：将对象作为弹性伸缩盒显示，伸缩盒为过渡版本</li><li>inline-flexbox： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为过渡版本</li><li>flex：将对象作为弹性伸缩盒显示，伸缩盒为最新版本</li><li>inline-flex： 将对象作为内联块级弹性伸缩盒显示，伸缩盒为最新版本</li></ul><p>目前最稳定最新的使用 <code>display: flex | inline-flex</code> 即可</p><p>CSS 的 colums、float、clear、vertical-align 属性在伸缩项目上没有效果</p><h5 id="flex-direction-定义伸缩方向"><a href="#flex-direction-定义伸缩方向" class="headerlink" title="flex-direction 定义伸缩方向"></a>flex-direction 定义伸缩方向</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br></pre></td></tr></table></figure><ul><li>row：默认值，在 ltr 排版方式下从左向右排列；在 rtl 排版方式下从右向左排列</li><li>row-reverse：与 row 排列方式相反</li><li>column：类似于 row，只不过是从上到下排列</li><li>column-reverse：与 column 排列方式相反</li></ul><h5 id="flex-wrap-定义换行"><a href="#flex-wrap-定义换行" class="headerlink" title="flex-wrap 定义换行"></a>flex-wrap 定义换行</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;</span><br></pre></td></tr></table></figure><ul><li>nowrap：默认值，伸缩容器单行显示</li><li>wrap：伸缩容器多行显示</li><li>wrap-reverse：伸缩容器多行显示，只不过排列方式与 wrap 相反</li></ul><h5 id="flex-flow-复合属性"><a href="#flex-flow-复合属性" class="headerlink" title="flex-flow 复合属性"></a>flex-flow 复合属性</h5><p>是 flex-direction 和 flex-wrap 属性的符合属性，适用于伸缩容器</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;</span><br></pre></td></tr></table></figure><p>可以同时定义伸缩容器的主轴和侧轴，其默认值为 row nowrap</p><h5 id="justify-content-主轴对齐"><a href="#justify-content-主轴对齐" class="headerlink" title="justify-content 主轴对齐"></a>justify-content 主轴对齐</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;</span><br></pre></td></tr></table></figure><ul><li>flex-start：默认值，伸缩项目向一行的起始位置靠齐</li><li>flex-end：伸缩项目向一行的结束位置靠齐</li><li>center：伸缩项目向一行的中间位置靠齐</li><li>space-between：平均分布在行里，第一个在开始位置，最后一个在终点位置</li><li>space-around：伸缩项目会平均分布在行里，两端也会保留相对于中间间隔一半空间</li></ul><h5 id="align-items-侧轴对齐"><a href="#align-items-侧轴对齐" class="headerlink" title="align-items 侧轴对齐"></a>align-items 侧轴对齐</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><ul><li>flex-start：伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴起始的边</li><li>flex-end：伸缩项目在侧轴起点边的外边距紧靠住该行在侧轴终点的边</li><li>center：伸缩项目的外边距在该行的侧轴上居中显示</li><li>baseline：伸缩项目根据他们的基线对齐</li><li>stretch：默认值，伸缩项目拉伸填充整个伸缩容器</li></ul><h5 id="align-content-伸缩行对齐"><a href="#align-content-伸缩行对齐" class="headerlink" title="align-content 伸缩行对齐"></a>align-content 伸缩行对齐</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">align-contetnt: flex-start | flex-end | center | space-between | space-around |</span><br><span class="line">  stretch;</span><br></pre></td></tr></table></figure><ul><li>flex-start：各行向伸缩容器的起点位置堆叠</li><li>flex-end：各行向伸缩容器的终点位置堆叠</li><li>center：各行向伸缩容器的中间位置堆叠</li><li>space-between：各行在伸缩容器中平均分布</li><li>space-around：各行在伸缩容器中平均分布，在两边各有一半的空间</li><li>stretch：默认值，各行将会伸展以占用剩余的空间</li></ul><h5 id="flex-定义伸缩项目"><a href="#flex-定义伸缩项目" class="headerlink" title="flex 定义伸缩项目"></a>flex 定义伸缩项目</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex</span>: none | [ &lt; <span class="string">&quot;flex-grow&quot;</span> &gt; &lt; <span class="string">&quot;flex-shrink&quot;</span> &gt;? || &lt; <span class="string">&quot;flex-basis&quot;</span> &gt; ];</span><br></pre></td></tr></table></figure><p>flex 是 flex-grow、flex-shirnk 和 flex-basis 三个属性的复合属性，适用于伸缩项目</p><ul><li>后两个参数是可选参数，默认值是 “0 1 auto”</li></ul><h6 id="flex-grow-扩展空间"><a href="#flex-grow-扩展空间" class="headerlink" title="flex-grow 扩展空间"></a>flex-grow 扩展空间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-grow</span>: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>默认值为 0，负值也可以生效，接收一个不带单位的值</p><p>决定伸缩容器剩余空间按比例应扩展多少空间</p><h6 id="flex-shrink-收缩空间"><a href="#flex-shrink-收缩空间" class="headerlink" title="flex-shrink 收缩空间"></a>flex-shrink 收缩空间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-shrink</span>: &lt;number&gt;;</span><br></pre></td></tr></table></figure><p>默认值为 1，负值也可以生效，与 flex-grow 功能相反</p><h6 id="flex-basis-伸缩比率"><a href="#flex-basis-伸缩比率" class="headerlink" title="flex-basis 伸缩比率"></a>flex-basis 伸缩比率</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">flex-basis</span>: &lt;length&gt; | auto;</span><br></pre></td></tr></table></figure><p>默认值为 auto，负值不合法</p><h6 id="order-显示位置"><a href="#order-显示位置" class="headerlink" title="order 显示位置"></a>order 显示位置</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">order</span>: &lt;integer&gt;;</span><br></pre></td></tr></table></figure><p>默认情况下，伸缩项目是按照文档流出现的先后顺序排列，使用 order 可以改变</p><h6 id="align-self-对齐方式"><a href="#align-self-对齐方式" class="headerlink" title="align-self 对齐方式"></a>align-self 对齐方式</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;</span><br></pre></td></tr></table></figure><p>属性值与 align-items 的属性值相同</p><h4 id="传统盒模型"><a href="#传统盒模型" class="headerlink" title="传统盒模型"></a>传统盒模型</h4><p>每个盒子都有 边界（外边距 margin）、边框（border）、填充（补白、内边距 padding）、内容（content）</p><h5 id="width-amp-height-宽高"><a href="#width-amp-height-宽高" class="headerlink" title="width &amp; height 宽高"></a>width &amp; height 宽高</h5><ul><li>当图像仅定义宽度或高度，则浏览器能够自动调整横纵比，使宽和高可以协调缩放</li><li>也可以设置 min-width max-width min-height max-height 灵活设置盒模型的大小</li><li>宽度 和 高度 指 content+padding+border</li></ul><h5 id="border-边框"><a href="#border-边框" class="headerlink" title="border 边框"></a>border 边框</h5><p>默认情况下不会显示边框，但是在为图片定义超链接时会自动显示 2~3 像素宽的蓝色粗边框</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border</span>： <span class="attribute">none</span>;</span><br></pre></td></tr></table></figure><h6 id="border-style-边框样式"><a href="#border-style-边框样式" class="headerlink" title="border-style 边框样式"></a>border-style 边框样式</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-style</span>: <span class="built_in">dotted</span>(点线) | <span class="built_in">dashed</span>(虚线) | <span class="built_in">soild</span>(实线) | <span class="built_in">double</span>(双线) | <span class="built_in">groove</span>(</span><br><span class="line">    立体凹槽</span><br><span class="line">  ) | <span class="built_in">ridge</span>(立体凸槽) | <span class="built_in">inset</span>(立体凹边) | <span class="built_in">outset</span>(立体凸边) | none | hidden;</span><br></pre></td></tr></table></figure><table><thead><tr><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>none</td><td>默认值，无边框，不受任何指定的 border-width 值影响</td></tr><tr><td>hidden</td><td>隐藏边框，IE 不支持</td></tr><tr><td>dotted</td><td>点线</td></tr><tr><td>dashed</td><td>虚线</td></tr><tr><td>soild</td><td>实线</td></tr><tr><td>double</td><td>双线边框，两线及其间隔宽度之和等于指定的 border-width 值</td></tr><tr><td>groove</td><td>3D 立体凹槽</td></tr><tr><td>ridge</td><td>3D 立体凸槽</td></tr><tr><td>inset</td><td>3D 立体凹边</td></tr><tr><td>outset</td><td>3D 立体凸边</td></tr></tbody></table><h6 id="border-color-边框颜色"><a href="#border-color-边框颜色" class="headerlink" title="border-color 边框颜色"></a>border-color 边框颜色</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-color</span>: value; <span class="comment">/* 同时设置四个边框的颜色 */</span></span><br><span class="line"><span class="attribute">border-color</span>: value value value value;</span><br></pre></td></tr></table></figure><p>也可以分别设置：border-top-color border-bottom-color border-left-color border-right-color</p><h6 id="border-width-边框宽度"><a href="#border-width-边框宽度" class="headerlink" title="border-width 边框宽度"></a>border-width 边框宽度</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-width</span>: length; <span class="comment">/* 同时设置四个边框的宽度 */</span></span><br><span class="line"><span class="attribute">border-width</span>: length length length length;</span><br></pre></td></tr></table></figure><ul><li>也可以分别设置：border-top-width border-bottom-width border-left-width border-right-width</li><li>可以使用关键字：thin、medium 和 thick。<ul><li>不同浏览器解析不同， 5px、3px、2px 或者 3px、2px、1px</li></ul></li></ul><h6 id="边框三角形"><a href="#边框三角形" class="headerlink" title="边框三角形"></a>边框三角形</h6><p>可以利用四个方向的 border-width border-color 设计出各种基于 CSS 三角形</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">  <span class="selector-class">.sanjiao</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="attribute">width</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">height</span>: <span class="number">0</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-top-width</span>: <span class="number">100px</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/* border-bottom-width: 100px; */</span></span></span><br><span class="line"><span class="css">    <span class="comment">/* border-left-width: 100px; */</span></span></span><br><span class="line"><span class="css">    <span class="attribute">border-right-width</span>: <span class="number">200px</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-style</span>: solid;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-top-color</span>: blue;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-left-color</span>: blue;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-bottom-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">    <span class="attribute">border-right-color</span>: <span class="number">#fff</span>;</span></span><br><span class="line"><span class="css">  &#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;sanjiao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="border-image-边框背景"><a href="#border-image-边框背景" class="headerlink" title="border-image 边框背景"></a>border-image 边框背景</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-image</span>: none | &lt;image&gt; [&lt;number&gt; | &lt;percentage&gt;]&#123;<span class="number">1</span>,<span class="number">4</span>&#125; <span class="selector-attr">[/ &lt;border-width&gt;&#123;1,4&#125;]</span></span><br></pre></td></tr></table></figure><p>用法和 background-image 相似</p><ul><li>webkit 引擎 支持 -webkit-border-image 私有属性</li><li>Mozilla Gecko 引擎 支持 -moz-border-image 私有属性</li><li>Presto 引擎 支持 -o-border-image 私有属性</li><li>IE 浏览器 暂不支持，也没有定义私有属性</li></ul><h5 id="border-radius-圆角边框"><a href="#border-radius-圆角边框" class="headerlink" title="border-radius 圆角边框"></a>border-radius 圆角边框</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">border-radius</span>: none | &lt;length&gt;&#123;<span class="number">1</span>,<span class="number">4</span>&#125;<span class="selector-attr">[/&lt;length&gt;&#123;1,4&#125;]</span></span><br></pre></td></tr></table></figure><ul><li>none：默认值，表示元素没有圆角</li><li>长度值，不可为负值</li><li>也可以包含俩个属性值，用 <code>/</code> 分隔，表示 水平半径 和 垂直半径，只有一个值的是代表这两个属性值相等</li><li>也可以分别设置：border-top-right-radius border-bottom-right-radius border-bottom-left-radius border-top-left-radius</li><li>值中包含 0，则这个角就是矩形，不会显示为圆角</li></ul><h5 id="margin-定义边界"><a href="#margin-定义边界" class="headerlink" title="margin 定义边界"></a>margin 定义边界</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">margin</span>: &lt;length&gt;;</span><br><span class="line"><span class="attribute">margin</span>: top right bottom left;</span><br><span class="line"><span class="attribute">margin</span>: top left&amp;right bottom;</span><br><span class="line"><span class="attribute">margin</span>: top&amp;bottom left&amp;right;</span><br></pre></td></tr></table></figure><ul><li>可分别定义 margin-top margin-bottom margin-left margin-right</li><li>也可在 margin 中直接设定四个值，使用空格进行分隔，顺序是 上 右 下 左，即从顶部顺时针设置</li><li>某个边不定义大小，可以使用 auto(自动) 关键字代替</li><li>上下不同，左右同可省略最后一个参数</li><li>上下同，左右同，写两个参数即可</li><li>margin 可以取负值，强迫元素偏移原来位置，实现相对定位</li><li>margin: 0 auto 可以起到块状元素居中显示</li></ul><h6 id="边界重叠"><a href="#边界重叠" class="headerlink" title="边界重叠"></a>边界重叠</h6><ul><li>边界重叠只发生在块状元素怒，且只是垂直相邻边界才会发生重叠</li><li>边界重叠时，两个边界中最小的那边将被覆盖</li><li>只有边界才会出现重叠，补白和边框不会出现</li></ul><h5 id="padding-定义补白"><a href="#padding-定义补白" class="headerlink" title="padding 定义补白"></a>padding 定义补白</h5><p>属性值的设置与 margin 相同</p><ul><li>不可为负</li></ul><p>一般开发中，通常清除所有元素的预定义样式：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="opacity-透明度"><a href="#opacity-透明度" class="headerlink" title="opacity 透明度"></a>opacity 透明度</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">opacity</span>: <span class="number">0</span>~<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>数值越低越透明</p><p>早期 IE 使用：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">filter</span>: <span class="built_in">alpha</span>(opacity=<span class="number">0</span>~<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="box-shadow-盒子阴影"><a href="#box-shadow-盒子阴影" class="headerlink" title="box-shadow 盒子阴影"></a>box-shadow 盒子阴影</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-shadow</span>: none | &lt;shadow&gt; [, &lt;shadow&gt;] *;</span><br></pre></td></tr></table></figure><p>其属性值与 text-shadow 类似</p><ul><li>shadow：<code>inset &amp;&amp; [&lt;length&gt;&#123;2,4&#125; &amp;&amp; &lt;color&gt;?]</code></li><li>inset：设置时时内阴影，默认为外阴影</li><li>也可以多个阴影效果叠加，使用 <code>,</code> 分隔</li></ul><h4 id="完整盒模型-CSS3"><a href="#完整盒模型-CSS3" class="headerlink" title="完整盒模型 CSS3"></a>完整盒模型 CSS3</h4><h5 id="box-sizing-定义尺寸解析方式"><a href="#box-sizing-定义尺寸解析方式" class="headerlink" title="box-sizing 定义尺寸解析方式"></a>box-sizing 定义尺寸解析方式</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">box-sizing</span>: content-box | border-box | inherit;</span><br></pre></td></tr></table></figure><ul><li>content-box：初始值，维持 CSS2.1 的组成模式，即元素 width/heigth = content+border+padding</li><li>border-box：重新定义，width/height = content</li></ul><p>webkit 引擎 支持 -webkit-border-sizing 私有属性；</p><p>Mozilla Gecko 引擎 支持 -moz-border-sizing 私有属性；</p><p>Prest 引擎 和 IE 浏览器 直接支持该属性</p><h5 id="resize-拖动改变元素尺寸"><a href="#resize-拖动改变元素尺寸" class="headerlink" title="resize 拖动改变元素尺寸"></a>resize 拖动改变元素尺寸</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">resize</span>: none | both | horizontal | vertical | inherit;</span><br></pre></td></tr></table></figure><ul><li>none：初始值，不提供尺寸调整进制</li><li>both：提供尺寸调整机制，允许用户调节元素的宽度和高度</li><li>horizontal：提供单向水平尺寸调整机制</li><li>vertical：提供单向垂直尺寸调整机制</li><li>inherit：默认继承</li></ul><h5 id="overflow-x-overflow-y-溢出处理"><a href="#overflow-x-overflow-y-溢出处理" class="headerlink" title="overflow-x overflow-y 溢出处理"></a>overflow-x overflow-y 溢出处理</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">overflow-x</span>: visiable | hidden | scroll | auto | no-display | no-contentoverflow-y: visiable | hidden | scroll | auto | no-display | no-content</span><br></pre></td></tr></table></figure><ul><li>visiable：默认值，不剪切内容，也不添加滚动条，元素将会被剪切为包含对象的窗口大小，且 clip 属性设置将失效</li><li>auto：在需要时剪切内容并添加滚动条，为 body 和 textarea 的默认值</li><li>hidden：不显示超出元素尺寸的内容</li><li>scroll：当内容超出元素尺寸，则 overflow-x 显示为横向滚动条，overflow-y 显示为纵向滚动条</li><li>no-display：当内容超出元素尺寸，则不显示元素，此时类似添加了 display:none 声明。仅作为交流使用</li><li>no-content：当内容超出元素尺寸，则不显示内容，此时类似添加了 visibility:hidden 声明。仅作为交流使用</li></ul><p>使用时应同时设置 overflow-x 和 overflow-y 的属性值，不要出现一个为 hidden，而另一个为 visiable 的情况；</p><p>还要避免编写依赖指定值为 visiable 的 overflow-x 和 overflow-y 属性的计算值的代码</p><h5 id="outline-定义轮廓"><a href="#outline-定义轮廓" class="headerlink" title="outline 定义轮廓"></a>outline 定义轮廓</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline</span>: [outline-color] || [outline-style] || [outline-width] ||</span><br><span class="line">  [outline-offset] || inherit;</span><br></pre></td></tr></table></figure><ul><li>定义颜色、轮廓样式、宽度、偏移位置的数值</li><li>可以将轮廓线理解为飘在元素上方，不占位置，显不显示轮廓线不会影响文档流，也不会破坏网页布局</li><li>轮廓线有可能是非矩形的</li></ul><h6 id="outline-width-轮廓宽度"><a href="#outline-width-轮廓宽度" class="headerlink" title="outline-width 轮廓宽度"></a>outline-width 轮廓宽度</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline-width</span>: thin | medium | thick | &lt;length&gt; | inherit;</span><br></pre></td></tr></table></figure><p>不允许设置负值</p><h6 id="outline-style-轮廓样式"><a href="#outline-style-轮廓样式" class="headerlink" title="outline-style 轮廓样式"></a>outline-style 轮廓样式</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline-style</span>: auto | &lt;border-style&gt; | inherit;</span><br></pre></td></tr></table></figure><ul><li>auto：根据浏览器自动设置</li><li>border-style：沿用边框样式</li><li>inherit：默认继承</li></ul><h6 id="outline-color-轮廓颜色"><a href="#outline-color-轮廓颜色" class="headerlink" title="outline-color 轮廓颜色"></a>outline-color 轮廓颜色</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline-color</span>: &lt;color&gt; | invert | inherit;</span><br></pre></td></tr></table></figure><ul><li>color：颜色类型值</li><li>invert：执行颜色反转（逆向的颜色），确保轮廓线在不同的背景颜色中都是可见的</li><li>inherit：默认继承</li></ul><h6 id="outline-offset-轮廓偏移"><a href="#outline-offset-轮廓偏移" class="headerlink" title="outline-offset 轮廓偏移"></a>outline-offset 轮廓偏移</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">outline-offset</span>: &lt;length&gt; | inherit;</span><br></pre></td></tr></table></figure><p>定义轮廓距离容器的值</p><h4 id="背景-background"><a href="#背景-background" class="headerlink" title="背景 background"></a>背景 background</h4><h5 id="background-color-背景颜色"><a href="#background-color-背景颜色" class="headerlink" title="background-color 背景颜色"></a>background-color 背景颜色</h5><p><code>background: rgba(0, 0, 0, a);</code> 可以实现半透明</p><h5 id="background-image-背景图片"><a href="#background-image-背景图片" class="headerlink" title="background-image 背景图片"></a>background-image 背景图片</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>: none | <span class="built_in">url</span>();</span><br></pre></td></tr></table></figure><p>CSS3 支持 渐变背景，其规则比较复杂，使用时查看文档</p><h5 id="background-repeat-显示方式"><a href="#background-repeat-显示方式" class="headerlink" title="background-repeat 显示方式"></a>background-repeat 显示方式</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-repeat</span>: repeat-x | repeat-y | [repeat | space | round | no-repeat]&#123;<span class="number">1</span>,<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure><ul><li>repeat-x：背景图像在横向上平铺</li><li>repeat-y：背景图像在纵向上平铺</li><li>repeat：在横向和纵向平铺</li><li>no-repeat：不平铺</li><li>round：自动缩放到直到适应且填充满整个容器</li><li>space：以相同的间距平铺且填充满整个容器或某个方向</li></ul><h5 id="background-position-显示位置"><a href="#background-position-显示位置" class="headerlink" title="background-position 显示位置"></a>background-position 显示位置</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-position</span>: [left | center | right | top | bottom];</span><br></pre></td></tr></table></figure><ul><li>默认值为 0% 0%，等效于 left top</li></ul><h5 id="background-attachment-背景附着"><a href="#background-attachment-背景附着" class="headerlink" title="background-attachment 背景附着"></a>background-attachment 背景附着</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-attachment</span>: fixed | local | scroll;</span><br></pre></td></tr></table></figure><ul><li>fixed：背景图像相对于浏览器窗体固定</li><li>local：背景图像相对于元素内容固定</li><li>scroll：背景图像相对于元素固定</li></ul><h5 id="background-origin-定义坐标"><a href="#background-origin-定义坐标" class="headerlink" title="background-origin 定义坐标"></a>background-origin 定义坐标</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-origin</span>: border-box | padding-box | content-box;</span><br></pre></td></tr></table></figure><ul><li>border-box：从边框区域开始显示背景</li><li>padding-box：从补白区域开始显示背景</li><li>content-box：仅在内容区域显示背景</li></ul><p>Webkit 引擎还支持 -webkit-backgroundorigin</p><p>Mozilla Gecko 引擎支持 -moz-background-origin</p><h5 id="background-clip-定义裁剪区域"><a href="#background-clip-定义裁剪区域" class="headerlink" title="background-clip 定义裁剪区域"></a>background-clip 定义裁剪区域</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-clip</span>: border-box | padding-box | content-box | text;</span><br></pre></td></tr></table></figure><ul><li>border-box：从边框区域开始显示背景</li><li>padding-box：从补白区域开始显示背景</li><li>content-box | content：仅在内容区域显示背景</li><li>text：从前景内容（如文字）区域向外裁剪背景</li></ul><p>Webkit 引擎还支持 -webkit-backgroundclip</p><p>Mozilla Gecko 引擎支持 -moz-background-clip</p><p>Presto 引擎 和 IE9+ 引擎支持该属性部分取值</p><p>FireFox 不支持该 text 值</p><h5 id="background-size-背景图片大小"><a href="#background-size-背景图片大小" class="headerlink" title="background-size 背景图片大小"></a>background-size 背景图片大小</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background-size</span>: [&lt;length&gt; | &lt;percentage&gt; | auto]&#123;<span class="number">1</span>,<span class="number">2</span>&#125; | cover | contain;</span><br></pre></td></tr></table></figure><ul><li>尽量只改一个，防止图片比例被破坏</li><li>可以是百分比值</li><li>cover：图片进行等比例缩放，直到填满背景盒子</li><li>contain：图片进行等比例缩放，直到碰到背景框</li></ul><p>Webkit 引擎还支持 -webkit-backgroundsize</p><p>Mozilla Gecko 引擎支持 -moz-background-size</p><h5 id="background-break-定义循环方式"><a href="#background-break-定义循环方式" class="headerlink" title="background-break 定义循环方式"></a>background-break 定义循环方式</h5><p>定义平铺内联元素背景图像时的循环方式</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">background</span>-break: bounding-box | each-box | coninuous;</span><br></pre></td></tr></table></figure><ul><li>Firefox 中使用 -moz-background-inline-policy</li><li>其他浏览器还不支持</li></ul><h5 id="简写"><a href="#简写" class="headerlink" title="简写"></a>简写</h5><p><code>background: 背景颜色 背景图片地址 背景平铺 背景滚动 背景位置;</code></p><p>例子： <code>background: #000 url() no-repeat fixed center -25px;</code></p><p>可以设置多背景图像</p><p><code>background: url(1) ... , url(2) ...;</code></p><ul><li>每组之间逗号分隔，有交集则前面的覆盖后面的</li><li>背景色一般设置在最后一组</li><li>允许多重指定的属性有：background-image，background-repeat，background-position，background-clip，background-origin，background-size</li></ul><h4 id="动画-transform"><a href="#动画-transform" class="headerlink" title="动画 transform"></a>动画 transform</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform</span>: none | &lt;transform-function&gt; [ &lt;transform-function&gt; ] *;</span><br></pre></td></tr></table></figure><ul><li>初始值是 none，适用于块元素和行内元素</li><li>transform-function：设置变换函数，可以是一个或多个变换函数列表</li><li>各早期版本浏览器支持的私有属性：-webkit-transform、moz-transform、-o-tranform、-ms-tranform</li></ul><h5 id="2D-变换"><a href="#2D-变换" class="headerlink" title="2D 变换"></a>2D 变换</h5><h6 id="rotate-定义旋转"><a href="#rotate-定义旋转" class="headerlink" title="rotate() 定义旋转"></a>rotate() 定义旋转</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotate(&lt;angle&gt;)</span><br></pre></td></tr></table></figure><h6 id="scale-定义缩放"><a href="#scale-定义缩放" class="headerlink" title="scale() 定义缩放"></a>scale() 定义缩放</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale(&lt;number&gt; <span class="selector-attr">[, &lt;number&gt;]</span>)</span><br></pre></td></tr></table></figure><ul><li>两个参数表示定义宽和高缩放比例，第二个参数省略表示两值相同</li><li>number 参数值可以是正数、负数和小数<ul><li>正数值基于指定的宽度和高度将放大元素</li><li>负数表示翻转元素（如文字反转），然后再缩放元素</li><li>使用小于一的正数可以缩小元素</li></ul></li><li>可以使用 <strong>scaleX()</strong> 和 <strong>scaleY()</strong> 分别设置</li></ul><h6 id="translate-定义移动"><a href="#translate-定义移动" class="headerlink" title="translate() 定义移动"></a>translate() 定义移动</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate(&lt;translation-value&gt; <span class="selector-attr">[, &lt;translation-value&gt;]</span>)</span><br></pre></td></tr></table></figure><ul><li>分别表示 x 轴 和 y 轴 相对于原位置的偏移距离</li><li>省略第二个参数则第二个参数默认为 0</li><li>为负值为反向偏移</li><li>可以使用 <strong>translateX()</strong> 和 <strong>translateY()</strong> 分别设置</li></ul><h6 id="skew-定义倾斜"><a href="#skew-定义倾斜" class="headerlink" title="skew() 定义倾斜"></a>skew() 定义倾斜</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">skew(&lt;angle&gt; <span class="selector-attr">[, &lt;angle&gt;]</span>)</span><br></pre></td></tr></table></figure><ul><li>以 x 轴和 或 y 轴 为轴旋转，与 rotate() 不同，这个会改变形状</li><li>可以使用 <strong>skewX()</strong> 和 <strong>skewY()</strong> 分别设置</li></ul><h6 id="matrix-定义矩阵"><a href="#matrix-定义矩阵" class="headerlink" title="matrix() 定义矩阵"></a>matrix() 定义矩阵</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matrix(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;)</span><br></pre></td></tr></table></figure><p>1 到 6 参数分别代表：x 轴缩放、x 轴倾斜、y 轴倾斜、y 轴缩放、x 轴移动、y 轴移动</p><h5 id="3D-变换"><a href="#3D-变换" class="headerlink" title="3D 变换"></a>3D 变换</h5><h6 id="translate3d-定义位移"><a href="#translate3d-定义位移" class="headerlink" title="translate3d() 定义位移"></a>translate3d() 定义位移</h6><p>增加了可以让元素在 3D 空间延 Z 轴 进行位移</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">translate3d(tx, ty, tz)</span><br></pre></td></tr></table></figure><ul><li>tz：不能是一个百分比值，负责会被视为无效值</li><li>可以使用 <strong>translateZ()</strong> 单独设置 Z 轴</li></ul><h6 id="scale3d-定义缩放"><a href="#scale3d-定义缩放" class="headerlink" title="scale3d() 定义缩放"></a>scale3d() 定义缩放</h6><p>增加了可以让元素在 3D 空间在 Z 轴 方向上按比例缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scale3d(sx, sy, sz)</span><br></pre></td></tr></table></figure><ul><li>可以使用 <strong>scaleZ()</strong> 单独设置 Z 轴</li><li>scaleZ(-1) 定义了一个原点在 Z 轴 的对称点（按照元素的交换原点）</li></ul><h6 id="rotate3d-定义旋转"><a href="#rotate3d-定义旋转" class="headerlink" title="rotate3d() 定义旋转"></a>rotate3d() 定义旋转</h6><p>增加了可以让元素在 3D 空间在 Z 轴 方向上按比例缩放</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rotate3d(x, y, z, <span class="selector-tag">a</span>)</span><br></pre></td></tr></table></figure><ul><li>x, y, z 均为 0~1 之间的数值，分别描述元素围绕 x, y, z 轴旋转的矢量值</li><li>可以使用 <strong>rotateX(a)</strong> <strong>rotateY(a)</strong> 和 <strong>rotateZ(a)</strong> 分别设置</li><li>a：是一个角度值，主要用来指定元素在 3D 空间旋转的角度，为正顺时针转，为负逆时针转</li></ul><h5 id="transfrom-origin-改变变换中心"><a href="#transfrom-origin-改变变换中心" class="headerlink" title="transfrom-origin 改变变换中心"></a>transfrom-origin 改变变换中心</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transform-origin</span>: [ [ &lt;percentage&gt; | &lt;length&gt; | left | center | right ] [</span><br><span class="line">  &lt;percentage&gt; | &lt;length&gt; | top | center | bottom ]? ];</span><br></pre></td></tr></table></figure><ul><li>CSS 变换的原点默认为对象的中心点</li><li>接收两个参数，可以是产具体值，也可以是关键词</li></ul><h5 id="transition-设置过渡动画"><a href="#transition-设置过渡动画" class="headerlink" title="transition 设置过渡动画"></a>transition 设置过渡动画</h5><h6 id="transition-property-设置过渡属性"><a href="#transition-property-设置过渡属性" class="headerlink" title="transition-property 设置过渡属性"></a>transition-property 设置过渡属性</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-property</span>: none | all | [ &lt;IDENT&gt; ] [ <span class="string">&quot;,&quot;</span> &lt;IDENT&gt; ] *;</span><br></pre></td></tr></table></figure><ul><li>none：表示没有元素</li><li>all：默认值，表示针对所有元素，包括 :before 和 :after 伪元素</li><li>IDENT：指定 CSS 属性列表，几乎所有色彩、大小或位置等相关的 CSS 属性，都可以应用过渡</li></ul><h6 id="transition-duration-设置过渡时间"><a href="#transition-duration-设置过渡时间" class="headerlink" title="transition-duration 设置过渡时间"></a>transition-duration 设置过渡时间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-duration</span>: &lt;time&gt; [, &lt;time&gt;] *;</span><br></pre></td></tr></table></figure><p>初始值为 0，适用于所有元素，包括 :before 和 :after 伪元素</p><h6 id="transition-delay-设置延迟时间"><a href="#transition-delay-设置延迟时间" class="headerlink" title="transition-delay 设置延迟时间"></a>transition-delay 设置延迟时间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-delay</span>: &lt;time&gt; [, &lt;time&gt;] *;</span><br></pre></td></tr></table></figure><ul><li>初始值为 0，适用于所有元素，包括 :before 和 :after 伪元素</li><li>设置时间可以为正整数、负整数和 0</li><li>为 0 时 必须设置单位是 s 或者 ms</li><li>为负数时，过渡的动作会从该时间点开始显示，之前的动作被截断</li><li>为正数时，过渡的动作会延迟触发</li></ul><h6 id="transition-timing-function-设置过渡动画类型"><a href="#transition-timing-function-设置过渡动画类型" class="headerlink" title="transition-timing-function 设置过渡动画类型"></a>transition-timing-function 设置过渡动画类型</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">transition-timing-function</span>: ease | linear | ease-in | ease-out | ease-in-out |</span><br><span class="line">    <span class="built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear |</span><br><span class="line">    ease-in | ease-out | ease-in-out | <span class="built_in">cubic-bezier</span>(</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;</span><br><span class="line">    ) ] *;</span><br></pre></td></tr></table></figure><ul><li>ease：平滑过渡，等同于 cubic-bezier(0.25, 0.1, 0.25, 1.0) 函数</li><li>linear：线性过渡，等同于 cubic-bezier(0.0, 0.0, 1.0, 1.0) 函数</li><li>ease-in：由慢到快，等同于 cubic-bezier(0.42, 0, 1.0, 1.0) 函数</li><li>ease-out：由快到慢，等同于 cubic-bezier(0, 0, 0.58, 1.0) 函数</li><li>ease-in-out：由慢到快再到慢，等同于 cubic-bezier(0.42, 0, 0.58, 1.0) 函数</li><li>cubic-bezier：特殊的立方贝塞尔曲线效果</li></ul><h6 id="设置触发效果"><a href="#设置触发效果" class="headerlink" title="设置触发效果"></a>设置触发效果</h6><p>一般通过鼠标事件或状态定义动画，如 CSS 伪类 和 JavaScript 事件</p><ul><li>:link、:visited、:hover、:active、:focus、:checked</li><li>click、focus、mousemove、mouseover、mouseout 等</li></ul><h5 id="animation-设置帧动画"><a href="#animation-设置帧动画" class="headerlink" title="animation 设置帧动画"></a>animation 设置帧动画</h5><p>功能和 transition 相同，区别在于：</p><ul><li>transition 只能指定属性的开始值和结束值，及其之间的过渡效果</li><li>animation 可以定义多个关键帧以及定义每个关键帧中元素的属性值来实现更为复杂的动画效果</li></ul><p>兼容性：</p><ul><li>-webkit-animation、-moz-animation、-o-animation</li><li>IE6~9 不支持 animation 属性</li></ul><h6 id="keyframes-设置关键帧"><a href="#keyframes-设置关键帧" class="headerlink" title="@keyframes 设置关键帧"></a>@keyframes 设置关键帧</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@keyframes</span> animationname &#123;</span><br><span class="line">    keyframes-selector &#123;</span><br><span class="line">        css-styles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>animationname：定义动画名称</li><li>keyframes-selector：定义帧的事件未知，也就是动画时长的百分比<ul><li>可取值：0%~100%、from（等价于 0%）、to（等价于 100%）</li></ul></li><li>css-styles：表示一个或多个合法的 CSS 样式属性</li><li>为了避免有兼容性的问题，应始终定义 0% 和 100% 位置帧</li></ul><h6 id="animation-name-定义动画名称"><a href="#animation-name-定义动画名称" class="headerlink" title="animation-name 定义动画名称"></a>animation-name 定义动画名称</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-name</span>: none | IDENT [, none | IDENT] *;</span><br></pre></td></tr></table></figure><p>初始值为 none，定义一个适用的动画列表</p><h6 id="animation-duration-定义动画时间"><a href="#animation-duration-定义动画时间" class="headerlink" title="animation-duration 定义动画时间"></a>animation-duration 定义动画时间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-duration</span>: &lt;time&gt; [, &lt;time&gt;] *;</span><br></pre></td></tr></table></figure><ul><li>定义播放时间</li><li>默认属性值为 0</li><li>为负值时，被视为 0</li></ul><h6 id="animation-timing-function-设置过渡动画类型"><a href="#animation-timing-function-设置过渡动画类型" class="headerlink" title="animation-timing-function 设置过渡动画类型"></a>animation-timing-function 设置过渡动画类型</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-timing-function</span>: ease | linear | ease-in | ease-out | ease-in-out |</span><br><span class="line">    <span class="built_in">cubic-bezier</span>(&lt;number&gt;, &lt;number&gt;, &lt;number&gt;, &lt;number&gt;) [, ease | linear |</span><br><span class="line">    ease-in | ease-out | ease-in-out | <span class="built_in">cubic-bezier</span>(</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;,</span><br><span class="line">      &lt;number&gt;</span><br><span class="line">    ) ] *;</span><br></pre></td></tr></table></figure><p>初始值为 ease，参数值和 transition-timing-function 相同</p><h6 id="animation-delay-定义延迟时间"><a href="#animation-delay-定义延迟时间" class="headerlink" title="animation-delay 定义延迟时间"></a>animation-delay 定义延迟时间</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-delay</span>: &lt;time&gt; [, &lt;time&gt;] *;</span><br></pre></td></tr></table></figure><p>允许一个动画开始执行一段时间后才被应用</p><h6 id="animation-iteration-count-定义播放次数"><a href="#animation-iteration-count-定义播放次数" class="headerlink" title="animation-iteration-count 定义播放次数"></a>animation-iteration-count 定义播放次数</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-iteration-count</span>: infinite | &lt;number&gt; [, infinite | &lt;number&gt;] *;</span><br></pre></td></tr></table></figure><ul><li>默认值为 1，动画只播放一次</li><li>infinite 表示无限次，即 CSS 动画永远重复</li><li>取值为非整数，将导致动画结束一个周期的一部分</li><li>值为负数，则在交替周期内反向播放动画</li></ul><h6 id="animation-direction-定义播放方向"><a href="#animation-direction-定义播放方向" class="headerlink" title="animation-direction 定义播放方向"></a>animation-direction 定义播放方向</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-direction</span>: normal | alternate [, normal | alternate] *;</span><br></pre></td></tr></table></figure><ul><li>normal：默认值，每次循环都是向前播放</li><li>alternate：表示第偶数次向前播放，第奇数次项反方向播放</li></ul><h6 id="animation-play-state-定义播放状态"><a href="#animation-play-state-定义播放状态" class="headerlink" title="animation-play-state 定义播放状态"></a>animation-play-state 定义播放状态</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-play-state</span>: paused | running;</span><br></pre></td></tr></table></figure><ul><li><p>running：初始值，定义动画正在播放</p></li><li><p>paused：定义动画已暂停</p></li><li><p>可以在 JavaScript 中使用该属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.style.animationPlayState = <span class="string">&quot;paused&quot;</span>;</span><br></pre></td></tr></table></figure></li></ul><h6 id="animation-fill-mode-定义播放外状态"><a href="#animation-fill-mode-定义播放外状态" class="headerlink" title="animation-fill-mode 定义播放外状态"></a>animation-fill-mode 定义播放外状态</h6><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">animation-fill-mode</span>: none | forwards | backwards | both [, none | forwards |</span><br><span class="line">    backwards | both ] *;</span><br></pre></td></tr></table></figure><ul><li>none：初始值，不设置对象动画外的转态</li><li>forwards：设置对象状态为动画结束时的状态</li><li>backwards：设置对象状态为动画开始时的状态</li><li>both：设置对象状态为动画结束或开始的状态</li></ul><h4 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h4><h5 id="list-style-image-列表符号"><a href="#list-style-image-列表符号" class="headerlink" title="list-style-image 列表符号"></a>list-style-image 列表符号</h5><p>自定义项目符号，允许指定一个外部图标文件</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">list-style-image</span>: none | <span class="built_in">url</span>();</span><br></pre></td></tr></table></figure><ul><li>自定义项目符号存在时，会覆盖 list-style-type 设置的符号</li><li>比较简陋，可以利用背景图精确定位，然后左侧留白巧妙达到效果，需要取消默认样式</li></ul><h5 id="list-style-position-符号位置"><a href="#list-style-position-符号位置" class="headerlink" title="list-style-position 符号位置"></a>list-style-position 符号位置</h5><h5 id="list-style-type-符号类型"><a href="#list-style-type-符号类型" class="headerlink" title="list-style-type 符号类型"></a>list-style-type 符号类型</h5><table><thead><tr><th>属性值</th><th>说明</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>disc</td><td>实心圆，默认值</td><td>upper-roman</td><td>大写罗马数字</td></tr><tr><td>circle</td><td>空心圆</td><td>lower-alpha</td><td>小写英文字母</td></tr><tr><td>square</td><td>实心方块</td><td>upper-alpha</td><td>大写英文字母</td></tr><tr><td>decimal</td><td>阿拉伯数字</td><td>none *</td><td>不使用项目符号</td></tr><tr><td>lower-roman</td><td>小写罗马数字</td><td>armenian</td><td>传统的亚美尼亚数字</td></tr><tr><td>cjk-ideographic</td><td>浅白的表意数字</td><td>georgian</td><td>传统的乔治数字</td></tr><tr><td>lower-greek</td><td>基本的希腊小写字母</td><td>hebrew</td><td>传统的希伯莱数字</td></tr><tr><td>hiragana</td><td>日文平假名字符</td><td>hiragana-iroha</td><td>日文平假名序号</td></tr><tr><td>katakana</td><td>日文片假名字符</td><td>katakana-iroha</td><td>日文片假名序号</td></tr><tr><td>lower-latin</td><td>小写拉丁字母</td><td>upper-latin</td><td>大写拉丁字母</td></tr></tbody></table><h4 id="属性值"><a href="#属性值" class="headerlink" title="属性值"></a>属性值</h4><h5 id="initial-取消样式指定"><a href="#initial-取消样式指定" class="headerlink" title="initial 取消样式指定"></a>initial 取消样式指定</h5><p>让各种属性使用默认值，例：<code>color: initial; /* 恢复到浏览器默认的黑色字体 */</code></p><h5 id="inherit-默认继承"><a href="#inherit-默认继承" class="headerlink" title="inherit 默认继承"></a>inherit 默认继承</h5><p>默认继承来自父辈的该属性的属性值</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><h5 id="cursor-定义鼠标样式"><a href="#cursor-定义鼠标样式" class="headerlink" title="cursor 定义鼠标样式"></a>cursor 定义鼠标样式</h5><ul><li>auto：根据上下文决定应该显示什么光标</li><li>crosshair：十字线光标（+）</li><li>default：基于平台的默认光标，通常渲染为一个箭头</li><li>pointer：指针光标，表示一个超链接<ul><li><code>cursor: hand;</code> ：兼容 IE6 以下版本浏览器</li></ul></li><li>move：十字箭头光标，用于标示对象可被移动</li><li>e-resize|ne-resize|nw-resize|n-resize|se-resize|sw-resize|s-resize|resize：表示正在移动某个边或某个角的鼠标箭头样式</li><li>text：表示可以选择文本，通常渲染为 I 型光标</li><li>wait：表示程序正忙，需要用户等待，通常渲染为手表或沙漏</li><li>help：光标下的对象包含有帮助内容，通常渲染为一个问号或一个气球</li><li>&lt;url&gt;URL：自定义光标类型的图标路径<ul><li>IE 和 Opera 仅支持 *.cur 等待定的图片格式</li><li>其他几款既支持特定图片类型，也支持常见的 jpg png gif 等类型</li></ul></li></ul><h3 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h3><h4 id="层叠性"><a href="#层叠性" class="headerlink" title="层叠性"></a>层叠性</h4><h5 id="CSS-样式表的优先级"><a href="#CSS-样式表的优先级" class="headerlink" title="CSS 样式表的优先级"></a>CSS 样式表的优先级</h5><p>作者定义的样式 &gt; 用户设置的样式 &gt; 浏览器的默认样式 &gt; HTML 的默认样式</p><p>特殊：</p><p>CSS2 中，用户设置的带 !important 的样式要优先于 作者声明的 !important 样式</p><h5 id="CSS-样式的优先级"><a href="#CSS-样式的优先级" class="headerlink" title="CSS 样式的优先级"></a>CSS 样式的优先级</h5><p>计算权值的方式判断优先级</p><ul><li>权值为 0 的：通配符选择器</li><li>权值为 1 的：标签选择器、伪元素选择器、伪对象选择器</li><li>权值为 10 的：类选择器、属性选择器</li><li>权值为 100 的：ID 选择器</li></ul><p>对于多个选择器组合而成的复合型选择器，分别计算后相加</p><ol><li>分值越高优先级越高</li><li>若分值相同则根据位置关系来进行判断，越靠近对象的优先级越高</li></ol><p>另外，<code>!important</code> 表示最大优先级，要放置在声明语句与分号之间</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span> <span class="meta">!important</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>被继承的值具有特殊性，权值为 0</p><p>即不管父级样式的优先级多大，被子级元素继承时，该原始的优先级权重都为 0</p><p>例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">    <span class="selector-id">#header</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: blue;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">span</span> &#123;</span></span><br><span class="line"><span class="css">      <span class="attribute">color</span>: grey;</span></span><br><span class="line"><span class="css">    &#125;</span></span><br><span class="line"><span class="css">  </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">class</span>=<span class="string">&quot;blue&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span>&gt;</span>遗产继承不如白手起家<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 为灰色而不是蓝色 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>内联样式优先级更高</li><li>在相同特殊性下，遵循就近原则</li><li><code>!important</code> 有最大优先权，不论远近<ul><li>但继承的 <code>!important</code> 内的样式也还是 0</li></ul></li></ul><h4 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h4><p>指被包含的元素将拥有外层元素的样式效果</p><h4 id="显示类型-1"><a href="#显示类型-1" class="headerlink" title="显示类型"></a>显示类型</h4><h5 id="块状元素-Block"><a href="#块状元素-Block" class="headerlink" title="块状元素 Block"></a>块状元素 Block</h5><p>宽度一般为 100%，占据一行</p><p>address、blockquote、div、dl、fieldset、form、h1~h6、hr、noframes、noscript、ol、p、pre、table、ul、li、legend</p><h5 id="行内元素-Inline"><a href="#行内元素-Inline" class="headerlink" title="行内元素 Inline"></a>行内元素 Inline</h5><p>没有固定的大小，定义它的 width 和 height 属性无效，可以在行内自由流动，可以定义边界、补白、边框和背景</p><p>其显示的高度和宽度只能够根据所包含内容的高度和宽度来确定</p><p>a、abbr、acronym、b、bdo、big、br、button、cite、code、dfn、em、i、img、input、kbd、label、map、object、q、samp、script、select、small、span、strike、strong、sub、textarea、tt、var</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> CSS3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML笔记</title>
      <link href="/2021/08/03/HTML%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/08/03/HTML%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>是最基础的网页开发语言</p><p>Hyper Text Markup Language 超文本标记语言</p><ul><li>超文本:<ul><li>超文本是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本.</li></ul></li><li>标记语言:<ul><li>由标签构成的语言。&lt;标签名称&gt; 如 html，xml</li><li>标记语言不是编程语言</li></ul></li></ul><h2 id="快速入门"><a href="#快速入门" class="headerlink" title="快速入门"></a>快速入门</h2><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ol><li><p>html 文档后缀名 .html 或者 .htm</p></li><li><p>标签分为</p><ol><li>围堵标签：有开始标签和结束标签。如 <code>&lt;html&gt;&lt;/html&gt;</code></li><li>自闭合标签：开始标签和结束标签在一起。如 <code>&lt;br/&gt;</code></li></ol></li><li><p>标签可以嵌套：</p></li></ol><p>需要正确嵌套，不能你中有我，我中有你</p><ul><li><p>错误：<code>&lt;a&gt;&lt;b&gt;&lt;/a&gt;&lt;/b&gt;</code></p></li><li><p>正确：<code>&lt;a&gt;&lt;b&gt;&lt;/b&gt;&lt;/a&gt;</code></p></li></ul><ol start="4"><li><p>在开始标签中可以定义属性。属性是由键值对构成，值需要用引号(单双都可)引起来</p></li><li><p>html 的标签不区分大小写，但是建议使用小写。</p></li></ol><ul><li><p>代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;red&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">font</span> <span class="attr">color</span>=<span class="string">&quot;green&quot;</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">font</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="标签学习"><a href="#标签学习" class="headerlink" title="标签学习"></a>标签学习</h3><h4 id="文件标签"><a href="#文件标签" class="headerlink" title="文件标签"></a>文件标签</h4><p>构成 html 最基 本的标签</p><ul><li>html : html 文档的根标签</li><li>head : 头标签。用于指定 html 文档的一些属性。引入外部的资源</li><li>title : 标题标签</li><li>body : 体标签</li><li><code>&lt;!DOCTYPE html&gt;</code> : html5 中定义该文档是 html 文档</li></ul><h4 id="文本标签"><a href="#文本标签" class="headerlink" title="文本标签"></a>文本标签</h4><p>和文本有关的标签</p><ul><li><p>注释：<!-- 注释内容 --></p></li><li><p>标题标签 : <code>&lt;h1&gt; ... &lt;h6&gt;</code></p><ul><li>h1 ~ h6 : 字体大小逐渐递减</li></ul></li><li><p><code>&lt;p&gt;&lt;/p&gt;</code> : 段落标签</p></li><li><p><code>&lt;br/&gt;</code> 或 <code>&lt;br&gt;</code> ：换行标签</p></li><li><p><code>&lt;hr&gt;</code> : 展示一条水平线</p><p>属性：</p><ul><li>color：颜色</li><li>width：宽度</li><li>size：高度</li><li>align：对其方式<ul><li>center：居中</li><li>left：左对齐</li><li>right：右对齐</li></ul></li></ul></li><li><p><code>&lt;b&gt;&lt;/b&gt;</code> : 字体加粗</p></li><li><p><code>&lt;i&gt;&lt;/i&gt;</code> : 字体斜体</p></li><li><p><code>&lt;font&gt;&lt;/font&gt;</code> : 字体标签</p><p>属性：</p><ul><li>color：颜色</li><li>size：大小</li><li>face：字体</li></ul></li><li><p><code>&lt;center&gt;&lt;/center&gt;</code> : 文本居中</p></li></ul><h4 id="属性定义"><a href="#属性定义" class="headerlink" title="属性定义"></a>属性定义</h4><ul><li>color：<ol><li> 英文单词：red,green,blue</li><li> rgb(值 1，值 2，值 3)：值的范围：0~255 如 rgb(0,0,255)</li><li> #值 1 值 2 值 3：值的范围：00~FF 之间。如： #FF00FF</li></ol></li><li>width：<ol><li> 数值：<code>width=&#39;20&#39;</code> 数值的单位默认是 px(像素)</li><li> 数值%：占比相对于父元素的比例</li></ol></li></ul><h4 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h4><p><code>&lt;img src=&quot;&quot;&gt;</code> : 展示图片</p><pre><code>    * 属性：        * src：指定图片的位置</code></pre><h4 id="列表标签"><a href="#列表标签" class="headerlink" title="列表标签"></a>列表标签</h4><p>有序列表：</p><p><code>&lt;ol&gt;&lt;li&gt;&lt;/li&gt;&lt;/ol&gt;</code></p><p>无序列表：</p><p><code>&lt;ul&gt;&lt;li&gt;&lt;/li&gt;&lt;/ul&gt;</code></p><p>自定义列表：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>自定义列表题目<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容描述1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>内容描述2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="链接标签"><a href="#链接标签" class="headerlink" title="链接标签"></a>链接标签</h4><p><code>&lt;a href=&quot;&quot; target=&quot;&quot;&gt;&lt;/a&gt;</code> : 定义一个超链接</p><p>属性：</p><ul><li>href：指定访问资源的 URL(统一资源定位符)</li><li>target：指定打开资源的方式<ul><li><code>_self</code> : 默认值，在当前页面打开</li><li><code>_blank</code> : 在空白页面打开</li></ul></li></ul><h4 id="div-amp-span"><a href="#div-amp-span" class="headerlink" title="div &amp; span"></a>div &amp; span</h4><ul><li><code>&lt;div&gt;&lt;/div</code> : 每一个 div 占满一整行，块级标签；</li><li><code>&lt;span&gt;&lt;/span&gt;</code> : 文本信息在一行展示，行内标签，内联标签</li></ul><h4 id="语义化标签"><a href="#语义化标签" class="headerlink" title="语义化标签"></a>语义化标签</h4><p>html5 中为了提高程序的可读性，提供了一些标签</p><ul><li><code>&lt;header&gt;&lt;/header&gt;</code> : 页眉</li><li><code>&lt;footer&gt;&lt;/footer&gt;</code> : 页脚</li></ul><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><p><code>&lt;table&gt;&lt;/table&gt;</code> : 定义表格</p><ul><li>width：宽度</li><li>border：边框</li><li>cellpadding：定义内容和单元格的距离</li><li>cellspacing：定义单元格之间的距离。如果指定为 0，则单元格的线会合为一条、</li><li>bgcolor：背景色</li><li>align：对齐方式</li></ul><p><code>&lt;tr&gt;&lt;/tr&gt;</code> : 定义行</p><ul><li>bgcolor：背景色</li><li>align：对齐方式</li></ul><p><code>&lt;td&gt;&lt;/td&gt;</code> : 定义单元格</p><ul><li>colspan：合并列 左右</li><li>rowspan：合并行 上下 先上 先左</li></ul><p><code>&lt;th&gt;&lt;/th&gt;</code> : 定义表头单元格</p><p><code>&lt;caption&gt;&lt;/caption&gt;</code> : 表格标题，在 table 内写</p><p><code>&lt;thead&gt;&lt;/thead&gt;</code> : 表示表格的头部分</p><p><code>&lt;tbody&gt;&lt;/tbody&gt;</code> : 表示表格的体部分</p><p><code>&lt;tfoot&gt;&lt;/tfoot&gt;</code> : 表示表格的脚部分</p><h3 id="表单标签"><a href="#表单标签" class="headerlink" title="表单标签"></a>表单标签</h3><h4 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h4><p>用于采集用户输入的数据的。用于和服务器进行交互。</p><p><code>&lt;form&gt;&lt;/form&gt;</code> : 用于定义表单的。可以定义一个范围，范围代表采集用户数据的范围</p><ul><li>属性：<ul><li>action : 指定提交数据的 URL</li><li>method : 指定提交方式，一共有七种，常用的有两种<ul><li>get：<ul><li>请求参数会在地址栏中显示。会封装到请求行中</li><li>请求参数大小是有限制的</li><li>不太安全</li></ul></li><li>post：<ul><li>请求参数不会再地址栏中显示。会封装在请求体中</li><li>请求参数的大小没有限制</li><li>较为安全</li></ul></li></ul></li></ul></li></ul><p>表单项中的数据要想被提交，必须指定其 name 属性</p><h4 id="表单项标签"><a href="#表单项标签" class="headerlink" title="表单项标签"></a>表单项标签</h4><h5 id="input"><a href="#input" class="headerlink" title="input"></a>input</h5><p><code>&lt;input type=&quot;&quot;&gt;&lt;/input&gt;</code> : type 属性值，改变元素展示的样式</p><p>type 的属性值：</p><table><thead><tr><th align="center">属性值</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">文本输入框</td><td align="center">默认值</td></tr><tr><td align="center">password</td><td align="center">密码输入框</td><td align="center">内容隐藏</td></tr><tr><td align="center">email</td><td align="center">邮箱格式输入框</td><td align="center"></td></tr><tr><td align="center">number</td><td align="center">仅接受数字</td><td align="center"></td></tr><tr><td align="center">search</td><td align="center">搜索框</td><td align="center">自带 X 号，可全文删除</td></tr><tr><td align="center">range</td><td align="center">滑块</td><td align="center"></td></tr><tr><td align="center">time</td><td align="center">获得小时和分钟</td><td align="center"></td></tr><tr><td align="center">date</td><td align="center">获得年月日</td><td align="center"></td></tr><tr><td align="center">month</td><td align="center">获得年月</td><td align="center"></td></tr><tr><td align="center">week</td><td align="center">获得星期</td><td align="center"></td></tr><tr><td align="center">color</td><td align="center">获得颜色</td><td align="center"></td></tr><tr><td align="center">radio</td><td align="center">单选框</td><td align="center">多个单选框实现单选 : name 属性值必须一样<br>value 属性，指定其被选中后提交的值<br>checked 属性，可以指定默认值</td></tr><tr><td align="center">checkbox</td><td align="center">复选框</td><td align="center">value 属性，指定其被选中后提交的值<br>checked 属性，可以指定默认值</td></tr><tr><td align="center">file</td><td align="center">文件选择框</td><td align="center">multiple : 多文件上传</td></tr><tr><td align="center">hidden</td><td align="center">隐藏域</td><td align="center">用于提交一些信息</td></tr><tr><td align="center">submit</td><td align="center">提交按钮</td><td align="center">点击可以提交表单</td></tr><tr><td align="center">button</td><td align="center">普通按钮</td><td align="center"></td></tr><tr><td align="center">reset</td><td align="center">重置按钮</td><td align="center">清空 from 中全文</td></tr><tr><td align="center">image</td><td align="center">图片提交按钮</td><td align="center">src : 指定图片的路径</td></tr></tbody></table><p>属性：</p><table><thead><tr><th align="center">属性</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">maxlength</td><td align="center">控制输入最多的字符</td></tr><tr><td align="center">value</td><td align="center">默认显示数据</td></tr><tr><td align="center">placeholder</td><td align="center">指定输入框的提示信息，输入框为空时显示</td></tr><tr><td align="center">autofocus</td><td align="center">页面加载完成自动获得焦点</td></tr><tr><td align="center">autocomplete</td><td align="center">自动记录输入内容，需要提交按钮，要有 name<br>参数：on || off</td></tr><tr><td align="center">require</td><td align="center">必填项</td></tr><tr><td align="center">accesskey</td><td align="center">指定聚焦到元素的快捷键，alt + 字母</td></tr><tr><td align="center">label</td><td align="center">指定输入框的文字描述信息</td></tr></tbody></table><p>注意：label 的 for 属性一般会和 input 的 id 属性值 对应。如果对应了，则点击 label 区域，会让 input 输入框获取焦点</p><h5 id="select"><a href="#select" class="headerlink" title="select"></a>select</h5><p>下拉列表，子元素列表选项为 <code>&lt;option&gt;&lt;/option&gt;</code></p><h5 id="datalist"><a href="#datalist" class="headerlink" title="datalist"></a>datalist</h5><p>下拉列表选择，子元素 option 指定列表项 与 input 使用 id 实现链接</p><h5 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h5><p>文本域</p><ul><li>cols : 指定列数，每一行有多少个字符</li><li>row : 默认多少行</li></ul><h5 id="filedset"><a href="#filedset" class="headerlink" title="filedset"></a>filedset</h5><p>打包，可以将表单内的相关元素打包，分组</p><h2 id="文档结构和基本语法"><a href="#文档结构和基本语法" class="headerlink" title="文档结构和基本语法"></a>文档结构和基本语法</h2><h3 id="XHTML"><a href="#XHTML" class="headerlink" title="XHTML"></a>XHTML</h3><p>The Extensible HyperText Markup Language =&gt; 可扩展标识语言</p><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义文档类型 doctype -&gt; document type 使用时必须大写 --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML1.0 Transitional//EN&quot;</span> <span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 声明文档命名空间 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设置文档字符编码--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Type&quot;</span> <span class="attr">content</span>=<span class="string">&quot;text/html; charset=gb2312&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XHTML 是 HTML 向 XML 过渡的标识语言</p><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><ol><li>在文档的开头必须定义文档类型</li><li>在根元素中应声明命名空间，即设置 xmlns 属性</li><li>所有的标签都必须是闭合的</li><li>所有元素和属性都必须小写</li><li>所有的属性都必须用引号（””）括起来</li><li>所有标签都必须合理嵌套</li><li>所有属性都必须被赋值，没有值的属性就用自身来赋值 <code>&lt;td nowrap=&quot;nowrap&quot;/&gt;</code></li><li>所有特殊符号都用编码表示</li><li>不要在注释内容中使用“–”，只能出现在注释开头和结束</li><li>废除了 name 属性，而使用 id 属性作为统一的名称</li></ol><h3 id="HTML5"><a href="#HTML5" class="headerlink" title="HTML5"></a>HTML5</h3><h4 id="基本结构-1"><a href="#基本结构-1" class="headerlink" title="基本结构"></a>基本结构</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="基本语法-1"><a href="#基本语法-1" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="文档类型-DOCTYPE"><a href="#文档类型-DOCTYPE" class="headerlink" title="文档类型 DOCTYPE"></a>文档类型 DOCTYPE</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>声明文档的类型，且必须位于代码的第一行</p></li><li><p>不需要向 XHTML 那么复杂，<code>&lt;!DOCTYPE html&gt;</code> 即可</p></li><li><p>使用工具时，在声明中加入 SYSTEM 识别符：<code>&lt;!DOCTYPE html SSYSTEM &quot;about:legacy-compat&quot;&gt;</code></p></li><li><p>在 HTML5 中是不区分大小写的，引号也不区分单双</p></li><li><p>会触发浏览器以标准模式显示页面</p><p>浏览器显示模式：</p><ul><li>怪异模式 : Quirks</li><li>近标准模式 : Alomst Standards</li><li>标准模式（非怪异模式）: Standards</li></ul></li></ul><h5 id="字符编码-meta"><a href="#字符编码-meta" class="headerlink" title="字符编码 meta"></a>字符编码 meta</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h5 id="标记省略"><a href="#标记省略" class="headerlink" title="标记省略"></a>标记省略</h5><p>不允许写结束标记的：只允许使用 <code>&lt;br/&gt;</code> 或 <code>&lt;br&gt;</code> 这种形式</p><p>area base br col command embed hr img input keygen link meta param source track wbr</p><p>可以省略结束标记的：</p><p>li dt dd p rt rp optgroup option colgroup thead tbody tfoot tr td th</p><p>可以省略全部标记的：</p><p>html head body colgroup tbody</p><h2 id="HTML4"><a href="#HTML4" class="headerlink" title="HTML4"></a>HTML4</h2><h3 id="HTML4-元素"><a href="#HTML4-元素" class="headerlink" title="HTML4 元素"></a>HTML4 元素</h3><h4 id="结构元素"><a href="#结构元素" class="headerlink" title="结构元素"></a>结构元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">div</td><td align="center">在文档中定义一块区域，即包含框，容器</td></tr><tr><td align="center">ol</td><td align="center">有序列表</td></tr><tr><td align="center">ul</td><td align="center">无序列表</td></tr><tr><td align="center">li</td><td align="center">列表项</td></tr><tr><td align="center">dl</td><td align="center">自定义列表</td></tr><tr><td align="center">dt</td><td align="center">自定义列表中的词条</td></tr><tr><td align="center">dd</td><td align="center">对定义的词条进行解释</td></tr><tr><td align="center">del</td><td align="center">定义删除的文本</td></tr><tr><td align="center">ins</td><td align="center">定义插入的文本</td></tr><tr><td align="center">h1 ~ h6</td><td align="center">一级标题(最大) ~ 六级标题</td></tr><tr><td align="center">p</td><td align="center">定义段落结构</td></tr><tr><td align="center">hr</td><td align="center">定义水平线</td></tr></tbody></table><h4 id="内容元素"><a href="#内容元素" class="headerlink" title="内容元素"></a>内容元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">span</td><td align="center">在文本行中定义一个区域，即行内包含框</td></tr><tr><td align="center">a</td><td align="center">定义超链接</td></tr><tr><td align="center">abbr</td><td align="center">定义缩写词</td></tr><tr><td align="center">address</td><td align="center">定义地址</td></tr><tr><td align="center">dfn</td><td align="center">定义术语，以斜体显示</td></tr><tr><td align="center">kbd</td><td align="center">定义键盘键</td></tr><tr><td align="center">samp</td><td align="center">定义样本</td></tr><tr><td align="center">var</td><td align="center">定义变量</td></tr><tr><td align="center">tt</td><td align="center">定义打印机字体</td></tr><tr><td align="center">code</td><td align="center">定义计算机源代码</td></tr><tr><td align="center">pre</td><td align="center">定义预定义格式文本，保留源代码格式</td></tr><tr><td align="center">blockquote</td><td align="center">定义大块内容引用</td></tr><tr><td align="center">cite</td><td align="center">定义引文</td></tr><tr><td align="center">q</td><td align="center">定义引用短语</td></tr><tr><td align="center">strong</td><td align="center">定义重要文本</td></tr><tr><td align="center">em</td><td align="center">定义文本为重要</td></tr></tbody></table><h4 id="修饰元素"><a href="#修饰元素" class="headerlink" title="修饰元素"></a>修饰元素</h4><table><thead><tr><th align="center">元素名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">粗体，视觉提醒</td></tr><tr><td align="center">i</td><td align="center">斜体，语气强调</td></tr><tr><td align="center">big</td><td align="center">定义较大文本</td></tr><tr><td align="center">small</td><td align="center">定义较小文本</td></tr><tr><td align="center">sup</td><td align="center">定义上标</td></tr><tr><td align="center">sub</td><td align="center">定义下标</td></tr><tr><td align="center">bdi &amp; bdo</td><td align="center">定义文本显示方向</td></tr><tr><td align="center">br</td><td align="center">定义换行</td></tr><tr><td align="center">u</td><td align="center">非文本注解，显示下划线</td></tr></tbody></table><p>已废用:</p><p>center(定义文本居中)</p><p>font(定义文字的样式大小颜色)</p><p>s(strike 的缩写) strike(定义删除线)</p><h3 id="HTML4-属性"><a href="#HTML4-属性" class="headerlink" title="HTML4 属性"></a>HTML4 属性</h3><h4 id="核心属性"><a href="#核心属性" class="headerlink" title="核心属性"></a>核心属性</h4><p>主要包括以下三个，为大部分元素所拥有</p><table><thead><tr><th align="center">属性名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">class</td><td align="center">定义类规则或样式规则</td></tr><tr><td align="center">id</td><td align="center">定义元素的唯一标识</td></tr><tr><td align="center">style</td><td align="center">定义元素的样式声明</td></tr></tbody></table><p>没有这三个属性的元素：</p><p>html head title base meta param script style</p><h4 id="语言属性"><a href="#语言属性" class="headerlink" title="语言属性"></a>语言属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>lang</td><td>定义元素的语言代码或编码</td></tr><tr><td>dir</td><td>定义文本方向，包括 ltr(从左向右) 和 rtl 俩值</td></tr></tbody></table><p>没有语言属性的元素：</p><p>frameset frame iframe br hr base param script</p><h4 id="键盘属性"><a href="#键盘属性" class="headerlink" title="键盘属性"></a>键盘属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>accesskey</td><td>定义访问某元素的快捷键</td></tr><tr><td>tabindex</td><td>定义元素的 Tab 键索引编号</td></tr></tbody></table><p>使用 accesskey 可以通过（Alt + 字母 ）访问指定 URL，但浏览器不能很好的支持</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://agonilay.githib.io&quot;</span> <span class="attr">accesskey</span>=<span class="string">&quot;a&quot;</span></span></span><br><span class="line"><span class="tag">  &gt;</span>按住 Alt 键，单击 A 键可以链接到我的博客&lt;/a</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure><p>tabindex 用来定义元素的 Tab 键访问顺序</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;1&quot;</span>&gt;</span>Tab 1<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;3&quot;</span>&gt;</span>Tab 3<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#&quot;</span> <span class="attr">tabindex</span>=<span class="string">&quot;2&quot;</span>&gt;</span>Tab 2<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="内容属性"><a href="#内容属性" class="headerlink" title="内容属性"></a>内容属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td><strong>alt</strong></td><td>定义元素的替换文本（图片加载失败时）</td></tr><tr><td><strong>title</strong></td><td>定义元素的提示文本（鼠标悬停时）</td></tr><tr><td>longdesc</td><td>定义元素包含内容的大段描述信息</td></tr><tr><td>cite</td><td>定义元素包含内容的引用信息</td></tr><tr><td>datetime</td><td>定义元素包含内容的日期和时间</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">alt</span>=<span class="string">&quot;图片无法正常显示时的替换文本&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">title</span>=<span class="string">&quot;鼠标悬停时的提示文本&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="其他属性"><a href="#其他属性" class="headerlink" title="其他属性"></a>其他属性</h4><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>rel</td><td>定义当前界面与其他界面的关系</td></tr><tr><td>rev</td><td>定义其他揭秘那与当前界面之间的链接关系</td></tr></tbody></table><p>区别：</p><ul><li>rel 表示从源文档到目标文档的关系</li><li>rev 表示从目标文档到源文档的关系</li></ul><p>用途：</p><ul><li>确定当前文档与目标文档之间的位置关系，并进行准确定义</li><li>方便浏览器对信息的来源进行准确判断</li></ul><h2 id="HTML5-1"><a href="#HTML5-1" class="headerlink" title="HTML5"></a>HTML5</h2><h3 id="HTML5-元素"><a href="#HTML5-元素" class="headerlink" title="HTML5 元素"></a>HTML5 元素</h3><h4 id="结构元素-1"><a href="#结构元素-1" class="headerlink" title="结构元素"></a>结构元素</h4><table><thead><tr><th>元素名</th><th>说明</th></tr></thead><tbody><tr><td>header</td><td>页面中的一个内容区块或整个页面的标题</td></tr><tr><td>footer</td><td>表示整个页面或其中一个内容区块的注脚<br>一般会包含创作者的姓名、创作日期及联系信息</td></tr><tr><td>section</td><td>表示页面中的一个内容区块，如章节、页眉页脚…</td></tr><tr><td>article</td><td>表示页面中的一块与上线问不相关的独立内容</td></tr><tr><td>aside</td><td>表示 article 元素的内容之外的，与 article 元素的内容相关的辅助信息</td></tr><tr><td>nav</td><td>表示页面中导航链接的部分</td></tr><tr><td>main</td><td>表示页面中的主要部分</td></tr><tr><td>figure</td><td>表示一段独立的流内容，一般表示一个文档主体流内容中的一个独立单元</td></tr></tbody></table><h4 id="功能元素"><a href="#功能元素" class="headerlink" title="功能元素"></a>功能元素</h4><table><thead><tr><th>元素</th><th>说明</th><th>例子</th></tr></thead><tbody><tr><td>video</td><td>定义视频</td><td></td></tr><tr><td>audio</td><td>定义音频</td><td></td></tr><tr><td>embed</td><td>用于插入各种多媒体</td><td><code>&lt;embed src=&quot;horse.wav&quot;&gt;</code></td></tr><tr><td>mark</td><td>在视觉上向用户呈现那些需要突出显示或高亮显示的文字</td><td></td></tr><tr><td>dialog</td><td>定义对话框或窗口</td><td><code>&lt;dialog open&gt;这是打开的会话窗口&lt;/dialog&gt;</code></td></tr><tr><td>bdi</td><td>定义文本的文本方向，使其脱离周围文本的方向设置</td><td></td></tr><tr><td>figcaption</td><td>定义 figure 元素的标题</td><td></td></tr><tr><td>time</td><td>表示日期或时间，也可以同时表示两者</td><td></td></tr><tr><td>canvas</td><td>表示图形，如图表和其他图像</td><td></td></tr><tr><td>output</td><td>表示不同类型的输出</td><td></td></tr><tr><td>source</td><td>为媒介元素定义媒介资源</td><td>如：<code>&lt;video&gt;</code> <code>&lt;audio&gt;</code></td></tr><tr><td>menu</td><td>表示菜单列表</td><td></td></tr><tr><td>ruby</td><td>表示 ruby 注释（中文注音或字符）</td><td><code>&lt;ruby&gt;汉&lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;阿瓦达&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;ruby&gt;</code></td></tr><tr><td>rt</td><td>表示字符（中文注音或字符）的解释或发音</td><td></td></tr><tr><td>rp</td><td>在 ruby 中使用</td><td></td></tr><tr><td>wbr</td><td>表示软换行，窗口或父级元素的宽度足够时，没必要换行<br>而当宽度不够时，主动在此处进行换行</td><td></td></tr><tr><td>commend</td><td>表示命令按钮</td><td>如：单选按钮、复选框或按钮</td></tr><tr><td>details</td><td>表示用户要求得到并且可以得到的细节信息</td><td></td></tr><tr><td>summary</td><td>为<code>&lt;details&gt;</code>元素定义可见的标题</td><td></td></tr><tr><td>datalist</td><td>表示可选数据的列表，与 input 元素配合使用</td><td></td></tr><tr><td>datagrid</td><td>表示可选数据的列表，以树形列表的形式来显示</td><td></td></tr><tr><td>keygen</td><td>表示生成密钥</td><td></td></tr><tr><td>progress</td><td>表示运行中的进程</td><td></td></tr><tr><td>meter</td><td>度量给定范围内的数据</td><td></td></tr><tr><td>track</td><td>定义用在媒体播放器中的文本轨道</td><td></td></tr></tbody></table><h4 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h4><p>通过 type 属性，HTML5 为 input 元素新增了很多类型</p><ul><li>tel : 表示必须输入电话号码的文本框</li><li>search : 表示搜索文本框</li><li>url : 表示必须输入 URL 地址的文本框</li><li>email : 表示必须输入电子邮件地址的文本框</li><li>datetime : 表示日期和时间文本框</li><li>date : 表示日期文本框</li><li>month : 表示月份文本框</li><li>week : 表示星期文本框</li><li>time : 表示时间文本框</li><li>datetime-local : 表示本地日期和时间文本框</li><li>number : 表示必须输入数字的文本框</li><li>range : 表示范围文本框</li><li>color : 表示颜色文本框</li></ul><h3 id="HTML5-属性"><a href="#HTML5-属性" class="headerlink" title="HTML5 属性"></a>HTML5 属性</h3><h4 id="表单属性"><a href="#表单属性" class="headerlink" title="表单属性"></a>表单属性</h4><ul><li><p>autofocus ：让元素在页面打开时自动获得焦点</p><ul><li>input(type=”text”)、select、textarea、button</li></ul></li><li><p>placeholder ：对用户的输入进行提示</p><ul><li>input(type=”text”)、textarea</li></ul></li><li><p>form ：声明它属于哪个表单，然后就可以将它放在页面的任何位置，而不一定是表单之内</p><ul><li>input、output、select、textarea、button、fieldset</li></ul></li><li><p>required ：在用户提交时进行检查，检查该元素内一定要有输入内容</p><ul><li>input(type=”text”)、textarea</li></ul></li><li><p>为 input 元素增加 autocomplete、min、max、multiple(允许多文件上传)、pattern 和 step 属性</p></li><li><p>为 input 和 button 元素增加 formaction、formenctype、formmethod、formnovalidate 与 formtarget 属性</p><p>重载 form 元素的 action、enctype、method、novalidate 与 target 属性</p></li><li><p>为 fieldset 元素增加了 disabled 属性</p></li><li><p>novalidate ： 取消提交时进行的有关检查，表单可以被无条件地提交</p><ul><li>input button from</li></ul></li></ul><h4 id="链接属性"><a href="#链接属性" class="headerlink" title="链接属性"></a>链接属性</h4><ul><li>media ：目标 URL 是为什么类型的媒介/设备进行优化的，只能在 href 属性存在时使用<ul><li>a area</li></ul></li><li>为 area 元素增加了 hreflang 和 rel 属性，以保持与 a 元素、link 元素的一致</li><li>为 link 元素增加了新属性 sizes，该属性可以与 icon 元素结合使用(通过 rel 属性)，该属性指定关联图标(icon 元素)的大小</li><li>为 base 元素增加了 target 属性，主要目的是保持与 a 元素的一致性</li></ul><h4 id="其他属性-1"><a href="#其他属性-1" class="headerlink" title="其他属性"></a>其他属性</h4><ul><li>reversed ：ol 元素 列表项倒序显示</li><li>为 meta 增加了 charset 属性</li><li>为 menu 增加了两个新的属性 type 和 label<ul><li>label ：为菜单定义一个可见的标注</li><li>type ：让菜单可以上下文菜单、工具条与列表菜单三种形式出现</li></ul></li><li>scoped ：style 元素增加，用来规定样式的作用范围</li><li>async ：script 元素增加，定义脚本是否异步执行</li><li>manifest ：html 元素增加，开发离线 Web 应用程序时它与 API 结合使用，定义一个 URL，在这个 URL 上描述文档的缓存信息</li><li>为 iframe 增加三个属性 sandbox、seamless 与 srcdoc，用来提高页面安全性，防止不信任的 Web 页面执行某些操作</li></ul><h3 id="HTML5-全局属性"><a href="#HTML5-全局属性" class="headerlink" title="HTML5 全局属性"></a>HTML5 全局属性</h3><h4 id="contenteditable-在线编辑"><a href="#contenteditable-在线编辑" class="headerlink" title="contenteditable 在线编辑"></a>contenteditable 在线编辑</h4><p>允许用户可以在线编辑元素的内容，布尔值属性</p><ul><li>true ：允许编辑</li><li>false ：不允许编辑</li><li>inherit ：未指定 true 或 false 时，由 inherit 状态决定，看父元素是否可编辑</li></ul><p>想要保存编辑后的内容，使用 innerHTML 获取</p><p>所有主流浏览器都支持 contenteditable 属性</p><p>在 JavaScript 中，元素还有一个 isContentEditable 属性，当元素可编辑时，该属性值为 true，反之则为 false</p><h4 id="contentmenu-右击菜单"><a href="#contentmenu-右击菜单" class="headerlink" title="contentmenu 右击菜单"></a>contentmenu 右击菜单</h4><p>用于定义 div 元素的上下文菜单，在用户右键单击元素时出现</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">contextmenu</span>=<span class="string">&quot;mymenu&quot;</span>&gt;</span></span><br><span class="line">  上下文菜单</span><br><span class="line">  <span class="tag">&lt;<span class="name">menu</span> <span class="attr">type</span>=<span class="string">&quot;context&quot;</span> <span class="attr">id</span>=<span class="string">&quot;mymenu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">menuitem</span> <span class="attr">label</span>=<span class="string">&quot;微信分享&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">menuitem</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">menuitem</span> <span class="attr">label</span>=<span class="string">&quot;微博分享&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">menuitem</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">menu</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>目前只有 Firefox 支持 contentmenu 属性</p><h4 id="data-自定义属性"><a href="#data-自定义属性" class="headerlink" title="data-* 自定义属性"></a>data-* 自定义属性</h4><p>使用 data-* 可以自定义用户数据</p><ul><li><p>属性名：不应该包含任何大写字母，在前缀“data-”之后必须至少有一个字符</p><ul><li><p>多个单词使用：<code>-</code> 连接</p></li><li><p>脚本中获取或访问属性使用 <code>dataset.对应小驼峰式</code></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;bird&quot;</span>&gt;</span>鸟<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;fish&quot;</span>&gt;</span>鱼<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span> <span class="attr">data-animal-type</span>=<span class="string">&quot;piggy&quot;</span>&gt;</span>小猪<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> lis = <span class="built_in">document</span>.getElementByTagName(<span class="string">&quot;li&quot;</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(lis[i].dataset.animalType); <span class="comment">// &lt;--</span></span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>属性值：可以是任意字符串</p></li></ul><p>当浏览器（用户代理）解析时，会完全忽略前缀为“data-”的自定义属性</p><p>所有主流浏览器都支持 自定义属性</p><h4 id="draggable-可被拖动"><a href="#draggable-可被拖动" class="headerlink" title="draggable 可被拖动"></a>draggable 可被拖动</h4><p>定义元素是否可以被拖动，但不是元素位置改变</p><p>true、false、auto(定义使用浏览器的默认行为)</p><p>此属性常被用在拖放操作中</p><h4 id="dropzone-拖动操作"><a href="#dropzone-拖动操作" class="headerlink" title="dropzone 拖动操作"></a>dropzone 拖动操作</h4><p>定义在元素上拖动数据时，是否复制、移动或链接被拖动数据</p><ul><li>copy ：会产生被拖动数据的副本</li><li>move ：会导致被拖动数据被移动到新位置</li><li>link ：会产生执行原始数据的链接</li></ul><p>但是，目前主流浏览器都不支持 dropzone 属性</p><h4 id="hidden-隐藏"><a href="#hidden-隐藏" class="headerlink" title="hidden 隐藏"></a>hidden 隐藏</h4><p>所有元素都包含一个 hidden 属性，设置元素的可见状态，true 不可见，false 可见</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;...&quot;</span> <span class="attr">hidden</span>&gt;</span>元素隐藏<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>除了 IE 所有主流浏览器都支持 hidden 属性</p><h4 id="spellcheck-拼写-语法检查"><a href="#spellcheck-拼写-语法检查" class="headerlink" title="spellcheck 拼写 语法检查"></a>spellcheck 拼写 语法检查</h4><p>定义是否对元素进行拼写和语法检查，可以对以下内容进行拼写检查：</p><ul><li>input 元素中的文本值（非密码）</li><li>textarea 元素中的文本</li><li>可编辑元素中的文本</li></ul><p>布尔值属性，true 检查，false 不检查</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">spellcheck</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 必须写值，光写spellcheck错误 --&gt;</span></span><br></pre></td></tr></table></figure><h4 id="translate-翻译"><a href="#translate-翻译" class="headerlink" title="translate 翻译"></a>translate 翻译</h4><p>定义是否应该翻译元素内容，yes 翻译，no 不翻译</p><p>但目前所有主流浏览器都无法正确支持 translate 属性</p><p>HTML5 文档链接</p><p><a href="http://www.qianduankaifa.cn/exercise/html5_base/">http://www.qianduankaifa.cn/exercise/html5_base/</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> HTML5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>八月打卡计划</title>
      <link href="/2021/08/02/%E5%85%AB%E6%9C%88%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92/"/>
      <url>/2021/08/02/%E5%85%AB%E6%9C%88%E6%89%93%E5%8D%A1%E8%AE%A1%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="0831"><a href="#0831" class="headerlink" title="0831"></a>0831</h2><h3 id="今日行思"><a href="#今日行思" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：看 vue.js 书学习</p><p>时间（记录行动的时间段）9：00 - 12：30</p><h3 id="今日思考"><a href="#今日思考" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 中 render 函数</p><h3 id="明日计划"><a href="#明日计划" class="headerlink" title="明日计划"></a>明日计划</h3><p>之后几天 到开学 因为家中店铺旁边小学开学，要去帮忙爸妈看店</p><h2 id="0830"><a href="#0830" class="headerlink" title="0830"></a>0830</h2><h3 id="今日行思-1"><a href="#今日行思-1" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书学习</p><p>时间（记录行动的时间段）9：00 - 12：30，14：30 - 18：30，21：30 - 1：20</p><h3 id="今日思考-1"><a href="#今日思考-1" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务 - 调接口</p><p>vue 中 虚拟 DOM 以及 render 函数</p><p>其中，render 函数是一个大难点</p><h3 id="今日得失"><a href="#今日得失" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发，调接口</li><li>vue.js 的深入学习</li><li>Window PowerShell</li></ul><h3 id="明日计划-1"><a href="#明日计划-1" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续进行开发任务，继续看 vue.js 书，去帮爸妈看店</p><h3 id="今日获得的资源"><a href="#今日获得的资源" class="headerlink" title="今日获得的资源"></a>今日获得的资源</h3><p>vue 笔记完善，CMD 窗口美化，以及 Window PowerShell 的使用及美化</p><h2 id="0829"><a href="#0829" class="headerlink" title="0829"></a>0829</h2><h3 id="今日行思-2"><a href="#今日行思-2" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，预习下学期课程收尾，整理前端笔记完成</p><p>时间（记录行动的时间段）9：00 - 12：30，15：00 - 19：40，21：30 - 23：00</p><h3 id="今日思考-2"><a href="#今日思考-2" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务 - 调接口</p><p>前端笔记整理过程中对前端知识点的回想</p><h3 id="今日得失-1"><a href="#今日得失-1" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发，调接口</li><li>字节前端笔记整理完毕</li></ul><h3 id="明日计划-2"><a href="#明日计划-2" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续进行开发任务，深入看 vue.js 书</p><h3 id="今日获得的资源-1"><a href="#今日获得的资源-1" class="headerlink" title="今日获得的资源"></a>今日获得的资源</h3><p>前端笔记</p><h2 id="0828"><a href="#0828" class="headerlink" title="0828"></a>0828</h2><h3 id="今日行思-3"><a href="#今日行思-3" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，预习下学期课程，整理前端部分笔记</p><p>时间（记录行动的时间段）8：30 - 12：10，14：00 - 20：20，22：30 - 00：30</p><h3 id="今日思考-3"><a href="#今日思考-3" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务 - 调接口</p><p>难点：</p><ul><li>调接口时碰到了 引入路径 以及 跨域的问题</li><li>需要多积累跨域这方面的知识</li></ul><h3 id="今日得失-2"><a href="#今日得失-2" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发，调接口</li></ul><h3 id="明日计划-3"><a href="#明日计划-3" class="headerlink" title="明日计划"></a>明日计划</h3><p>下学期课程预习收尾，继续进行开发任务，整理前端笔记</p><h3 id="今日获得的资源-2"><a href="#今日获得的资源-2" class="headerlink" title="今日获得的资源"></a>今日获得的资源</h3><p>字节跳动的前端笔记文章 –&gt; 部分转化为了 自己 的 md 格式，更方便查看</p><h2 id="0827"><a href="#0827" class="headerlink" title="0827"></a>0827</h2><h3 id="明日计划-4"><a href="#明日计划-4" class="headerlink" title="明日计划"></a>明日计划</h3><p>调接口进行开发任务，下学期课程预习，过前端笔记</p><h2 id="0826"><a href="#0826" class="headerlink" title="0826"></a>0826</h2><h3 id="今日行思-4"><a href="#今日行思-4" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书，预习下学期课程</p><p>时间（记录行动的时间段）10：00 - 12：10，12：50 - 15：30</p><h3 id="今日思考-4"><a href="#今日思考-4" class="headerlink" title="今日思考"></a>今日思考</h3><p>进行开发任务过程</p><h3 id="今日得失-3"><a href="#今日得失-3" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发</li><li>下一学期课程的预习</li><li>vue 书的学习</li></ul><h3 id="明日计划-5"><a href="#明日计划-5" class="headerlink" title="明日计划"></a>明日计划</h3><p>朋友过生日，给自己放一天假，休息休息</p><h2 id="0825"><a href="#0825" class="headerlink" title="0825"></a>0825</h2><h3 id="今日行思-5"><a href="#今日行思-5" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书，预习下学期课程</p><p>时间（记录行动的时间段）9：30 - 12：10，13：40 - 19：00，21：00 - 24：00</p><h3 id="今日思考-5"><a href="#今日思考-5" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>同样进行开发任务过程中思考代码以及组件的优化</li><li>博客同时部署到 gitee 和 github 上</li></ol><h3 id="今日得失-4"><a href="#今日得失-4" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>项目的开发</li><li>下一学期课程的预习</li></ul><h3 id="明日计划-6"><a href="#明日计划-6" class="headerlink" title="明日计划"></a>明日计划</h3><p>完成开发任务，看书学习，继续预习下学期课程</p><h2 id="0824"><a href="#0824" class="headerlink" title="0824"></a>0824</h2><h3 id="今日行思-6"><a href="#今日行思-6" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，看 vue.js 书</p><p>时间（记录行动的时间段）8：40 - 12：10，15：00 - 20：00，21：20 - 23：40</p><h3 id="今日思考-6"><a href="#今日思考-6" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>vue 中的指令包括自定义指令，以及计算属性，监听器的用法</li><li>进行开发任务过程中思考代码以及组件的优化</li></ol><h3 id="今日得失-5"><a href="#今日得失-5" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>复习 vue 中基础知识点</li><li>项目的开发，一个完整的编辑页面</li></ul><h3 id="明日计划-7"><a href="#明日计划-7" class="headerlink" title="明日计划"></a>明日计划</h3><p>完成开发任务，看书学习，预习下学期课程</p><h3 id="今日积累的新学习资源"><a href="#今日积累的新学习资源" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue 笔记</p><h2 id="0823"><a href="#0823" class="headerlink" title="0823"></a>0823</h2><h3 id="今日行思-7"><a href="#今日行思-7" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：开发完整日历组件，进行开发任务，看了 vue.js 书，复习了 ES6 的知识点</p><p>时间（记录行动的时间段）9：00 - 12：30，13：50 - 19：00，21：00 - 24：00</p><h3 id="今日思考-7"><a href="#今日思考-7" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>ES6 知识点的巩固</li><li>MVC MVP MVVM 的区别</li><li>模块化开发以及单页面程序的理解</li></ol><h3 id="今日得失-6"><a href="#今日得失-6" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>复习 ES6 部分知识点</li><li>项目的完成，其中包含一个 日历的开发（难点）</li></ul><h3 id="明日计划-8"><a href="#明日计划-8" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，看书学习</p><h3 id="今日积累的新学习资源-1"><a href="#今日积累的新学习资源-1" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue 笔记</p><h2 id="0822"><a href="#0822" class="headerlink" title="0822"></a>0822</h2><h3 id="今日行思-8"><a href="#今日行思-8" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，进行小 demo 开发，开发日历模块，晚上学长讲解，看了下学期要学的课，晚上进行了项目开发</p><p>时间（记录行动的时间段）8：30 - 12：50，15：00 - 24：00</p><h3 id="今日思考-8"><a href="#今日思考-8" class="headerlink" title="今日思考"></a>今日思考</h3><p>怎么体现程序的好坏：</p><ul><li>算法和数据结构来做的 – 时间复杂度空间复杂度</li></ul><p>程序设计来讲：</p><ul><li>健壮性：点击效果</li><li>扩展性</li><li>可维护性</li></ul><p>Vue：</p><ul><li>数据驱动</li><li>插槽</li><li>组件的设计和使用</li></ul><p>代码书写：判断可以错误优先处理原则</p><p>命名：遵守规范!!!</p><h3 id="今日得失-7"><a href="#今日得失-7" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>vue2 一个列表的小项目 demo</li><li>新课程的预习</li><li>晚上学长讲解代码，学到了 很多</li></ul><h3 id="明日计划-9"><a href="#明日计划-9" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，看下学期学习的课程</p><h3 id="今日积累的新学习资源-2"><a href="#今日积累的新学习资源-2" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>vue2 的一个项目 demo</p><h2 id="0821"><a href="#0821" class="headerlink" title="0821"></a>0821</h2><h3 id="今日行思-9"><a href="#今日行思-9" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，同时看 vue.js 书，看了下学期要学的课</p><p>时间（记录行动的时间段）8：30 - 12：50，15：00 - 19：00，21：00 - 24：00</p><h3 id="今日思考-9"><a href="#今日思考-9" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 路由 vue-router 的原理及使用</p><p>eslint 的作用及使用</p><p>vscode 中使用 eslint</p><h3 id="今日得失-8"><a href="#今日得失-8" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>vue 路由 与 eslint 的使用</li><li>新课程的预习</li></ul><h3 id="明日计划-10"><a href="#明日计划-10" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，继续向后学习 b 站 VUE 视频，看下学期学习的课程</p><h3 id="今日积累的新学习资源-3"><a href="#今日积累的新学习资源-3" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>ESLint 官方文档、VueRouter 官方文档</p><h2 id="0820"><a href="#0820" class="headerlink" title="0820"></a>0820</h2><h3 id="今日行思-10"><a href="#今日行思-10" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：vue2 学习</p><p>时间（记录行动的时间段）20：10 - 23：00</p><h3 id="今日思考-10"><a href="#今日思考-10" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue2 自定义组件和插槽的学习</p><h3 id="今日得失-9"><a href="#今日得失-9" class="headerlink" title="今日得失"></a>今日得失</h3><p>今日白天参加了 要好朋友的生日，也算给自己放了一天假</p><h3 id="明日计划-11"><a href="#明日计划-11" class="headerlink" title="明日计划"></a>明日计划</h3><p>学习 vue2 视频课程学习</p><h2 id="0819"><a href="#0819" class="headerlink" title="0819"></a>0819</h2><h3 id="今日行思-11"><a href="#今日行思-11" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：30 - 11：50，13：30 - 15：30</p><h3 id="今日思考-11"><a href="#今日思考-11" class="headerlink" title="今日思考"></a>今日思考</h3><p>今日无思考</p><h3 id="今日得失-10"><a href="#今日得失-10" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：vue2 的学习</p><h3 id="明日计划-12"><a href="#明日计划-12" class="headerlink" title="明日计划"></a>明日计划</h3><p>明天放松一天，朋友过生日</p><h2 id="0818"><a href="#0818" class="headerlink" title="0818"></a>0818</h2><h3 id="今日行思-12"><a href="#今日行思-12" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，做购物车案例</p><p>时间（记录行动的时间段）8：00 - 13：00，14：10 - 16：20，22：00 - 23：30</p><h3 id="今日思考-12"><a href="#今日思考-12" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 组件之间传值，包括 子向父、父向子、兄弟组件之间</p><p>使用最优的方式方法实现功能</p><h3 id="今日得失-11"><a href="#今日得失-11" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 ref 引用、动态组件以及插槽</li><li>购物车案例的完成</li></ol><h3 id="明日计划-13"><a href="#明日计划-13" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，继续向后学习 b 站 VUE 视频</p><h2 id="0817"><a href="#0817" class="headerlink" title="0817"></a>0817</h2><h3 id="今日行思-13"><a href="#今日行思-13" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习，看 JS 书</p><p>时间（记录行动的时间段）9：00 - 13：50，14：40 - 19：00，20：20 - 24：00</p><h3 id="今日思考-13"><a href="#今日思考-13" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 组件之间传值，包括 子向父、父向子、兄弟组件之间</p><p>数组循环的特殊方法：forEach、some、filter、every、reduce</p><p>JS 对象的底层知识原理方法</p><h3 id="今日得失-12"><a href="#今日得失-12" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 vue 组件、数组集中循环方法 的学习</li><li>JS 对象的深度剖析</li></ol><h3 id="明日计划-14"><a href="#明日计划-14" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，进行购物车案例的开发，继续向后学习 b 站 VUE 视频</p><h2 id="0816"><a href="#0816" class="headerlink" title="0816"></a>0816</h2><h3 id="今日行思-14"><a href="#今日行思-14" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）15：50 - 19：00，20：20 - 24：00</p><h3 id="今日思考-14"><a href="#今日思考-14" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 项目中的 组件化开发 尤为重要</p><p>vue 组件的组成结构，语法结构，组件间的关系</p><h3 id="今日得失-13"><a href="#今日得失-13" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>vue2 的学习，包括 vue-cli vue 组件的部分学习</li></ol><p>失：</p><ol><li>今天上午和朋友有事处理，下午回到家</li></ol><h3 id="明日计划-15"><a href="#明日计划-15" class="headerlink" title="明日计划"></a>明日计划</h3><p>有开发任务完成，继续向后学习 b 站 VUE 视频</p><h2 id="0815"><a href="#0815" class="headerlink" title="0815"></a>0815</h2><h3 id="今日行思-15"><a href="#今日行思-15" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行了开发任务，学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：10 - 12：30；13：50 - 19：00</p><h3 id="今日思考-15"><a href="#今日思考-15" class="headerlink" title="今日思考"></a>今日思考</h3><p>侦听器及计算属性</p><p>开发过程中的规范，要求要严格遵循</p><h3 id="今日得失-14"><a href="#今日得失-14" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>完善了一些之前的开发任务中的缺陷和不足，以及规范的实施</li><li>vue2 的学习，包括 侦听器 计算属性 vue-cli vue 组件的部分学习</li></ul><h3 id="明日计划-16"><a href="#明日计划-16" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续向后学习 b 站 VUE 视频</p><h2 id="0814"><a href="#0814" class="headerlink" title="0814"></a>0814</h2><h3 id="今日行思-16"><a href="#今日行思-16" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：完成了开发任务，学习 vue2 视频课程学习</p><p>时间（记录行动的时间段）8：40 - 12：30；13：50 - 17：00；18：20 - 24：00</p><h3 id="今日思考-16"><a href="#今日思考-16" class="headerlink" title="今日思考"></a>今日思考</h3><p>vue 中指令的作用以及区分，要多练习，多使用，多回看笔记巩固</p><h3 id="今日得失-15"><a href="#今日得失-15" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>完成了行得每日打卡的任务开发</li><li>vue2 的基础巩固，零碎知识点的学习</li></ul><h3 id="明日计划-17"><a href="#明日计划-17" class="headerlink" title="明日计划"></a>明日计划</h3><p>继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-4"><a href="#今日积累的新学习资源-4" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTTP 权威指南，webpack 笔记补充，vue2 部分笔记、dayjs 网站 - JS 时间第三方库</p><h2 id="0813"><a href="#0813" class="headerlink" title="0813"></a>0813</h2><h3 id="今日行思-17"><a href="#今日行思-17" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，学习 黑马的 vue 课程</p><p>时间（记录行动的时间段）8：20 - 12：30；14：40 - 18：30；20：00 - 23：30</p><h3 id="今日思考-17"><a href="#今日思考-17" class="headerlink" title="今日思考"></a>今日思考</h3><p>难点：</p><p>开发过程中的 上传选择图片以及选择资源部分是一个难点</p><h3 id="今日得失-16"><a href="#今日得失-16" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>进行了行得的任务开发</li><li>积累了难点中叙述的功能开发方式</li></ul><h3 id="明日计划-18"><a href="#明日计划-18" class="headerlink" title="明日计划"></a>明日计划</h3><p>明日完成开发任务，继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-5"><a href="#今日积累的新学习资源-5" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><h2 id="0812"><a href="#0812" class="headerlink" title="0812"></a>0812</h2><h3 id="今日行思-18"><a href="#今日行思-18" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行开发任务，学习 黑马的 vue 课程</p><p>时间（记录行动的时间段）10：00 - 12：00；13：00 - 19：20；20：30 - 00：30</p><h3 id="今日思考-18"><a href="#今日思考-18" class="headerlink" title="今日思考"></a>今日思考</h3><p>使用 webpack 打包的方法，流程</p><h3 id="今日得失-17"><a href="#今日得失-17" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习了部分 webpack 的知识，也算是复习巩固之前学过的一点皮毛</li><li>进行了行得的任务开发</li></ul><p>失：</p><ul><li>上午家里有些事，帮了帮忙，耗了一些时间</li></ul><h3 id="明日计划-19"><a href="#明日计划-19" class="headerlink" title="明日计划"></a>明日计划</h3><p>明日完成开发任务，继续向后学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-6"><a href="#今日积累的新学习资源-6" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><h2 id="0811"><a href="#0811" class="headerlink" title="0811"></a>0811</h2><h3 id="今日行思-19"><a href="#今日行思-19" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：进行了开发</p><p>时间（记录行动的时间段）8：50 - 12：00；13：30 - 18：00；19：30 - 23：00</p><h3 id="今日思考-19"><a href="#今日思考-19" class="headerlink" title="今日思考"></a>今日思考</h3><p>开发过程中尽量简化，要复用</p><h3 id="明日计划-20"><a href="#明日计划-20" class="headerlink" title="明日计划"></a>明日计划</h3><p>进行开发任务，学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-7"><a href="#今日积累的新学习资源-7" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 权威指南</p><h2 id="0810"><a href="#0810" class="headerlink" title="0810"></a>0810</h2><h3 id="今日行思-20"><a href="#今日行思-20" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3 弹性盒模型和动画学习，进行开发任务</p><p>时间（记录行动的时间段）8：30 - 12：20；14：30 - 18：50；20：30 - 24：00</p><h3 id="今日思考-20"><a href="#今日思考-20" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 弹性盒模型，动画</li><li>难点：<ol><li>弹性盒模型</li><li>动画</li></ol></li></ol><h3 id="今日得失-18"><a href="#今日得失-18" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS 的内容</li><li>完成了行得的任务开发</li></ul><h3 id="明日计划-21"><a href="#明日计划-21" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，开始学习 b 站 VUE 视频</p><h3 id="今日积累的新学习资源-8"><a href="#今日积累的新学习资源-8" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS(包含 CSS3) 完整笔记，已上传</p><h2 id="0809"><a href="#0809" class="headerlink" title="0809"></a>0809</h2><h3 id="今日行思-21"><a href="#今日行思-21" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3 浮动学习，弹性盒模型学习了一部分，完成了开发任务</p><p>时间（记录行动的时间段）8：30 - 11：30；14：00 - 18：20；20：20 - 24：00</p><h3 id="今日思考-21"><a href="#今日思考-21" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 布局及盒模型的学习，开发任务中样式设计时的简便方式，积累经验</li></ol><h3 id="今日得失-19"><a href="#今日得失-19" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS3 浮动，弹性盒模型学习了一部分</li></ul><h3 id="明日计划-22"><a href="#明日计划-22" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 弹性盒模型学习要结束，开始学习 CSS 及 CSS3 动画</p><h3 id="今日积累的新学习资源-9"><a href="#今日积累的新学习资源-9" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>深入浅出 React 和 Redux 书</p><h2 id="0808"><a href="#0808" class="headerlink" title="0808"></a>0808</h2><h3 id="今日行思-22"><a href="#今日行思-22" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3 布局及盒模型学习，完成开发任务，修改博客</p><p>时间（记录行动的时间段）8：10 - 11：50；14：00 - 18：20；19：20 - 23：30</p><h3 id="今日思考-22"><a href="#今日思考-22" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 布局及盒模型的学习，开发任务中样式设计时的简便方式，积累经验</li><li>难点：</li></ol><h3 id="今日得失-20"><a href="#今日得失-20" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ul><li>学习结束了 CSS3 布局</li><li>完成了行得的任务开发</li></ul><h3 id="明日计划-23"><a href="#明日计划-23" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS 浮动学习，</p><h3 id="今日积累的新学习资源-10"><a href="#今日积累的新学习资源-10" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>java 数据结构与算法书、vue.js 深入浅出书</p><h2 id="0807"><a href="#0807" class="headerlink" title="0807"></a>0807</h2><h3 id="今日行思-23"><a href="#今日行思-23" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：CSS3 难点学习</p><p>时间（记录行动的时间段）8：00 - 12：20；16：30 - 17：00；20：30 - 23：00</p><h3 id="今日思考-23"><a href="#今日思考-23" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 样式属性的复习</li><li>难点：表单、表格的新增元素和属性的使用和分类</li></ol><h3 id="今日得失-21"><a href="#今日得失-21" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：学习结束了 CSS3 样式</p><h3 id="明日计划-24"><a href="#明日计划-24" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 样式今天已复习结束，JS 先延后，先学习 CSS3 布局，盒模型内容</p><h3 id="今日积累的新学习资源-11"><a href="#今日积累的新学习资源-11" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 笔记内 CSS3 样式完善</p><h2 id="0806"><a href="#0806" class="headerlink" title="0806"></a>0806</h2><h3 id="今日行思-24"><a href="#今日行思-24" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：我部分草稿箱开发完成，CSS 复习完毕，CSS3 样式属性难点学习</p><p>时间（记录行动的时间段）9：30 - 12：20；14：30 - 18：30；20：00 - 23：00</p><h3 id="今日思考-24"><a href="#今日思考-24" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS3 样式属性的复习</li><li>难点：<ol><li>图片属性和文字属性中，各自有易混淆的，要着重去记忆</li><li>渐变背景是一个难点，要多去回顾，练习</li></ol></li></ol><h3 id="今日得失-22"><a href="#今日得失-22" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>学习了 CSS3 新的属性及样式，包括</li><li>下午进行了 行得 的开发，”我” 界面开发完成 草稿箱 界面所有内容</li></ol><p>失：</p><ol><li>昨晚没睡好，早上四点多被肚子疼起来，有一些闹肚子，可能是昨天着凉了，上午吃了药，好转了一些，状态不太好</li></ol><h3 id="明日计划-25"><a href="#明日计划-25" class="headerlink" title="明日计划"></a>明日计划</h3><p>依旧按质按量按时完成开发任务，CSS3 样式明天复习结束，并要开始 JS 的复习</p><h3 id="今日积累的新学习资源-12"><a href="#今日积累的新学习资源-12" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 笔记内 CSS3 部分完善</p><h2 id="0805"><a href="#0805" class="headerlink" title="0805"></a>0805</h2><h3 id="今日行思-25"><a href="#今日行思-25" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：我部分开发完成，CSS 复习完毕，CSS3 样式已经开始一部分</p><p>时间（记录行动的时间段）8：30 - 12：30；14：30 - 18：00；20：00 - 23：00</p><h3 id="今日思考-25"><a href="#今日思考-25" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS 中文本相关的属性深入掌握及区分</li><li>HTML5 新增标签及属性值的了解及记录</li></ol><h3 id="今日得失-23"><a href="#今日得失-23" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习了 CSS 基础内容</li><li>上午及下午一部分时间进行了 行得 的开发，”我” 界面开发完成 我的收藏 我的发布 界面所有内容</li></ol><p>失：</p><ol><li>晚上又老朋友来看望我，延误了一部分学习计划，不过问题不大，也差不多是吃饭时间，看了中国乒乓女团的决赛</li></ol><h3 id="明日计划-26"><a href="#明日计划-26" class="headerlink" title="明日计划"></a>明日计划</h3><p>按质按量按时完成开发任务，CSS3 样式复习继续</p><h3 id="今日积累的新学习资源-13"><a href="#今日积累的新学习资源-13" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 笔记 和 HTML 笔记的完善</p><p>网上淘了一些前端有关书籍，包括 vue.js、react.js、js、css、node 的书籍</p><h2 id="0804"><a href="#0804" class="headerlink" title="0804"></a>0804</h2><h3 id="今日行思-26"><a href="#今日行思-26" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：过 CSS 基础，行得 APP 界面开发</p><p>时间（记录行动的时间段）8：00 - 12：30；14：00 - 18：00；17：00 - 24：00</p><h3 id="今日思考-26"><a href="#今日思考-26" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>CSS 中基础的属性以及属性值</li><li>CSS 中选择器的分类以及熟练掌握使用</li><li>使用 vue 开发中组件要设计完善，考虑之后开发</li></ol><h3 id="今日得失-24"><a href="#今日得失-24" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习了 CSS 基础内容</li><li>下午进行了 行得 的开发，”我” 界面开发完成 我的关注 我的粉丝 我的收藏 三个界面</li></ol><h3 id="明日计划-27"><a href="#明日计划-27" class="headerlink" title="明日计划"></a>明日计划</h3><p>“我”界面要开发完毕，CSS 要复习完毕，并且尽可能的向后进行 CSS3 的内容复习与拓展</p><h3 id="今日积累的新学习资源-14"><a href="#今日积累的新学习资源-14" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>CSS 笔记</p><h2 id="0803"><a href="#0803" class="headerlink" title="0803"></a>0803</h2><h3 id="今日行思-27"><a href="#今日行思-27" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：HTML 基础过一遍</p><p>时间（记录行动的时间段）8：00 - 12：00；14：30 - 17：00；晚上</p><h3 id="今日思考-27"><a href="#今日思考-27" class="headerlink" title="今日思考"></a>今日思考</h3><ol><li>HTML 每个重要标签的作用，以及其所有可以使用的属性，包括在那些浏览器中不兼容</li><li>HTML4 中的标签、元素、属性</li><li>HTML5 新增的所有内容功能以及与之前的关系、区别和配合使用的方法</li></ol><h3 id="今日得失-25"><a href="#今日得失-25" class="headerlink" title="今日得失"></a>今日得失</h3><p>得：</p><ol><li>复习结束了 HTML 的基础，也包括 HTML4 以及 HTML5 的内容</li><li>学会了给博客指定文章置顶</li></ol><p>失：今天未达到早起训练一小时的目标，只进行了二十分钟，要逐渐调节生物钟</p><h3 id="明日计划-28"><a href="#明日计划-28" class="headerlink" title="明日计划"></a>明日计划</h3><p>在完成任务的基础上，CSS 以及 CSS3 的复习与巩固</p><h3 id="今日积累的新学习资源-15"><a href="#今日积累的新学习资源-15" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTML 笔记完整，已上传至博客</p><p>另外得到了一个 HTML5 的 API 文档，可以查看所有的标签及属性，在 HTML 笔记 博客末尾</p><h2 id="0802"><a href="#0802" class="headerlink" title="0802"></a>0802</h2><h3 id="今日行思-28"><a href="#今日行思-28" class="headerlink" title="今日行思"></a>今日行思</h3><p>行动：完成学长安排的任务，开始过一遍前端最基础的东西</p><p>时间（记录行动的时间段）11：00 - 12：30；13：30 - 17：00；20：00 - 23：30</p><h3 id="今日思考-28"><a href="#今日思考-28" class="headerlink" title="今日思考"></a>今日思考</h3><p>1、HTML 的重要性</p><p>2、下拉触底功能的原理</p><h3 id="今日得失-26"><a href="#今日得失-26" class="headerlink" title="今日得失"></a>今日得失</h3><p>学会了在移动端实现下拉触底加载</p><p>复习了 HTML 的一部分基础，包括标签以及一些属性</p><h3 id="明日计划-29"><a href="#明日计划-29" class="headerlink" title="明日计划"></a>明日计划</h3><p>在完成任务的基础上，继续复习 HTML 内容，明天把 HTML 的内容复习完</p><h3 id="今日积累的新学习资源-16"><a href="#今日积累的新学习资源-16" class="headerlink" title="今日积累的新学习资源"></a>今日积累的新学习资源</h3><p>HTML 学习笔记</p>]]></content>
      
      
      <categories>
          
          <category> 学习相关 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Webpack笔记</title>
      <link href="/2021/07/30/Webpack%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/30/Webpack%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h3><p>使用 Webpack</p><h3 id="webpack"><a href="#webpack" class="headerlink" title="webpack"></a>webpack</h3><p>当前 Web 开发 面临的困境：</p><ul><li>文件以来关系错综复杂</li><li>静态资源请求效率低</li><li>模块化支持不友好</li><li>浏览器对高级 JavaScript 特性兼容程度较低</li></ul><h4 id="webpack-概述"><a href="#webpack-概述" class="headerlink" title="webpack 概述"></a>webpack 概述</h4><p>webpack 是一个流行的前端项目构建工具（打包工具），可以解决当前 web 开发中所面临的困境。</p><p>提供了友好的模块化支持，以及<strong>代码压缩混淆</strong>、<strong>处理 js 兼容问题</strong>、<strong>性能优化</strong>等强大的功能，提高了开发效率和项目的可维护性。</p><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><h5 id="1-创建列表隔行变色项目"><a href="#1-创建列表隔行变色项目" class="headerlink" title="1.创建列表隔行变色项目"></a>1.创建列表隔行变色项目</h5><ol><li>创建项目空白目录，并运行 <code>npm init -y</code> 命令，进行初始化包管理配置文件 package.json</li><li>新建 src 源代码目录</li><li>新建 src -&gt; index.html 首页</li><li>初始化首页基本结构</li><li>运行 <code>npm install jquery -S</code> 命令， 安装 jQuery</li><li>通过模块化的形式，实现列表隔行变色效果</li></ol><h5 id="2-在项目中安装和配置-webpack"><a href="#2-在项目中安装和配置-webpack" class="headerlink" title="2. 在项目中安装和配置 webpack"></a>2. 在项目中安装和配置 webpack</h5><ol><li><p>运行 <code>npm install webpack@5.42.1 webpack-cli@4.7.2 -D</code> 命令，安装 webpack 相关的包</p></li><li><p>在项目根目录中，创建名为 webpack.config.js 的 webpack 配置文件</p></li><li><p>在 webpack 的配置文件中，初始化如下基本配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">mode</span>: <span class="string">&quot;development&quot;</span>, <span class="comment">// mode 用来指定构建模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>mode 节点的可选值有两个，分别是：</p><ul><li>development<ul><li>开发环境</li><li>不会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度快，适合在开发阶段使用</li></ul></li><li>production<ul><li>生产环境</li><li>会对打包生成的文件进行代码压缩和性能优化</li><li>打包速度很慢，仅适合在项目发布阶段使用</li></ul></li></ul></li><li><p>在 package.json 配置文件中的 scripts 节点下，新增 dev 脚本如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack&quot;</span> <span class="comment">// script 节点下的脚本，可以通过 npm run 执行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在终端中运行 <code>npm run dev</code> 命令，启动 webpack 进行项目打包。</p></li></ol><p>注意：主页面中导入的应该为打包生成后的 dist 文件夹下的 js 文件</p><h5 id="3-配置打包的入口和出口"><a href="#3-配置打包的入口和出口" class="headerlink" title="3. 配置打包的入口和出口"></a>3. 配置打包的入口和出口</h5><p>webpack 的 4.x 版本中默认约定：</p><ul><li>打包的 入口文件 为 src -&gt; index.js</li><li>打包的 输出文件 为 dist -&gt; main.js</li></ul><p>修改打包的入口(entry)和出口(output)，可以在 webpack.config.js 中增加如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">entry</span>: path.join(__dirname, <span class="string">&quot;./src/index.js&quot;</span>), <span class="comment">// 打包入口文件的路径</span></span><br><span class="line">  <span class="attr">output</span>: &#123;</span><br><span class="line">    <span class="attr">path</span>: path.join(__dirname, <span class="string">&quot;./dist&quot;</span>), <span class="comment">// 输出文件的存放路径</span></span><br><span class="line">    <span class="attr">filename</span>: <span class="string">&quot;bundle.js&quot;</span>, <span class="comment">// 输出文件的名称</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="4-配置-webpack-的自动打包功能"><a href="#4-配置-webpack-的自动打包功能" class="headerlink" title="4. 配置 webpack 的自动打包功能"></a>4. 配置 webpack 的自动打包功能</h5><ol><li><p>运行 <code>npm install webpack-dev-server@3.11.2 -D</code> 命令，安装支持项目自动打包的工具</p></li><li><p>修改 package.json -&gt; scripts 中的 dev 命令如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack server&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure></li><li><p>将 src -&gt; index.html 中，script 脚本的引用路径，修改为 “/bundle.js”</p></li><li><p>运行 <code>npm run dev</code> 命令，重新进行打包</p></li><li><p>在浏览器中访问 <a href="http://localhost:8080/">http://localhost:8080</a> 地址，查看自动打包效果。</p></li></ol><h5 id="5-配置-html-webpack-plugin-生成预览页面"><a href="#5-配置-html-webpack-plugin-生成预览页面" class="headerlink" title="5. 配置 html-webpack-plugin 生成预览页面"></a>5. 配置 html-webpack-plugin 生成预览页面</h5><ol><li><p>运行 <code>npm install html-webpack-plugin@5.3.2 -D</code> 命令，安装生成预览页面的插件</p></li><li><p>修改 webpack.config.js 文件头部区域，添加如下配置信息：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">&quot;html-webpack-plugin&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> htmlPlugin = <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">  <span class="attr">template</span>: <span class="string">&quot;./src/index.html&quot;</span>,</span><br><span class="line">  <span class="attr">filename</span>: <span class="string">&quot;index.html&quot;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>修改 webpack.config.js 文件中向外暴露的配置对象，新增如下配置节点：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">plugins</span>: [htmlPlugin], <span class="comment">// plugins 数组时 webpack 打包期间会用到的一些插件列表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol><h5 id="6-配置自动打包相关的参数"><a href="#6-配置自动打包相关的参数" class="headerlink" title="6. 配置自动打包相关的参数"></a>6. 配置自动打包相关的参数</h5><p>安装插件 <code>npm install webpack-dev-server -D</code></p><p>在 package.json 中配置：</p><ul><li>–open 打包完成自动打开浏览器页面</li><li>–host 配置 IP 地址</li><li>–port 配置端口</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;webpack server --open --host 127.0.0.1 --port 8080&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">devServer</span>: &#123;</span><br><span class="line">    <span class="attr">open</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">host</span>: <span class="string">&quot;127.0.0.1&quot;</span>,</span><br><span class="line">    <span class="attr">port</span>: <span class="number">8080</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="webpack-中的加载器"><a href="#webpack-中的加载器" class="headerlink" title="webpack 中的加载器"></a>webpack 中的加载器</h4><ol><li>webpack 默认只能打包处理 .js 结尾的文件，处理不了其他后缀的文件</li><li>代码中包含了其他文件，因此 webpack 默认处理不了</li><li>会查找 webpack.config.js 这个配置文件，看 module.rules 数组中，是否配置了对应的 loader 加载器</li><li>找到后，将文件转交给最后一个 loader 进行处理</li><li>处理完毕后，会把处理的结果转交给上一个 loader</li><li>到最后，前面没有下一个 loader 了，就把最后的结果转交给了 webpack</li><li>webpack 将结果合并到 /dist/bundle.js 中，最终生成打包好的文件</li></ol><h5 id="报错解决"><a href="#报错解决" class="headerlink" title="报错解决"></a>报错解决</h5><p>控制台报错：</p><p>DevTools failed to load SourceMap: Could not load content for webpack:///node_modules/sockjs-client/</p><p>解决：</p><p>webpack.config.js 中配置一项</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123; <span class="attr">devtool</span>: <span class="string">&quot;inline-source-map&quot;</span> &#125;;</span><br></pre></td></tr></table></figure><h5 id="通过-loader-打包非-js-模块"><a href="#通过-loader-打包非-js-模块" class="headerlink" title="通过 loader 打包非 js 模块"></a>通过 loader 打包非 js 模块</h5><ul><li>less-loader 可以打包处理 .less 相关的文件</li><li>sass-loader 可以打包处理 .scss 相关的文件</li><li>url-loader 可以打包处理 css 中与 url 路径相关的文件</li></ul><h5 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h5><h6 id="1-打包处理-css-文件"><a href="#1-打包处理-css-文件" class="headerlink" title="1. 打包处理 css 文件"></a>1. 打包处理 css 文件</h6><ol><li><p>运行 <code>npm install style-loader@3.0.0 css-loader@5.2.6 -D</code> 命令，安装处理 css 文件的 loader</p></li><li><p>在 webpack.config.js 的 module -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [&#123; <span class="attr">test</span>: <span class="regexp">/\.css$/</span>, use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>] &#125;];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，test 表示匹配的文件类型，use 表示对应要调用的 loader</p></li></ol><p>注意：</p><ul><li>use 数组中指定的 loader 顺序是固定的</li><li>多个 loader 的调用顺序是：从后往前调用</li></ul><h6 id="2-打包处理-less-文件"><a href="#2-打包处理-less-文件" class="headerlink" title="2. 打包处理 less 文件"></a>2. 打包处理 less 文件</h6><ol><li><p>运行 <code>npm i less-loader less -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.less$/</span>, use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;less-loader&quot;</span>] &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="3-打包处理-scss-文件"><a href="#3-打包处理-scss-文件" class="headerlink" title="3. 打包处理 scss 文件"></a>3. 打包处理 scss 文件</h6><ol><li><p>运行 <code>npm i sass-loader node-sass -D</code> 命令，</p><p>运行不通使用：</p><ol><li><p>首先删除 node_modules 中的 sass-loader 和 node-sass 目录</p></li><li><p>配置淘宝镜像</p><p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code></p></li><li><p>用 cnpm 重新安装一次<br><code>cnpm install node-sass -D</code><br><code>cnpm install sass-loader -D</code></p></li></ol></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123; <span class="attr">test</span>: <span class="regexp">/\.scss$/</span>, use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;sass-loader&quot;</span>] &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="4-配置-postCSS-自动添加-css-的兼容前缀"><a href="#4-配置-postCSS-自动添加-css-的兼容前缀" class="headerlink" title="4. 配置 postCSS 自动添加 css 的兼容前缀"></a>4. 配置 postCSS 自动添加 css 的兼容前缀</h6><ol><li><p>运行 <code>npm i postcss-loader autoprefixer -D</code> 命令，</p></li><li><p>在项目根目录中创建 postcss 的配置文件 postcss.config.js，并初始化如下配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入自动添加前缀的插件const autoprefixer = require(&#x27;autoprefixer&#x27;)module.exports = &#123;    plugins: [ autoprefixer ] // 挂载插件&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，修改 css 的 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">      use: [<span class="string">&quot;style-loader&quot;</span>, <span class="string">&quot;css-loader&quot;</span>, <span class="string">&quot;postcss-loader&quot;</span>],</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h6 id="5-打包样式表中的图片和字体文件"><a href="#5-打包样式表中的图片和字体文件" class="headerlink" title="5. 打包样式表中的图片和字体文件"></a>5. 打包样式表中的图片和字体文件</h6><ol><li><p>运行 <code>npm i url-loader file-loader -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>: &#123;</span><br><span class="line">  <span class="attr">rules</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">test</span>: <span class="regexp">/\.jpg|png|gif|bmp|ttf|eot|svg|woff|woff2$/</span>,</span><br><span class="line">      use: <span class="string">&quot;url-loader?limit=32417&amp;outputPath=images&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：</p><ul><li>? 后 limit 参数是文件的大小（单位是字节），小于此大小 才会编译为 base64 格式</li><li>outputPath 参数是该类型文件打包后存放的文件夹</li></ul></li></ol><h6 id="6-打包处理-js-文件中的高级语法"><a href="#6-打包处理-js-文件中的高级语法" class="headerlink" title="6. 打包处理 js 文件中的高级语法"></a>6. 打包处理 js 文件中的高级语法</h6><ol><li><p>运行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i babel-loader@<span class="number">8.2</span>.<span class="number">2</span> @babel/core@<span class="number">7.14</span>.<span class="number">6</span> @babel/runtime@<span class="number">7.14</span>.<span class="number">5</span> -D</span><br></pre></td></tr></table></figure><p>命令，安装 babel 转换器相关的包</p></li><li><p>运行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i @babel/preset-env @babel/plugin-transform-runtime @babel/plugin-proposal-<span class="class"><span class="keyword">class</span>-<span class="title">properties</span> -<span class="title">D</span></span></span><br></pre></td></tr></table></figure><p>命令，安装 babel 语法插件相关的包</p></li><li><p>在项目根目录下，创建 babel 配置文件 babel.config.js 并初始化基本配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  <span class="attr">presets</span>: [<span class="string">&quot;@babel/env&quot;</span>],</span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&quot;@babel/plugin-transform-rutime&quot;</span>,</span><br><span class="line">    <span class="string">&quot;@babel/plugin-proposal-class-properties&quot;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// exclude 为排除项，表示 babel-loader 不需要处理 node_modules 中的 js 文件module: &#123;    rules: [        &#123; test: /\.js$/, use: &#x27;babel-loader&#x27;, exclude: /node_modules/ &#125;    ]&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h6 id="7-配置-vue-组件的加载器"><a href="#7-配置-vue-组件的加载器" class="headerlink" title="7. 配置 vue 组件的加载器"></a>7. 配置 vue 组件的加载器</h6><ol><li><p>运行 <code>npm i vue-loader vue-template-compiler -D</code> 命令，</p></li><li><p>在 webpack.config.js 的 modeule -&gt; rules 数组中，添加 loader 规则如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> VueLoaderPlugin = <span class="built_in">require</span>(<span class="string">&#x27;vue-loader/lib/plugin&#x27;</span>)<span class="built_in">module</span>.exports = &#123;    <span class="attr">module</span>: &#123;        <span class="attr">rules</span>: [            &#123; <span class="attr">test</span>: <span class="regexp">/\.vue$/</span>, use: <span class="string">&#x27;vue-loader&#x27;</span> &#125;        ]    &#125;,    <span class="attr">plugin</span>: [        <span class="keyword">new</span> VueLoaderPlugin()    ]&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><p>在 package.json 的 scripts 节点下，新增 build 命令如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>&#125;,</span><br></pre></td></tr></table></figure><p>–mode 用来指定 webpack 的运行模式</p><h5 id="自动删除-dist-目录"><a href="#自动删除-dist-目录" class="headerlink" title="自动删除 dist 目录"></a>自动删除 dist 目录</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i clean-webpack-plugin -D</span><br></pre></td></tr></table></figure><p>导入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 左侧的 &#123;&#125; 是解构赋值const &#123; CleanWebpackPlugin &#125; = require(&#x27;clean-webpack-plugin&#x27;)plugins: [    new CleanWebPlugin()]</span></span><br></pre></td></tr></table></figure><h5 id="source-Map"><a href="#source-Map" class="headerlink" title="source Map"></a>source Map</h5><p>开发环境下默认生成的 Source Map，记录的是生成后的代码的位置。会导致运行时报错的行数与源代码的行数不一致的问题</p><p>解决：在 webpack.config.js 中增加如下的配置，即可使得运行时报错的行数与源代码的行数保存一致</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;    devtool: &#x27;eval-source-map&#x27;,&#125;</span><br></pre></td></tr></table></figure><p><strong>折中方法</strong>，只定位行数不暴露源码：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;    devtool: &#x27;nosources-source-map&#x27;&#125;</span><br></pre></td></tr></table></figure><p>不推荐的参数 source-map 坚决不要使用</p><ul><li>在生产环境下，设置成 nosources-source-map 或 直接关闭 Source Map</li><li>开发调试阶段，建议把 devtool 的值设置为 eval-source-map</li></ul><h4 id="webpack-中的"><a href="#webpack-中的" class="headerlink" title="webpack 中的 @"></a>webpack 中的 @</h4><p>@ 表示 src 源代码目录，从外往里查找；不要使用 ../ 从里往外查找</p><p>需要在 webpack.config.js 中进行配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;    <span class="attr">resolve</span>: &#123;        <span class="attr">alias</span>: &#123;            <span class="comment">// 告诉 webpack 程序员写的代码中 @ 表示 src 这一层目录            &#x27;@&#x27;: path.join(__dirname, &#x27;./src&#x27;)        &#125;    &#125;&#125;</span></span><br></pre></td></tr></table></figure><h4 id="webpack-中使用-Vue"><a href="#webpack-中使用-Vue" class="headerlink" title="webpack 中使用 Vue"></a>webpack 中使用 Vue</h4><ol><li>运行 <code>npm i vue -S</code> 安装 vue</li><li>在 src -&gt; index.js 入口文件中，通过 <code>ipmort Vue from &#39;vue&#39; </code> 来导入 vue 构造函数</li><li>创建 vue 的实例对象，并且要控制的 el 区域</li><li>通过 render 函数渲染 App 根组件</li></ol><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&quot;vue&quot;</span>; <span class="comment">// 导入 单文件组件import App from &#x27;./components/App.vue&#x27;const vm = new Vue(&#123;  el: &#x27;#app&#x27;,  render: h =&gt; h(App)&#125;)</span></span><br></pre></td></tr></table></figure><p><strong>报错处理</strong>：</p><p>Error: Cannot find module ‘@babel/preset-preset.env’</p><p>解决：</p><p>将 babel.config.js 配置文件中的 <code>preset-env</code> ，改为 <code>env</code></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Webpack </tag>
            
            <tag> 前端工程化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES8笔记</title>
      <link href="/2021/07/30/ES8%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/30/ES8%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ES8-新特性"><a href="#ES8-新特性" class="headerlink" title="ES8 新特性"></a>ES8 新特性</h2><h3 id="async-和-await"><a href="#async-和-await" class="headerlink" title="async 和 await"></a>async 和 await</h3><p>async 和 await 两种语法结合可以让异步代码像同步代码一样</p><h5 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h5><p>返回值是 Promise 对象</p><ul><li>只要 return 返回的结果不是一个 Promise 类型的对象，则这个结果就是一个成功的 Promise</li><li>抛出错误，返回的结果是一个失败的 Promise</li><li>返回的结果是一个 Promise 对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 返回正常</span></span><br><span class="line">  <span class="comment">// return &#x27;字符串&#x27;;</span></span><br><span class="line">  <span class="comment">// 抛出错误</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// throw new Error(&#x27;出错啦！！&#x27;)</span></span><br><span class="line">  <span class="comment">// 返回的是Promise</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;成功的数据&quot;</span>);</span><br><span class="line">    <span class="comment">// reject(&#x27;失败的数据&#x27;);</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = fn();</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// Promise 对象</span></span><br></pre></td></tr></table></figure><h5 id="await-表达式"><a href="#await-表达式" class="headerlink" title="await 表达式"></a>await 表达式</h5><ul><li>await 必须写在 async 函数中</li><li>await 右侧的表达式一般为 promise 对象</li><li>await 返回的是 promise 成功的值</li><li>await 的 promise 失败了, 就会抛出异常, 需要通过 try…catch 捕获处理</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// resolve(&#x27;成功的值&#x27;)</span></span><br><span class="line">  reject(<span class="string">&quot;失败啦&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// await 要放在 async 函数中</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="keyword">await</span> p;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h5 id="async-amp-await-获取文件"><a href="#async-amp-await-获取文件" class="headerlink" title="async &amp; await 获取文件"></a>async &amp; await 获取文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 为学</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readWeiXue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/为学.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果失败</span></span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="comment">// 如果成功</span></span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 插秧诗</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readChaYang</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/插秧诗.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果失败</span></span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="comment">// 如果成功</span></span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取 观书有感</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readGuanShu</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/观书有感.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 如果失败</span></span><br><span class="line">      <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">      <span class="comment">// 如果成功</span></span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明一个 async 函数</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获取 为学</span></span><br><span class="line">  <span class="keyword">let</span> weixue = <span class="keyword">await</span> readWeiXue();</span><br><span class="line">  <span class="comment">// 获取 插秧诗</span></span><br><span class="line">  <span class="keyword">let</span> chayang = <span class="keyword">await</span> readChaYang();</span><br><span class="line">  <span class="comment">// 获取 观书有感</span></span><br><span class="line">  <span class="keyword">let</span> guanshu = <span class="keyword">await</span> readGuanShu();</span><br><span class="line">  <span class="built_in">console</span>.log(weixue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h5 id="async-amp-await-封装-AJAX-请求"><a href="#async-amp-await-封装-AJAX-请求" class="headerlink" title="async &amp; await 封装 AJAX 请求"></a>async &amp; await 封装 AJAX 请求</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 发送 AJAX 请求，返回的结果是 Promise 对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendAJAX</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 1. 创建对象</span></span><br><span class="line">    <span class="keyword">const</span> x = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 初始化</span></span><br><span class="line">    x.open(<span class="string">&quot;GET&quot;</span>, url);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 发送</span></span><br><span class="line">    x.send();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 事件绑定</span></span><br><span class="line">    x.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (x.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.status &gt;= <span class="number">200</span> &amp;&amp; x.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">          <span class="comment">// 成功</span></span><br><span class="line">          resolve(x.response);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">// 如果失败</span></span><br><span class="line">          reject(x.status);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Promise then 方法测试</span></span><br><span class="line"><span class="comment">// const result = sendAJAX(&#x27;https://api.apiopen.top/getJoke&#x27;).then(value =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   console.log(value);</span></span><br><span class="line"><span class="comment">// &#125;, reason =&gt; &#123;&#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// async 与 await 测试</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 发送 AJAX 请求</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="keyword">await</span> sendAJAX(<span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">main();</span><br></pre></td></tr></table></figure><h3 id="对象方法扩展"><a href="#对象方法扩展" class="headerlink" title="对象方法扩展"></a>对象方法扩展</h3><h5 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h5><p>返回一个给定对象的所有可枚举属性值的数组</p><ul><li>获取一个对象所有的键<code>Object.key(对象名)</code></li><li>获取一个对象所有的值<code>Object.values(对象名)</code></li></ul><h5 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries()"></a>Object.entries()</h5><p>返回一个给定对象自身可遍历属性 [key,value] 的数组</p><ul><li>获取一个对象所有的键值对，一个键值对就是一个数组元素</li></ul><h5 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors"></a>Object.getOwnPropertyDescriptors</h5><p>该方法返回指定对象所有自身属性的描述对象</p><ul><li>value：值</li><li>writable：是否可写</li><li>configurable：是否可以删除</li><li>enumerable：是否可以枚举</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> ES8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES7笔记</title>
      <link href="/2021/07/30/ES7%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/30/ES7%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="ES7-新特性"><a href="#ES7-新特性" class="headerlink" title="ES7 新特性"></a>ES7 新特性</h2><h3 id="Array-prototype-includes"><a href="#Array-prototype-includes" class="headerlink" title="Array.prototype.includes"></a>Array.prototype.includes</h3><p>Includes 方法用来检测数组中是否包含某个元素，返回 boolean 类型值</p><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符"></a>指数运算符</h3><p>在 ES7 中引入指数运算符「**」，用来实现幂运算，功能与 Math.pow 结果相同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span> ** <span class="number">10</span>); <span class="comment">// 1024</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">10</span>)); <span class="comment">// 1024</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ES7 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6笔记</title>
      <link href="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/30/ES6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-ECMASript-相关介绍"><a href="#第一章-ECMASript-相关介绍" class="headerlink" title="第一章 ECMASript 相关介绍"></a>第一章 <strong>ECMASript</strong> 相关介绍</h2><h3 id="1-1-什么是-ECMA"><a href="#1-1-什么是-ECMA" class="headerlink" title="1.1 什么是 ECMA"></a>1.1 什么是 ECMA</h3><p>ECMA（European Computer Manufacturers Association）中文名称为欧洲计算机制造商协会，这个组织的目标是评估、开发和认可电信和计算机标准。1994 年后该组织改名为 Ecma 国际。</p><h3 id="1-2-什么是-ECMAScript"><a href="#1-2-什么是-ECMAScript" class="headerlink" title="1.2 什么是 ECMAScript"></a>1.2 什么是 ECMAScript</h3><p>ECMAScript 是由 Ecma 国际通过 ECMA-262 标准化的脚本程序设计语言。</p><h3 id="1-3-为什么要学习-ES6"><a href="#1-3-为什么要学习-ES6" class="headerlink" title="1.3 为什么要学习 ES6"></a>1.3 为什么要学习 ES6</h3><ul><li>ES6 的版本变动内容最多，具有里程碑意义</li><li>ES6 加入许多新的语法特性，编程实现更简单、高效</li><li>ES6 是前端发展趋势，就业必备技能</li></ul><h3 id="1-4-ES6-兼容性"><a href="#1-4-ES6-兼容性" class="headerlink" title="1.4 ES6 兼容性"></a>1.4 ES6 兼容性</h3><p><a href="http://kangax.github.io/compat-table/es6/">http://kangax.github.io/compat-table/es6/</a> 可查看兼容性</p><h2 id="第二章-ECMAScript-6-新特性"><a href="#第二章-ECMAScript-6-新特性" class="headerlink" title="第二章 ECMAScript 6 新特性"></a>第二章 ECMAScript 6 新特性</h2><h3 id="2-1-let-关键字"><a href="#2-1-let-关键字" class="headerlink" title="2.1 let 关键字"></a>2.1 let 关键字</h3><h5 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h5><ul><li>变量不能重复声明</li><li>块儿级作用域</li><li>不存在变量提升(不允许在变量声明之前使用变量)</li><li>不影响作用域链</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>​ 以后声明变量使用 let 就对了</p><h3 id="2-2-const-关键字"><a href="#2-2-const-关键字" class="headerlink" title="2.2 const 关键字"></a>2.2 const 关键字</h3><h5 id="特性-1"><a href="#特性-1" class="headerlink" title="特性"></a>特性</h5><ul><li>声明必须赋初始值</li><li>标识符一般为大写</li><li>不允许重复声明</li><li>值不允许修改</li><li>块儿级作用域</li></ul><h5 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h5><p>​ 对象属性修改和数组元素变化不会出发 const 错误</p><h5 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h5><p>​ 声明对象类型使用 const，非对象类型声明选择 let</p><h3 id="2-3-变量的解构赋值"><a href="#2-3-变量的解构赋值" class="headerlink" title="2.3 变量的解构赋值"></a>2.3 变量的解构赋值</h3><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构赋值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="string">&quot;张学友&quot;</span>, <span class="string">&quot;刘德华&quot;</span>, <span class="string">&quot;黎明&quot;</span>, <span class="string">&quot;郭富城&quot;</span>];</span><br><span class="line"><span class="keyword">let</span> [zhang, liu, li, guo] = arr;</span><br><span class="line"><span class="built_in">console</span>.log(zhang); <span class="comment">// 张学友</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对象的解构赋值</span></span><br><span class="line"><span class="keyword">const</span> lin = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;林志颖&quot;</span>,</span><br><span class="line">  <span class="attr">tags</span>: [<span class="string">&quot;车手&quot;</span>, <span class="string">&quot;歌手&quot;</span>, <span class="string">&quot;小旋风&quot;</span>, <span class="string">&quot;演员&quot;</span>],</span><br><span class="line">  <span class="attr">changge</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以唱歌&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; name, tags &#125; = lin;</span><br><span class="line"><span class="built_in">console</span>.log(name); <span class="comment">// 林志颖</span></span><br><span class="line"><span class="keyword">let</span> &#123; cahngge &#125; = lin;</span><br><span class="line">changge(); <span class="comment">// 我可以唱歌</span></span><br></pre></td></tr></table></figure><h3 id="2-4-模板字符串"><a href="#2-4-模板字符串" class="headerlink" title="2.4 模板字符串"></a>2.4 模板字符串</h3><p>模板字符串（template string）是增强版的字符串，用一对反引号（`）标识</p><h5 id="特性-2"><a href="#特性-2" class="headerlink" title="特性"></a>特性</h5><ul><li>字符串中可以出现换行符</li><li>可以使用 ${xxx} 的输出变量</li></ul><h3 id="2-5-简化对象写法"><a href="#2-5-简化对象写法" class="headerlink" title="2.5 简化对象写法"></a>2.5 简化对象写法</h3><p>ES6 允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> name = <span class="string">&quot;尚硅谷&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> slogon = <span class="string">&quot;永远追求行业更高标准&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> improve = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;可以提高你的技能&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//属性和方法简写</span></span><br><span class="line"><span class="keyword">let</span> atguigu = &#123;</span><br><span class="line">  name,</span><br><span class="line">  slogon,</span><br><span class="line">  improve,</span><br><span class="line">  <span class="function"><span class="title">change</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;可以改变你&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-6-箭头函数"><a href="#2-6-箭头函数" class="headerlink" title="2.6 箭头函数"></a>2.6 箭头函数</h3><p>ES6 允许使用「箭头」 <code>=&gt;</code> 定义函数。</p><p>ES6 允许给函数参数赋初始值</p><ul><li>具有默认值的参数，一般靠后</li><li>可以与解构赋值结合</li></ul><h5 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h5><ul><li>如果形参只有一个，则小括号可以省略</li><li>函数体如果只有一条语句，则花括号可以省略，此时 return 必须省略，而且函数的返回值为该条语句的执行结果</li><li>箭头函数 this 是静态的，始终指向声明时所在作用域下 this 的值</li><li>箭头函数不能作为构造函数实例化</li><li>不能使用 arguments</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通用写法</span></span><br><span class="line"><span class="keyword">let</span> fn = <span class="function">(<span class="params">arg1, arg2, arg3</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> arg1 + arg2 + arg3;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 省略花括号的情况</span></span><br><span class="line"><span class="keyword">let</span> fn3 = <span class="function">(<span class="params">score</span>) =&gt;</span> score * <span class="number">20</span>;</span><br></pre></td></tr></table></figure><h5 id="应用场景-2"><a href="#应用场景-2" class="headerlink" title="应用场景"></a>应用场景</h5><p>适合与 this 无关的回调 定时器、数组的方法回调</p><p>不适合与 this 有关的回调 事件回调、对象的方法</p><h3 id="2-7-rest-参数"><a href="#2-7-rest-参数" class="headerlink" title="2.7 rest 参数"></a>2.7 rest 参数</h3><p>ES6 引入 rest 参数，用于获取函数的实参，用来代替 arguments</p><ul><li><code>...args</code></li><li>rest 参数必须要放到最后</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 作用与 arguments 类似</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// [1,2,3,4,5]</span></span><br><span class="line">&#125;</span><br><span class="line">add(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * rest 参数必须是最后一个形参</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">minus</span>(<span class="params">a, b, ...args</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 100</span></span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 1</span></span><br><span class="line">  <span class="built_in">console</span>.log(args); <span class="comment">// [2,3,4,5,19]</span></span><br><span class="line">&#125;</span><br><span class="line">minus(<span class="number">100</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">19</span>);</span><br></pre></td></tr></table></figure><h5 id="应用场景-3"><a href="#应用场景-3" class="headerlink" title="应用场景"></a>应用场景</h5><p>rest 参数非常适合不定个数参数函数的场景</p><h3 id="2-8-spread-运算符"><a href="#2-8-spread-运算符" class="headerlink" title="2.8 spread 运算符"></a>2.8 spread 运算符</h3><p>扩展运算符（spread）也是三个点<code>...</code>。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列，对数组进行解包。</p><h5 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h5><ol><li><p>数组的合并</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="keyword">const</span> arr2 = [<span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="comment">// const hebing = arr1.concat(arr2); 原先api函数</span></span><br><span class="line"><span class="keyword">const</span> hebing = [...arr1, ...arr2];</span><br></pre></td></tr></table></figure></li><li><p>数组的克隆</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 注意是 浅克隆</span></span><br><span class="line"><span class="keyword">const</span> hebing = [...arr1];</span><br></pre></td></tr></table></figure></li><li><p>将伪数组转为真正的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> divs = <span class="built_in">document</span>.querySelectAll(<span class="string">&quot;div&quot;</span>); <span class="comment">// 伪数组</span></span><br><span class="line"><span class="keyword">const</span> divArr = [...divs];</span><br></pre></td></tr></table></figure></li></ol><h3 id="2-9-Symbol"><a href="#2-9-Symbol" class="headerlink" title="2.9 Symbol"></a>2.9 Symbol</h3><p>ES6 引入了一种新的原始数据类型 Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，是一种类似于字符串的数据类型。</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ul><li>Symbol 的值是唯一的，用来解决命名冲突的问题</li><li>Symbol 值不能与其他数据进行运算</li><li>Symbol 定义的 对象属性 不能使用 for…in 循环遍历 ，但是可以 使用 Reflect.ownKeys 来获取对象的所有键名</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Symbol</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span> s); <span class="comment">// Symbol() &quot;symbol&quot;</span></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">&quot;张艺兴&quot;</span>); <span class="comment">// 注释作用</span></span><br><span class="line"><span class="keyword">let</span> s3 = <span class="built_in">Symbol</span>(<span class="string">&quot;张艺兴&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2 === s3); <span class="comment">// false</span></span><br><span class="line"><span class="comment">// Symbol.for 创建</span></span><br><span class="line"><span class="keyword">let</span> s4 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;张艺兴&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s5 = <span class="built_in">Symbol</span>.for(<span class="string">&quot;张艺兴&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s4, <span class="keyword">typeof</span> s4); <span class="comment">// Symbol(张艺兴) &quot;symbol&quot;</span></span><br><span class="line"><span class="built_in">console</span>.log(s4 === s5); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><code>Symbol[&#39;say&#39;]: function () &#123;&#125;</code></p><h5 id="内置值"><a href="#内置值" class="headerlink" title="内置值"></a>内置值</h5><h4 id="JS-数据类型总结"><a href="#JS-数据类型总结" class="headerlink" title="JS 数据类型总结"></a>JS 数据类型总结</h4><p><strong>USONB</strong> (you are so niubility)</p><ul><li>u : undefined</li><li>s : string Symbol</li><li>o : object</li><li>n : null number</li><li>b : boolean</li></ul><h3 id="2-10-迭代器"><a href="#2-10-迭代器" class="headerlink" title="2.10 迭代器"></a>2.10 迭代器</h3><p>遍历器（Iterator）就是一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署 Iterator 接口，就可以完成遍历操作。</p><ul><li><p>ES6 创造了一种新的遍历命令 for…of 循环，Iterator 接口主要供 for…of 消费</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个数组</span></span><br><span class="line"><span class="keyword">const</span> xiyou = [<span class="string">&quot;1&quot;</span>, <span class="string">&quot;2&quot;</span>, <span class="string">&quot;3&quot;</span>, <span class="string">&quot;4&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 for...of 遍历数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> xiyou) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>原生具备 iterator 接口的数据(可用 for of 遍历)</p><ul><li>Array</li><li>Arguments</li><li>Set</li><li>Map</li><li>String</li><li>TypedArray</li><li>NodeList</li></ul></li><li><p>工作原理</p><ul><li>创建一个指针对象，指向当前数据结构的起始位置</li><li>第一次调用对象的 next 方法，指针自动指向数据结构的第一个成员</li><li>接下来不断调用 next 方法，指针一直往后移动，直到指向最后一个成员</li><li>每调用 next 方法返回一个包含 value 和 done 属性的对象</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> iterator = xiyou[<span class="built_in">Symbol</span>.iterator]();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用对象的 next 方法</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br></pre></td></tr></table></figure><p>运行结果：</p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622185251823.png" class></li></ul><h5 id="应用场景-4"><a href="#应用场景-4" class="headerlink" title="应用场景"></a>应用场景</h5><p>需要自定义遍历数据的时候，要想到迭代器。</p><h5 id="自定义遍历对象"><a href="#自定义遍历对象" class="headerlink" title="自定义遍历对象"></a>自定义遍历对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个对象</span></span><br><span class="line"><span class="keyword">const</span> banji = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;终极一班&quot;</span>,</span><br><span class="line">  <span class="attr">stus</span>: [<span class="string">&quot;xiaoming&quot;</span>, <span class="string">&quot;xiaoning&quot;</span>, <span class="string">&quot;xiaotian&quot;</span>, <span class="string">&quot;knight&quot;</span>],</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="comment">// 索引变量</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> _this = <span class="built_in">this</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; _this.stus.length) &#123;</span><br><span class="line">          <span class="keyword">const</span> result = &#123; <span class="attr">value</span>: _this.stus[index], <span class="attr">done</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">          <span class="comment">// 下表自增</span></span><br><span class="line">          index++;</span><br><span class="line">          <span class="comment">// 返回结果</span></span><br><span class="line">          <span class="keyword">return</span> result;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">value</span>: <span class="literal">undefined</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历这个对象</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> banji) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-11-生成器"><a href="#2-11-生成器" class="headerlink" title="2.11 生成器"></a>2.11 生成器</h3><p>生成器函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同，起其实就是一个特殊的函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// yield 函数代码的分隔符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// console.log(111);</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;一只没有耳朵&quot;</span>;</span><br><span class="line">  <span class="comment">// console.log(222);</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;一只没有尾巴&quot;</span>;</span><br><span class="line">  <span class="comment">// console.log(333);</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">&quot;真奇怪&quot;</span>;</span><br><span class="line">  <span class="comment">// console.log(444);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = gen();</span><br><span class="line"><span class="comment">// 调用 next() 方法才会执行方法</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> gen()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行截图：</p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622193807793.png" class><h5 id="生成器函数参数"><a href="#生成器函数参数" class="headerlink" title="生成器函数参数"></a>生成器函数参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arg);</span><br><span class="line">  <span class="keyword">let</span> one = <span class="keyword">yield</span> <span class="string">&quot;一只没有耳朵&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(one);</span><br><span class="line">  <span class="keyword">let</span> two = <span class="keyword">yield</span> <span class="string">&quot;一只没有尾巴&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(two);</span><br><span class="line">  <span class="keyword">let</span> three = <span class="keyword">yield</span> <span class="string">&quot;真奇怪&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(three);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> iterator = gen(<span class="string">&quot;AAA&quot;</span>);</span><br><span class="line"><span class="comment">// 调用 next() 方法才会执行方法</span></span><br><span class="line"><span class="built_in">console</span>.log(iterator.next());</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&quot;BBB&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&quot;CCC&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(iterator.next(<span class="string">&quot;DDD&quot;</span>));</span><br></pre></td></tr></table></figure><p>运行截图：</p><img src="/2021/07/30/ES6%E7%AC%94%E8%AE%B0/image-20210622194527052.png" class><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>…</p><h3 id="2-12-Promise"><a href="#2-12-Promise" class="headerlink" title="2.12 Promise"></a>2.12 Promise</h3><p>Promise 是 ES6 引入的异步编程的新解决方案。语法上 Promise 是一个构造函数，用来封装异步操作并可以获取其成功或失败的结果。</p><h5 id="Promise-构造方法"><a href="#Promise-构造方法" class="headerlink" title="Promise 构造方法"></a>Promise 构造方法</h5><p><code>const promise = new Promise(function(resolve, reject) &#123;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 实例化 Promise 对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// let data = &#x27;数据库中的用户数据&#x27;</span></span><br><span class="line">    <span class="comment">// resolve(data); // 调用 then 中第一个方法</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> err = <span class="string">&quot;数据读取失败&quot;</span>;</span><br><span class="line">    reject(err); <span class="comment">// 调用 then 中第二个方法</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 Promise 对象的 then 方法</span></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value); <span class="comment">// 数据库中的用户数据</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(reason); <span class="comment">// 数据读取失败</span></span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="Promise-读取文件"><a href="#Promise-读取文件" class="headerlink" title="Promise 读取文件"></a>Promise 读取文件</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;./resources/为学.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) reject(err);</span><br><span class="line">    <span class="comment">// 如果成功</span></span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;读取失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="Promise-封装-AJAX"><a href="#Promise-封装-AJAX" class="headerlink" title="Promise 封装 AJAX"></a>Promise 封装 AJAX</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口地址 http://api.apiopen.top/getJoke</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1. 创建对象</span></span><br><span class="line">  <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 初始化</span></span><br><span class="line">  xhr.open(<span class="string">&quot;GET&quot;</span>, <span class="string">&quot;https://api.apiopen.top/getJoke&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 发送</span></span><br><span class="line">  xhr.send();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 4. 绑定事件，处理响应结果</span></span><br><span class="line">  xhr.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (xhr.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.status &gt;= <span class="number">200</span> &amp;&amp; xhr.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        resolve(xhr.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定回调</span></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">reason</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then"></a>Promise.prototype.then</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 promise 对象</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    resolve(<span class="string">&quot;用户数据&quot;</span>);</span><br><span class="line">    <span class="comment">// reject(&#x27;出错啦&#x27;);</span></span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 then 方法  then方法的返回结果是 Promise 对象，对象状态又回调函数的执行结果决定</span></span><br><span class="line"><span class="comment">// 1. 如果回调函数中返回的结果是一个 非Promise 类型的数据，状态为成功，返回值为对象那个的成功值</span></span><br><span class="line"><span class="keyword">const</span> result = p.then(</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">    <span class="comment">// 1. 非 Promise 类型的数据</span></span><br><span class="line">    <span class="comment">// return 123;</span></span><br><span class="line">    <span class="comment">// 2. 是 Promise 对象</span></span><br><span class="line">    <span class="comment">// return new Promise((resolve, reject) =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//   // resolve(&#x27;ok&#x27;);</span></span><br><span class="line">    <span class="comment">//   reject(&#x27;出错&#x27;)</span></span><br><span class="line">    <span class="comment">// &#125;)</span></span><br><span class="line">    <span class="comment">// 3. 抛出错误</span></span><br><span class="line">    <span class="comment">// throw new Error(&#x27;出错啦&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.warn(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure><h6 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链式调用 可以避免回调地狱的形成</span></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;&#125;</span><br><span class="line">).then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure><p>另外，then 方法中的两个方法 不一定需要全有</p><h6 id="案例-读取多个文件"><a href="#案例-读取多个文件" class="headerlink" title="案例-读取多个文件"></a>案例-读取多个文件</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入 fs 模块</span></span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 之前的方法 - 回调地狱</span></span><br><span class="line"><span class="comment">// fs.readFile(&#x27;./resources/为学.md&#x27;, &#x27;utf8&#x27;, (err, data1) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   fs.readFile(&#x27;./resources/插秧诗.md&#x27;, &#x27;utf8&#x27;, (err, data2) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//     fs.readFile(&#x27;./resources/观书有感.md&#x27;, &#x27;utf8&#x27;, (err, data3) =&gt; &#123;</span></span><br><span class="line"><span class="comment">//       let result = data1 + &#x27;\r\n&#x27; + data2 + &#x27;\r\n&#x27; + data3;</span></span><br><span class="line"><span class="comment">//       console.log(result);</span></span><br><span class="line"><span class="comment">//     &#125;)</span></span><br><span class="line"><span class="comment">//   &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Promise 实现</span></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;./resources/为学.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    resolve(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    fs.readFile(<span class="string">&quot;./resources/插秧诗.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">      resolve([value, data]);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      fs.readFile(<span class="string">&quot;./resources/观书有感.md&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">        value.push(data);</span><br><span class="line">        resolve(value);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value.join(<span class="string">&quot;\r\n&quot;</span>));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h5 id="Promise-catch-方法"><a href="#Promise-catch-方法" class="headerlink" title="Promise catch 方法"></a>Promise catch 方法</h5><p>不用不影响开发，catch 的作用只是简化，可以只写后面错误的函数，不需要写前面的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置 p 对象的状态为失败，并设置失败的值</span></span><br><span class="line">    reject(<span class="string">&quot;出错啦！&quot;</span>);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">  <span class="function">(<span class="params">value</span>) =&gt;</span> &#123;&#125;,</span><br><span class="line">  <span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(reason);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">p.catch(<span class="function">(<span class="params">reason</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.warn(reason);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="2-13-Set"><a href="#2-13-Set" class="headerlink" title="2.13 Set"></a>2.13 Set</h3><p>ES6 提供了新的数据结构 Set（集合）。</p><p>它类似于数组，但成员的值都是唯一的，集合实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。</p><h5 id="属性-amp-方法"><a href="#属性-amp-方法" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h5><ul><li>size 返回集合的元素个数</li><li>add 增加一个新元素，返回当前集合</li><li>delete 删除元素，返回 boolean 值</li><li>has 检测集合中是否包含某个元素，返回 boolean 值</li><li>clear 清空集合，返回 undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明一个 Set</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&quot;大事儿&quot;</span>, <span class="string">&quot;小事儿&quot;</span>, <span class="string">&quot;好事儿&quot;</span>, <span class="string">&quot;坏事儿&quot;</span>, <span class="string">&quot;小事儿&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(s, <span class="keyword">typeof</span> s);</span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// 自动去重 &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 元素的个数</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.size); <span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 添加新的元素</span></span><br><span class="line">s2.add(<span class="string">&quot;喜事儿&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;坏事儿&quot;, &quot;喜事儿&quot;&#125;</span></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">s2.delete(<span class="string">&quot;坏事儿&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// &#123;&quot;大事儿&quot;, &quot;小事儿&quot;, &quot;好事儿&quot;, &quot;喜事儿&quot;&#125;</span></span><br><span class="line"><span class="comment">// 检测</span></span><br><span class="line"><span class="built_in">console</span>.log(s2.has(<span class="string">&quot;好事儿&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line">s2.clear();</span><br><span class="line"><span class="built_in">console</span>.log(s2); <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可实现 for...of 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> s2) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Set-集合实践"><a href="#Set-集合实践" class="headerlink" title="Set 集合实践"></a>Set 集合实践</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>];</span><br><span class="line"><span class="comment">// 1. 数组去重</span></span><br><span class="line"><span class="comment">// let result = [...new Set(arr)];</span></span><br><span class="line"><span class="comment">// console.log(result);</span></span><br><span class="line"><span class="comment">// 2. 交集</span></span><br><span class="line"><span class="keyword">let</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="comment">// let result = [...new Set(arr)].filter(item =&gt; &#123;</span></span><br><span class="line"><span class="comment">//   let s2 = new Set(arr2);</span></span><br><span class="line"><span class="comment">//   if (s2.has(item)) &#123;</span></span><br><span class="line"><span class="comment">//     return true;</span></span><br><span class="line"><span class="comment">//   &#125; else &#123;</span></span><br><span class="line"><span class="comment">//     return false;</span></span><br><span class="line"><span class="comment">//   &#125;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// 简化</span></span><br><span class="line"><span class="keyword">let</span> result = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> <span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item));</span><br><span class="line"><span class="built_in">console</span>.log(result); <span class="comment">// [4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 并集</span></span><br><span class="line"><span class="keyword">let</span> union = [...new <span class="built_in">Set</span>([...arr, ...arr2])];</span><br><span class="line"><span class="built_in">console</span>.log(union); <span class="comment">// [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 差集</span></span><br><span class="line"><span class="keyword">let</span> diff = [...new <span class="built_in">Set</span>(arr)].filter(<span class="function">(<span class="params">item</span>) =&gt;</span> !<span class="keyword">new</span> <span class="built_in">Set</span>(arr2).has(item));</span><br><span class="line"><span class="built_in">console</span>.log(diff); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure><h3 id="2-14-Map"><a href="#2-14-Map" class="headerlink" title="2.14 Map"></a>2.14 Map</h3><p>ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合。但是“键”<br>的范围不限于字符串，各种类型的值（包括对象）都可以当作键。Map 也实现了 iterator 接口，所以可以使用『扩展运算符』和『for…of…』进行遍历。</p><h5 id="属性-amp-方法-1"><a href="#属性-amp-方法-1" class="headerlink" title="属性&amp;方法"></a>属性&amp;方法</h5><ul><li>size 返回 Map 的元素个数</li><li>add 增加一个新元素，返回当前 Map</li><li>get 返回键名对象的键值</li><li>has 检测 Map 中是否包含某个元素，返回 boolean 值</li><li>clear 清空集合，返回 undefined</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明 Map</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加元素</span></span><br><span class="line">m.set(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;张艺兴&quot;</span>);</span><br><span class="line">m.set(<span class="string">&quot;change&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;张艺兴是最帅的&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> key = &#123;</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line">m.set(key, [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// size</span></span><br><span class="line"><span class="built_in">console</span>.log(m.size); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除</span></span><br><span class="line">m.delete(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取</span></span><br><span class="line"><span class="comment">// console.log(m.get(&#x27;change&#x27;));</span></span><br><span class="line"><span class="built_in">console</span>.log(m.get(key)); <span class="comment">// [&quot;北京&quot;, &quot;上海&quot;, &quot;深圳&quot;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空</span></span><br><span class="line"><span class="comment">// m.clear();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> v <span class="keyword">of</span> m) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure><h3 id="2-15-Class-类"><a href="#2-15-Class-类" class="headerlink" title="2.15 Class 类"></a>2.15 Class 类</h3><p>ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对<br>象的模板。通过 class 关键字，可以定义类。基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p><h5 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h5><ul><li>class 声明类</li><li>constructor 定义构造函数初始化</li><li>extends 继承父类</li><li>super 调用父级构造方法</li><li>static 定义静态方法和属性</li><li>父类方法可以重写</li></ul><h5 id="ES5-方法"><a href="#ES5-方法" class="headerlink" title="ES5 方法"></a>ES5 方法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="comment">// 手机</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Phone</span>(<span class="params">brand, price</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.brand = brand;</span><br><span class="line">  <span class="built_in">this</span>.price = price;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加方法</span></span><br><span class="line">Phone.prototype.call = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">let</span> huawei = <span class="keyword">new</span> Phone(<span class="string">&quot;华为&quot;</span>, <span class="number">5999</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(huawei);</span><br><span class="line"><span class="comment">// huawei.call();</span></span><br></pre></td></tr></table></figure><h5 id="ES6-class"><a href="#ES6-class" class="headerlink" title="ES6 class"></a>ES6 class</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shouji</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法 名字不能修改</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 方法必须使用该语法，不能使用 ES5 的对象完整形式</span></span><br><span class="line">  <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> onePlus = <span class="keyword">new</span> Shouji(<span class="string">&quot;1+&quot;</span>, <span class="number">1999</span>);</span><br><span class="line"><span class="built_in">console</span>.log(onePlus);</span><br></pre></td></tr></table></figure><h5 id="静态成员"><a href="#静态成员" class="headerlink" title="静态成员"></a>静态成员</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 静态属性</span></span><br><span class="line">  <span class="keyword">static</span> name = <span class="string">&quot;手机&quot;</span>;</span><br><span class="line">  <span class="keyword">static</span> change = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以改变世界&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nokia = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(nokia.name); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(Phone.name); <span class="comment">// 手机</span></span><br></pre></td></tr></table></figure><h5 id="类继承"><a href="#类继承" class="headerlink" title="类继承"></a>类继承</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">brand, price</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.brand = brand;</span><br><span class="line">    <span class="built_in">this</span>.price = price;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 父类的成员属性</span></span><br><span class="line">  <span class="function"><span class="title">call</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我可以打电话&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPhone</span> <span class="keyword">extends</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造方法</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">brand, price, color, size</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(brand, price);</span><br><span class="line">    <span class="built_in">this</span>.color = color;</span><br><span class="line">    <span class="built_in">this</span>.size = size;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">photo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;拍照&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">playGame</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;打游戏&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> xiaomi = <span class="keyword">new</span> SmartPhone(<span class="string">&quot;小米&quot;</span>, <span class="number">799</span>, <span class="string">&quot;黑色&quot;</span>, <span class="string">&quot;4.7inch&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(xiaomi);</span><br><span class="line">xiaomi.call();</span><br><span class="line">xiaomi.photo();</span><br><span class="line">xiaomi.playGame();</span><br></pre></td></tr></table></figure><p>子类可以进行对父类方法的重写</p><p>注：但是不能通过<code>super()</code>调用父类重名方法</p><h5 id="set-和-get"><a href="#set-和-get" class="headerlink" title="set 和 get"></a>set 和 get</h5><p>获取时，触发 get 方法</p><p>修改赋值时，触发 set 方法</p><p>注：set 方法必须有一个参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">price</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;价格属性被读取了&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">111</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> <span class="title">price</span>(<span class="params">newV</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;价格属性被修改了&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> Phone();</span><br><span class="line"><span class="built_in">console</span>.log(s.price); <span class="comment">// 111// 触发 get</span></span><br><span class="line">s.price = <span class="string">&quot;free&quot;</span>; <span class="comment">// 触发 set</span></span><br></pre></td></tr></table></figure><h3 id="2-16-数值扩展"><a href="#2-16-数值扩展" class="headerlink" title="2.16 数值扩展"></a>2.16 数值扩展</h3><h5 id="Number-EPSILON"><a href="#Number-EPSILON" class="headerlink" title="Number.EPSILON"></a>Number.EPSILON</h5><p>Number.EPSILON 是 JavaScript 表示的最小精度 <code>ε</code></p><p>EPSILON 属性的值接近于：2.2204460492503130808472633361816E-16</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>); <span class="comment">// false</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">equal</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Math</span>.abs(a - b) &lt; <span class="built_in">Number</span>.EPSILON) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(equal(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><h5 id="二进制和八进制"><a href="#二进制和八进制" class="headerlink" title="二进制和八进制"></a>二进制和八进制</h5><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀 0b 和 0o 表示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0o777</span>; <span class="comment">// 八进制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="number">100</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">0xff</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><h5 id="Number-isFinite"><a href="#Number-isFinite" class="headerlink" title="Number.isFinite()"></a>Number.isFinite()</h5><p>用来检查一个数值是否为有限的，返回 boolean</p><h5 id="Number-isNaN"><a href="#Number-isNaN" class="headerlink" title="Number.isNaN()"></a>Number.isNaN()</h5><p>用来检查一个值是否为 NaN，返回 boolean</p><h5 id="Number-parseInt-amp-Number-parseFloat"><a href="#Number-parseInt-amp-Number-parseFloat" class="headerlink" title="Number.parseInt() &amp; Number.parseFloat()"></a>Number.parseInt() &amp; Number.parseFloat()</h5><p>移植到了 Number 对象下，使用不变，（截取整数，截取浮点数）</p><h5 id="Number-isInteger"><a href="#Number-isInteger" class="headerlink" title="Number.isInteger()"></a>Number.isInteger()</h5><p>用来判断一个数值是否为整数， 返回 boolean</p><h5 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h5><p>将数字的小数部分抹掉</p><h5 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h5><p>判断一个数是 正数(1) 负数(-1) 还是 0(0) 括号内为相应的返回值</p><h3 id="2-17-对象方法"><a href="#2-17-对象方法" class="headerlink" title="2.17 对象方法"></a>2.17 对象方法</h3><h5 id="Object-is-a-b"><a href="#Object-is-a-b" class="headerlink" title="Object.is(a,b)"></a>Object.is(a,b)</h5><p>判断两个值是否完全相等</p><p>与全等号 <code>===</code> 区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> === <span class="literal">NaN</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="Object-assign-a-b"><a href="#Object-assign-a-b" class="headerlink" title="Object.assign(a,b)"></a>Object.assign(a,b)</h5><p>对象的合并，后面的将前面的覆盖掉</p><p>可以用于更新对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> config1 = &#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">  <span class="attr">prot</span>: <span class="number">3306</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">pass</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">  <span class="attr">test</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> config2 = &#123;</span><br><span class="line">  <span class="attr">host</span>: <span class="string">&quot;http://www.baidu.com&quot;</span>,</span><br><span class="line">  <span class="attr">prot</span>: <span class="number">33060</span>,</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">  <span class="attr">pass</span>: <span class="string">&quot;020316&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(config1, config2));</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">host: &quot;http://www.baidu.com&quot;</span></span><br><span class="line"><span class="comment">    name: &quot;AgoniLay&quot;</span></span><br><span class="line"><span class="comment">    pass: &quot;020316&quot;</span></span><br><span class="line"><span class="comment">    prot: 33060</span></span><br><span class="line"><span class="comment">    test: &quot;test&quot;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="Object-setPrototypeof-amp-Object-getPrototypeof"><a href="#Object-setPrototypeof-amp-Object-getPrototypeof" class="headerlink" title="Object.setPrototypeof &amp; Object.getPrototypeof"></a>Object.setPrototypeof &amp; Object.getPrototypeof</h5><p>设置原型对象，一般不使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.assign(config1, config2));</span><br><span class="line"><span class="comment">// Object.setPrototypeof  Object.getPrototypeof</span></span><br><span class="line"><span class="keyword">const</span> school = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> cities = &#123;</span><br><span class="line">  <span class="attr">xiaoqu</span>: [<span class="string">&quot;北京&quot;</span>, <span class="string">&quot;上海&quot;</span>, <span class="string">&quot;深圳&quot;</span>],</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(school, cities);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getPrototypeOf(school));</span><br><span class="line"><span class="built_in">console</span>.log(school);</span><br></pre></td></tr></table></figure><h3 id="2-18-模块化"><a href="#2-18-模块化" class="headerlink" title="2.18 模块化"></a>2.18 模块化</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>模块化是指将一个大的程序文件，拆分成许多小的文件，然后将小文件组合起来。</p><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>防止命名冲突</li><li>代码复用</li><li>高维护性</li></ul><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><p>模块功能主要由两个命令构成：export 和 import</p><ul><li>export 命令用于规定模块的对外接口</li><li>import 命令用于输入其他模块提供的功能</li></ul><h4 id="模块化规范"><a href="#模块化规范" class="headerlink" title="模块化规范"></a>模块化规范</h4><h5 id="浏览器端"><a href="#浏览器端" class="headerlink" title="浏览器端"></a>浏览器端</h5><ol><li>AMD：Request.js (<a href="http://www.requirejs.cn/">http://www.requirejs.cn/</a>)</li><li>CMD：Sea.js (<a href="https://seajs.github.io/seajs/docs/">https://seajs.github.io/seajs/docs/</a>)</li></ol><h5 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h5><ul><li>CommonJS：NodeJS<ol><li>模块分为 单文件模块 与 包</li><li>模块成员导出：module.exports 和 exports</li><li>模块成员导入：require(‘模块标识符’)</li></ol></li></ul><h3 id="2-19-大一统的模块化规范-ES6-模块化"><a href="#2-19-大一统的模块化规范-ES6-模块化" class="headerlink" title="2.19 大一统的模块化规范 - ES6 模块化"></a>2.19 大一统的模块化规范 - ES6 模块化</h3><p>是 浏览器端 与 服务器端 通用的模块化开发规范</p><ul><li>每一个 js 文件都是一个独立的模块</li><li>导入模块成员使用 import 关键字</li><li>暴露模块成员使用 export 关键字</li></ul><h4 id="Node-js-中-babel-体验-ES6-模块化"><a href="#Node-js-中-babel-体验-ES6-模块化" class="headerlink" title="Node.js 中 babel 体验 ES6 模块化"></a>Node.js 中 babel 体验 ES6 模块化</h4><h5 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h5><ol><li><p>安装工具</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/node</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save @babel/polyfill</span><br></pre></td></tr></table></figure></li><li><p>根目录下新建 babel.config.js 文件 写入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">targets</span>: &#123;</span><br><span class="line">        <span class="attr">edge</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">        <span class="attr">firefox</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">        <span class="attr">chrome</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">        <span class="attr">safari</span>: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure></li><li><p>执行代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npx babel-node index.js</span><br></pre></td></tr></table></figure></li></ol><h4 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h4><h5 id="默认导出-与-默认导入"><a href="#默认导出-与-默认导入" class="headerlink" title="默认导出 与 默认导入"></a>默认导出 与 默认导入</h5><ul><li>默认导出：<code>export default 默认导出的成员</code></li><li>默认导入：<code>import 接收名称 from &#39;模块标识符/路径&#39;</code></li></ul><p>注意点：</p><ol><li>在每个模块中，只允许使用唯一的一次 export default，否则会报错</li><li>在模块中如果没有默认导出，那么将会 是一个空对象 <code>&#123;&#125;</code></li></ol><h5 id="按需导出-与-按需导入"><a href="#按需导出-与-按需导入" class="headerlink" title="按需导出 与 按需导入"></a>按需导出 与 按需导入</h5><ul><li>按需导出：<code>export let s1 = 10</code></li><li>按需导入：<code>import &#123; s1 &#125; from &#39;模块标识符/路径&#39;</code></li></ul><p>注意点：</p><ol><li>在一个模块中，可以使用多次按需导出</li></ol><h5 id="直接导入并执行模块代码"><a href="#直接导入并执行模块代码" class="headerlink" title="直接导入并执行模块代码"></a>直接导入并执行模块代码</h5><p><code>import &#39;模块标识符/路径&#39;</code></p><p>直接执行代码，没有导出。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> ES6 </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript笔记(四)</title>
      <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/"/>
      <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/</url>
      
        <content type="html"><![CDATA[<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><p>Browser Object Model</p><p>定义了浏览器的接口</p><p>BOM 对象：Window，History，Navigator，Screen，Location</p><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="滚动条滚动距离"><a href="#滚动条滚动距离" class="headerlink" title="滚动条滚动距离"></a>滚动条滚动距离</h4><h5 id="pageXOffset-pageYOffset"><a href="#pageXOffset-pageYOffset" class="headerlink" title="pageXOffset / pageYOffset"></a>pageXOffset / pageYOffset</h5><p>求滚动条滚动距离，返回 number 类型的数值，单位是像素</p><ul><li>pageXOffset –&gt; 横向</li><li>pageYOffset –&gt; 纵向</li></ul><p>兼容性：IE9 以下不兼容</p><ul><li>document.body/documentElement.scorllLeft –&gt; 求横向滚动条滚动距离</li><li>document.body/documentElement.scorllTop –&gt; 纵向</li></ul><p>有兼容性混乱，不同浏览器可用的方法不同，但只会有一种方法有值，另一个值为 0，处理兼容性的话让这两种值相加即可。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.body.scrollLeft + <span class="built_in">document</span>.documentElement.scrollLeft;</span><br><span class="line"><span class="built_in">document</span>.body.scrollTop + <span class="built_in">document</span>.documentElement.scrollTop;</span><br></pre></td></tr></table></figure><h4 id="查看视口的尺寸"><a href="#查看视口的尺寸" class="headerlink" title="查看视口的尺寸"></a>查看视口的尺寸</h4><h5 id="innerWidth-innerHeight"><a href="#innerWidth-innerHeight" class="headerlink" title="innerWidth / innerHeight"></a>innerWidth / innerHeight</h5><p>获取试图窗口的尺寸</p><p>兼容性：IE9 以下不兼容</p><p>浏览器标准模式下使用：</p><ul><li><p>document.documentElement.clientWidth</p></li><li><p>document.documentElement.clientHeight</p></li></ul><p>怪异模式下使用：</p><ul><li>document.body.clientWidth</li><li>document.body.clientHeight</li></ul><h4 id="查看元素几何尺寸"><a href="#查看元素几何尺寸" class="headerlink" title="查看元素几何尺寸"></a>查看元素几何尺寸</h4><p>获得关于这个元素的 尺寸、位置 信息</p><h5 id="getBoundingClientRect"><a href="#getBoundingClientRect" class="headerlink" title="getBoundingClientRect();"></a>getBoundingClientRect();</h5><ol><li>兼容性很好</li><li>所有元素节点都有此方法</li><li>left 和 top 表示该元素左上角的 X 和 Y 坐标，right 和 bottom 表示该元素右下角的 X 和 Y 坐标</li><li>返回的结果并不是实时的</li><li>width 和 height 老版本 IE 不兼容</li><li>使用并不多</li></ol><img src="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E5%9B%9B/1627039991064.png" class><h5 id="offsetWidth-offsetHeight"><a href="#offsetWidth-offsetHeight" class="headerlink" title="offsetWidth / offsetHeight"></a>offsetWidth / offsetHeight</h5><p>查看元素的尺寸（视觉尺寸：包含 padding, border）</p><h5 id="offsetLeft-offsetTop"><a href="#offsetLeft-offsetTop" class="headerlink" title="offsetLeft / offsetTop"></a>offsetLeft / offsetTop</h5><p>查看元素的位置（距离他有定位的父级的距离）</p><h5 id="offsetParent"><a href="#offsetParent" class="headerlink" title="offsetParent"></a>offsetParent</h5><p>返回最近的有定位的父级，若没有，则返回 body</p><h4 id="让滚动条滚动"><a href="#让滚动条滚动" class="headerlink" title="让滚动条滚动"></a>让滚动条滚动</h4><h5 id="scroll-scrollTo-scrollBy"><a href="#scroll-scrollTo-scrollBy" class="headerlink" title="scroll(),scrollTo() / scrollBy()"></a>scroll(),scrollTo() / scrollBy()</h5><p><code>scroll(x, y)</code> &amp; <code>scrollTo(x, y)</code> 没有任何区别：使滚动条滚到指定位置</p><p><code>scrollBy(x, y)</code> 累加滚动距离，有正负，多次调用多次执行</p><h4 id="浏览器编译模式"><a href="#浏览器编译模式" class="headerlink" title="浏览器编译模式"></a>浏览器编译模式</h4><h5 id="标准模式"><a href="#标准模式" class="headerlink" title="标准模式"></a>标准模式</h5><p>html 页面顶部添加下面一行开启</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br></pre></td></tr></table></figure><h5 id="怪异模式"><a href="#怪异模式" class="headerlink" title="怪异模式"></a>怪异模式</h5><p>兼容之前的几个版本，向后兼容</p><h5 id="判断方式"><a href="#判断方式" class="headerlink" title="判断方式"></a>判断方式</h5><p><code>document.compatMode</code> 属性，返回值：</p><ul><li><code>CSS1Compat</code> ：标准模式</li><li><code>BackCompat</code> ：怪异模式</li></ul><h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><h4 id="绑定事件方法"><a href="#绑定事件方法" class="headerlink" title="绑定事件方法"></a>绑定事件方法</h4><ol><li><p><code>ele.onxxx = function (event) &#123;&#125;</code></p><ul><li>兼容性很好，但同一个事件上只能绑定一个处理函数</li><li>基本等同于写在 HTML 行间</li></ul></li><li><p>行间写，不需要写 function</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onclick</span>=<span class="string">&quot;console.log(&#x27;a&#x27;);&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>obj.addEventListener(type, fn, false);</code></p><ul><li>(事件类型, 事件处理函数, false)</li><li>IE9 以下不兼容</li><li>可以为一个事件绑定多个处理程序</li><li>绑定事件时，若在循环中，注意闭包问题</li><li>false：冒泡模型；true：捕获模型</li></ul></li><li><p><code>obj.attachEvent(onxxx, fn);</code></p><ul><li>IE 独有</li></ul></li></ol><p>事件对象，在函数的括号中写入 e 或者 event，记载了事件发生时的一些列数据和信息</p><h4 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h4><ul><li><p>前三种方法进行事件绑定后 this 指向的是绑定的元素本身</p></li><li><p>attachEvent 绑定事件后，this 指向的是 window</p><p>解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementByTagName(<span class="string">&#x27;div&#x27;</span>)[<span class="number">0</span>];</span><br><span class="line">div.attachEvent(<span class="string">&#x27;onclick&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    handle.call(div);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 事件处理程序</span></span><br><span class="line">    <span class="built_in">this</span>. ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="兼容性解决"><a href="#兼容性解决" class="headerlink" title="兼容性解决"></a>兼容性解决</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addEvent</span>(<span class="params">elem, type, handle</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (elem.addEventListener) &#123;</span><br><span class="line">    elem.addEventListener(type, handle, <span class="literal">false</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (elem.attachEvent) &#123;</span><br><span class="line">    elem.attachEvent(<span class="string">&quot;on&quot;</span> + type, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      handle.call(elem);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    elem[<span class="string">&quot;on&quot;</span> + type] = handle;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解除事件处理程序"><a href="#解除事件处理程序" class="headerlink" title="解除事件处理程序"></a>解除事件处理程序</h4><ul><li><code>ele.onclick = null;</code></li><li><code>ele.removeListener(type, fn, false);</code></li><li><code>ele.detachEvent(&#39;on&#39; + type, fn)</code><ul><li>如果绑定的函数是匿名函数，则无法解除</li></ul></li></ul><h4 id="事件处理模型"><a href="#事件处理模型" class="headerlink" title="事件处理模型"></a>事件处理模型</h4><h5 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a>事件冒泡</h5><p>结构上（非视觉上）嵌套关系的元素，会存在事件冒泡的功能，即同一事件，自子元素冒泡向父元素。（自底向上）</p><h5 id="事件捕获"><a href="#事件捕获" class="headerlink" title="事件捕获"></a>事件捕获</h5><p>结构上（非视觉上）嵌套关系的元素，会存在事件捕获的功能，即同一事件，自父元素捕获至子元素。（自顶向下）</p><ul><li>将 addEventListener() 内第三个参数 false 改为 true，即成了捕获模型</li><li>IE 没有捕获事件</li></ul><p>顺序：</p><ul><li>先捕获，后冒泡</li><li>事件执行看绑定顺序</li></ul><p>focus, blur, change, submit, reset, select 等事件不冒泡</p><h6 id="特殊："><a href="#特殊：" class="headerlink" title="特殊："></a>特殊：</h6><p>setCapture()：只能在 ie 中使用，给元素使用</p><p>使用后，该元素会捕获页面上发生的所有时间</p><p>releaseCapture()：取消上述捕获</p><h5 id="取消冒泡"><a href="#取消冒泡" class="headerlink" title="取消冒泡"></a>取消冒泡</h5><ul><li><code>e.stopPropagation();</code> W3C 标准 –&gt; 但不支持 IE9 以下版本</li><li><code>e.cancelBubble = true;</code> IE 使用</li></ul><h6 id="兼容性处理解决"><a href="#兼容性处理解决" class="headerlink" title="兼容性处理解决"></a>兼容性处理解决</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">stopBubble</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.stopPropagation) &#123;</span><br><span class="line">    event.stopPropagation();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.cancelBubble = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><p>默认事件 – 表单提交，a 标签跳转，右键菜单等。</p><ul><li>a 标签跳转</li><li>右键菜单事件 <code>oncontextmenu</code></li></ul><p>阻止方法：</p><ol><li><code>return false;</code> –&gt; 兼容性特别好，以对象属性的方式注册的事件才生效（onxxx）</li><li><code>e.preventDefault();</code> –&gt; W3C 标准</li><li><code>e.returnValue = false;</code> –&gt; IE 使用</li></ol><h6 id="兼容性处理解决-1"><a href="#兼容性处理解决-1" class="headerlink" title="兼容性处理解决"></a>兼容性处理解决</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cancelHandler</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (event.preventDefault) &#123;</span><br><span class="line">    event.preventDefault();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    event.returnValue = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h4><h5 id="兼容"><a href="#兼容" class="headerlink" title="兼容"></a>兼容</h5><p><code>var event = event || window.event</code></p><h5 id="事件源对象"><a href="#事件源对象" class="headerlink" title="事件源对象"></a>事件源对象</h5><ul><li><code>event.target</code> –&gt; 火狐</li><li><code>event.srcElement</code> –&gt; IE</li></ul><p>以上两个 chorme 都有</p><h6 id="兼容-1"><a href="#兼容-1" class="headerlink" title="兼容"></a>兼容</h6><p><code>var target = event.target || event.srcElement</code></p><h4 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>4<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>5<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> ul = <span class="built_in">document</span>.getElementsBytagName(<span class="string">&quot;ul&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">  ul.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> target = event.target || event.srcElement;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(target.innerText);</span></span><br><span class="line"><span class="javascript">  &#125;;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li>效率高：不需要循环所有的元素一个个绑定</li><li>可扩展：当有新的子元素时不需要重新绑定事件</li></ol><h4 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h4><h5 id="鼠标事件"><a href="#鼠标事件" class="headerlink" title="鼠标事件"></a>鼠标事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">click</td><td align="center">鼠标点击</td><td align="center">mousedown + mouseup</td></tr><tr><td align="center">mousedown</td><td align="center">鼠标点下</td><td align="center"></td></tr><tr><td align="center">mousemove</td><td align="center">鼠标移动</td><td align="center"></td></tr><tr><td align="center">mouseup</td><td align="center">鼠标抬起</td><td align="center"></td></tr><tr><td align="center">contextmenu</td><td align="center">右键菜单事件</td><td align="center">仅用于取消右键菜单</td></tr><tr><td align="center">mouseover</td><td align="center">鼠标进入</td><td align="center"></td></tr><tr><td align="center">mouseout</td><td align="center">鼠标离开</td><td align="center"></td></tr><tr><td align="center">mouseenter</td><td align="center">鼠标进入</td><td align="center">HTML5 新规范，同 mouseover</td></tr><tr><td align="center">mouseleave</td><td align="center">鼠标离开</td><td align="center">HTML5 新规范，同 mouseout</td></tr></tbody></table><h6 id="区分鼠标左右键"><a href="#区分鼠标左右键" class="headerlink" title="区分鼠标左右键"></a>区分鼠标左右键</h6><p><code>event.button</code> 属性</p><ul><li>0：左键</li><li>1：点击滚轮</li><li>2：右键</li></ul><p>仅在 mousedown 和 mouseup 事件上可用，click 事件不可用</p><h6 id="区分拖拽和点击"><a href="#区分拖拽和点击" class="headerlink" title="区分拖拽和点击"></a>区分拖拽和点击</h6><p>长时间按是长按，短时间按才触发 click 事件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> firstTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> lastTime = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">var</span> key = <span class="literal">false</span>;</span><br><span class="line"><span class="built_in">document</span>.onmousedown = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  firstTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.onmouseup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  lastTime = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime();</span><br><span class="line">  <span class="keyword">if</span> (lastTime - firstTime &lt; <span class="number">300</span>) &#123;</span><br><span class="line">    key = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (key) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;click&quot;</span>);</span><br><span class="line">    key = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="移动端事件"><a href="#移动端事件" class="headerlink" title="移动端事件"></a>移动端事件</h6><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">touchstart</td><td align="center">触摸开始</td></tr><tr><td align="center">touchmove</td><td align="center">触摸移动</td></tr><tr><td align="center">touchend</td><td align="center">触摸结束</td></tr></tbody></table><h5 id="键盘事件"><a href="#键盘事件" class="headerlink" title="键盘事件"></a>键盘事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">keydown</td><td align="center">按键按下</td></tr><tr><td align="center">keypress</td><td align="center">按键按下</td></tr><tr><td align="center">keyup</td><td align="center">按键抬起</td></tr></tbody></table><h6 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h6><p>keydown &gt; keypress &gt; keyup</p><h6 id="keydown-amp-keypress"><a href="#keydown-amp-keypress" class="headerlink" title="keydown &amp; keypress"></a>keydown &amp; keypress</h6><ul><li>keydown：能够监测到所有按键，除 Fn 辅助键外<ul><li>大小写没有区别</li><li>没有 <code>e.charCode</code> 属性</li></ul></li><li>keypress：只能检测到 ASCII 表 中有的值（字符类按键）<ul><li>可以区分大小写</li></ul></li></ul><h6 id="转换字符方法"><a href="#转换字符方法" class="headerlink" title="转换字符方法"></a>转换字符方法</h6><p><code>String.fromCahrCode(e.charCode)</code></p><h5 id="文本操作事件"><a href="#文本操作事件" class="headerlink" title="文本操作事件"></a>文本操作事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">input</td><td align="center">只要文本框值发生改变触发</td></tr><tr><td align="center">change</td><td align="center">获取焦点和失去焦点的值发生改变触发</td></tr><tr><td align="center">focus</td><td align="center">获取焦点</td></tr><tr><td align="center">blur</td><td align="center">失去焦点</td></tr></tbody></table><h5 id="其他事件"><a href="#其他事件" class="headerlink" title="其他事件"></a>其他事件</h5><table><thead><tr><th align="center">事件名</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">scroll</td><td align="center">页面发生滚动</td></tr><tr><td align="center">load</td><td align="center">页面所有加载项均完成后触发</td></tr></tbody></table><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> div = <span class="built_in">document</span>.getElementByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span></span><br><span class="line"><span class="javascript">  &#125;; <span class="comment">// 绑定 onload 后会等页面渲染、下载完后才会执行，就可以获取到之后的元素</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 正常上方 js 无法获取到这个div --&gt;</span></span><br></pre></td></tr></table></figure><p>缺点：</p><ol><li>效率低</li><li>没必要</li></ol><h2 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h2><p>前后端之间联系一种数据纽带，通常叫做接口，一种就是叫做 json 类型的数据</p><h4 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;deng&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换方法"><a href="#类型转换方法" class="headerlink" title="类型转换方法 *"></a>类型转换方法 *</h4><p><code>JSON.stringify(obj)</code> –&gt; 将对象类型转换为 json 格式的字符串</p><p><code>JSON.parse(obj)</code> –&gt; 将字符串转换为对象类型</p><p>博客笔记地址（四）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077901">https://blog.csdn.net/qq_58163927/article/details/119077901</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> BOM </tag>
            
            <tag> JSON </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript笔记(三)</title>
      <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%89/"/>
      <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%89/</url>
      
        <content type="html"><![CDATA[<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>Document Object Model</p><p>用来操作 html 和 xml 功能的一类对象的集合</p><p>document 代表整个文档</p><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><h5 id="getElementById"><a href="#getElementById" class="headerlink" title="getElementById()"></a>getElementById()</h5><p>通过元素的 id 属性值选择</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementById(<span class="string">&quot;only&quot;</span>);</span><br></pre></td></tr></table></figure><p>定义在了 Document.prototype 上</p><p>ie8 以下的浏览器，不区分 id 大小写，而且 name 和 id 一样的元素，也可以选出来</p><h5 id="getElementsByTagName"><a href="#getElementsByTagName" class="headerlink" title="getElementsByTagName() *"></a>getElementsByTagName() *</h5><p>通过标签名的方式选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;current&quot;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>定义在了 Document.prototype 和 Element.prototype 上</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> span = div.document.getElementsByTagName(<span class="string">&quot;span&quot;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>还可以使用 通配符 <code>*</code> 选择全部选择器；</p><p>无任何兼容性问题，较为常用</p><h5 id="getElementsByName"><a href="#getElementsByName" class="headerlink" title="getElementsByName()"></a>getElementsByName()</h5><p>t 通过 name 属性值选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByName(<span class="string">&quot;current&quot;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>定义在了 HTMLDocument.prototype 上，即 XML 不能可用</p><p>name 并不是在所有标签内都好使</p><h5 id="getElementsByClassName"><a href="#getElementsByClassName" class="headerlink" title="getElementsByClassName()"></a>getElementsByClassName()</h5><p>通过类名 class 选择所有，放到一个类数组中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByClassName(<span class="string">&quot;current&quot;</span>)[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>ie8 和 ie8 以下的 ie 版本中没有</p><h5 id="querySelector"><a href="#querySelector" class="headerlink" title="querySelector()"></a>querySelector()</h5><p>选一个</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelector(<span class="string">&quot;div &gt; span strong.demo&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="querySelectorAll"><a href="#querySelectorAll" class="headerlink" title="querySelectorAll()"></a>querySelectorAll()</h5><p>选一组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> strong = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div &gt; span strong.demo&quot;</span>);</span><br></pre></td></tr></table></figure><p>以上两个 query 的选择器的缺点：</p><ol><li>在 ie7 和 ie7 以下版本中没有</li><li>不是实时的，选出来的是静态的，相当于选出来的就是个副本，元素发生改变不会发生改变</li></ol><h3 id="遍历节点树"><a href="#遍历节点树" class="headerlink" title="遍历节点树"></a>遍历节点树</h3><h4 id="获取节点"><a href="#获取节点" class="headerlink" title="获取节点"></a>获取节点</h4><p>均无兼容性问题</p><h5 id="parentNode"><a href="#parentNode" class="headerlink" title="parentNode"></a>parentNode</h5><p>一个元素只有一个父节点，document 就是最高的</p><p>null &gt; document &gt; html &gt; body &gt; …</p><h5 id="childNodes"><a href="#childNodes" class="headerlink" title="childNodes *"></a>childNodes *</h5><p>获取一个元素所有的<strong>子节点</strong>，包括 文本、注释、属性、元素等</p><h5 id="firstChild"><a href="#firstChild" class="headerlink" title="firstChild"></a>firstChild</h5><p>获取元素的第一个子节点</p><h5 id="lastChild"><a href="#lastChild" class="headerlink" title="lastChild"></a>lastChild</h5><p>获取元素的最后一个子节点</p><h5 id="nextSibling"><a href="#nextSibling" class="headerlink" title="nextSibling"></a>nextSibling</h5><p>获取元素的后一个兄弟节点</p><h5 id="previousSibling"><a href="#previousSibling" class="headerlink" title="previousSibling"></a>previousSibling</h5><p>获取元素的前一个兄弟节点</p><h4 id="获取元素节点"><a href="#获取元素节点" class="headerlink" title="获取元素节点"></a>获取元素节点</h4><p>除 children 无兼容性问题外，其他的均是 ie9 及 ie9 以下不兼容</p><h5 id="parentElement"><a href="#parentElement" class="headerlink" title="parentElement"></a>parentElement</h5><p>父元素节点，没有到 document</p><p>null &gt; html &gt; body &gt; …</p><h5 id="children"><a href="#children" class="headerlink" title="children *"></a>children *</h5><p>获取元素的所有<strong>元素子节点</strong></p><h5 id="childElementCount"><a href="#childElementCount" class="headerlink" title="childElementCount"></a>childElementCount</h5><p>元素的元素字节点的个数</p><p><code>node.childElementCount === node.children.length</code></p><h5 id="firstElementChild"><a href="#firstElementChild" class="headerlink" title="firstElementChild"></a>firstElementChild</h5><p>第一个元素子节点</p><h5 id="lastElementChild"><a href="#lastElementChild" class="headerlink" title="lastElementChild"></a>lastElementChild</h5><p>最后一个元素子节点</p><h5 id="nextElementSibling"><a href="#nextElementSibling" class="headerlink" title="nextElementSibling"></a>nextElementSibling</h5><p>上一个兄弟元素节点</p><h5 id="previousElementSibling"><a href="#previousElementSibling" class="headerlink" title="previousElementSibling"></a>previousElementSibling</h5><p>后一个兄弟元素节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定兄弟节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retSibling</span>(<span class="params">e, n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (e &amp;&amp; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.nextElementSibling) &#123;</span><br><span class="line">                e = e.nextElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.nextSibling; e &amp;&amp; e.nodeType != <span class="number">1</span>; e = e.nextSibling);</span><br><span class="line">            &#125;</span><br><span class="line">            n--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (e.previousElementSibling;) &#123;</span><br><span class="line">            e = e.previousElementSibling;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (e = e.previousElementSibling; e &amp;&amp; e.nodeType != <span class="number">1</span>; e = e.previousSibling);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h3><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><p>节点的四个属性：</p><h5 id="nodeName"><a href="#nodeName" class="headerlink" title="nodeName"></a>nodeName</h5><ul><li>元素的标签名，以大写形式表示，只读</li></ul><h5 id="nodeValue"><a href="#nodeValue" class="headerlink" title="nodeValue"></a>nodeValue</h5><ul><li>文本节点 和 注释节点的文本内容，可读写</li><li>只有 Text 节点 和 Comment 节点</li></ul><h5 id="nodeType"><a href="#nodeType" class="headerlink" title="nodeType *"></a>nodeType *</h5><ul><li>该节点的类型，只读</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义 获取所有元素子节点</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retElementChild</span>(<span class="params">node</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// no children</span></span><br><span class="line">  <span class="keyword">var</span> temp = &#123;</span><br><span class="line">      <span class="attr">length</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="attr">push</span>: <span class="built_in">Array</span>.prototype.push,</span><br><span class="line">      <span class="attr">splice</span>: <span class="built_in">Array</span>.prototype.splice,</span><br><span class="line">    &#125;,</span><br><span class="line">    child = node.childNodes,</span><br><span class="line">    len = child.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (child[i].nodeType === <span class="number">1</span>) &#123;</span><br><span class="line">      temp.push(child[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="attributes"><a href="#attributes" class="headerlink" title="attributes"></a>attributes</h5><ul><li>Element 节点的属性集合</li></ul><h4 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h4><h5 id="hasChildNodes"><a href="#hasChildNodes" class="headerlink" title="hasChildNodes()"></a>hasChildNodes()</h5><p>判断元素是否具有子节点，返回 boolean 值</p><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><p>后面的数字是 nodeType 属性返回的值</p><p>元素节点 – 1</p><p>属性节点 – 2</p><p>文本节点 – 3</p><p>注释节点 – 8</p><p>document – 9</p><h3 id="DOM-结构树"><a href="#DOM-结构树" class="headerlink" title="DOM 结构树"></a>DOM 结构树</h3><p>document –&gt; HTMLDocument –&gt; Document –&gt; Node –&gt; EventTarget –&gt; Object</p><ul><li>document.documentElement 指代的是 html</li><li>HTMLDocumnet.head 指代的是 head</li><li>HTMLDocumnet.body 指代的是 body</li></ul><p>domTree + cssTree = rangerTree</p><p>重排（reflow）：整个界面进行重构，效率很低，要尽量避免</p><ol><li>dom 节点的删除，添加</li><li>dom 节点的宽高变化，位置变化，display none –&gt; block</li><li>offsetWidth offsetLeft –&gt; 获取实时数据，也会触发重排</li></ol><p>重绘（repaint）：效率相对消耗比较少，对应位置改变</p><h3 id="DOM-基本操作"><a href="#DOM-基本操作" class="headerlink" title="DOM 基本操作"></a>DOM 基本操作</h3><h4 id="增"><a href="#增" class="headerlink" title="增"></a>增</h4><h5 id="createElement"><a href="#createElement" class="headerlink" title="createElement() *"></a>createElement() *</h5><p>创建元素节点，括号内写标签名</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.createElment(<span class="string">&quot;div&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="createTextNode"><a href="#createTextNode" class="headerlink" title="createTextNode()"></a>createTextNode()</h5><p>创建文本节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;AgoniLay&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="createComment"><a href="#createComment" class="headerlink" title="createComment()"></a>createComment()</h5><p>创建注释节点</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> comment = <span class="built_in">document</span>.createComment(<span class="string">&quot;This is AgoniLay！&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="插"><a href="#插" class="headerlink" title="插"></a>插</h4><h5 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild() *"></a>appendChild() *</h5><p>将节点添加到调用者中，类似于 push</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementsByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">var</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;AgoniLay&quot;</span>);</span><br><span class="line">div.appendChild(text);</span><br></pre></td></tr></table></figure><p>将已在界面内的节点添加到别的中去</p><p>是剪切效果，原先的会被剪切到要添加的地方</p><h5 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore() *"></a>insertBefore() *</h5><p>将要插入的 插入到元素中去，并且插入到 第二个参数所代表元素 之前</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.insertBefore(strong, span);</span><br></pre></td></tr></table></figure><h5 id="insertAfter-自定义"><a href="#insertAfter-自定义" class="headerlink" title="insertAfter() 自定义"></a>insertAfter() 自定义</h5><p>自己封装 insertAfter() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Element.prototype.insertAfter = funtion (targetNode, afterNode) &#123;</span><br><span class="line">    <span class="keyword">var</span> beforeNode = afterNode.nextElementSibling;</span><br><span class="line">    <span class="keyword">if</span> (beforeNode == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="built_in">this</span>.appendChild(targetNode);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.insertBefore(targetNode, beforeNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="删"><a href="#删" class="headerlink" title="删"></a>删</h4><h5 id="removeChild"><a href="#removeChild" class="headerlink" title="removeChild() *"></a>removeChild() *</h5><p>父节点剪切出自己的子节点，作为返回值返回出来</p><h5 id="remove"><a href="#remove" class="headerlink" title="remove() *"></a>remove() *</h5><p>自己将自己本身销毁，无返回值</p><h4 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h4><h5 id="replaceChild"><a href="#replaceChild" class="headerlink" title="replaceChild()"></a>replaceChild()</h5><p>由父节点调用，用新的 替换 旧的，并将旧的返回出来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parentNode.replaceChild(<span class="keyword">new</span>, origin)</span><br></pre></td></tr></table></figure><h4 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h4><h5 id="innerHTML"><a href="#innerHTML" class="headerlink" title="innerHTML() *"></a>innerHTML() *</h5><p>改变一个元素中的 <strong>html</strong> 内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.innerHTML = <span class="string">&quot;123&quot;</span>; <span class="comment">// 会将原来里面的所有值覆盖</span></span><br><span class="line">div.innerHTML += <span class="string">&quot;456&quot;</span>; <span class="comment">// 先取值，在追加 --&gt; 可读可写</span></span><br></pre></td></tr></table></figure><p>会识别括号内的一系列 html 文本</p><h5 id="innerText"><a href="#innerText" class="headerlink" title="innerText()"></a>innerText()</h5><p>读写标签内的文本，但是会覆盖</p><p>innerText() 方法 老版本火狐不兼容，火狐中有 textContent() 方法，但此方法 老版本 ie 不好使</p><h4 id="节点方法"><a href="#节点方法" class="headerlink" title="节点方法"></a>节点方法</h4><h5 id="setAttribute"><a href="#setAttribute" class="headerlink" title="setAttribute()"></a>setAttribute()</h5><p>设置行间属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.setAttribute(<span class="string">&quot;class&quot;</span>, <span class="string">&quot;demo&quot;</span>);</span><br><span class="line"><span class="comment">// div --&gt; &lt;div class=&quot;demo&quot;&gt;&lt;/div&gt;</span></span><br><span class="line">div.setAttribute(<span class="string">&quot;id&quot;</span>, <span class="string">&quot;only&quot;</span>);</span><br><span class="line"><span class="comment">// div --&gt; &lt;div class=&quot;demo&quot; id=&quot;only&quot;&gt;&lt;/div&gt;</span></span><br></pre></td></tr></table></figure><h5 id="getAttribute"><a href="#getAttribute" class="headerlink" title="getAttribute()"></a>getAttribute()</h5><p>取到行内属性</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">div.getAttribute(<span class="string">&quot;id&quot;</span>); <span class="comment">// --&gt; only</span></span><br></pre></td></tr></table></figure><h5 id="className"><a href="#className" class="headerlink" title="className()"></a>className()</h5><p>可以读写元素节点的 class 属性</p><h3 id="脚本化-CSS"><a href="#脚本化-CSS" class="headerlink" title="脚本化 CSS"></a>脚本化 CSS</h3><h4 id="读写-css-属性"><a href="#读写-css-属性" class="headerlink" title="读写 css 属性"></a>读写 css 属性</h4><h5 id="dom-style"><a href="#dom-style" class="headerlink" title="dom.style *"></a>dom.style *</h5><ul><li>如果属性名中带有 <code>-</code> ，则换成小驼峰式：<code>background-color</code> –&gt; <code>backgroundColor</code></li><li>碰到 float 这样的保留字属性，尽量前面加 css：<code>float</code> –&gt; <code>cssFloat</code></li><li>复合属性建议拆解：<code>border: 1px soild red;</code> –&gt; <code>borderWidth=&quot;1px&quot;; borderStyle=&quot;soild&quot;; borderColor=&quot;red&quot;</code></li><li>可读可写，但只能读取到行间样式，写也是添加到行间，无兼容性问题</li><li>只有这一种方法可以写入 css 值</li></ul><h5 id="getComputedStyle"><a href="#getComputedStyle" class="headerlink" title="getComputedStyle() *"></a>getComputedStyle() *</h5><p>获取当前元素所展示出的一切 css 属性的显式值（最终显示出来的，包括默认值）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.getComputedStyle(ele, <span class="literal">null</span>)[prop];</span><br></pre></td></tr></table></figure><ul><li><p>只读</p></li><li><p>返回的样式都是绝对值</p><ul><li>颜色：rgb 形式</li><li>尺寸：px 单位</li></ul></li><li><p>第二个参数 null 的作用：获取伪元素的属性表</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = <span class="built_in">document</span>.getElementByTagName(<span class="string">&quot;div&quot;</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="built_in">window</span>.getComputedStyle(div, <span class="string">&quot;after&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>IE8 及 IE8 以下不兼容</p><ul><li><code>div.currentStyle</code> –&gt; <code>CSSStyleDeclaration</code></li></ul></li></ul><p>兼容性问题解决：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getStyle</span>(<span class="params">elem, prop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">window</span>.getComputedStyle) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">window</span>.getComputedStyle(elem, <span class="literal">null</span>)[prop];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> elem.currentStyle[prop];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>博客笔记地址（三）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077863">https://blog.csdn.net/qq_58163927/article/details/119077863</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript笔记(二)</title>
      <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/"/>
      <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="ECMAScript"><a href="#ECMAScript" class="headerlink" title="ECMAScript"></a>ECMAScript</h2><p>客户端脚本语言的标准</p><h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><h4 id="与-html-结合方式"><a href="#与-html-结合方式" class="headerlink" title="与 html 结合方式"></a>与 html 结合方式</h4><ol><li><p>内部 JS：</p><ul><li><p>标签体内容就是 js 代码</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">text</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 内容</span></span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>外部 JS：</p><ul><li><p>通过 src 属性引入外部的 js 文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script text=<span class="string">&quot;text/javascript&quot;</span> src=<span class="string">&quot;location&quot;</span>&gt;</span><br><span class="line">  <span class="comment">// 内容</span></span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ol><p>注意：</p><ol><li>可以定义在 html 页面的任何地方。但是定义的位置会影响执行顺序；</li><li>可以定义多个；</li><li>同一个标签不能同时引入外部 同时有内部的，这样的话只有外部的好使。</li></ol><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><ol><li>单行注释：//注释内容</li><li>多行注释：/<em>注释内容</em>/</li></ol><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><h5 id="原始数据类型-基本数据类型"><a href="#原始数据类型-基本数据类型" class="headerlink" title="原始数据类型(基本数据类型)"></a>原始数据类型(基本数据类型)</h5><h6 id="number"><a href="#number" class="headerlink" title="number"></a>number</h6><p>数字类型，整数 / 小数 / NaN(not a number 一个不是数字的数字类型)</p><p><code>toFixed(x)</code> 小数点后保留 x 位小数</p><p>问题 bug：</p><ul><li><p>浮点数精度不准</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.14</span> * <span class="number">100</span>); <span class="comment">// 14.000000000000002</span></span><br></pre></td></tr></table></figure></li><li><p>小数点前 以及 小数点后 位数大于 16 会出现精度问题</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">1000000000000001</span> + <span class="number">1000000000000001</span>); <span class="comment">// 2000000000000002</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">10000000000000001</span> + <span class="number">10000000000000001</span>); <span class="comment">// 20000000000000000</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.000000000000001</span> + <span class="number">1.000000000000001</span>); <span class="comment">// 2.000000000000002</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1.0000000000000001</span> + <span class="number">1.0000000000000001</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></li></ul><img src="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%BA%8C/image-20210714200731388.png" class><h6 id="string"><a href="#string" class="headerlink" title="string"></a>string</h6><p>字符串类型，字符串 “abc” “a” ‘abc’</p><h6 id="boolean"><a href="#boolean" class="headerlink" title="boolean"></a>boolean</h6><p>布尔类型，true 和 false</p><ol><li>null：一个对象为空的占位符</li><li>undefined：未定义。如果一个变量没有给初始化值，则会被默认赋值为 undefined</li></ol><p>存放在 <strong>栈</strong> 里，规则 先进后出</p><h5 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h5><ol><li><p>Array：数组。</p></li><li><p>Object：对象。</p></li><li><p>function：函数。</p><p>…</p></li></ol><p>存放在 <strong>堆</strong> 里，拷贝的是地址</p><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>一小块存储数据的内存空间</p><h5 id="强弱类型"><a href="#强弱类型" class="headerlink" title="强弱类型"></a>强弱类型</h5><p>Java 语言是强类型语言，而 JavaScript 是弱类型语言。</p><ul><li>强类型：在开辟变量存储空间时，定义了空间将来存储的数据的数据类型。只能存储固定类型的数据</li><li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li></ul><h5 id="全局-amp-局部变量"><a href="#全局-amp-局部变量" class="headerlink" title="全局&amp;局部变量"></a>全局&amp;局部变量</h5><p>访问规则</p><ul><li>里面的可以访问到外面的，外面的不能访问里面的</li></ul><h5 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> 变量名 = 初始化值;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义多个遍历并赋值</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>,</span><br><span class="line">  b = <span class="number">20</span>,</span><br><span class="line">  c = <span class="number">30</span>,</span><br><span class="line">  d = <span class="number">40</span>,</span><br><span class="line">  e;</span><br><span class="line"><span class="built_in">document</span>.write(a, b, c, d, e);</span><br></pre></td></tr></table></figure><h5 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h5><ol><li>变量名必须以英文字母、_ 、$ 开头；</li><li>变量名可以包括英文字母、_ 、$ 、数字；</li><li>不可以用系统的关键字、保留字作为变量名。</li></ol><h5 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h5><p>获取变量的类型。</p><p>number string boolean object undefined function</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="number">123</span>); <span class="comment">// number</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="string">&quot;123&quot;</span>); <span class="comment">// string</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">// boolean</span></span><br></pre></td></tr></table></figure><p>用法：</p><ul><li><code>typeof(值)</code></li><li><code>typeof 值</code></li></ul><p>注：</p><ol><li><p><strong>null</strong>、array 运算后得到的是 object</p></li><li><p>typeof() 返回的值是字符串类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="keyword">typeof</span> a); <span class="comment">// string</span></span><br></pre></td></tr></table></figure></li></ol><p>特殊：</p><p>变量不定义就使用必定会报错，只有一种情况下不会</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>自定义 type 方法：区分所有类别</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">type</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="keyword">typeof</span> target;</span><br><span class="line">  <span class="keyword">var</span> template = &#123;</span><br><span class="line">    <span class="string">&quot;[object Array]&quot;</span>: <span class="string">&quot;array&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Object]&quot;</span>: <span class="string">&quot;object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Number]&quot;</span>: <span class="string">&quot;number - object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object Boolean]&quot;</span>: <span class="string">&quot;boolean - object&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[object String]&quot;</span>: <span class="string">&quot;string - object&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">if</span> (target === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;null&quot;</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="string">&quot;object&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> str = <span class="built_in">Object</span>.prototype.toString.call(target);</span><br><span class="line">    <span class="keyword">return</span> template[str];</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><h5 id="隐式类型转换"><a href="#隐式类型转换" class="headerlink" title="隐式类型转换"></a>隐式类型转换</h5><h6 id="isNaN"><a href="#isNaN" class="headerlink" title="isNaN()"></a>isNaN()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">NaN</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="number">123</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;123&quot;</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="string">&quot;abc&quot;</span>)); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">null</span>)); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">isNaN</span>(<span class="literal">undefined</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>isNaN() 之前会先 Number()</p><p>模拟 isNaN() 方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myIsNaN</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="built_in">Number</span>(num);</span><br><span class="line">  ret += <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">if</span> (ret == <span class="string">&quot;NaN&quot;</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="–"><a href="#–" class="headerlink" title="++ – + -"></a>++ – + -</h6><p>(自增 自减 正负号)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">a++; <span class="comment">// 124</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = +<span class="string">&quot;123&quot;</span>; <span class="comment">// +123</span></span><br><span class="line"><span class="keyword">var</span> b = +<span class="string">&quot;abc&quot;</span>; <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure><h6 id><a href="#" class="headerlink" title="+"></a>+</h6><p>(加号)</p><p>两侧没有字符串，则正常数字相加，调用 Number() 方法将不是 number 的隐式转换</p><p>当加号两侧至少有一侧是字符串时，会调用 String() 方法把两侧均转换为字符串</p><p>当加号左侧是引用类型值时，调用的是 String() 方法隐式转换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[] + <span class="number">1</span>; <span class="comment">// --&gt; String([]) + 1 --&gt; &quot;1&quot;</span></span><br><span class="line">[] + <span class="string">&quot;&quot;</span>; <span class="comment">// &quot;&quot;</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line">+<span class="number">1</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>但引用值的隐式类型转换不用知道，规则较多。</p><h6 id="-1"><a href="#-1" class="headerlink" title="- * / %"></a>- * / %</h6><p>(运算符号)</p><p>调用 Number() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="string">&quot;2&quot;</span> * <span class="string">&quot;1&quot;</span>; <span class="comment">// number : 2</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="string">&quot;a&quot;</span> * <span class="string">&quot;1&quot;</span>; <span class="comment">// number : NaN</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[] - <span class="number">1</span>; <span class="comment">// -1</span></span><br></pre></td></tr></table></figure><h6 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp; || !"></a>&amp;&amp; || !</h6><p>判断调用 Boolean() 方法</p><h6 id="lt-gt-…"><a href="#lt-gt-…" class="headerlink" title="&lt; &gt; …"></a>&lt; &gt; …</h6><p>(比较符号)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span> &gt; <span class="string">&quot;2&quot;</span>; <span class="comment">// boolean: true</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="string">&quot;3&quot;</span> &gt; <span class="string">&quot;2&quot;</span>; <span class="comment">// 会比较对应的 ASCII码 值</span></span><br></pre></td></tr></table></figure><p>特殊</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> &gt; <span class="number">0</span>; <span class="comment">// false 不转换，系统规定 undefined 和 null 不能和数进行比较</span></span><br><span class="line"><span class="literal">null</span> &gt; <span class="number">0</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h6 id="-2"><a href="#-2" class="headerlink" title="== !="></a>== !=</h6><p>调用 Boolean() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span> == <span class="literal">true</span>; <span class="comment">// boolean: true</span></span><br></pre></td></tr></table></figure><p>引用值比较的是地址：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#125; == &#123;&#125;; <span class="comment">// false</span></span><br><span class="line">[] == []; <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">var</span> obj1 = obj;</span><br><span class="line">obj == obj1; <span class="comment">// true</span></span><br><span class="line">obj === obj1; <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p>特殊：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">undefined</span> == <span class="literal">null</span>; <span class="comment">// true</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="显式类型转换"><a href="#显式类型转换" class="headerlink" title="显式类型转换"></a>显式类型转换</h5><h6 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h6><p>把里面的东西转换为数字型</p><p>null false =&gt; 0</p><p>undefined =&gt; NaN</p><h6 id="parseInt"><a href="#parseInt" class="headerlink" title="parseInt()"></a>parseInt()</h6><p>把里面的数转换为整数</p><p>注：看到非数字位截止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;123abc&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="comment">// 用途</span></span><br><span class="line"><span class="comment">// 把像素值从 100px 中取出来</span></span><br></pre></td></tr></table></figure><p><code>parseInt(值, radix)</code> radix: 2 - 36</p><p>后面的第二个参数表示此数所表示的进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">&quot;B&quot;</span>, <span class="number">16</span>); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><p>后面填 0</p><ul><li>有的浏览器是 原样转换整型输出</li><li>有的是输出 NaN</li></ul><h6 id="parseFloat"><a href="#parseFloat" class="headerlink" title="parseFloat()"></a>parseFloat()</h6><p>注：看到除了第一个 . 的非数字位截止</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">parseFloat</span>(<span class="string">&quot;123.12abc&quot;</span>); <span class="comment">// 123.12</span></span><br></pre></td></tr></table></figure><h6 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h6><h6 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a>toString()</h6><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> demo = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> str = demo.toString(); <span class="comment">// &quot;10</span></span><br><span class="line"><span class="comment">// 转换进制</span></span><br><span class="line"><span class="keyword">var</span> num = demo.toString(<span class="number">8</span>); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure><p>注：undefined 和 null 不能用 toSting() 方法</p><p>例子：</p><p>二进制 转 十六进制</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">10000</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="built_in">parseInt</span>(num, <span class="number">2</span>);</span><br><span class="line"><span class="built_in">console</span>.log(test.toString(<span class="number">16</span>)); <span class="comment">// aa</span></span><br></pre></td></tr></table></figure><h5 id="不发生类型转换"><a href="#不发生类型转换" class="headerlink" title="不发生类型转换"></a>不发生类型转换</h5><h6 id="-3"><a href="#-3" class="headerlink" title="=== !=="></a>=== !==</h6><p>数值 和 类型 均相等才可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> === <span class="number">1</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> === <span class="string">&quot;1&quot;</span>; <span class="comment">// false</span></span><br><span class="line"><span class="number">1</span> !== <span class="string">&quot;1&quot;</span>; <span class="comment">// true</span></span><br><span class="line"><span class="number">1</span> !== <span class="number">1</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>特殊：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span>; <span class="comment">// false</span></span><br></pre></td></tr></table></figure><h5 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="literal">false</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">document</span>.write(str); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">var</span> demo = <span class="literal">false</span> == <span class="number">1</span>;</span><br><span class="line"><span class="built_in">document</span>.write(demo); <span class="comment">// false</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> a &amp;&amp; -<span class="literal">true</span> + +<span class="literal">undefined</span> + <span class="string">&quot;&quot;</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;基础扎实！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="number">11</span> + <span class="string">&quot;11&quot;</span> * <span class="number">2</span> == <span class="number">33</span>) &#123;</span><br><span class="line">  <span class="built_in">document</span>.write(<span class="string">&quot;基础扎实！&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">!!<span class="string">&quot; &quot;</span> + !!<span class="string">&quot;&quot;</span> - !!<span class="literal">false</span> || <span class="built_in">document</span>.write(<span class="string">&quot;你觉得能打印，你就是🐖&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><h5 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符"></a>一元运算符</h5><p>只有一个运算数的运算符<br>++，– ， +(正号)</p><ul><li>++ –: 自增(自减)<ul><li>++(–) 在前，先自增(自减)，再运算</li><li>++(–) 在后，先运算，再自增(自减)</li></ul></li><li>+(-)：正负号</li></ul><p>注意：在 JS 中，如果运算数不是运算符所要求的类型，那么 js 引擎会自动的将运算数进行类型转换</p><ul><li>其他类型转 number：<ul><li>string 转 number：按照字面值转换。如果字面值不是数字，则转为 NaN（不是数字的数字）</li><li>boolean 转 number ：true 转为 1，false 转为 0</li></ul></li></ul><h5 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h5><p>​ + - * / %</p><p>注：</p><ol><li>1/0 会得 Infinity（无穷）</li><li>1/0 会得 -Infinity</li><li>0/0 会得 NaN</li></ol><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>​ = += -= *= /= %=</p><h5 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h5><p>​ &lt; &gt;= &lt;= == ===(全等于)</p><p>比较方式：</p><ol><li><p>类型相同：直接比较</p><p>​ 字符串：按照字典顺序比较。按位逐一比较，直到得出大小为止。即 ASCII 码 值</p></li><li><p>类型不同：先进行类型转换，再比较</p><p>​ ===：全等于。在比较之前，先判断类型，如果类型不一样，则直接返回 false</p></li></ol><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>​ &amp;&amp; || !</p><ul><li><p>&amp;&amp;（与）：先看第一个表达式转化为 boolean 值是否为真，结果为真，则依次往后看每个表达式转换为 boolean 值的结果，直到碰到结果为 false 的表达式，返回该表达式的值。</p><p>用法：（短路语句）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> data = ...;</span><br><span class="line"><span class="comment">// data &amp;&amp; 执行一个语句，会用到data;</span></span><br><span class="line">data &amp;&amp; fn(data);</span><br></pre></td></tr></table></figure></li><li><p>||（或）：碰到表达式的结果 boolean 值为真则返回该表达式的值</p><p>用法：（兼容）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">div.onclick = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 兼容 IE 浏览器</span></span><br><span class="line">  <span class="keyword">var</span> event = e || <span class="built_in">window</span>.event;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>! （非）：将表达式的值转换为 boolean 值 再取反，返回该 boolean 值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = !!<span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="comment">// !! 可以让一个值转换为 boolean值</span></span><br></pre></td></tr></table></figure></li></ul><p>注意：</p><p>undefined、null、NaN、””、0、false ==&gt; false</p><p>除了以上六个值以外，其他的转换为 boolean 类型均为 true</p><p>练习：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.foo || (<span class="built_in">window</span>.foo = <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="comment">// window.foo = &#x27;bar&#x27;</span></span><br><span class="line"><span class="comment">// 先读小括号内的，即先赋值</span></span><br></pre></td></tr></table></figure><h5 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h5><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表达式 ? 值<span class="number">1</span> : 值<span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>判断表达式的值，如果是 true 则取值 1，如果是 false 则取值 2；</p><h5 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h5><p>会将后面的结果返回出去</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = (<span class="number">1</span> - <span class="number">1</span>, <span class="number">1</span> + <span class="number">1</span>);</span><br><span class="line">a-- &gt; <span class="number">2</span>;</span><br></pre></td></tr></table></figure><h5 id="括号运算符"><a href="#括号运算符" class="headerlink" title="括号运算符"></a>括号运算符</h5><ol><li><p>优先运算</p><p>将里面的内容变为表达式</p><p><code>(function () &#123;&#125;)</code> 函数声明失效，变为表达式</p></li><li><p>立即执行</p><p><code>(function () &#123;&#125;)()</code></p></li></ol><h4 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h4><ol><li><p>if…else…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (判断语句) &#123;</span><br><span class="line">  条件体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>switch:</p></li></ol><ul><li><p>在 java 中，switch 语句可以接受的数据类型： byte int shor char,枚举(1.5) ,String(1.7)</p></li><li><p>在 JS 中,switch 语句可以接受任意的原始数据类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> () &#123;</span><br><span class="line">    <span class="keyword">case</span> 判断条件<span class="number">1</span>:</span><br><span class="line">    执行语句<span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 判断条件<span class="number">2</span>:</span><br><span class="line">    执行语句<span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> 判断条件<span class="number">3</span>:</span><br><span class="line">        执行语句<span class="number">3</span>; <span class="keyword">break</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="attr">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ol start="3"><li><p>while</p><p>底层机制就是 for 循环：for 循环括号内两边不写语句就是 while 循环：<code>for (;条件语句;) &#123;&#125;</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (条件语句) &#123;</span><br><span class="line">  循环语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>do…while</p><p>先执行一次，再判断条件语句</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  循环体;</span><br><span class="line">&#125; <span class="keyword">while</span> (条件语句);</span><br></pre></td></tr></table></figure></li><li><p>for</p></li><li><p>break</p><p>跳出循环或者 switch</p></li><li><p>continue</p><p>终止本次循环进行下次循环</p></li></ol><h4 id="JS-特殊语法"><a href="#JS-特殊语法" class="headerlink" title="JS 特殊语法"></a>JS 特殊语法</h4><ol><li>语句以 ; 结尾，如果一行只有一条语句则 ; 可以省略 (不建议)</li><li>变量的定义使用 var 关键字，也可以不使用</li></ol><ul><li>用：定义的变量是局部变量</li><li>不用：定义的变量是全局变量(不建议)</li></ul><ol start="3"><li>练习：99 乘法表</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>99乘法表<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">      <span class="selector-tag">td</span> &#123;</span></span><br><span class="line"><span class="css">        <span class="attribute">border</span>: <span class="number">1px</span> solid;</span></span><br><span class="line"><span class="css">      &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;&lt;table  align=&#x27;center&#x27;&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="comment">//1.完成基本的for循环嵌套，展示乘法表</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">1</span>; j &lt;= i; j++) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.write(<span class="string">&quot;&lt;td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          <span class="comment">//输出  1 * 1 = 1</span></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.write(i + <span class="string">&quot; * &quot;</span> + j + <span class="string">&quot; = &quot;</span> + i * j + <span class="string">&quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.write(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">        <span class="comment">/*//输出换行</span></span></span><br><span class="line"><span class="comment"><span class="javascript">document.write(&quot;&lt;br&gt;&quot;);*/</span></span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.write(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">      &#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">      <span class="comment">//2.完成表格嵌套</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">document</span>.write(<span class="string">&quot;&lt;/table&gt;&quot;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="基本对象"><a href="#基本对象" class="headerlink" title="基本对象"></a>基本对象</h3><h4 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h4><p>使用包装类对象创建的以下三种对象，依然还带有原本的数据类型的特点，不同在于可以有属性和方法</p><p>但是 undefined 和 null 不可以设置属性</p><h5 id="Number-数字对象"><a href="#Number-数字对象" class="headerlink" title="Number:数字对象"></a>Number:数字对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><h5 id="String-字符串对象"><a href="#String-字符串对象" class="headerlink" title="String:字符串对象"></a>String:字符串对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> Stirng(<span class="string">&quot;abcd&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="Boolean-布尔对象"><a href="#Boolean-布尔对象" class="headerlink" title="Boolean:布尔对象"></a>Boolean:布尔对象</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> bol = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="string">&quot;true&quot;</span>);</span><br></pre></td></tr></table></figure><h5 id="详解"><a href="#详解" class="headerlink" title="详解"></a>详解</h5><p>原始数据类型不能有自己的属性和方法</p><h6 id="自定义属性"><a href="#自定义属性" class="headerlink" title="自定义属性"></a>自定义属性</h6><p>但下面这个却不报错：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">4</span>;</span><br><span class="line">num.len = <span class="number">3</span>; <span class="comment">// 不报错</span></span><br><span class="line"><span class="built_in">console</span>.log(num.len); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>原因：（包装类）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">4</span>;</span><br><span class="line">num.len = <span class="number">3</span>; <span class="comment">// 不报错</span></span><br><span class="line"><span class="comment">// new Number(4).len = 3;</span></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"><span class="comment">// new Number(4).len --&gt; undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(num.len); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h6 id="length-问题"><a href="#length-问题" class="headerlink" title="length 问题"></a>length 问题</h6><p>在数组中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// arr.length --&gt; 5</span></span><br><span class="line">arr.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// arr.length --&gt; 2</span></span><br><span class="line"><span class="comment">// arr --&gt; [1, 2]</span></span><br></pre></td></tr></table></figure><p>但是，在字符串中</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abcd&quot;</span>;</span><br><span class="line"><span class="comment">// str.length --&gt; 4</span></span><br><span class="line">str.length = <span class="number">2</span>;</span><br><span class="line"><span class="comment">// new String(&#x27;abcd&#x27;).length = 2;</span></span><br><span class="line"><span class="comment">// delete</span></span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// abcd</span></span><br><span class="line"><span class="comment">// new String(&#x27;abcd&#x27;).length</span></span><br><span class="line"><span class="built_in">console</span>.log(str.length); <span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p>字符串对象 本身就有 length 属性，调用时是从包装类对象中返回的属性值</p><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str += <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> test = <span class="keyword">typeof</span> str; <span class="comment">// test --&gt; &#x27;string&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (test.length == <span class="number">6</span>) &#123;</span><br><span class="line">  test.sign = <span class="string">&quot;typeof的返回结果可能为String&quot;</span>;</span><br><span class="line">  <span class="comment">// new String(test).sign = &#x27;xxx&#x27;;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// new String(test).sign</span></span><br><span class="line"><span class="built_in">console</span>.log(test.sign);</span><br></pre></td></tr></table></figure><h4 id="Function-函数对象"><a href="#Function-函数对象" class="headerlink" title="Function:函数对象"></a>Function:函数对象</h4><p>高内聚，弱耦合</p><h5 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="keyword">new</span> <span class="built_in">Function</span>(形式参数列表，方法体)；<span class="comment">//忘掉吧</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> 方法名称(<span class="params">形式参数列表</span>) </span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命名函数表达式</span></span><br><span class="line"><span class="keyword">var</span> 方法名 = <span class="function"><span class="keyword">function</span> <span class="title">abc</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 匿名函数表达式 --- 函数表达式</span></span><br><span class="line"><span class="keyword">var</span> 方法名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 形式参数（形参）</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> c = a + b;</span><br><span class="line">  <span class="built_in">document</span>.write(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实际参数（实参）</span></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure><p>参数不限制位数</p><h6 id="arguments"><a href="#arguments" class="headerlink" title="arguments"></a>arguments</h6><p>表示实参列表，也有一些属性</p><ul><li><p>arguments.length 实参个数</p></li><li><p>arguments.callee 指向这个函数自身引用 –&gt; 即函数本身</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> num = (<span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="built_in">arguments</span>.callee(n - <span class="number">1</span>);</span><br><span class="line">&#125;)(<span class="number">100</span>);</span><br></pre></td></tr></table></figure></li></ul><p>函数名.length 形参个数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arguments -- [11,2,3] 实参列表</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>); <span class="comment">// [11,2,3]</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>.length); <span class="comment">// 3</span></span><br><span class="line">  <span class="comment">// 函数名.length -- 形参长度</span></span><br><span class="line">  concole.log(sum.length); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">11</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求不定参数个数的和</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    result += <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">document</span>.write(result);</span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>, <span class="number">3</span>);</span><br></pre></td></tr></table></figure><p>arguments 里面的值 和 形参的值 之间有映射关系，但只是在形参和实参对应时才生效</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// arguments  --&gt;  [1]</span></span><br><span class="line">  a = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">arguments</span>[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">  b = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">1</span>]); <span class="comment">// undefined</span></span><br><span class="line">&#125;</span><br><span class="line">sum(<span class="number">1</span>);</span><br></pre></td></tr></table></figure><h5 id="caller"><a href="#caller" class="headerlink" title="caller"></a>caller</h5><p>函数的一个属性：表示被调用的环境</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  demo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  demo, caller; <span class="comment">// --&gt; test --&gt; function test() &#123;demo();&#125;</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure><p>不怎么用，但会和 arguments.callee 一块出现做区分</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol><li>方法定义时，形参的类型不用写，返回值类型也不写</li><li>方法时一个对象，如果定义名称相同的方法，会覆盖</li><li>在 JS 中，方法的调用只与方法的名称有关，和参数列表无关</li><li>在方法声明中有一个隐藏的内置对象（数组），arguments，封装所有的实际参数</li></ol><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法名称(实际参数列表);</span><br></pre></td></tr></table></figure><h6 id="连续调用"><a href="#连续调用" class="headerlink" title="连续调用"></a>连续调用</h6><p>模拟 jQuery 连续调用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> deng = &#123;</span><br><span class="line">  <span class="attr">smoke</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Somking...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">drink</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Drinking...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">perm</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;Perming...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">deng.smoke().drink().perm();</span><br></pre></td></tr></table></figure><h5 id="结束条件和返回值"><a href="#结束条件和返回值" class="headerlink" title="结束条件和返回值"></a>结束条件和返回值</h5><ul><li>return 语句后的内容将不再执行，终止函数</li><li>返回值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">myNumber</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> +target;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> num = myNumber(<span class="string">&quot;123&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num + <span class="string">&quot; &quot;</span> + num); <span class="comment">// number 123</span></span><br></pre></td></tr></table></figure><h5 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h5><h6 id="求阶乘"><a href="#求阶乘" class="headerlink" title="求阶乘"></a>求阶乘</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 求阶乘方法</span></span><br><span class="line"><span class="comment">// n! = n * (n-1)!</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mul</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n * mul(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> n = <span class="built_in">parseInt</span>(prompt(<span class="string">&quot;input&quot;</span>));</span><br><span class="line">mul(n);</span><br><span class="line"><span class="comment">// 递归</span></span><br><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">mul(5);</span></span><br><span class="line"><span class="comment">    5 * mul(4);</span></span><br><span class="line"><span class="comment">    5 * 4 * mul(3);</span></span><br><span class="line"><span class="comment">    5 * 4 * 3 * mul(2);</span></span><br><span class="line"><span class="comment">    5 * 4 * 3 * 2 * 1; </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h6 id="斐波那契数列"><a href="#斐波那契数列" class="headerlink" title="斐波那契数列"></a>斐波那契数列</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 斐波那契数列</span></span><br><span class="line"><span class="comment">// fb(n) == fb(n - 1) + fb(n - 2)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fb</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">2</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> fb(n - <span class="number">1</span>) + fb(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="原型-prototype"><a href="#原型-prototype" class="headerlink" title="原型 prototype"></a>原型 prototype</h5><p>原型是 function 对象的一个属性，它定义了构造函数制造出的对象的公共祖先。通过该构造函数产生的对象，可以继承该圆心的属性和方法。原型也是对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.LastName = <span class="string">&quot;Agoni&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// person.LastName --&gt; &quot;Agoni&quot;</span></span><br><span class="line"><span class="comment">// person1.LastName --&gt; &quot;Agoni&quot;</span></span><br></pre></td></tr></table></figure><p>对象中固定不变的属性（公有的内容）可以提取出来放到原型中，避免代码多次执行造成冗余。</p><h6 id="增删改查"><a href="#增删改查" class="headerlink" title="增删改查"></a>增删改查</h6><p>删</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> Person.prototype.LastName;</span><br></pre></td></tr></table></figure><p>经过了 var 给 window 上增加的属性为不可配置性属性，delete 无法删除。</p><p>增改查</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.LastName = <span class="string">&quot;Agoni&quot;</span>;</span><br></pre></td></tr></table></figure><p>设置属性（可以多个一起设置）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1400</span>,</span><br><span class="line">    lang, <span class="number">4900</span>,</span><br><span class="line">    <span class="attr">carName</span>: <span class="string">&quot;BMW&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和 <code>Person.prototype.name = &quot;&quot;</code> 的区别：</p><ul><li>上面的那一种是重新放一个空间，如之前已设置过且已经生成了对象，则 <code>__proto__</code> 所指向的还是原先的那个空间；</li><li>下面的是在原先的空间中设置或修改属性，使得 <code>__proto__</code> 的访问数据变更</li></ul><h6 id="构造器-constructor"><a href="#构造器-constructor" class="headerlink" title="构造器 constructor"></a>构造器 constructor</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="comment">// car.constructor --&gt; funciton Car() &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Car.prototype = &#123;</span><br><span class="line">  <span class="attr">constructor</span>: Person,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// car.constructor --&gt; function Person() &#123;&#125;</span></span><br></pre></td></tr></table></figure><h6 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h6><p>隐式属性 <code>__proto__</code> 内就放着原型，在控制台展开可以查看</p><p>原理：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">funciton <span class="function"><span class="title">Person</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// var this = &#123;</span></span><br><span class="line">    <span class="comment">//     __proto__ : Person.prototype</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><p>原型也可以改变：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码接上一部分</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;sunny&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// person.name --&gt; &quot;abc&quot;</span></span><br><span class="line">Person.__proto__ = obj;</span><br><span class="line"><span class="comment">// person.name --&gt; &quot;sunny&quot;</span></span><br></pre></td></tr></table></figure><h6 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Grand.prototype.lastName = <span class="string">&quot;agoni&quot;</span>;</span><br><span class="line">funciton <span class="function"><span class="title">Grand</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> grand = <span class="keyword">new</span> Grand();</span><br><span class="line"></span><br><span class="line">Father.prototype = grand;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = <span class="string">&quot;Lay&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"></span><br><span class="line">Son.prototype = fatehr;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.hobbit = <span class="string">&quot;smoke&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">// son.hobbit --&gt; &quot;smoke&quot;</span></span><br><span class="line"><span class="comment">// son.name --&gt; &quot;Lay&quot;</span></span><br><span class="line"><span class="comment">// son.lastName --&gt; &quot;Agoni&quot;</span></span><br></pre></td></tr></table></figure><p>查找属性，依照 <code>son --&gt; father --&gt; grand</code> 顺序依次查找，这个链就叫 原型链。</p><p>链顶并不是最末的：</p><h6 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h6><p>是<strong>绝大多数</strong>对象的最终原型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Grand.prototype.__proto__  --&gt;  Object.prototype</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// son.toString() --&gt; function toString() &#123; [native code] &#125; // 最终终端的方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Object.prototype.__proto__  --&gt;  null</span></span><br></pre></td></tr></table></figure><p>Object.prototype 里面没有 __proto__ 了</p><h6 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h6><p>括号内填原型：只能是 对象 或 null</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="string">&quot;sunny&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="built_in">Object</span>.create(Person.prototype);</span><br></pre></td></tr></table></figure><p>特殊点：</p><p>原型最终不会指向 Object.prototype</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// obj.toString() --&gt; 访问不到，报错</span></span><br></pre></td></tr></table></figure><p>语法：</p><p><code>Object.create(prototype, definedProperty&lt;特性&gt;)</code></p><h6 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype = &#123;</span><br><span class="line">  <span class="attr">toString</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hehe&quot;</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">// person.toString(); --&gt; &quot;hehe&quot;</span></span><br></pre></td></tr></table></figure><p>发生截断，不会访问到终端 Object.prototype 的 toSting() 方法</p><p>Number Array Boolean String 都对 toSting() 方法进行了重写</p><h6 id="document-write-原理"><a href="#document-write-原理" class="headerlink" title="document.write 原理"></a>document.write 原理</h6><p>会隐式调用 toSting() 方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line"><span class="built_in">document</span>.write(obj); <span class="comment">// 报错，因为自己创建的对象值为 null 且 Object.create() 创建的没有原型链，没有 toString() 方法，所以报错</span></span><br><span class="line"></span><br><span class="line">obj.toStirng = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;AgoniLay&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">document</span>.write(obj); <span class="comment">// AgoniLay --&gt; 调用了 AgoniLay 方法</span></span><br></pre></td></tr></table></figure><h5 id="call-apply"><a href="#call-apply" class="headerlink" title="call/apply"></a>call/apply</h5><h6 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test(); <span class="comment">// --&gt; test.call();</span></span><br></pre></td></tr></table></figure><p>call 带参数</p><p>根本作用：<strong>改变 tihs 指向</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;deng&quot;</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 第一个参数指 this 的指向，之后的依次代表 实参 对应 形参</span></span><br><span class="line">Person.call(obj, <span class="string">&quot;agoni&quot;</span>, <span class="number">19</span>);</span><br><span class="line"><span class="comment">// obj --&gt; &#123;name: &#x27;agoni&#x27;, age: 19&#125;</span></span><br></pre></td></tr></table></figure><p>使用实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name;</span><br><span class="line">  <span class="built_in">this</span>.age = age;</span><br><span class="line">  <span class="built_in">this</span>.sex = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, sex, tel, grade</span>) </span>&#123;</span><br><span class="line">  Person.call(<span class="built_in">this</span>, name, age, sex);</span><br><span class="line">  <span class="built_in">this</span>.tel = tel;</span><br><span class="line">  <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">&quot;sunny&quot;</span>, <span class="number">123</span>, <span class="string">&quot;male&quot;</span>, <span class="number">1309</span>, <span class="number">2017</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Wheel</span>(<span class="params">wheelSize, style</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.style = style;</span><br><span class="line">  <span class="built_in">this</span>.wheelSize = wheelSize;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Sit</span>(<span class="params">c, sitColor</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.c = c;</span><br><span class="line">  <span class="built_in">this</span>.sitColor = sitColor;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Model</span>(<span class="params">height, width, len</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.height = height;</span><br><span class="line">  <span class="built_in">this</span>.width = width;</span><br><span class="line">  <span class="built_in">this</span>.len = len;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">wheelSize, style, c, sitColor, height, width, len</span>) </span>&#123;</span><br><span class="line">  Wheel.call(<span class="built_in">this</span>, wheelSize, style);</span><br><span class="line">  Sit.call(<span class="built_in">this</span>, c, sitColor);</span><br><span class="line">  Model.call(<span class="built_in">this</span>, height, width, len);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> car = <span class="keyword">new</span> Car(<span class="number">100</span>, <span class="string">&quot;花里胡哨&quot;</span>, <span class="string">&quot;真皮&quot;</span>, <span class="string">&quot;red&quot;</span>, <span class="number">1800</span>, <span class="number">1900</span>, <span class="number">4900</span>);</span><br><span class="line"><span class="comment">// car &#123;style: &quot;花里胡哨&quot;, wheelSize: 100, c: &quot;真皮&quot;, sitColor: &quot;red&quot;, height: 1800, …&#125;</span></span><br></pre></td></tr></table></figure><h6 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h6><p>和 call() 区别：</p><ul><li>传参列表不同：apply 第一个参数还是 this 所指对象，第二个参数是一个数组，数组里面是所有的实参<ul><li>call 需要把实参按照形参的个数传进去</li><li>apply 需要传一个 arguments</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">wheelSize, style, c, sitColor, height, width, len</span>) </span>&#123;</span><br><span class="line">  Wheel.apply(<span class="built_in">this</span>, [wheelSize, style]);</span><br><span class="line">  Sit.call(<span class="built_in">this</span>, [c, sitColor]);</span><br><span class="line">  Model.call(<span class="built_in">this</span>, [height, width, len]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="继承-–-gt-圣杯模式"><a href="#继承-–-gt-圣杯模式" class="headerlink" title="继承 –&gt; 圣杯模式"></a>继承 –&gt; 圣杯模式</h5><ol><li><p>传统形式 –&gt; 原型链</p><ul><li>过多的继承了没用的属性</li></ul></li><li><p>借用构造函数 call()/apply()</p><ul><li>不能继承借用构造函数的原型</li><li>每次构造函数都要多走一个函数（视觉上减少代码，但多走了方法）</li></ul></li><li><p>共享原型</p><p><code>son.prototype = father.prototype</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Father.prototype.lastName = <span class="string">&quot;AgoniLay&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">funciton <span class="function"><span class="title">inherit</span>(<span class="params">Target, Origin</span>)</span> &#123;</span><br><span class="line">    Target.prototype = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先继承，后用</span></span><br><span class="line">inherit(Son, Father);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="comment">// son.lastName --&gt; &quot;AgoniLay&quot;</span></span><br><span class="line"><span class="comment">// father.lastName --&gt; &quot;AgoniLay&quot;</span></span><br><span class="line"></span><br><span class="line">Son.prototype.sex = <span class="string">&quot;male&quot;</span>; <span class="comment">// 添加后，son 和 father 都有了这个属性</span></span><br><span class="line"><span class="comment">// son.sex --&gt; &quot;male&quot;</span></span><br><span class="line"><span class="comment">// father.sex --&gt; &quot;male&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>圣杯模式</strong> *</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通俗写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inherit</span>(<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="comment">// 以下两行顺序不能颠倒</span></span><br><span class="line">  F.prototype = Origin.prototype;</span><br><span class="line">  Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">  <span class="comment">// 优化</span></span><br><span class="line">  Target.prototype.constuctor = Target;</span><br><span class="line">  Target.prototype.uber = Origin.prototype;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Father.prototype.lastName = <span class="string">&quot;AgoniLay&quot;</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Father</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Son</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">inherit(Son, Father);</span><br><span class="line"><span class="keyword">var</span> son = <span class="keyword">new</span> Son();</span><br><span class="line"><span class="keyword">var</span> father = <span class="keyword">new</span> Father();</span><br><span class="line"><span class="comment">// father.lastName --&gt; &quot;AgoniLay&quot;</span></span><br><span class="line"><span class="comment">// son.lastName --&gt; &quot;AgoniLay&quot;</span></span><br><span class="line"></span><br><span class="line">Son.prototype.sex = <span class="string">&quot;male&quot;</span>;</span><br><span class="line"><span class="comment">// son.sex --&gt; &quot;male&quot;</span></span><br><span class="line"><span class="comment">// father.sex --&gt; undifined</span></span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 雅虎的</span></span><br><span class="line"><span class="keyword">var</span> inherit = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> F = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;; <span class="comment">// 闭包应用 -- 私有化变量</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Target, Origin</span>) </span>&#123;</span><br><span class="line">    F.prototype = Origin.prototype;</span><br><span class="line">    Target.prototype = <span class="keyword">new</span> F();</span><br><span class="line">    Target.prototype.constructor = Target;</span><br><span class="line">    Target.prototype.uber = Origin.prototype;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></li></ol><h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a>Array:数组对象</h4><h5 id="创建-1"><a href="#创建-1" class="headerlink" title="创建"></a>创建</h5><ol><li><p><code>var arr = [];</code> 数组字面量 – 推荐使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [, ,]; <span class="comment">// [undefined * 2]</span></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, , <span class="number">2</span>]; <span class="comment">// [1, undefined, 2] --&gt; 稀松数组</span></span><br></pre></td></tr></table></figure></li><li><p><code>var arr = new Array();</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br></pre></td></tr></table></figure><p>和 数组字面量 区别：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只传一个参数，代表数组的长度</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10</span>); <span class="comment">// [undefined * 10]</span></span><br><span class="line"><span class="comment">// 但不能只传一个小数</span></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">10.2</span>); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="读和写"><a href="#读和写" class="headerlink" title="读和写"></a>读和写</h5><p>溢出读是 undefined，可以溢出写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span> <span class="comment">// [2,2,3]</span></span><br><span class="line"><span class="built_in">console</span>.log(arr[<span class="number">10</span>]); <span class="comment">// undefined 不会报错</span></span><br><span class="line">arr[<span class="number">10</span>] = <span class="string">&quot;aa&quot;</span>; <span class="comment">// 可以添加 --&gt; [1,2,3,undefined * 7,&quot;aa&quot;]</span></span><br></pre></td></tr></table></figure><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>可以改变原数组的方法开始：只有七个</p><h6 id="push"><a href="#push" class="headerlink" title="push()"></a>push()</h6><p>在数组<strong>最后</strong>添加数据，不仅可以添加一个，返回值是添加后的数组长度</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己写 push() 方法</span></span><br><span class="line"><span class="keyword">var</span> arr = [];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="built_in">this</span>[<span class="built_in">this</span>.length] = <span class="built_in">arguments</span>[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">this</span>.length;</span><br><span class="line">&#125;;</span><br><span class="line">arr.push(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 3 --&gt; [1,2,3]</span></span><br></pre></td></tr></table></figure><p>但 push 的原理是取决于属性中 length 值，与 length 值有关</p><h6 id="pop"><a href="#pop" class="headerlink" title="pop()"></a>pop()</h6><p>把数组的<strong>最后一位</strong>剪切出来返回</p><h6 id="unshift"><a href="#unshift" class="headerlink" title="unshift()"></a>unshift()</h6><p>在数组<strong>开头</strong>添加数据，不仅可以添加一个，返回值是添加后的数组长度</p><h6 id="shift"><a href="#shift" class="headerlink" title="shift()"></a>shift()</h6><p>把数组的<strong>第一位</strong>剪切出来返回</p><h6 id="reverse"><a href="#reverse" class="headerlink" title="reverse()"></a>reverse()</h6><p>把数组<strong>逆转</strong>，把原数组返回</p><h6 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h6><p><code>arr.splice(从第几位开始, 截取多少的长度, 在切口处添加新的数据)</code></p><p>返回截取的数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>); <span class="comment">// [1,2] --&gt; [1,2,3,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>];</span><br><span class="line">arr.splice(<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) <span class="comment">// [1,2] --&gt; [1,0,0,0,2,3,3]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 不截取，只是向中间插入数据 例：向上面数组 3 后面添加一个 0</span></span><br><span class="line">arr.splice(<span class="number">3</span>,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>];</span><br><span class="line"><span class="comment">// 截取的位置可以是负数，表示从倒数开始</span></span><br><span class="line">arr.splice(-<span class="number">1</span>,<span class="number">1</span>); <span class="comment">// [4] --&gt; [1,2,3]</span></span><br><span class="line"><span class="comment">// 实现</span></span><br><span class="line">splice = <span class="function"><span class="keyword">function</span> (<span class="params">pos, ...</span>) </span>&#123;</span><br><span class="line">    pos += pos &gt; <span class="number">0</span> ? <span class="number">0</span> : <span class="built_in">this</span>.length; <span class="comment">// -1 + 4 = 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="sort"><a href="#sort" class="headerlink" title="sort() *"></a>sort() *</h6><p>在原数组上将原数组内元素升序排列（但并不是数字值的大小）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">0</span>, -<span class="number">1</span>, <span class="number">9</span>];</span><br><span class="line">arr.sort(); <span class="comment">// [-1,0,1,3,4,9]</span></span><br><span class="line"><span class="comment">// 降序</span></span><br><span class="line">arr.sort().reverse();</span><br></pre></td></tr></table></figure><p>为了解决这个问题，sort 留了一个接口让用户自定义排序方式</p><p>规则：</p><ol><li>必须写俩形参</li><li>看返回值<ol><li>当返回值为负数时，那么前面的数放在前面</li><li>为正数，那么后面的数在前</li><li>为 0，不动</li></ol></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">10</span>];</span><br><span class="line"><span class="comment">// 传参顺序 1,3  1,5  1,4  1,10  3,5</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 函数体</span></span><br><span class="line">  <span class="comment">// if (a &gt; b) &#123;</span></span><br><span class="line">  <span class="comment">//    return 1;</span></span><br><span class="line">  <span class="comment">//&#125; else &#123;</span></span><br><span class="line">  <span class="comment">//    return -1;</span></span><br><span class="line">  <span class="comment">//&#125;</span></span><br><span class="line">  <span class="comment">// 简化</span></span><br><span class="line">  <span class="keyword">return</span> a - b; <span class="comment">// 升序</span></span><br><span class="line">  <span class="comment">// return b - a; // 降序</span></span><br><span class="line">&#125;); <span class="comment">// [1, 3, 4, 5, 10]</span></span><br></pre></td></tr></table></figure><p>运用：</p><p>给一个有序的数组，乱序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.random() - <span class="number">0.5</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>给一个对象数组，按某一属性排</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cheng = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;cheng&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">30</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> deng = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;deng&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">60</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> zhang = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;zhang&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> arr = [cheng, deng, zhang];</span><br><span class="line"><span class="comment">// 按年龄升序排列</span></span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.age - b.age;</span><br><span class="line">&#125;); <span class="comment">// [&quot;zhang&quot;, &quot;cheng&quot;, &quot;deng&quot;]</span></span><br></pre></td></tr></table></figure><p>按字符串长度排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;as&quot;</span>, <span class="string">&quot;asdad&quot;</span>, <span class="string">&quot;s&quot;</span>, <span class="string">&quot;sjdfhakjsdfhlkajsd&quot;</span>, <span class="string">&quot;asdjhajsk&quot;</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a.length - b.length;</span><br><span class="line">&#125;); <span class="comment">// [&#x27;s&#x27;, &#x27;as&#x27;, &#x27;asdad&#x27;, &#x27;asdjhajsk&#x27;, &#x27;sjdfhakjsdfhlkajsd&#x27;]</span></span><br></pre></td></tr></table></figure><p>按字节长度排序</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">retBytes</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> num = str.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (str.charCodeAt(i) &gt; <span class="number">255</span>) &#123;</span><br><span class="line">      num++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> num++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">&quot;赛的环境asdj&quot;</span>, <span class="string">&quot;asd&quot;</span>, <span class="string">&quot;啥的， 爱睡觉的&quot;</span>, <span class="string">&quot;a saa&quot;</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> retBytes(a) - retBytes(b);</span><br><span class="line">&#125;); <span class="comment">// [&quot;asd&quot;, &quot;a saa&quot;, &quot;赛的环境asdj&quot;, &quot;啥的， 爱睡觉的&quot;]</span></span><br></pre></td></tr></table></figure><p>不改变原数组的方法开始：调用完使用 变量 接收，否则没有意义</p><h6 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h6><p>把括号内的数组拼接到前面数组的后面，不在原数组上修改，返回拼接后的数组</p><h6 id="toString"><a href="#toString" class="headerlink" title="toString()"></a>toString()</h6><p>将数组返回为字符串类型的字符串</p><h6 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h6><p><code>arr.slice(&#39;从该位开始截取&#39;, &#39;截取到该位&#39;)</code></p><p><code>arr.slice(1)</code> 从第 1 位截取，截取到最后，也可以填负数（规则 + length）</p><p><code>arr.slice()</code> 整个截取</p><h6 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h6><p>将数组中元素按规定连接起来，返回一个字符串</p><p>参数可以传所有原始值，但最好传字符串</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">arr.join(<span class="string">&quot;&amp;&quot;</span>); <span class="comment">// &quot;1&amp;2&amp;3&quot;</span></span><br><span class="line">arr.join(); <span class="comment">// &quot;1,2,3&quot;</span></span><br></pre></td></tr></table></figure><h6 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h6><p>是字符串的方法，是 join() 的可逆方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">&quot;1-2-3-4-5&quot;</span>;</span><br><span class="line">str.split(<span class="string">&quot;-&quot;</span>); <span class="comment">// [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;]</span></span><br></pre></td></tr></table></figure><p>自定义方法：</p><h6 id="unique"><a href="#unique" class="headerlink" title="unique()"></a>unique()</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = &#123;&#125;;</span><br><span class="line">  <span class="keyword">var</span> arr = [];</span><br><span class="line">  <span class="keyword">var</span> len = <span class="built_in">this</span>.length;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!temp[<span class="built_in">this</span>[i]]) &#123;</span><br><span class="line">      temp[<span class="built_in">this</span>[i]] = <span class="string">&quot;agoni&quot;</span>;</span><br><span class="line">      arr.push(<span class="built_in">this</span>[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="类数组"><a href="#类数组" class="headerlink" title="类数组"></a>类数组</h5><p>类数组有要求：</p><ol><li>属性要为索引（数组）属性</li><li>必须有 length 属性</li></ol><h4 id="Math-对象"><a href="#Math-对象" class="headerlink" title="Math 对象"></a>Math 对象</h4><h4 id="Date-对象"><a href="#Date-对象" class="headerlink" title="Date 对象"></a>Date 对象</h4><h4 id="Reg-正则表达式对象"><a href="#Reg-正则表达式对象" class="headerlink" title="Reg 正则表达式对象"></a>Reg 正则表达式对象</h4><h3 id="JS-运行"><a href="#JS-运行" class="headerlink" title="JS 运行"></a>JS 运行</h3><p>this</p><p>闭包</p><p>with</p><p>eval</p><p>预编译</p><p>try…catch</p><p>有待更新…</p><p>博客笔记地址（二）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077465">https://blog.csdn.net/qq_58163927/article/details/119077465</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> ECMAScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript笔记(一)</title>
      <link href="/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%80/"/>
      <url>/2021/07/30/JavaScript%E7%AC%94%E8%AE%B0-%E4%B8%80/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器及其内核"><a href="#浏览器及其内核" class="headerlink" title="浏览器及其内核"></a>浏览器及其内核</h1><table><thead><tr><th align="center">主流浏览器</th><th align="center">内核</th></tr></thead><tbody><tr><td align="center">IE</td><td align="center">trident</td></tr><tr><td align="center">Chorme</td><td align="center">webkit/blink</td></tr><tr><td align="center">firefox</td><td align="center">Gecko</td></tr><tr><td align="center">Opera</td><td align="center">presto</td></tr><tr><td align="center">Safari</td><td align="center">webkit</td></tr><tr><td align="center">搜狗</td><td align="center">webkit</td></tr></tbody></table><h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="基础入门"><a href="#基础入门" class="headerlink" title="基础入门"></a>基础入门</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>一门客户端脚本语言</p><ul><li>运行在客户端浏览器中的。每一个浏览器都有 JavaScript 的解析引擎</li><li>脚本语言：不需要编译，直接就可以被浏览器解析执行了</li></ul><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>可以来增强用户和 html 页面的交互过程，可以来控制 html 元素，让页面有一些动态的效果，增强用户的体验。</li></ul><h3 id="JavaScript-发展史"><a href="#JavaScript-发展史" class="headerlink" title="JavaScript 发展史"></a>JavaScript 发展史</h3><ol><li>1992 年，Nombase 公司，开发出第一门客户端脚本语言，专门用于表单的校验。命名为 ： C– ，后来更名为：ScriptEase</li><li>1995 年，Netscape(网景)公司，开发了一门客户端脚本语言：LiveScript。后来，请来 SUN 公司的专家，修改 LiveScript，命名为 JavaScript</li><li>1996 年，微软抄袭 JavaScript 开发出 JScript 语言</li><li>1997 年，ECMA(欧洲计算机制造商协会)，制定出客户端脚本语言的标准：ECMAScript，就是统一了所有客户端脚本语言的编码方式。</li></ol><p>注：JavaScript = ECMAScript + JavaScript 自己特有的东西(BOM+DOM)</p><p>博客笔记地址（一）：<a href="https://blog.csdn.net/qq_58163927/article/details/119077397">https://blog.csdn.net/qq_58163927/article/details/119077397</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 前端 </tag>
            
            <tag> 浏览器内核 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TypeScript笔记</title>
      <link href="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<p>在线文档：<a href="https://24kcs.github.io/vue3_study">https://24kcs.github.io/vue3_study</a></p><h1 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h1><h2 id="初识"><a href="#初识" class="headerlink" title="初识"></a>初识</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>TypeScript 是一种由微软开发的开源、跨平台的编程语言。它是 JavaScript 的超集，最终会被编译为 JavaScript 代码</p><p><strong>TypeScript 是 JavaScript 的一个超集</strong>，主要提供了<strong>类型系统</strong>和<strong>对 ES6+ 的支持</strong>，它由 Microsoft 开发，代码 <a href="https://github.com/Microsoft/TypeScript">开源于 GitHub (opens new window)</a> 上</p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li>始于 JavaScript，归于 JavaScript</li><li>强大的类型系统</li><li>先进的 JavaScript</li></ul><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>命令行输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i -g typescript</span><br></pre></td></tr></table></figure><p>检查安装：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tsc -V</span><br><span class="line">    &gt; Version <span class="number">4.3</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure><h3 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h3><p>01_第一次的 ts.ts</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// str这个参数是string类型的</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params">str: <span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;您好啊&quot;</span> + str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> text = <span class="string">&quot;张艺兴&quot;</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(sayHi(text));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>index.html 中直接引入了 ts 的文件，浏览器是会报错的（如果 ts 文件中只有单纯的 js 代码，是可以正常的引入及使用的）</p><p>如果有 ts 的语法，可以进行编译代码：</p><h4 id="手动编译代码"><a href="#手动编译代码" class="headerlink" title="手动编译代码"></a>手动编译代码</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc 文件名</span><br></pre></td></tr></table></figure><p>将会生成对应的 js 文件，然后再 index.html 直接引入 js 文件即可</p><h4 id="自动编译代码（vccode-中）"><a href="#自动编译代码（vccode-中）" class="headerlink" title="自动编译代码（vccode 中）"></a>自动编译代码（vccode 中）</h4><ol><li><p>文件目录下终端运行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tsc --init</span><br></pre></td></tr></table></figure><p>自动初始化生成 tsconfig.json 文件</p></li><li><p>在其中做修改：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;compilerOptions&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;outDir&quot;</span>: <span class="string">&quot;./js&quot;</span>, <span class="comment">/* 把 ts 文件最终编译后，放在js的目录中 */</span></span><br><span class="line">    <span class="attr">&quot;strict&quot;</span>: <span class="literal">false</span>,  <span class="comment">/* 不使用严格模式 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动监视任务，终端运行</p><p>单击 项目文件夹 选中，找到上方终端打开 运行任务 选择 tsc:监视 打开运行</p></li></ol><h4 id="类型注解"><a href="#类型注解" class="headerlink" title="类型注解"></a>类型注解</h4><p>一种轻量级的为函数或者变量添加的约束</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// str 是string类型的</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params">str: <span class="built_in">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;床前明月光，&quot;</span> + str;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// msg 是一个数组</span></span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;疑似地上霜&quot;</span>;</span><br><span class="line">  <span class="comment">// let msg = 22</span></span><br><span class="line">  <span class="comment">// 智能的错误提示信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(showMsg(msg));</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><h4 id="接口-类"><a href="#接口-类" class="headerlink" title="接口 - 类"></a>接口 - 类</h4><p>是一种能力，一种约束而已</p><h4 id="使用-webpack-打包-TS"><a href="#使用-webpack-打包-TS" class="headerlink" title="使用 webpack 打包 TS"></a>使用 webpack 打包 TS</h4><p>安装依赖</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm i -D typescript</span><br><span class="line"></span><br><span class="line">npm i -D webpack webpack-cli@<span class="number">3.3</span>.<span class="number">12</span></span><br><span class="line">webpack-dev-server</span><br><span class="line"></span><br><span class="line">npm i -D html-webpack-plugin clean-webpack-plugin ts-loader cross-env</span><br></pre></td></tr></table></figure><p>配置打包命令</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;dev&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=development webpack-dev-server --config build/webpack.config.js&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;build&quot;</span>: <span class="string">&quot;cross-env NODE_ENV=production webpack --config build/webpack.config.js&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行出现错误，尝试：</p><p>错误：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">internal/modules/cjs/loader.js:<span class="number">888</span></span><br><span class="line">    <span class="keyword">throw</span> err;</span><br><span class="line">^</span><br><span class="line"></span><br><span class="line"><span class="built_in">Error</span>: Cannot find module <span class="string">&#x27;webpack-cli/bin/config-yargs&#x27;</span></span><br></pre></td></tr></table></figure><p>处理：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall webpack-cli</span><br><span class="line">cnpm i webpack-cli@<span class="number">3.3</span>.<span class="number">12</span> -D</span><br></pre></td></tr></table></figure><p>报错：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">× ｢wds｣: Invalid configuration <span class="keyword">object</span>. Webpack has been initialized using a configuration <span class="keyword">object</span> that does not <span class="keyword">match</span> the API schema.</span><br><span class="line">  - configuration.devtool should <span class="keyword">match</span> pattern <span class="string">&quot;^(inline-|hidden-|eval-)?(nosources-)?(cheap-(module-)?)?source-map$&quot;</span>.</span><br><span class="line">    BREAKING CHANGE since webpack <span class="number">5</span>: The devtool option is more strict.</span><br><span class="line">    Please strictly follow the order of the keywords in the pattern.</span><br></pre></td></tr></table></figure><p>处理：</p><p>webpack.config.js 文件中修改配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">devtool: &#x27;eval-cheap-module-source-map&#x27;</span><br></pre></td></tr></table></figure><h2 id="常用语法"><a href="#常用语法" class="headerlink" title="常用语法"></a>常用语法</h2><h3 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h3><p>TypeScript 支持与 JavaScript 几乎相同的数据类型，此外还提供了实用的枚举类型方便我们使用。</p><p>总结：ts 中变量一开始是声明类型，那么后期赋值的时候，只能用这个类型的数据，是不允许用其他类型的数据赋值给当前的这个变量中</p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 布尔类型   ------&gt; boolean</span></span><br><span class="line"><span class="comment">// let 变量名:数据类型 = 值</span></span><br><span class="line"><span class="keyword">let</span> flag: boolean = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">console</span>.log(flag);</span><br></pre></td></tr></table></figure><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数字类型   ------&gt; number</span></span><br><span class="line"><span class="keyword">let</span> a1: number = <span class="number">10</span>; <span class="comment">// 十进制</span></span><br><span class="line"><span class="keyword">let</span> a2: number = <span class="number">0b1010</span>; <span class="comment">// 二进制</span></span><br><span class="line"><span class="keyword">let</span> a3: number = <span class="number">0o12</span>; <span class="comment">// 八进制</span></span><br><span class="line"><span class="keyword">let</span> a4: number = <span class="number">0xa</span>; <span class="comment">// 十六进制</span></span><br></pre></td></tr></table></figure><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 字符串类型 ------&gt; string</span></span><br><span class="line"><span class="keyword">let</span> str1: string = <span class="string">&quot;床前明月光&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str2: string = <span class="string">&quot;小明去开窗&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str3: string = <span class="string">&quot;遇到一耳光&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> str4: string = <span class="string">&quot;牙齿掉光光&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;str1&#125;</span>,<span class="subst">$&#123;str2&#125;</span>,<span class="subst">$&#123;str3&#125;</span>,<span class="subst">$&#123;str4&#125;</span>`</span>);</span><br></pre></td></tr></table></figure><h5 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a>undefined 和 null</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nud: <span class="literal">undefined</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> nll: <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nud);</span><br><span class="line"><span class="built_in">console</span>.log(nll);</span><br><span class="line"><span class="comment">// undefined 和 null 都可以做为其他类型的子类型，把 undefined 和 null 赋值给其他类型的变量</span></span><br><span class="line"><span class="keyword">let</span> num2: number = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(num2); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><p>赋值后报错是因为：在 tsconfig.js 中开启了严格模式</p><p>将 <code>&quot;strict&quot;: true</code> 更改为 <code>&quot;strict&quot;: false</code> 即可</p><h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组定义方式1</span></span><br><span class="line"><span class="comment">// let 变量名: 数据类型[] = [值1，值2]</span></span><br><span class="line"><span class="keyword">let</span> arr1: number[] = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr1);</span><br><span class="line"><span class="comment">// 数组定义方式2：泛型方式</span></span><br><span class="line"><span class="comment">// let 变量名: Array&lt;数据类型&gt; = [值1，值2]</span></span><br><span class="line"><span class="keyword">let</span> arr2: <span class="built_in">Array</span>&lt;number&gt; = [<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr2);</span><br></pre></td></tr></table></figure><p>数组定义后，里面的数据的类型必须和定义数组的时候的类型是一致的，否则有错误提示信息，也不会编译通过的</p><h5 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 元组类型：在定义数组的时候，类型和数据的个数一开始就已经限定了</span></span><br><span class="line"><span class="keyword">let</span> arr3: [string, number, boolean] = [<span class="string">&quot;张艺兴&quot;</span>, <span class="number">18.232</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br></pre></td></tr></table></figure><p>注意问题：元组类型在使用的时候，数据的类型的位置和数据的个数 应该和在定义元组时的数据类型及位置应该是一致的</p><h5 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h5><p><code>enum</code> 类型是对 JavaScript 标准数据类型的一个补充。 使用枚举类型可以为一组数值赋予友好的名字。</p><p>枚举里面的每个数据值都可以叫元素，每个元素都有自己的编号，编号是默认从 0 开始的，依次递增加 1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">enum Color &#123;</span><br><span class="line">    <span class="comment">// 枚举中的元素可以是中文的数据值，但是不推荐</span></span><br><span class="line">    red = <span class="number">2</span>,</span><br><span class="line">    green,</span><br><span class="line">    blue</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个 Color  的枚举类型的变量来接受枚举的值</span></span><br><span class="line"><span class="keyword">let</span> color: Color = Color.red</span><br><span class="line"><span class="built_in">console</span>.log(color); <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">console</span>.log(Color.red, Color.green, Color.blue); <span class="comment">// 2 3 4</span></span><br><span class="line"><span class="built_in">console</span>.log(Color[<span class="number">3</span>]); <span class="comment">// green</span></span><br></pre></td></tr></table></figure><h5 id="any"><a href="#any" class="headerlink" title="any"></a>any</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> str: any = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 100</span></span><br><span class="line">str = <span class="string">&quot;年少不知富婆好，错把少女当成宝&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 年少不知富婆好，错把少女当成宝</span></span><br><span class="line"><span class="comment">// 当一个数组中要存储多个数据，个数不确定，类型不确定，此时也可以使用 any 类型来定义数组</span></span><br><span class="line"><span class="keyword">let</span> arr: any[] = [<span class="number">100</span>, <span class="string">&quot;张艺兴&quot;</span>, <span class="literal">true</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr); <span class="comment">// [100, &quot;张艺兴&quot;, true]</span></span><br><span class="line"><span class="comment">// 这种情况下也没有错误的提示信息</span></span><br><span class="line"><span class="comment">// console.log(arr[0].split(&#x27;&#x27;)); // 报错</span></span><br></pre></td></tr></table></figure><h5 id="void"><a href="#void" class="headerlink" title="void"></a>void</h5><p>在函数声明的时候，小括号的后面使用 :void ，代表的时该函数没有任何的返回值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;只要富婆把握住，连夜搬进大别墅&quot;</span>);</span><br><span class="line">  <span class="comment">// return null // 可行</span></span><br><span class="line">&#125;</span><br><span class="line">showMsg();</span><br><span class="line"><span class="built_in">console</span>.log(showMsg()); <span class="comment">// undifined</span></span><br><span class="line"><span class="comment">// 定义 void 类型的值，可以接收一个 undefined 的值，但是意义不大</span></span><br><span class="line"><span class="keyword">let</span> vd: <span class="keyword">void</span> = <span class="literal">undefined</span>;</span><br><span class="line"><span class="built_in">console</span>.log(vd); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><h5 id="object"><a href="#object" class="headerlink" title="object"></a>object</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数 参数是 object 类型，返回值也是 object 类型</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getObj</span>(<span class="params">obj: object</span>): <span class="title">object</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(obj);</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getObj(&#123; <span class="attr">name</span>: <span class="string">&quot;张宝文&quot;</span>, <span class="attr">age</span>: <span class="string">&quot;男&quot;</span> &#125;)); <span class="comment">// 必须参函数，且是对象类型</span></span><br><span class="line"><span class="comment">// console.log(getObj(&#x27;123&#x27;)) // 错误</span></span><br><span class="line"><span class="built_in">console</span>.log(getObj(<span class="built_in">String</span>)); <span class="comment">// 可以通过</span></span><br></pre></td></tr></table></figure><h5 id="联合类型"><a href="#联合类型" class="headerlink" title="联合类型"></a>联合类型</h5><p>联合类型（Union Types）表示取值可以为多种类型中的一种</p><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求1: 定义一个一个函数得到一个数字或字符串值的字符串形式值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">str: number | string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str.toString();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getString(<span class="number">123</span>)); <span class="comment">// &#x27;123&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(getString(<span class="string">&quot;123&quot;</span>)); <span class="comment">// &#x27;123&#x27;</span></span><br></pre></td></tr></table></figure><h5 id="类型断言"><a href="#类型断言" class="headerlink" title="类型断言"></a>类型断言</h5><p>通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。 类型断言好比其它语言里的类型转换，但是不进行特殊的数据检查和解构。 它没有运行时的影响，只是在编译阶段起作用。 TypeScript 会假设你，程序员，已经进行了必须的检查。</p><p>类型断言有两种形式。 其一是 <code>&lt;&gt;</code> 语法, 另一个为 <code>as</code> 语法</p><p><code>(&lt;string&gt;str)</code> &amp; <code>(str as string)</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getString</span>(<span class="params">str:number|string</span>):<span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="comment">// return str.toString().length</span></span><br><span class="line">    <span class="comment">// 如果说str本身就是string类型的,就没有必要toString()方法</span></span><br><span class="line">    <span class="keyword">if</span> ((&lt;string&gt;str).length) &#123;</span><br><span class="line">        <span class="comment">// str.length存在</span></span><br><span class="line">        <span class="keyword">return</span> (str <span class="keyword">as</span> string).length</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 此时说明str是number类型</span></span><br><span class="line">        <span class="keyword">return</span> str.toString().length</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(getString(<span class="number">12345</span>)) <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">console</span>.log(getString(<span class="string">&#x27;0123456&#x27;</span>)) <span class="comment">// 7</span></span><br></pre></td></tr></table></figure><h5 id="类型推断"><a href="#类型推断" class="headerlink" title="类型推断"></a>类型推断</h5><p>TS 会在没有明确的指定类型的时候推测出一个类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> txt = <span class="number">100</span>; <span class="comment">// number类型</span></span><br><span class="line">txt = <span class="string">&quot;张艺兴&quot;</span>; <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">console</span>.log(txt);</span><br></pre></td></tr></table></figure><img src="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/image-20210625151306764.png" class><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> txt2; <span class="comment">// any类型</span></span><br><span class="line">txt2 = <span class="number">100</span>;</span><br><span class="line">txt2 = <span class="string">&quot;张艺兴&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(txt2); <span class="comment">// undefined -&gt; 100 -&gt; 张艺兴</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>TypeScript 的核心原则之一是对值所具有的结构进行类型检查。我们使用接口（Interfaces）来定义对象的类型。</p><p>接口是对象的状态(属性)和行为(方法)的抽象(描述)</p><h5 id="接口试探"><a href="#接口试探" class="headerlink" title="接口试探"></a>接口试探</h5><ul><li>只读：前面添加 readonly</li><li>可有可无：后面跟上 ?</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// 需求: 创建人的对象, 需要对人的属性进行一定的约束</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// id是number类型, 必须有, 只读的</span></span><br><span class="line">    <span class="comment">// name是string类型, 必须有</span></span><br><span class="line">    <span class="comment">// age是number类型, 必须有</span></span><br><span class="line">    <span class="comment">// sex是string类型, 可以没有</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个接口类型,该接口作为person的类型使用,限定或者是约束该对象中的属性数据</span></span><br><span class="line">    interface IPerson &#123;</span><br><span class="line">        <span class="comment">// id 是只读的  ------&gt; readonly 而不是 const</span></span><br><span class="line">        readonly id:number,</span><br><span class="line">        <span class="attr">name</span>:string,</span><br><span class="line">        <span class="attr">age</span>:number,</span><br><span class="line">        <span class="comment">// sex 可有可无 ------&gt; ?</span></span><br><span class="line">        sex?:string</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义一个对象,该对象的类型就是我定义的接口 IPerson</span></span><br><span class="line">    <span class="keyword">const</span> person:IPerson = &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;张艺兴&#x27;</span>,</span><br><span class="line">        <span class="attr">age</span>: <span class="number">18</span></span><br><span class="line">        <span class="comment">// sex: &#x27;男&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(person)</span><br><span class="line">    <span class="comment">// id属性现在是可读可写 要加 readonly属性</span></span><br><span class="line">    <span class="comment">// person.id = 100</span></span><br><span class="line">    person.sex = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">    <span class="built_in">console</span>.log(person)</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><h5 id="函数类型"><a href="#函数类型" class="headerlink" title="函数类型"></a>函数类型</h5><p>为了使用接口表示函数类型，我们需要给接口定义一个调用签名。它就像是一个只有参数列表和返回值类型的函数定义。参数列表里的每个参数都需要名字和类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数类型：通过接口的方式作为函数的类型来使用</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个接口，用来作为某个函数的类型使用</span></span><br><span class="line">interface ISearchFunc &#123;</span><br><span class="line">  <span class="comment">// 定义一个调用签名</span></span><br><span class="line">  (source: string, <span class="attr">subString</span>: string): boolean;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个函数，该类型就是上面定义的接口</span></span><br><span class="line"><span class="keyword">const</span> seachString: ISearchFunc = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  source: string,</span></span></span><br><span class="line"><span class="params"><span class="function">  subString: string</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">boolean</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 在 source 字符串中查找 substring 这个字符串</span></span><br><span class="line">  <span class="keyword">return</span> source.search(subString) &gt; -<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用函数</span></span><br><span class="line"><span class="built_in">console</span>.log(seachString(<span class="string">&quot;哈哈，我又变帅了&quot;</span>, <span class="string">&quot;帅&quot;</span>));</span><br></pre></td></tr></table></figure><h5 id="类类型"><a href="#类类型" class="headerlink" title="类类型"></a>类类型</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个接口</span></span><br><span class="line">interface IFly &#123;</span><br><span class="line">    <span class="comment">// 该方法没有任何的实现（方法中什么都没有）</span></span><br><span class="line">    fly()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类，这个类的类型就是上面的接口（实际上也可以理解为，IFly接口约束了当前这个Person类）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="title">implements</span> <span class="title">IFly</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">    <span class="function"><span class="title">fly</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会飞了，我是超人&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person()</span><br><span class="line">person.fly()</span><br></pre></td></tr></table></figure><h6 id="一个类可以实现多个接口"><a href="#一个类可以实现多个接口" class="headerlink" title="一个类可以实现多个接口"></a>一个类可以实现多个接口</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 再定义一个接口</span></span><br><span class="line">interface ISwim &#123;</span><br><span class="line">    swim()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类，这个类的类型就是Ifly和Iswim（当前这个类可以实现多个接口,一个类也可以同时被多个接口进行约束）</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span> <span class="title">implements</span> <span class="title">IFly</span>,<span class="title">ISwim</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 实现接口中的方法</span></span><br><span class="line">    <span class="function"><span class="title">fly</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我飞了2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="title">swim</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;我会游泳2&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> person2 = <span class="keyword">new</span> Person2()</span><br><span class="line">person2.fly()</span><br><span class="line">person2.swim()</span><br></pre></td></tr></table></figure><h6 id="接口继承接口"><a href="#接口继承接口" class="headerlink" title="接口继承接口"></a>接口继承接口</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义了一个接口，继承其他的多个接口</span></span><br><span class="line">interface IMyFlyAndSwim <span class="keyword">extends</span> IFly, ISwim &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个类，直接实现这个接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person3</span> <span class="title">implements</span> <span class="title">IMyFlyAndSwim</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">fly</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我飞了3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">swim</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我会游泳3&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person3 = <span class="keyword">new</span> Person3();</span><br><span class="line">person3.fly();</span><br><span class="line">person3.swim();</span><br></pre></td></tr></table></figure><p>总结</p><ul><li>定义接口（使用的是 interface 关键字）</li><li>接口和接口之间叫继承（使用的是 extends 关键字）</li><li>类和接口之间叫实现（使用的是 implements 关键字）</li></ul><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ts 中类的定义及使用</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义属性</span></span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  age: number;</span><br><span class="line">  gender: string;</span><br><span class="line">  <span class="comment">// 定义构造函数：未来将来实例化对象的时候，可以直接对属性的值进行初始化</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">    name: string = <span class="string">&quot;张艺兴&quot;</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    age: number = <span class="number">18</span>,</span></span></span><br><span class="line"><span class="params"><span class="function">    gender: string = <span class="string">&quot;男&quot;</span></span></span></span><br><span class="line"><span class="params"><span class="function">  </span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 更新对象中的属性数据</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.gender = gender;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义实例方法</span></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params">str: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(</span><br><span class="line">      <span class="string">`大家好，我是<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>，今年已经<span class="subst">$&#123;<span class="built_in">this</span>.age&#125;</span>岁了，是个<span class="subst">$&#123;<span class="built_in">this</span>.gender&#125;</span>生，`</span> +</span><br><span class="line">        str</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ts 中使用类，实例化对象，可以直接进行初始化操作</span></span><br><span class="line"><span class="keyword">const</span> person = <span class="keyword">new</span> Person(<span class="string">&quot;张宝文&quot;</span>, <span class="number">19</span>);</span><br><span class="line">person.sayHi(<span class="string">&quot;你叫什么？&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类，继承自上方Person</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number, gender: string</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用的是父类中的构造函数，使用的super</span></span><br><span class="line">    <span class="built_in">super</span>(name, age, gender);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以调用父类中的方法</span></span><br><span class="line">  <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;我是学生类中的sayHi方法&quot;</span>);</span><br><span class="line">    <span class="comment">// 带哦用父类中的sayHi方法</span></span><br><span class="line">    <span class="built_in">super</span>.sayHi(<span class="string">&quot;你呢&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 Student</span></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> Student(<span class="string">&quot;郑佳丽&quot;</span>, <span class="number">19</span>, <span class="string">&quot;女&quot;</span>);</span><br><span class="line">student.sayHi();</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>类和类之间如果要有继承关系，需要使用 extends 关键字</li><li>子类中可以调用父类中的构造函数，调用的是 super 关键字（包括调用父类中的实例方法，也可以使用 super）</li><li>子类中可以重写父类中的方法</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>父类型的引用指向子类型的对象，不同类型的对象针对相同的方法，产生不同的行为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个父类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义一个属性</span></span><br><span class="line">  <span class="attr">name</span>: string;</span><br><span class="line">  <span class="comment">// 定义一个构造函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 初始化（更新属性值）</span></span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">distance: number = <span class="number">0</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>跑了<span class="subst">$&#123;distance&#125;</span>米这么远的距离`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数，实现子类属性的初始化操作</span></span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法，重写父类中的实例方法</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">distance: number = <span class="number">5</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>跑了<span class="subst">$&#123;distance&#125;</span>米这么远的距离`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个子类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Pig</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name: string</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 调用父类的构造函数，实现子类属性的初始化操作</span></span><br><span class="line">    <span class="built_in">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 实例方法，重写父类中的实例方法</span></span><br><span class="line">  <span class="function"><span class="title">run</span>(<span class="params">distance: number = <span class="number">10</span></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;<span class="built_in">this</span>.name&#125;</span>跑了<span class="subst">$&#123;distance&#125;</span>米这么远的距离`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化父类对象</span></span><br><span class="line"><span class="keyword">const</span> animal: Animal = <span class="keyword">new</span> Animal(<span class="string">&quot;动物&quot;</span>);</span><br><span class="line">animal.run();</span><br><span class="line"><span class="comment">// 实例化子类对象</span></span><br><span class="line"><span class="keyword">const</span> dog: Dog = <span class="keyword">new</span> Dog(<span class="string">&quot;大黄&quot;</span>);</span><br><span class="line">dog.run();</span><br><span class="line"><span class="comment">// 实例化子类对象</span></span><br><span class="line"><span class="keyword">const</span> pig: Pig = <span class="keyword">new</span> Pig(<span class="string">&quot;乔治&quot;</span>);</span><br><span class="line">pig.run();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"><span class="comment">// 父类和子类的关系：父子关系，此时，父类类型创建子类的对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> dog1: Animal = <span class="keyword">new</span> Dog(<span class="string">&quot;小黄&quot;</span>);</span><br><span class="line">dog1.run();</span><br><span class="line"><span class="keyword">const</span> pig1: Animal = <span class="keyword">new</span> Pig(<span class="string">&quot;佩奇&quot;</span>);</span><br><span class="line">pig1.run();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;====================&quot;</span>);</span><br><span class="line"><span class="comment">// 该函数需要的参数是 Animal 类型的</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showRun</span>(<span class="params">animal: Animal</span>) </span>&#123;</span><br><span class="line">  animal.run();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showRun(dog1);</span><br><span class="line">showRun(pig1);</span><br></pre></td></tr></table></figure><h4 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h4><p>修饰符(类中的成员的修饰符)：主要是描述类中的成员(属性，构造函数，方法)的可访问性</p><h5 id="public"><a href="#public" class="headerlink" title="public"></a>public</h5><p>公共的</p><p>类中的成员都有自己默认的访问修饰符 public</p><p>类中的成员默认的修饰符，代表的是公共的，任何位置都可以访问类中的成员</p><h5 id="private"><a href="#private" class="headerlink" title="private"></a>private</h5><p>私有的</p><p>外部无法访问这个成员数据，子类中也无法访问</p><h5 id="protected"><a href="#protected" class="headerlink" title="protected"></a>protected</h5><p>受保护的</p><p>外部无法访问这个成员数据，子类可访问</p><h5 id="readonly"><a href="#readonly" class="headerlink" title="readonly"></a>readonly</h5><p>只读的</p><p>可以对类中的属性成员进行修饰，该属性成员，就不能再外部被随意的修改了</p><ul><li>构造函数中可以对只读的属性成员的数据进行修改</li><li>如果构造函数中没有任何的参数，类中的属性成员此时使用 readonly 进行修饰了，那么外部也是不能对这个属性值进行更改的</li><li>构造函数中的参数可以使用 readonly 进行修饰,一旦修饰,那么该类中就有了这个只读的成员属性了,外部可以访问,但是不能修改</li><li>构造函数中的参数可以使用 public 及 private 及 protected 进行修饰,无论是哪个进行修饰,那么该类中都会自动的添加这么一个属性成员</li></ul><h4 id="存储器-get-set"><a href="#存储器-get-set" class="headerlink" title="存储器(get set)"></a>存储器(get set)</h4><p>TypeScript 支持通过 <code>getters/setters</code> 来截取对对象成员的访问。</p><p>让我们可以有效的控制对对象成员的访问,通过 getters 和 setters 来进行操作</p><p>例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部可以传入姓氏和名字数据,同时使用set和get控制姓名的数据,外部也可以修改操作</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">  <span class="attr">firstName</span>: string; <span class="comment">// 姓氏</span></span><br><span class="line">  lastName: string; <span class="comment">// 名字</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">firstName: string, lastName: string</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.firstName = firstName;</span><br><span class="line">    <span class="built_in">this</span>.lastName = lastName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 姓名的成员属性(外部可以访问,也可以修改)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 读取器 ------&gt; 负责读取数据</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">fullName</span>() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;get中...&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&quot;_&quot;</span> + <span class="built_in">this</span>.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 设置器 ------&gt; 负责修改数据</span></span><br><span class="line">  <span class="keyword">set</span> <span class="title">fullName</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;set中...&quot;</span>);</span><br><span class="line">    <span class="keyword">let</span> names = val.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    <span class="built_in">this</span>.firstName = names[<span class="number">0</span>];</span><br><span class="line">    <span class="built_in">this</span>.lastName = names[<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化对象</span></span><br><span class="line"><span class="keyword">const</span> person: Person = <span class="keyword">new</span> Person(<span class="string">&quot;东方&quot;</span>, <span class="string">&quot;不败&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br><span class="line"><span class="comment">// 获取该属性成员数据</span></span><br><span class="line"><span class="built_in">console</span>.log(person.fullName);</span><br><span class="line"><span class="comment">// 设置该属性的数据</span></span><br><span class="line">person.fullName = <span class="string">&quot;诸葛_孔明&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(person);</span><br></pre></td></tr></table></figure><img src="/2021/07/30/TypeScript%E7%AC%94%E8%AE%B0/image-20210625193104527.png" class><h4 id="静态属性-static"><a href="#静态属性-static" class="headerlink" title="静态属性(static)"></a>静态属性(static)</h4><p>静态成员:在类中通过 static 修饰的属性或方法,就是静态的属性及方法</p><p>静态成员在使用时是通过 类名. 的这种做法来调用的</p><h4 id="抽象类-abstract"><a href="#抽象类-abstract" class="headerlink" title="抽象类(abstract)"></a>抽象类(abstract)</h4><p>含抽象方法（抽象方法一般没有任何的具体内容的实现），也可以包含实例方法，抽象类是不能被实例化的,为了让子类进行实例化及实现内部的抽象方法</p><p>抽象类的目的或者是作用都是为子类服务的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类</span></span><br><span class="line">abstract <span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 抽象属性 一般不这么实现</span></span><br><span class="line">    <span class="comment">// abstract name:string</span></span><br><span class="line">    <span class="comment">// 抽象方法</span></span><br><span class="line">    abstract eat()</span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="function"><span class="title">sayHi</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;您好啊&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个子类（派生类）Dog</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">    <span class="comment">// name:string = &#x27;Lay&#x27;</span></span><br><span class="line">    <span class="comment">// 重新的实现抽象类中的方法，此时这个方法就是当前抽象类的实例方法了</span></span><br><span class="line">    <span class="function"><span class="title">eat</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;舔着吃，真好吃&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化 Dog 的对象</span></span><br><span class="line"><span class="keyword">const</span> dog:Dog = <span class="keyword">new</span> Dog()</span><br><span class="line">dog.eat()</span><br><span class="line"><span class="comment">// 调用的是抽象类中的实例方法</span></span><br><span class="line">dog.sayHi()</span><br><span class="line"><span class="comment">// console.log(dog.name);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不能实例化抽象类的对象</span></span><br><span class="line"><span class="comment">// const ani:Animal = new Animal()</span></span><br></pre></td></tr></table></figure><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="基本写法"><a href="#基本写法" class="headerlink" title="基本写法"></a>基本写法</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明，命名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: string, y: string</span>): <span class="title">string</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 求和的函数</span></span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result1: string = add(<span class="string">&quot;111&quot;</span>, <span class="string">&quot;222&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result1); <span class="comment">// &#x27;111222&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式，匿名函数</span></span><br><span class="line"><span class="keyword">const</span> add2 = <span class="function"><span class="keyword">function</span> (<span class="params">x: number, y: number</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> result2: number = add2(<span class="number">111</span>, <span class="number">222</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result2); <span class="comment">// 333</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数的完整写法</span></span><br><span class="line"><span class="comment">// add3 ----&gt; 变量名 ----&gt; 函数add3</span></span><br><span class="line"><span class="comment">// (x:number, y:number) =&gt; number 当前这个函数的类型</span></span><br><span class="line"><span class="comment">// function (x:number, y:number):number &#123; return x + y &#125; 相当于上面的这个函数类型的值</span></span><br><span class="line"><span class="keyword">const</span> add3: <span class="function">(<span class="params">x: number, y: number</span>) =&gt;</span> number = <span class="function"><span class="keyword">function</span> (<span class="params"></span></span></span><br><span class="line"><span class="params"><span class="function">  x: number,</span></span></span><br><span class="line"><span class="params"><span class="function">  y: number</span></span></span><br><span class="line"><span class="params"><span class="function"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> result3: number = add3(<span class="number">10</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">console</span>.log(result3); <span class="comment">// 11</span></span><br></pre></td></tr></table></figure><h4 id="可选参数和默认参数"><a href="#可选参数和默认参数" class="headerlink" title="可选参数和默认参数"></a>可选参数和默认参数</h4><ul><li>可选参数:函数在声明时,内部的函数使用了 <code>?</code> 进行修饰,就表示该参数可以传入也可以不传入</li><li>默认参数:函数在声明的时候,内部的参数有自己的默认值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数:传入姓氏和名字,可以得到姓名</span></span><br><span class="line"><span class="comment">// 需求:如果不传入任何内容,那么就返回默认的姓氏</span></span><br><span class="line"><span class="comment">// 如果只传入姓氏,那么就返回姓氏</span></span><br><span class="line"><span class="comment">// 如果传入姓氏和名字,那么返回来的就是姓名</span></span><br><span class="line"><span class="keyword">const</span> getFullName = <span class="function"><span class="keyword">function</span> (<span class="params">firstName: string = <span class="string">&quot;东方&quot;</span>, lastName?: string</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断名字是否传入</span></span><br><span class="line">  <span class="keyword">if</span> (lastName) &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName + <span class="string">&quot;_&quot;</span> + lastName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> firstName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="built_in">console</span>.log(getFullName(<span class="string">&quot;张&quot;</span>, <span class="string">&quot;艺兴&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>剩余参数(rest 参数)是放在函数声明的时候所有的参数最后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...args:string[] ----&gt; 剩余的参数是放在了一个字符串的数组当中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showMsg</span>(<span class="params">str: string, ...args: string[]</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(str);</span><br><span class="line">  <span class="built_in">console</span>.log(args);</span><br><span class="line">&#125;</span><br><span class="line">showMsg(<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;c&quot;</span>, <span class="string">&quot;d&quot;</span>, <span class="string">&quot;e&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="函数重载"><a href="#函数重载" class="headerlink" title="函数重载"></a>函数重载</h4><p>函数名字相同,函数的参数及个数不同</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个函数</span></span><br><span class="line"><span class="comment">// 需求: 我们有一个add函数，它可以接收2个string类型的参数进行拼接，也可以接收2个number类型的参数进行相加</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载声明</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: string, y: string</span>): <span class="title">string</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: number, y: number</span>): <span class="title">number</span></span></span></span><br><span class="line"><span class="function"><span class="function"></span></span></span><br><span class="line"><span class="function"><span class="function">// 函数声明</span></span></span><br><span class="line"><span class="function"><span class="function"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x: string | number, y: string | number</span>): <span class="title">string</span> | <span class="title">number</span> </span>&#123;</span></span></span><br><span class="line"><span class="function"><span class="function">    <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === <span class="string">&#x27;string&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;string&#x27;</span></span>) </span>&#123;</span></span><br><span class="line"><span class="function">        <span class="title">return</span> <span class="title">x</span> + <span class="title">y</span> // 字符串拼接</span></span><br><span class="line"><span class="function">    &#125; <span class="title">else</span> <span class="title">if</span> (<span class="params"><span class="keyword">typeof</span> x === <span class="string">&#x27;number&#x27;</span> &amp;&amp; <span class="keyword">typeof</span> y === <span class="string">&#x27;number&#x27;</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y <span class="comment">// 数组相加</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="comment">// 两个参数都是字符串</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="string">&#x27;张&#x27;</span>, <span class="string">&#x27;艺兴&#x27;</span>))</span><br><span class="line"><span class="comment">// 两个参数都是数字</span></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">10</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// 如果传入的是非法的数据, ts 应该给我提示出错误的信息内容</span></span><br><span class="line"><span class="comment">// console.log(add(&#x27;张&#x27;, 13))</span></span><br><span class="line"><span class="comment">// console.log(add(14, &#x27;13&#x27;))</span></span><br></pre></td></tr></table></figure><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>在定义函数、接口、类的时候不能预先确定要使用的数据的类型，而是在使用函数、接口、类的时候才能确定数据的类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：定义一个函数，传入两个参数，第一参数是数据。第二参数是数量，函数的作用是根据数量产生对应个数的数据，存放在以一个数组中</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getArr4</span>&lt;<span class="title">T</span>&gt;(<span class="params">value: T, count: number</span>): <span class="title">T</span>[] </span>&#123;</span><br><span class="line">  <span class="comment">// 根据数据和数量产生一个数组</span></span><br><span class="line">  <span class="comment">// const arr : T[] = []</span></span><br><span class="line">  <span class="keyword">const</span> arr: <span class="built_in">Array</span>&lt;T&gt; = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">    arr.push(value);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> arr3 = getArr4 &lt; number &gt; (<span class="number">200.12345</span>, <span class="number">5</span>);</span><br><span class="line"><span class="keyword">const</span> arr4 = getArr4 &lt; string &gt; (<span class="string">&quot;AgoniLay&quot;</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">console</span>.log(arr3);</span><br><span class="line"><span class="built_in">console</span>.log(arr4);</span><br><span class="line"><span class="comment">// // arr3中存储的是数字类型的数据</span></span><br><span class="line"><span class="comment">// // arr4中存储的是字符串类型的数据</span></span><br><span class="line"><span class="built_in">console</span>.log(arr3[<span class="number">0</span>].toFixed(<span class="number">3</span>));</span><br><span class="line"><span class="built_in">console</span>.log(arr4[<span class="number">0</span>].split(<span class="string">&quot;&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="多个泛型参数的函数"><a href="#多个泛型参数的函数" class="headerlink" title="多个泛型参数的函数"></a>多个泛型参数的函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getMsg</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;(<span class="params">value1: K, value2: V</span>): [<span class="title">K</span>, <span class="title">V</span>] </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> [value1, value2]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr1 = getMsg&lt;string,number&gt;(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">100</span>)</span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">0</span>].split(<span class="string">&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">console</span>.log(arr1[<span class="number">1</span>].toFixed(<span class="number">2</span>))</span><br></pre></td></tr></table></figure><h4 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h4><p>在定义接口时, 为接口中的属性或方法定义泛型类型，在使用接口时, 再指定具体的泛型类型</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：定义一个类，用来存储用户的相关信息（id，名字，年龄）</span></span><br><span class="line"><span class="comment">// 通过一个类的实例对象调用 add 方法可以添加多个用户信息对象，调用 getUserId 可以根据id 获取某个指定的用户信息对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个泛型接口</span></span><br><span class="line">interface IBaseCRUD&lt;T&gt; &#123;</span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">Array</span>&lt;T&gt;</span><br><span class="line">    add: <span class="function">(<span class="params">t: T</span>) =&gt;</span> T</span><br><span class="line">    <span class="attr">getUserId</span>: <span class="function">(<span class="params">id: number</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个用户信息的类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    id?: number  <span class="comment">// 用户的id</span></span><br><span class="line">    <span class="attr">name</span>: string  <span class="comment">// 用户的姓名</span></span><br><span class="line">    <span class="attr">age</span>: number  <span class="comment">// 用户的年龄</span></span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params">name: string, age: number</span>)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name</span><br><span class="line">        <span class="built_in">this</span>.age = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义一个类，可以针对用户的信息对象进行增加及查询的操作</span></span><br><span class="line"><span class="comment">// CRUD ----&gt; Create Read Update Delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UserCRUD</span> <span class="title">implements</span> <span class="title">IBaseCRUD</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 用来保存多个 User 类型的用户信息对象</span></span><br><span class="line">    <span class="attr">data</span>: <span class="built_in">Array</span>&lt;User&gt; = []</span><br><span class="line">    <span class="comment">// 方法用来存储用户信息对象的</span></span><br><span class="line">    add(user: User): User &#123;</span><br><span class="line">        <span class="comment">// 产生 id</span></span><br><span class="line">        user.id = <span class="built_in">Date</span>.now() + <span class="built_in">Math</span>.random()</span><br><span class="line">        <span class="comment">// 把用户信息对象添加到data数组中</span></span><br><span class="line">        <span class="built_in">this</span>.data.push(user)</span><br><span class="line">        <span class="keyword">return</span> user</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据id查询指定的用户信息对象</span></span><br><span class="line">    getUserId(id: number): User &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.data.find(<span class="function"><span class="params">user</span> =&gt;</span> user.id === id)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化添加用户信息对象的类 UserCRUD</span></span><br><span class="line"><span class="keyword">const</span> userCRUD: UserCRUD = <span class="keyword">new</span> UserCRUD()</span><br><span class="line">userCRUD.add(<span class="keyword">new</span> User(<span class="string">&#x27;agoni&#x27;</span>, <span class="number">20</span>))</span><br><span class="line">userCRUD.add(<span class="keyword">new</span> User(<span class="string">&#x27;lay&#x27;</span>, <span class="number">18</span>))</span><br><span class="line"><span class="keyword">const</span> &#123;id&#125; = userCRUD.add(<span class="keyword">new</span> User(<span class="string">&#x27;Lay&#x27;</span>, <span class="number">18</span>))</span><br><span class="line">userCRUD.add(<span class="keyword">new</span> User(<span class="string">&#x27;AgoniLay&#x27;</span>, <span class="number">19</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(userCRUD.data)</span><br><span class="line"><span class="comment">// 根据 id 查询用户信息对象数据</span></span><br><span class="line"><span class="keyword">const</span> user = userCRUD.getUserId(id)</span><br><span class="line"><span class="built_in">console</span>.log(user)</span><br></pre></td></tr></table></figure><h4 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个类，类中的属性值是不确定的，方法中的参数及返回值的类型也是不确定的</span></span><br><span class="line"><span class="comment">// 定义一个泛型类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericNumber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 默认的属性的值的类型是泛型类型</span></span><br><span class="line">    <span class="attr">defaultValue</span>: T</span><br><span class="line">    <span class="attr">add</span>: <span class="function">(<span class="params">x: T, y: T</span>) =&gt;</span> T</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例化类的对象的时候，再确定泛型的类型</span></span><br><span class="line"><span class="keyword">const</span> g1: GenericNumber&lt;number&gt; = <span class="keyword">new</span> GenericNumber&lt;number&gt;()</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line">g1.defaultValue = <span class="number">100</span></span><br><span class="line"><span class="comment">// 相加的方法</span></span><br><span class="line">g1.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g1.add(g1.defaultValue, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在实例化类的对象的时候，再确定泛型的类型</span></span><br><span class="line"><span class="keyword">const</span> g2: GenericNumber&lt;string&gt; = <span class="keyword">new</span> GenericNumber&lt;string&gt;()</span><br><span class="line"><span class="comment">// 设置属性值</span></span><br><span class="line">g2.defaultValue = <span class="string">&#x27;哈哈&#x27;</span></span><br><span class="line"><span class="comment">// 相加的方法</span></span><br><span class="line">g2.add = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(g2.add(<span class="string">&#x27;Agoni&#x27;</span>, <span class="string">&#x27;Lay&#x27;</span>))</span><br></pre></td></tr></table></figure><h4 id="泛型约束"><a href="#泛型约束" class="headerlink" title="泛型约束"></a>泛型约束</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果我们直接对一个泛型参数取 length 属性, 会报错, 因为这个泛型根本就不知道它有这个属性</span></span><br><span class="line"><span class="comment">// 定义一个接口,用来约束将来的某个类型中必须要有 length 这个属性</span></span><br><span class="line">interface ILength &#123;</span><br><span class="line">    <span class="comment">// 接口中有一个属性 length</span></span><br><span class="line">    <span class="attr">length</span>: number</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLength</span>&lt;<span class="title">T</span> <span class="title">extends</span> <span class="title">ILength</span>&gt;(<span class="params">x: T</span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x.length</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(getLength&lt;string&gt;(<span class="string">&#x27;How are you&#x27;</span>))</span><br><span class="line"><span class="comment">// console.log(getLength&lt;number&gt;(123))</span></span><br></pre></td></tr></table></figure><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><h4 id="声明文件"><a href="#声明文件" class="headerlink" title="声明文件"></a>声明文件</h4><h5 id="例：jQuery"><a href="#例：jQuery" class="headerlink" title="例：jQuery"></a>例：jQuery</h5><p>当使用第三方库时，我们需要引用它的声明文件，才能获得对应的代码补全、接口提示等功能。</p><h6 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句:"></a>声明语句:</h6><p>如果需要 ts 对新的语法进行检查, 需要要加载了对应的类型说明代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">declare <span class="keyword">var</span> jQuery: <span class="function">(<span class="params">selector: string</span>) =&gt;</span> any;</span><br></pre></td></tr></table></figure><h6 id="声明文件-1"><a href="#声明文件-1" class="headerlink" title="声明文件:"></a>声明文件:</h6><p>把声明语句放到一个单独的文件（jQuery.d.ts）中, ts 会自动解析到项目中所有声明文件</p><p>下载自动识别的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装 jquery</span></span><br><span class="line">npm i jquery</span><br><span class="line"><span class="comment">// 安装声明文件</span></span><br><span class="line">npm i @types/jquery --save-dev</span><br></pre></td></tr></table></figure><h4 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h4><p>JavaScript 中有很多内置对象，它们可以直接在 TypeScript 中当做定义好了的类型。</p><p>内置对象是指根据标准在全局作用域（Global）上存在的对象。这里的标准是指 ECMAScript 和其他环境（比如 DOM）的标准。</p><h5 id="ECMAScript-的内置对象"><a href="#ECMAScript-的内置对象" class="headerlink" title="ECMAScript 的内置对象"></a>ECMAScript 的内置对象</h5><ul><li>Boolean</li><li>Number</li><li>String</li><li>Date</li><li>RegExp</li><li>Error</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 1. ECMAScript 的内置对象 */</span></span><br><span class="line"><span class="keyword">let</span> b: <span class="built_in">Boolean</span> = <span class="keyword">new</span> <span class="built_in">Boolean</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">let</span> n: <span class="built_in">Number</span> = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">let</span> s: <span class="built_in">String</span> = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> d: <span class="built_in">Date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="keyword">let</span> r: <span class="built_in">RegExp</span> = <span class="regexp">/^1/</span>;</span><br><span class="line"><span class="keyword">let</span> e: <span class="built_in">Error</span> = <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;error message&quot;</span>);</span><br><span class="line">b = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// let bb: boolean = new Boolean(2)  // error</span></span><br></pre></td></tr></table></figure><h5 id="BOM-和-DOM-的内置对象"><a href="#BOM-和-DOM-的内置对象" class="headerlink" title="BOM 和 DOM 的内置对象"></a>BOM 和 DOM 的内置对象</h5><ul><li>Window</li><li>Document</li><li>HTMLElement</li><li>DocumentFragment</li><li>Event</li><li>NodeList</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> div: HTMLElement = <span class="built_in">document</span>.getElementById(<span class="string">&quot;test&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> divs: NodeList = <span class="built_in">document</span>.querySelectorAll(<span class="string">&quot;div&quot;</span>);</span><br><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">&quot;click&quot;</span>, <span class="function">(<span class="params">event: MouseEvent</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.dir(event.target);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">const</span> fragment: DocumentFragment = <span class="built_in">document</span>.createDocumentFragment();</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> TypeScript </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php笔记</title>
      <link href="/2021/07/29/php%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/29/php%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="错误解决"><a href="#错误解决" class="headerlink" title="错误解决"></a>错误解决</h2><h4 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h4><p>开头添加：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">header(<span class="string">&quot;Content-Type: text/html; charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><h2 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h2><h4 id="什么是-PHP"><a href="#什么是-PHP" class="headerlink" title="什么是 PHP"></a>什么是 PHP</h4><h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>一种服务器端的 HTML 脚本/编程语言,是一种简单的、面向对象的、解释型的、健壮的、安全的、性能非常之高的、独立于架构的、可移植的、动态的脚本语言。是一种广泛用于 Open Source（开放源代码）的尤其适合 Web 开发并可以嵌入 HTML 的多用途脚本语言。它的语法接近 C，Java 和 Perl，而且容易学习。</p><p>该语言让 Web 开发人员快速的书写动态生成的网页</p><h5 id="前身"><a href="#前身" class="headerlink" title="前身"></a>前身</h5><p>Personal HomePage：个人主页，使用 Perl 语言开发的一种写个人主页的语言</p><p>PHP：PHP Hypertext Preprosessor， php 超文本预处理器，底层使用 C 语言</p><h4 id="PHP-发展史"><a href="#PHP-发展史" class="headerlink" title="PHP 发展史"></a>PHP 发展史</h4><p>…</p><p>平台支持（window，Linux，UNIX）</p><p>数据库支持（Sqlserver，mysql，Oracle，Access）</p><h4 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h4><h5 id="静态网站特点"><a href="#静态网站特点" class="headerlink" title="静态网站特点"></a>静态网站特点</h5><ol><li>网页内容一经发布到网站服务器上，无论是否有用户访问，每个静态网页的内容都是保存在网站服务器上的，也就是说，静态网页是实实在在保存在服务器上的文件，每个网页都是一个独立的文件；</li><li>静态网页的内容相对稳定，因此<strong>容易被搜索引擎检索</strong>；</li><li>静态网页<strong>没有数据库的支持</strong>，在网站制作和维护方面工作量较大，因此当网站信息量很大时完全依靠静态网页制作方式比较困难；</li><li>静态网页的<strong>交互性较差</strong>，在功能方面有较大的限制。</li></ol><h5 id="动态网站特点"><a href="#动态网站特点" class="headerlink" title="动态网站特点"></a>动态网站特点</h5><ol><li><p>交互性：网页会根据用户的要求和选择而动态地改变和响应，浏览器作为客户端，成为一个动态交流的桥梁，动态网页的交互性也是今后 Web 发展的潮流。</p></li><li><p>自动更新：即无须手动更新 HTML 文档，便会自动生成新页面，可以大大节省工作量。</p></li><li><p>因时因人而变：即当不同时间、不同用户访问同一网址时会出现不同页面。</p><p>此外动态网页是与静态网页相对应的，也就是说，网页 URL 的后缀不是 .htm、.html、.shtml、.xml 等静态网页的常见形式，而是以 .asp、.jsp、.php、.perl、.cgi 等形式为后缀。在动态网页网址中有一个标志性的符号——“?”</p></li></ol><h2 id="网站基本概念"><a href="#网站基本概念" class="headerlink" title="网站基本概念"></a>网站基本概念</h2><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><p>服务器：能够提供服务的机器，取决于机器上所安装的软件（服务软件）</p><p>Web 服务器：提供 web 服务（网站访问），就需要安装 web 服务软件 Apache，tomcat，iis 等</p><h4 id="IP"><a href="#IP" class="headerlink" title="IP"></a>IP</h4><p>Internet Protocol，网络之间互联协议。网络之间互连的协议也就是为计算机网络相互连接进行通信而设计的协议</p><p>IP 地址具有<strong>唯一性</strong>（每台电脑都有一个唯一的 IP 地址）</p><h4 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h4><p>Domain Name，是由一串用点分隔的名字组成（<a href="http://www.itcast.cn)的/">www.itcast.cn）的</a> Internet 上某一台计算机或计算机组的名称</p><p>一个域名的目的是便于记忆和沟通的一组服务器的地址（网站，电子邮件，FTP 等）。域名作为力所能及难忘的互联网参与者的名称</p><p>特殊 IP：127.0.0.1，代表本机</p><p>特殊域名：localhost</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>Domain Name System，域名系统</p><p>通过主机名，最终得到该主机名对应的 IP 地址的过程叫做域名解析（或主机名解析）</p><p>用户输入域名 localhost –&gt; DNS（localhost 127.0.0.1）–&gt; 服务器电脑</p><h4 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h4><p>Port，可以认为是设备与外界通讯交流的出口。端口可分为<strong>虚拟端口</strong>和<strong>物理端口</strong>，其中虚拟端口指计算机内部或交换机路由器内的端口，不可见。</p><p>用户输入域名 localhost:端口 –&gt; DNS（localhost 127.0.0.1）–&gt; 服务器电脑 –&gt; 软件（服务）</p><h2 id="Web-程序的访问流程"><a href="#Web-程序的访问流程" class="headerlink" title="Web 程序的访问流程"></a>Web 程序的访问流程</h2><p>Web 分为两类：静态网站和动态网站</p><p>浏览器发起访问 –&gt; DNS 解析域名 –&gt; 服务器电脑 –&gt; 服务软件</p><h4 id="静态网站的访问"><a href="#静态网站的访问" class="headerlink" title="静态网站的访问"></a>静态网站的访问</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627153514946.png" class><h4 id="动态网站的访问"><a href="#动态网站的访问" class="headerlink" title="动态网站的访问"></a>动态网站的访问</h4><p>动态网站访问流程与静态差不多，但是会多出几个内容：服务器端解析、数据库</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627154927756.png" class><h2 id="安装-Apache"><a href="#安装-Apache" class="headerlink" title="安装 Apache"></a>安装 Apache</h2><h4 id="安装-Apache-软件"><a href="#安装-Apache-软件" class="headerlink" title="安装 Apache 软件"></a>安装 Apache 软件</h4><ol><li><p>获取 Apache 软件</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160153744.png" class></li><li><p>双击安装即可：指定对应路径</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160215862.png" class></li><li><p>选择安装模式：使用自定义</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160314247.png" class></li><li><p>选择安装位置</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160438991.png" class></li></ol><h4 id="Apache-的目录结构说明"><a href="#Apache-的目录结构说明" class="headerlink" title="Apache 的目录结构说明"></a>Apache 的目录结构说明</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627160730828.png" class><h4 id="Httpd-exe-的详细应用"><a href="#Httpd-exe-的详细应用" class="headerlink" title="Httpd.exe 的详细应用"></a>Httpd.exe 的详细应用</h4><ol><li><p>服务器进程：运行之后才能够工作</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161153791.png" class></li><li><p>用来查看 Apache 具有哪些功能以及配置文件是否有错：httpd 或者 httpd.exe（文件所在目录）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161416719.png" class><ol><li><p>查看使用的模块：httpd.exe -M</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161553233.png" class></li><li><p>验证配置文件是否有效：httpd -t</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627161837622.png" class></li></ol></li></ol><h2 id="配置默认站点"><a href="#配置默认站点" class="headerlink" title="配置默认站点"></a>配置默认站点</h2><ol><li><p>让 Apache 确定服务器上访问的位置：网站文件夹所在位置</p><p>Httpd.conf： DocumentRoot</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627170307785.png" class></li><li><p>方便用户使用名字访问对应网站：给文件夹对应的起一个别名</p><p>Httpd.conf： ServerName</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627162507164.png" class><p>端口可以单独实现：httpd.conf： listen</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627162551195.png" class></li><li><p><strong>凡是涉及到 Apache 配置问价的修改，那么需要重启 Apache 才能生效</strong></p></li><li><p>实现 DNS 域名解析：通常默认站点都是本地 DNS：hosts 文件</p><p>C:\Windows\System32\drivers\etc 下 hosts 文件</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627163009596.png" class></li></ol><h2 id="安装与配置-PHP"><a href="#安装与配置-PHP" class="headerlink" title="安装与配置 PHP"></a>安装与配置 PHP</h2><h4 id="安装-PHP-语言"><a href="#安装-PHP-语言" class="headerlink" title="安装 PHP 语言"></a>安装 PHP 语言</h4><ol><li><p>获取 PHP 安装文件：建议去官网</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627163637004.png" class></li><li><p>解压缩</p></li><li><p>安装：将压缩包放到 D:/server/ ，重命名 php5</p></li></ol><h4 id="PHP-目录结构说明"><a href="#PHP-目录结构说明" class="headerlink" title="PHP 目录结构说明"></a>PHP 目录结构说明</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164042157.png" class><h4 id="php-exe-的应用"><a href="#php-exe-的应用" class="headerlink" title="php.exe 的应用"></a>php.exe 的应用</h4><p>php.exe 就是可以解析 PHP 代码转变成 HTML 代码从而让浏览器可以解析的。</p><ol><li><p>通过 CMD 控制器进入到 php.exe 所在目录</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164214834.png" class></li><li><p>通过 php.exe 运行命令来指定要解析的 PHP 脚本 就可以：<code>php.exe -f</code> PHP 文件所在路径</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627164948370.png" class></li></ol><h2 id="配置-Apache-加载-PHP-模块"><a href="#配置-Apache-加载-PHP-模块" class="headerlink" title="配置 Apache 加载 PHP 模块"></a>配置 Apache 加载 PHP 模块</h2><ol><li><p>Apache 加载 PHP 模块：在 Apache 的主配置文件（httpd.conf）中加载对应的 PHP 提供的模块</p><p><code>LoadModule php5_module &#39;D:/server/php5/php5apache2_2.dll&#39;</code></p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627170739713.png" class></li><li><p>Apache 分配工作给 PHP 模块：如果是 PHP 代码就交给 PHP 处理：文件后缀判断 .php 结尾肯定是 PHP 代码</p><p><code>AddType application/x-httpd-php .php</code></p></li><li><p>将 PHP 的配置文件加载到 Apache 配置文件中：共同生效</p><ol><li><p>在 Apache 中指定 PHP 配置文件所在路径</p><p>PHPIniDir php.ini 所在路径</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627172103347.png" class></li><li><p>php.ini 文件默认是不存在的，是以 development 和 production 格式存在，需要格式化</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627172829719.png" class></li></ol><p>说明：PHP 的配置文件已经加入到 Apache 的配置项中，意味着 php.ini 的修改需要 Apache 重启才会生效。</p></li></ol><h2 id="安装与配置-MySQL"><a href="#安装与配置-MySQL" class="headerlink" title="安装与配置 MySQL"></a>安装与配置 MySQL</h2><h4 id="安装-MySQL-软件"><a href="#安装-MySQL-软件" class="headerlink" title="安装 MySQL 软件"></a>安装 MySQL 软件</h4><h4 id="MySQL-目录结构说明"><a href="#MySQL-目录结构说明" class="headerlink" title="MySQL 目录结构说明"></a>MySQL 目录结构说明</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627231602204.png" class><h4 id="Bin-目录的常用命令"><a href="#Bin-目录的常用命令" class="headerlink" title="Bin 目录的常用命令"></a>Bin 目录的常用命令</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627231701378.png" class><p>软件设计结构：C/S 和 B/S</p><p>C/S：Client 客户端/Server 服务端，用户需要安装客户端产品才能访问服务器，而且只能访问一种软件（当前自己）</p><p>B/S：Browser 浏览器/Server 服务端，用户只需要安装浏览器，就可以访问所有的服务器（B/S 架构服务）</p><h2 id="MySQL-访问流程"><a href="#MySQL-访问流程" class="headerlink" title="MySQL 访问流程"></a>MySQL 访问流程</h2><p>Mysql 是一款 C/S 架构的软件，需要通过客户端来访问服务端（MySQL 提示也提供了其他模式的访问：通过一些插件扩展来充当客户端）</p><ol><li><p>启用 MySQL 客户端： mysql.exe，该软件本身可以通过 CMD 控制台运行</p></li><li><p>MySQL 客户端访问服务端需要进行寻找匹配：连接认证</p><p>连接：IP 和端口确认，如果是本地都可以省略</p><p>-h 主机地址 –&gt; -hlocalhost（可以是 IP）</p><p>-P 端口 –&gt; -P3306</p><p>认证：通过用户名和密码进入服务器</p><p>-u 用户名 –&gt; -uroot，不可以省略（匿名用户除外）</p><p>-p 密码 –&gt; -proot</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234054183.png" class></li><li><p>退出命令</p><p><code>\q</code></p></li></ol><p>注意：通常连接认证的时候密码不建议明文，可以再输入 -p 之后回车，系统会再次让输入密码，这个时候就是密文</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234340617.png" class><h2 id="PHP-连接-MySQL-数据库"><a href="#PHP-连接-MySQL-数据库" class="headerlink" title="PHP 连接 MySQL 数据库"></a>PHP 连接 MySQL 数据库</h2><p>PHP 本身不具备操作 MySQL 数据库的能力，需要借助 PHP 操作 MySQL 的扩展来实现</p><ol><li><p>PHP 加载 MySQL 扩展：php.ini 文件</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627234726830.png" class></li><li><p>PHP 所有的扩展都是在 ext 文件夹中，需要制定扩展所在路径： extension_dir</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210627235322277.png" class></li><li><p>php.ini 已经被 Apache 加载，所以需要重启</p></li></ol><p>如果出错，尝试设置：</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628002453049.png" class><h2 id="设定-PHP-的系统时区"><a href="#设定-PHP-的系统时区" class="headerlink" title="设定 PHP 的系统时区"></a>设定 PHP 的系统时区</h2><p>通过 php.ini 中的 timezone 配置项来实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">; 增加时区</span><br><span class="line">date.timezone = PRC</span><br></pre></td></tr></table></figure><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628002923832.png" class><h2 id="配置虚拟主机"><a href="#配置虚拟主机" class="headerlink" title="配置虚拟主机"></a>配置虚拟主机</h2><p>一台服务器很贵，如果只能部署一个网站，那么非常浪费。所以需要通过其他渠道来实现一台主机上部署多个网站。</p><h4 id="什么是虚拟主机"><a href="#什么是虚拟主机" class="headerlink" title="什么是虚拟主机"></a>什么是虚拟主机</h4><p>虚拟主机：Virtual machine，并不存在真实的主机，但是可以提供真实主机所实现的功能。</p><p>通俗的讲，虚拟主机就是将计算机中不同的文件夹进行不同的命名，然后可以实现让服务器（Apache）根据用户的需求从不同的文件夹（网站）中读取不同的内容。</p><h4 id="虚拟主机的分类"><a href="#虚拟主机的分类" class="headerlink" title="虚拟主机的分类"></a>虚拟主机的分类</h4><p>在 Apache 中，可以将虚拟主机划分成两类：</p><ol><li><p>基于 IP 的虚拟主机：一台电脑上有多个 IP，每个 IP 对应一个网站</p><p>原理：电脑默认只有一个 IP，因为通常只配有一个网卡；但是有的电脑（服务器居多）可以配置多个网卡，每个网卡可以绑定一个 IP 地址。</p></li><li><p>基于域名的虚拟主机：一台电脑上只有一个 IP，但是 IP 下可以制作多个网站，但是需要给每个网站不同的名字（虚拟主机名）</p></li></ol><h2 id="搭建基于域名的虚拟主机"><a href="#搭建基于域名的虚拟主机" class="headerlink" title="搭建基于域名的虚拟主机"></a>搭建基于域名的虚拟主机</h2><p>在 Apache 中，虚拟主机的搭建有两种方式：</p><ol><li><p>在主配置文件中搭建：需要手动开启虚拟主机（基于域名）</p><p>NameVirtualHost *:80</p></li><li><p>在专门的虚拟主机配置文件中配置</p><ol><li><p>在主配置文件中加载虚拟主机配置文件(httpd.conf)：虚拟主机配置文件已经开启了虚拟主机 NameVirtualHost</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004217698.png" class></li><li><p>虚拟主机从配置文件（extra/httpd-vhosts.conf）中配置虚拟主机</p><ol><li><p>增加一个对应的站点文件夹位置：</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004550155.png" class></li><li><p>增加主机名字：文件夹的别名：ServerName</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628004830659.png" class></li><li><p>增加域名解析 DNS：(hosts 文件)</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628005736269.png" class></li><li><p>需要给当前设定的站点（目录）访问权限</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">Directory</span> <span class="string">&#x27;站点目录&#x27;</span>&gt;</span><br><span class="line">    Order Deny,Allow<span class="comment">// 没有顺序关系：实际顺序有关系</span></span><br><span class="line">    Deny <span class="keyword">from</span> 指定的范围</span><br><span class="line">    Allow <span class="keyword">from</span> 指定范围</span><br><span class="line">&lt;/<span class="built_in">Directory</span>&gt;</span><br></pre></td></tr></table></figure><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628010552694.png" class></li><li><p>配置访问列表：当访问是一个目录时（没有指定具体要访问的文件）</p><p>Options Indexes [FollowSymLinks]，如果访问目录，那么列表显示所有文件</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628011114358.png" class></li><li><p>当用户访问指定目录不指定文件的时候，通常需要系统指定一个默认文件</p><p>DirectoryIndex 默认的文件列表，使用空格分离</p><p>注意：如果网站中整个网站根目录允许访问，但是其中还有其他文件夹不允许访问：可以增加多个 Directory 标签，针对不同文件夹</p></li></ol></li><li><p>一旦启用虚拟主机配置文件，那么默认的主机地址 localhost 就不再生效，如果想要生效：为 localhost 增加单独的虚拟主机</p></li></ol><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628011958112.png" class></li></ol><h2 id="PHP-基础"><a href="#PHP-基础" class="headerlink" title="PHP 基础"></a>PHP 基础</h2><h3 id="PHP-语法初步"><a href="#PHP-语法初步" class="headerlink" title="PHP 语法初步"></a>PHP 语法初步</h3><p>PHP 是一种运行在服务器端的脚本语言，可以嵌入到 HTML 中。</p><h4 id="PHP-代码标记"><a href="#PHP-代码标记" class="headerlink" title="PHP 代码标记"></a>PHP 代码标记</h4><p>在 PHP 历史发展中，可以使用多种标记来区分 PHP 脚本</p><ul><li>ASP 标记： <code>&lt;% php代码 %&gt;</code></li><li>短标记： <code>&lt;? php代码 ?&gt;</code></li></ul><p>以上两种基本弃用，如果要使用那么需要在配置文件中开启</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628093541586.png" class><ul><li>脚本标记： <code>&lt;script lang=&quot;php&quot;&gt; php代码 &lt;/script&gt;</code></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628094015744.png" alt="image-20210628094015744"></p><ul><li>标准标记（常用）： <code>&lt;?php php代码 ?&gt;</code></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628094749928.png" class><h4 id="PHP-注释"><a href="#PHP-注释" class="headerlink" title="PHP 注释"></a>PHP 注释</h4><p>习惯：所有的代码在写的过程中都必须进行注释</p><p>PHP 中注释分为两种</p><ul><li><p>行注释：一次注释一行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ：后面跟的所有内容都是注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ：与 // 一样</span></span><br></pre></td></tr></table></figure></li><li><p>块注释：一次注释多行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* : 直到下面出现之前中间全部都是注释</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628100126110.png" class></li></ul><h4 id="PHP-语句分隔符"><a href="#PHP-语句分隔符" class="headerlink" title="PHP 语句分隔符"></a>PHP 语句分隔符</h4><p>语句分隔符：在 PHP 中，代码是以行尾单位，系统需要通过判断行的解说，该结束通常都是一个符号：英文分号 <code>;</code></p><p>特殊说明：</p><ol><li>PHP 中标记结束符?&gt;有自带语句结束符的效果，最后一行 PHP 代码可以没有语句结束符 <code>;</code> （不建议）</li><li>PHP 中其实很多代码的书写并不是嵌入到 HTML 中，而是单独存在，通常书写习惯中就不建议使用标记结束符?&gt;，PHP 会自动从开始到最后全部认为是 PHP 代码，从而解析</li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li>变量是用来存储数据的；</li><li>变量是存在名字的；</li><li>变量是通过名字来访问的：数据；</li><li>变量是可以改变的：数据。</li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>PHP 中的所有变量都必须使用 <code>$</code> 符号</p><ol><li>定义：在系统中增加对应的变量名字（内存）</li><li>赋值：可以将数据赋值给变量名（可以在定义的同时完成）</li><li>可以通过变量名访问存储的数据</li><li>可以将变量从内存中删除</li></ol><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628102030737.png" class><h4 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h4><ol><li>在 PHP 中变量名字必须以“$”符号开始；</li><li>名字由字母、数字和下划线“_”构成，但是不能以数字开头；</li><li>在 PHP 中本身还允许中文变量（不建议）。</li></ol><h4 id="预定义变量"><a href="#预定义变量" class="headerlink" title="预定义变量"></a>预定义变量</h4><p>预定义变量：提前定义的变量，系统定义的变量，存储许多需要用到的数据（预定义变量都是数组）</p><ul><li><p><strong>$_GET</strong>：获取所有表单以 get 方式提交的数据</p></li><li><p><strong>$_POST</strong>：POST 提交的数据都会保存在此</p></li><li><p><strong>$_REQUEST</strong>：GET 和 POST 提交的都会保存</p></li><li><p>$GLOBALS：PHP 中所有的全局变量</p></li><li><p><strong>$_SERVER</strong>：服务器信息</p></li><li><p><strong>$_SESSION</strong>：session 会话数据</p></li><li><p><strong>$_COOKIE</strong>：cookie 会话数据</p></li><li><p>$_ENV：环境信息（用的较少）</p></li><li><p>$_FILES：用户上传的文件信息</p></li></ul><h4 id="可变变量"><a href="#可变变量" class="headerlink" title="可变变量"></a>可变变量</h4><p>如果一个变量保存的值刚好是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值：在变量前面再多加一个$符号。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628104114494.png" class><h4 id="变量传值"><a href="#变量传值" class="headerlink" title="变量传值"></a>变量传值</h4><p>将一个变量赋值给另外一个变量：变量传值</p><p>变量传值一共有两种方式：值传递，引用传递</p><ul><li><p>值传递：将变量保存的值赋值一份，然后将新的值给另外一个变量保存（两个变量没有关系）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628105219725.png" class></li><li><p>引用传递：将变量保存的值所在的内存地址，传递给另外一个变量：两个变量指向同一块内存空间（两个变量是同一个值）</p><p><code>$新变量 = &amp;$老变量;</code></p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628105345581.png" class></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628110156014.png" class><p>在内存中，通常有以下几个分区</p><ul><li>栈区：程序可以操作的内存部分（不存数据，运行程序代码），少但是快</li><li>代码段：存储程序的内存部分（不执行）</li><li>数据段：存储普通数据（全局区和静态区）</li><li>堆区：存储复杂数据，大但是效率低</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>常量与变量一样，都是用来保存数据的。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><p>常量：const / constant，是一种在程序运行当中，不可改变的量（数据）</p><p>常量一旦定义，通常数据不可改变（用户级别）</p><h4 id="定义形式"><a href="#定义形式" class="headerlink" title="定义形式"></a>定义形式</h4><p>在 PHP 中常量有两种定义方式（5.3 之后才有两种）</p><ol><li>使用定义常量的函数：define(‘常量名’,常量值);</li><li>php5.3 之后才有的：const 常量名 = 值;</li></ol><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628110809490.png" class><h4 id="命名规则-1"><a href="#命名规则-1" class="headerlink" title="命名规则"></a>命名规则</h4><ol><li><p>常量不需要使用“$”符号，一旦使用系统就会认为是变量；</p></li><li><p>常量的名字组成由字母、数字和下划线组成，不能以数字开头；</p></li><li><p>常量的名字通常是以 <strong>大写字母</strong> 为主（与变量以示区别）；</p></li><li><p>常量命名的规则比变量要松散，可以使用一些特殊字符，该方式只能使用 define 定义；</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628111008222.png" class></li></ol><p>注意细节：</p><ol><li>Define 和 const 定义的常量是有区别：在于访问权限区别</li><li>定义常量通常不区分大小写，但是可以区分，可以参照 define 函数的第三个参数</li></ol><h4 id="使用形式"><a href="#使用形式" class="headerlink" title="使用形式"></a>使用形式</h4><p>常量的使用与变量一样：但是不可改变值（在定义的时候必须赋值）</p><p>有的时候还需要使用另外一种形式来访问（针对的是特殊名字的常量），需要用到另外一个访问常量的函数：constant(‘常量名’)</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628111559972.png" class><p>说明：常量和变量的使用</p><ol><li>凡是数据会可能变化的，那么肯定是用变量</li><li>数据不一定会变的，可以使用常量或者变量（变量居多）</li><li>数据不允许被修改的，一定用常量</li></ol><h4 id="系统常量"><a href="#系统常量" class="headerlink" title="系统常量"></a>系统常量</h4><p>系统常量：系统帮助用户定义的常量，用户可以直接使用</p><p>常用的几个系统常量：</p><ul><li><p>PHP_VERSION： PHP 版本号</p></li><li><p>PHP_INT_SIZE： 整形大小</p></li><li><p>PHP_INT_MAX： 整形能表示的最大值（PHP 中整形是允许出现负数：带符号）</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628112021974.png" class><p>在 PHP 中还有一些特殊的常量，他们有双下划线开始+长两名+双下划线结束，这种常量称之为系统 魔术常量：魔术常量的值通常会跟着环境变化，但是用户改变不了</p><ul><li><code>__DIR__</code>：当前被执行的脚本所在电脑的绝对路径</li><li><code>__FILE__</code>：当前被执行的脚本所在的电脑的绝对路径（带自己文件的名字）</li><li><code>__LINE__</code>：当前所属的行数</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628112651317.png" class><ul><li><code>__NAMESPACE__</code>：当前所属的命名空间</li><li><code>__CLASS__</code>：当前所属的类</li><li><code>__METHOD__</code>：当前所属的方法</li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>数据类型：data type，在 PHP 中指的是存储的数据本身的类型，而不是变量的类型。PHP 是一种弱类型语言，变量本身没有数据类型。</p><h4 id="PHP-的八种数据类型"><a href="#PHP-的八种数据类型" class="headerlink" title="PHP 的八种数据类型"></a>PHP 的八种数据类型</h4><p>在 PHP 中将数据分为三大类八小类：</p><ul><li><p>简单（基本）数据类型：4 个小类</p><ul><li>整型：int/integer，系统分配 4 个字节存储，表示整数类型（有前提：存的下）</li><li>浮点型：float/double，系统分配 8 个字节存储，表示小数或者整型存不下的整数</li><li>字符串型：string，系统根据实际长度分配，表示字符串（引号 ‘’ 或 “” ）</li><li>布尔类型：bool/boolean，表示布尔类型，只有两个值：true 和 false</li></ul></li><li><p>复合数据类型：2 个小类</p><ul><li>对象类型：object，存放对象（面向对象）</li><li>数组类型：array，存储多个数据（一次性）</li></ul></li><li><p>特殊数据类型：2 个小类</p><ul><li>资源类型：resource，存放资源数据（PHP 外部数据，如数据库、文件）</li><li>空类型：NULL，只有一个值就是 NULL（不能运算）</li></ul></li></ul><h4 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h4><p>类型转换：在很多的条件下，需要指定的数据类型，需要外部数据（当前 PHP 取得的数据），转换成目标数据类型</p><p>在 PHP 中有两种类型转换方式：</p><ol><li><p>自动转换：系统根据需求自己判定，自己转换（用的比较多，效率偏低）</p></li><li><p>强制（手动）转换：人为根据需要的目标类型转换</p><p>强制转换规则：在变量之前增加一个括号()，然后在里面写上对应类型：int/integer….其中 NULL 类型用到 unset()</p></li></ol><p>在转换过程中用到比较多的就是转布尔类型（判断）和转数值类型（算数运算）</p><p>其他类型转布尔类型：true 或者 false，在 PHP 中比较少类型换变成 false</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628113541600.png" class><p>其他类型转数值的说明：</p><ol><li><p>布尔 true 为 1，false 为 0；</p></li><li><p>字符串转数值有自己的规则</p><ol><li><p>以字母开头的字符串，永远为 0；</p></li><li><p>以数字开头的字符串，取到碰到字符串为止（不会同时包含两个小数点）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628114334753.png" class></li></ol></li></ol><h4 id="类型判断"><a href="#类型判断" class="headerlink" title="类型判断"></a>类型判断</h4><p>通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型（相同结果为 true，失败为 false）：是一组以 is_开头后面跟类型名字的函数：</p><pre><code>`is_xxx(变量名)`</code></pre><p>Bool 类型不能用 echo 来查看，可以使用 var_dump 结构查看：</p><pre><code>`var_dump(变量1,变量2…)`</code></pre><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628124820018.png" class><p>还有一组函数可以用来获取以及设定数据（变量）的类型</p><pre><code>gettype(变量名)：获取类型，得到的是该类型对应的字符串</code></pre><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628131733521.png" class><pre><code>settype(变量名,类型)：设定数据类型：与强制转换不同</code></pre><ol><li>强制转换(类型)变量名，是对数据值复制的内容进行处理（不会处理实际存储的内容）</li><li>settype 会直接改变数据本身</li></ol><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628132058386.png" class><h4 id="整数类型（int）"><a href="#整数类型（int）" class="headerlink" title="整数类型（int）"></a>整数类型（int）</h4><p>整数类型：保存整数数值（范围限制），4 个字节存储数据，最大就是 32 位：4,294,967,295。</p><p>但是在 PHP 中默认是有符号类型（区分正负数）</p><h5 id="定义方式"><a href="#定义方式" class="headerlink" title="定义方式"></a>定义方式</h5><p>十进制定义，二进制定义，八进制定义和十六进制定义</p><ul><li><p>$a = 120; //10 进制</p></li><li><p>$a=0b110; //2 进制</p></li><li><p>$a=0120; //8 进制</p></li><li><p>$a=0x120; //16 进制</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628134037488.png" class><h5 id="PHP-进制转换"><a href="#PHP-进制转换" class="headerlink" title="PHP 进制转换"></a>PHP 进制转换</h5><ul><li><p>decbin()：十进制转二进制</p></li><li><p>decoct()：十进制转八进制</p></li><li><p>dechex()：十进制转十六进制</p></li><li><p>bindec()：二进制转十进制</p></li><li><p>bin2hex()：二进制转十六进制</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628140009412.png" class><h4 id="浮点类型（float）"><a href="#浮点类型（float）" class="headerlink" title="浮点类型（float）"></a>浮点类型（float）</h4><p>浮点型：小数类型以及超过整型所能存储范围的整数（不保证精度），精度范围大概在 15 个有效数字左右</p><h5 id="定义方式-1"><a href="#定义方式-1" class="headerlink" title="定义方式"></a>定义方式</h5><p>$f = 1.23;</p><p>$f = 1.23e10; //科学计数法，其中 e 表示底 10</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628140744653.png" alt="image-20210628140744653"></p><p>简单说明浮点数为什么同样的字节数存储数据，但是却能表示更大的数据呢？</p><p>00000000 00000000 00000000 00000000 -&gt; 11111111 11111111 11111111 1111111 （整形最大值：所有位都是有效数据）</p><p>浮点数：加深 7 位算的结果是 10 的指数，后面三个字节存储表示具体数值</p><p>00000000 00000000 00000000 00000000 -&gt; 1<strong>1111111</strong> 11111111 11111111 1111111</p><p>注意：尽量不用用浮点数做精确判断：浮点数保存的数据不够精确，而且在计算机中凡是小数基本上存的都不准确</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141213736.png" class><h4 id="字符串类型（string）"><a href="#字符串类型（string）" class="headerlink" title="字符串类型（string）"></a>字符串类型（string）</h4><h5 id="字符串定义语法"><a href="#字符串定义语法" class="headerlink" title="字符串定义语法"></a>字符串定义语法</h5><ol><li>单引号字符串：使用单引号包裹</li><li>双引号字符串：使用双引号包裹</li></ol><p>引号方式：比较适合定义那些比较短（不超过一行）或者没有结构(缩进等)要求的字符串</p><p>如果有结构要求，或者内容超过一行，可以使用以下两种结构定义</p><ol><li><p>nowdoc 字符串：没有单引号的单引号字符串</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = &lt;&lt;&lt; <span class="string">&#x27;边界符&#x27;</span></span><br><span class="line">    字符串内容</span><br><span class="line">边界符;</span><br></pre></td></tr></table></figure></li><li><p>heredoc 字符串：没有双引号的双引号字符串</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$str</span> = &lt;&lt;&lt; 边界符</span><br><span class="line">    字符串内容</span><br><span class="line">边界符;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><p>heredoc 和 nowdoc 比引号方式要区别多一点，(查看源码可知保留了结构)</p><h5 id="字符串转义"><a href="#字符串转义" class="headerlink" title="字符串转义"></a>字符串转义</h5><p>转义的含义：在计算机通用协议中，有一些特定的方式定义的字母，系统会特定处理：通常这种方式都是使用反斜杠+字母(单词)的特性</p><p>\r\n：回车换行</p><p>PHP 在识别转义字符的时候也是使用同样的模式：反斜杠+字母</p><p>在 PHP 中系统常用的转义符号：</p><ul><li><p>\‘：在单引号字符串中显示单引号</p></li><li><p>\“：在双引号字符串中显示双引号</p></li><li><p>\r：代表回车（理论上是回到当前行的首位置）</p></li><li><p>\n：代表新一行</p></li><li><p>\t：类似 tab 键，输出 4 个空格</p></li><li><p>\$：在PHP中使用$符号作为变量符号，因此需要特定识别</p></li></ul><p>单引号和双引号的区别：</p><ol><li><p>其中单引号中能够识别 \‘，而双引号中就不能识别 \‘（下图浏览器查看的是页面源代码）</p></li><li><p>双引号中因为能够识别 $ 符号，所以双引号中可以解析变量，而单引号不可以</p></li></ol><p>双引号中变量识别的规则：</p><ol><li><p>变量本身系统能够与后面的内容区分：应该保证变量的独立性，不要让系统难以区分</p></li><li><p>使用变量专业标识符（区分），给变量加上一组大括号 {}</p></li></ol><p>结构化定义字符串变量的规则：</p><ol><li><pre><code>  结构化定义字符串对应的边界符有条件：    1.  上边界符后面不能跟任何内容(包括空格)；    2.  下边界符必须顶格：最左边；    3.  下边界符同样后面只能跟分号，不能跟任何内容；</code></pre></li><li> 结构化定义字符串的内部（边界符之间）的所有内容都是字符串本身</li></ol><h5 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h5><ol><li><p> 基本函数 strlen()：得到字符串的长度（字节为单位）</p></li><li><p>多字节字符串的长度问题：包含中文的长度。</p><p> 让一个中文的长度为 1 而不是 3</p></li><li><p>多字节字符串扩展模块：mbstring 扩展（mb ：Multi Bytes）</p><p> 首先需要加载 PHP 的 mbstring 扩展</p> <p> 可以使用 mb 扩展带来很多函数</p><p> mbstring 扩展针对的是一些关于字符统计：</p><pre><code> strlen只是针对标准交换码ASCII mbstring会针对不同的字符集 (php7默认字符集为utf-8)</code></pre> </li></ol><h5 id="字符集相关函数"><a href="#字符集相关函数" class="headerlink" title="字符集相关函数"></a>字符集相关函数</h5><ol><li><p>转换函数：implode(), explode(), str_split()</p><ul><li><p>implode(连接方式,数组)：将数组中的元素按照某个规则连接成一个字符串</p></li><li><p>explode(分割字符,目标字符串)：将字符串按照某个格式进行分割，变成数组</p><pre><code>中国|北京|顺义 == array(‘中国’,‘北京’,’顺义’);</code></pre></li><li><p>str_split(字符串,字符长度)：按照指定长度拆分字符串得到数组</p></li></ul></li><li><p>截取函数：trim(), ltrim(), rtrim()</p><ul><li>trim(字符串[,指定字符])：本身默认是用来去除字符串两边的空格（中间不行），但是也可以指定要去除的内容，是按照指定的内容循环去除两边有的内容：直到碰到一个不是目标字符为止</li><li>ltrim()：去除左边的</li><li>rtrim()：去除右边的</li></ul></li><li><p>截取函数：substr(), strstr()</p><ul><li>substr(字符串,起始位置从 0 开始[,长度])：指定位置开始截取字符串，可以截取指定长度（不指定到最后）</li><li>strstr(字符串,匹配字符)：从指定位置开始，截取到最后（可以用来取文件后缀名）</li></ul></li><li><p>大小转换函数：strtolower(), strtoupper(), ucfirst()</p><ul><li>strtolower：全部小写</li><li>strtoupper：全部大写</li><li>ucfirst：首字母大写</li></ul></li><li><p>查找函数：strpos(), strrpos()</p><ul><li>strpos(字符串，匹配字符)：判断字符在目标字符串中出现的位置（首次）</li><li>strrpos(字符串，匹配字符)：判断字符在目标字符串中最后出现的位置</li></ul></li><li><p>替换函数：str_replace()</p><ul><li>str_replace(匹配目标,替换的内容,字符串本身)：将目标字符串中部分字符串进行替换</li></ul></li><li><p>格式化函数：printf(), sprintf()</p><ul><li>sprintf/sprintf(输出字符串有占位符,顺序占位内容…)：格式化输出数据</li></ul></li><li><p>其他：str_repeat(), str_shuffle()</p><ul><li>str_repeat()：重复某个字符串 N 次</li><li>str_shuffle()：随机打乱字符串</li></ul></li></ol><h4 id="数组（array）"><a href="#数组（array）" class="headerlink" title="数组（array）"></a>数组（array）</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>数组：array，数据的组合，指将一组数据（多个）存储到一个指定的容器中，用变量指向该容器，然后可以通过变量一次性得到该容器中的所有数据。</p><h5 id="数组定义语法"><a href="#数组定义语法" class="headerlink" title="数组定义语法"></a>数组定义语法</h5><ol><li><p>使用 array 关键字：最常用的</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$变量 = <span class="keyword">array</span>(元素<span class="number">1</span>,元素<span class="number">2</span>,元素<span class="number">3</span>..);</span><br></pre></td></tr></table></figure></li><li><p>可以使用中括号来包裹数据：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$变量 = [元素<span class="number">1</span>,元素<span class="number">2</span>…];</span><br></pre></td></tr></table></figure></li><li><p>隐形定义数组：给变量增加一个中括号，系统自动变成数组</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$变量[] = 值<span class="number">1</span>;<span class="comment">//如果不提供下标也可以，系统自动生成（数字：从0开始）</span></span><br><span class="line">$变量[下标] = 值; <span class="comment">//中括号里面的内容称之为下标key，该下标可以是字母</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="PHP-数组特点"><a href="#PHP-数组特点" class="headerlink" title="PHP 数组特点"></a>PHP 数组特点</h5><ol><li><p>可以整数下标或者字符串下标</p><ul><li><p>如果数组下标都为整数：索引数组</p></li><li><p>如果数组下标都为字符串：关联数组</p></li></ul></li><li><p>不同下标可以混合存在：混合数组</p></li><li><p>数组元素的顺序以放入顺序为准，跟下标无关</p></li><li><p>数字下标的自增长特性：从 0 开始自动增长，如果中间手动出现较大的，那么后面的自增长元素从最大的值+1 开始</p></li><li><p>特殊值下标的自动转换</p><p>布尔值：true 和 false<br>空：NULL</p></li><li><p>PHP 中数组元素没有类型限制</p></li><li><p>PHP 中数组元素没有长度限制</p></li></ol><p>补充：PHP 中的数组是很大的数据，所以存储位置是堆区，为当前数组分配一块连续的内存。</p><h5 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h5><p>多维数组：数组里面的元素又是数组</p><h6 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h6><p>数组中所有的元素都是一维数组</p><h6 id="多维数组-1"><a href="#多维数组-1" class="headerlink" title="多维数组"></a>多维数组</h6><p>在第二维的数组元素中可以继续是数组，在 PHP 中没有维度限制（PHP 本质并没有二维数组）</p><p>但是：不建议使用超过三维以上的数组，会增加访问的复杂度，降低访问效率。</p><h6 id="异性数组（不规则数组）"><a href="#异性数组（不规则数组）" class="headerlink" title="异性数组（不规则数组）"></a>异性数组（不规则数组）</h6><p>异形数组：数组中的元素不规则，有普通基本变量也有数组。</p><p>在实际开发中，并不常用，尽量让数组元素规则化（便于进行访问）</p><h5 id="数组遍历"><a href="#数组遍历" class="headerlink" title="数组遍历"></a>数组遍历</h5><h6 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h6><p>数组遍历：普通数组数据的访问都是通过数组元素的下标来实现访问，如果说数组中所有的数据都需要依次输出出来，就需要我们使用到一些简化的规则来实现自动获取下标以及输出数组元素。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$arr</span> = <span class="keyword">array</span>(<span class="number">0</span>=&gt;<span class="keyword">array</span>(‘name’ =&gt; ‘Tom’),<span class="number">1</span>=&gt;<span class="keyword">array</span>(‘name’ =&gt; ‘Jim’));<span class="comment">//二维数组</span></span><br><span class="line"><span class="comment">//访问一维元素：$arr[一维下标]</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="number">0</span>];<span class="comment">//结果：array(‘name’ =&gt; ‘Tom’);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//访问二维元素：$arr[一维下标][二维下标]</span></span><br><span class="line"><span class="variable">$arr</span>[<span class="number">1</span>][‘name’];<span class="comment">//Jim</span></span><br></pre></td></tr></table></figure><h6 id="foreach-遍历语法"><a href="#foreach-遍历语法" class="headerlink" title="foreach 遍历语法"></a>foreach 遍历语法</h6><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>($数组变量 <span class="keyword">as</span> [$下标 =&gt;] $值)&#123;<span class="comment">//下标可有可无</span></span><br><span class="line"><span class="comment">//通过$下标访问元素的下标；通过$值访问元素的值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通常：如果是关联数组（字母下标），就需要下标，如果是数字下标就直接访问值</p><p>获取下标</p><p>在进行数据存储定义的时候，通常二维数组不会两个维度的 key 下标都为数字，一般是一维为数字（无意义），二维为字符串（数据库表字段），所以在进行遍历的时候，通常是只需要针对一维进行遍历，取得二维数组元素，然后二维数组元素通过下标去访问。</p><h6 id="foreach-遍历原理"><a href="#foreach-遍历原理" class="headerlink" title="foreach 遍历原理"></a>foreach 遍历原理</h6><p>foreach 遍历的原理：本质是数组的内部有一颗指针，默认是指向数组元素的第一个元素，foreach 就是利用指针去获取数据，同时移动指针。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">foreach</span>(<span class="variable">$arr</span> <span class="keyword">as</span> <span class="variable">$k</span> =&gt; <span class="variable">$v</span>)&#123;</span><br><span class="line"><span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>foreach 会重置指针：让指针指向第一个元素；</li><li>进入 foreach 循环：通过指针取得当前第一个元素，然后将下标取出放到对应的下标变量$k中（如果存在），将值取出来放到对应的值变量$v 中；（指针下移）</li><li>进入到循环内部（循环体），开始执行；</li><li>重复 2 和 3，直到在 2 的时候遇到指针取不到内容（指针指向数组最后</li></ol><h6 id="for-循环遍历数组"><a href="#for-循环遍历数组" class="headerlink" title="for 循环遍历数组"></a>for 循环遍历数组</h6><p>for 循环：基于已知边界条件（起始和结束）然后有条件的变化(规律,索引数组)</p><p>因此：for 循环遍历数组有对应条件</p><ol><li>获取数组长度：count(数组)得到数组元素的长度</li><li>要求数组元素的下标是规律的数字</li></ol><h6 id="while-配合-each-和-list-遍历数组"><a href="#while-配合-each-和-list-遍历数组" class="headerlink" title="while 配合 each 和 list 遍历数组"></a>while 配合 each 和 list 遍历数组</h6><p>while 是在外部定义边界条件，如果要实现可以和 for 循环一样。</p><p>list 与 each 配合特别好：</p><ol><li> each 一定有两个元素就是 0 和 1 元素，得到的数组结构正好可以给 list 使用，然后通过 list 的(变量 1,变量 2)得到 0 和 1 元素的值，对应的就是原数组的下标和值。</li><li> list(变量 1,变量 2) = each(数组); //是一种赋值运算，但是可以得到 false 结果（each 取不到正确的结果），整个表达式为 false，起到结束循环的效果</li></ol><h5 id="数组函数"><a href="#数组函数" class="headerlink" title="数组函数"></a>数组函数</h5><h6 id="排序函数"><a href="#排序函数" class="headerlink" title="排序函数"></a>排序函数</h6><ol><li>sort()：顺序排序（下标重排，下标和值的关系改变）</li><li>rsort()：逆序排序 （同上）</li><li>asort()：顺序排序（下标保留，下标和值的对应关系不变）</li><li>arsort()：逆序排序 (同上)</li><li>ksort()：顺序排序：按照键名（下标）</li><li>krsort()：逆序排序：按照键名（下标）</li><li>shuffle()：随机打乱数组元素，数组下标会重排</li></ol><h6 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h6><ol><li>reset()：重置指针，将数组指针指向首位</li><li>end()：重置指针，将数组指针指向最后一个元素</li><li>next()：指针下移，取得下一个元素的值</li><li>prev()：指针上移，取得上一个元素的值</li><li>current()：获取当前指针对应的元素值</li><li>key()：获取当前指针对应的下标值</li></ol><p>注意事项：next 和 prev 会移动指针，有可能导致指针移动到最前或者最后（离开数组），导致数组不能使用，通过 next 和 prev 不能回到正确的指针位置。只能通过 end 或者 reset 进行指针重置</p><h6 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h6><ol><li>count()：统计数组中元素的数量</li><li>array_push()：往数组中加入一个元素（数组最后）</li><li>array_pop()：从数组中弹出一个元素并返回（数组最后）</li><li>array_shift()：从数组中弹出一个元素并返回（数组开头）</li><li>array_unshift()：从数组中加入一个元素（数组开头）</li><li>array_reverse()：返回单元顺序相反的数组</li><li>in_array()：判断一个元素在数组中是否存在</li><li>array_keys()：获取一个数组的所有下标，返回一个索引数组</li><li>array_values()：获取一个数组的所有值，返回一个索引数组</li></ol><h4 id="布尔类型（boolean）"><a href="#布尔类型（boolean）" class="headerlink" title="布尔类型（boolean）"></a>布尔类型（boolean）</h4><p>布尔类型：两个值 true 和 false，通常是用于判断比较</p><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141333016.png" alt="image-20210628141333016"></p><p>在进行某些数据判断的时候，需要特别注意类型转换</p><pre><code>empty()：判断数据的值是否为“空”，不是NULL，如果为空返回true，不为空返回falseisset()：判断数据存储的变量本身是否存在，存在变量返回true，不存在返回false</code></pre><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628141717452.png" class><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>运算符：operator，是一种将数据进行运算的特殊符号，在 PHP 中一共有十种运算符之多</p><h4 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h4><p>符号是“=”，表示将右边的结果（可以是变量、数据、常量和其它运算出来的结果），保存到内存的某个位置，然后将位置的内存地址赋值给左侧的变量（常量）。</p><h4 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h4><p>算术运算：基本算术操作</p><ul><li><p>+：执行数据累加</p></li><li><p>-：数据相减</p></li><li><p>*：键盘上没有乘法符号，使用*代替，两个数相乘</p></li><li><p>/：正斜杠代替，表示两个数相除</p></li><li><p>%：取余(模)运算，两个数（整数）相除，保留余数</p></li></ul><p>注意：在进行除法运算或者取余运算的时候，对应的除数（第二个数）不能为 0</p><h4 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h4><p>比较运算：比较两个数据的大小，或者两个内容是否相同，返回的结果都是布尔类型：满足返回 true，不满足返回 false</p><ul><li><p>&gt;：左边大于右边，返回结果 true</p></li><li><p>&gt;=：左边大于等于右边</p></li><li><p>&lt;：左边小于右边</p></li><li><p>&lt;=：左边小于或者等于右边</p></li><li><p>==：左边的与右边的相同（大小相同）</p></li><li><p>!=：左边的与右边的不同（大小不同）</p></li><li><p>===：全等于，左边与右边相同：大小以及数据的类型都要相同</p></li><li><p>!==：不全等于，只要大小或者类型不同就为 true</p></li></ul><h4 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h4><p>逻辑运算：针对不同的结果进行匹配。满足条件返回 true，不满足返回 false</p><ul><li><p><code>&amp;&amp;</code> 和 <code>and</code> ：逻辑与，左边的条件与右边的条件同时成立（两边结果都为 true）</p></li><li><p><code>||</code> 和 <code>or</code> ：逻辑或，左边的条件或者右边的条件只要有一个满足即可</p></li><li><p><code>!</code> ：逻辑非，对已有条件进行取反，本身为 true，取反结果就是 false</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628142659903.png" class><p>逻辑与和逻辑或又称之为<strong>**短路运算**<strong>：如果第一个表达式结果已经满足条件了，那么就不会运行逻辑运算符后面的表达式：</strong>在书写代码的时候，尽量将出现概率最高的（能够直接判断出结果）的表达式放到第一位，提高运算效率</strong></p><h4 id="连接运算符"><a href="#连接运算符" class="headerlink" title="连接运算符"></a>连接运算符</h4><p>是 PHP 中将多个字符串拼接的一种符号</p><ul><li><code>.</code> ：将两个字符串连接到一起</li><li><code>.=</code> ： 复合运算，将左边的内容与右边的内容连接起来，然后重新赋值给左边变量</li></ul><p>A .= b ⇔ A = A . b</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628143257603.png" class><h4 id="错误抑制符"><a href="#错误抑制符" class="headerlink" title="错误抑制符"></a>错误抑制符</h4><p>在 PHP 中有一些错误可以提前预知，但是这些错误可能无法避免，但是又不希望报错给用户看，可以使用错误抑制符处理。</p><pre><code>`@` ：在可能出错的表达式前面使用@符号即可</code></pre><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628143553218.png" class><p>错误抑制符通常在生产环境（上线）会用到，在开发的时候不会用：系统本身最好没有任何错误。</p><h4 id="三目运算符"><a href="#三目运算符" class="headerlink" title="三目运算符"></a>三目运算符</h4><p>三目运算：有三个表达式参与的运算（简单的的分支结构缩写）</p><p>语法格式：</p><p><code>表达式1 ? 表达式2 : 表达式3;</code></p><p>运算：如果表达式 1 成立，那么执行表达式 2，否则执行表达式 3；</p><p>注意：如果表达式本身比较复杂，建议使用括号包起来。</p><p>三目运算可以进行复合三目运算：三目运算中的表达式 2 和 3 都是可以是另外一个三目运算。</p><p><code>表达式1 ? (表达式2 ? 表达式4 : 表达式5) : (表达式3 ? 表达式6 : 表达式7);</code></p><h4 id="自操作运算符"><a href="#自操作运算符" class="headerlink" title="自操作运算符"></a>自操作运算符</h4><p>自操作：自己操作自己的运算符</p><ul><li><p><code>++</code> ：在原来的值上+1</p></li><li><p><code>--</code> ：在原来的值上-1</p></li></ul><p>在 PHP 中自操作符是可以放到变量前或者后：前置自操作和后置自操作</p><ul><li><p>后置自操作：先把自己所保存的值留下来，然后改变自己，自己给别人的值是原来的值；</p></li><li><p>前置自操作：先把自己改变，然后把改变后的值给别人。</p></li></ul><p>衍生符号：类似自操作</p><ul><li><p><code>+=</code> ：左边的结果与右边结果相加，然后赋值给左边</p></li><li><p><code>-=</code> ：左边的减去右边的结果，然后复制给左边</p></li><li><p><code>*=</code> ：乘法操作</p></li><li><p><code>/=</code> ：除法操作</p></li><li><p><code>%=</code> ：模操作</p></li></ul><p>注意：右边是一个整体 $a += $b;  ⇔  $a = $a + ($b);</p><p>如果进行除法或者取余运算，那么要考虑右边表达式的结果是否为 0（为 0 出错）</p><h4 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h4><h5 id="计算机码"><a href="#计算机码" class="headerlink" title="计算机码"></a>计算机码</h5><p>计算机在实际存储数据的时候，采用的编码规则（二进制规则）</p><p>计算机码：原码、反码和补码。数值本身最左边一位是用来充当符号位：正 0 负 1</p><ul><li><p>原码：数据本身从十进制转换成二进制得到的结果</p><p>正数：左边符号位为 0（正数的原码、反码和补码就是原码本身）<br>负数：左边符号位为 1</p></li><li><p>反码：针对负数，符号位不变，其他位取反</p></li><li><p>补码：针对负数，反码+1</p></li></ul><p>系统中存在两个 0：+0 和-0 (0 的原码跟反码都有两个，因为这里 0 被分为+0 和-0)</p><pre><code>+0： 00000000-0 ： 10000000    原码</code></pre><ul><li>取反 11111111</li><li>补码 00000000</li></ul><h5 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h5><p>位运算：取出计算机中最小的单位（位 bit）进行运算</p><ul><li>&amp;：按位与，两个位都为 1，结果为 1，否则为 0</li></ul><ol><li><p>|：按位或，两个有一个为 1，结果为 1</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628151029489.png" class><p>注意：</p><ol><li><p>系统进行任何位运算的时候都是使用的补码。</p><p>–计算机存储的是补码(为了实现化减为加–用加法处理减法)。用-5 作为位运算时，-5 在计算机内的二进制表示是二进制补码。</p></li><li><p>运算结束之后都必须转换成原码才是最终要显示的数据</p><p>–补码的计算结果依然是补码，但是显示时需要转为原码：符号位为 0(正数)的补码=原码 不用转换；符号位为 1(负数)的需要把补码转换为原码。</p></li></ol></li></ol><ul><li><p>~：按位非，一个位如果为 1 则变成 0，否则反之</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628151449325.png" class></li><li><p>^：按位异或，两个相同则为 0，不同则为 1</p></li><li><p>&lt;&lt;：按位左移，整个位（32 位），向左移动一位，右边补 0</p></li><li><p>&gt;&gt;：按位右移，整个位向右移动一位，左边补符号位对应内容</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628152113926.png" class></li></ul><p>按位左移：乘以 2 的操作</p><p>按位右移：除以 2 的操作（不完全正确）：整数除 2 会出现小数</p><h4 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h4><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628152259662.png" class><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="控制分类"><a href="#控制分类" class="headerlink" title="控制分类"></a>控制分类</h4><ul><li>顺序结构：代码从上往下，顺序执行。（代码执行的最基本结构）</li><li>分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码</li><li>循环结构：在某个条件控制范围内，指定的代码（块）可以重复执行</li></ul><h4 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h4><p>最基本结构，所有代码默认都是从上往下依次执行</p><h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><p>在 PHP 中，分支结构主要有两种：if 分支 和 switch 分支</p><h5 id="if-分支"><a href="#if-分支" class="headerlink" title="if 分支"></a>if 分支</h5><ol><li><p>最简 if：只有一段代码，但是可以选择是否执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">//满足条件所要执行的内容 //顺序结构</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基础 if：有两面性，满足条件或者不满足条件都有对应的执行代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">//满足条件后执行的代码段;</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//不满足条件执行的代码段;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>复杂 if 结构：在判断条件之后，通常就有两种结果：满足或者不满足，在不满足之后还可以再次进行条件判断</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//满足条件表达式1的代码段;</span></span><br><span class="line">&#125;<span class="keyword">elseif</span>(条件表达式<span class="number">2</span>)&#123;<span class="comment">//`else if 分开也可以</span></span><br><span class="line">    <span class="comment">//不满足表达式1条件，但是满足表达式2的代码;</span></span><br><span class="line">&#125;…&#123;<span class="comment">//可以使用多个elseif来进行再次条件筛选</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">//全部不满足要执行的代码;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="switch-分支"><a href="#switch-分支" class="headerlink" title="switch 分支"></a>switch 分支</h5><p>switch 分支：有一组情形存在，同过一条件，通常有多个值，但是每一个值都会有对应不同的代码要执行。</p><p>switch 判断方式：是将条件放到分支结构内部判断。</p><p>switch 基本语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(条件表达式)&#123;</span><br><span class="line"><span class="comment">//所有条件判断：逐个进行</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">1</span>:<span class="comment">//当前条件表达式的结果与值1相等（==）</span></span><br><span class="line">        要执行的代码段;</span><br><span class="line">        <span class="keyword">break</span>;<span class="comment">//在switch中，如果条件匹配成功，那么系统就不会再次匹配条件，会自动顺序执行向下的所有代码（case代码除外），需要中断执行：break表示中断switch（结束）。</span></span><br><span class="line">    <span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">        要执行的代码段;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//可以使用类似else的语法：都不匹配</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">//匹配失败的代码;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>if 和 switch 的选择</p><ol><li>if 能做所有的分支结构事情</li><li>switch 处理的是条件比较多，同时比较单一，而且是固定值匹配的分支结构</li></ol><h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>代码段在一定的控制下，可以多次执行。</p><p>在 PHP 中循环结构有以下几种：</p><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>通过条件、起始和终止判断执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(条件表达式<span class="number">1</span>;条件表达式<span class="number">2</span>;条件表达式<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//条件表达式1：定义初始化条件，可以有多种赋值语句存在，使用逗号分隔即可</span></span><br><span class="line">    <span class="comment">//条件表达式2：边界判定，限定循环执行的次数</span></span><br><span class="line">    <span class="comment">//条件表达式3：用来执行条件变化（自操作）</span></span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for 循环执行原理：</p><ol><li>执行条件表达式 1：定义初始化条件（执行一次）</li><li>执行条件表达式 2：判断条件（N 次）<ol><li>满足条件：执行循环体</li><li>不满足条件：循环结束</li></ol></li><li>执行循环体：（N 次）</li><li>执行条件表达式 3：循环变量变化（N 次）</li><li>执行条件表达式 2：判断条件（N 次）</li><li>重复执行 3-4-2 步骤：直到第 2 步不满足条件结束循环</li></ol><p>for 循环特殊使用：for 循环中对应的括号（条件）可以一个都没有（死循环）但一定要避免出现；</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h5><p>通过判断条件终止</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">条件初始化;</span><br><span class="line"><span class="keyword">while</span>(条件表达式)&#123;</span><br><span class="line">    <span class="comment">//条件表达式就是判断边界条件</span></span><br><span class="line">    循环体;<span class="comment">//循环条件的变化</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>For 与 while 的选择</p><ol><li>如果是基于固定已知条件（数值而且是有规律的变化），使用 for 循环</li><li>while 可以做灵活的条件判定（while 使用的比较多）</li></ol><h5 id="do-while-循环"><a href="#do-while-循环" class="headerlink" title="do-while 循环"></a>do-while 循环</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    <span class="comment">//循环体</span></span><br><span class="line">&#125;<span class="keyword">while</span>(条件表达式);</span><br></pre></td></tr></table></figure><h5 id="foreach-循环"><a href="#foreach-循环" class="headerlink" title="foreach 循环"></a>foreach 循环</h5><p>专门针对数组</p><h5 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h5><p>循环控制：在循环内部对循环本身进行控制</p><ul><li><p>中断控制：重新开始循环，循环体中还有其他内容，也不执行，重新执行</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">continue</span> 层级;<span class="comment">//层级默认是1（循环可以多层嵌套）</span></span><br></pre></td></tr></table></figure></li><li><p>终止控制：循环直接结束</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">break</span> 层级;<span class="comment">//层级默认是1</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="流程控制替代语法"><a href="#流程控制替代语法" class="headerlink" title="流程控制替代语法"></a>流程控制替代语法</h4><p>流程控制替代语法：分支和循环结构的替代语法</p><p>PHP 本身是嵌入到 HTML 中的脚本语言，需要在 HTML 中书写一些关于判断或者循环的结构语法，必须符合 PHP 标签规范，需要 HTML 与 PHP 进行混搭，如果使用原始的 PHP 代码那么会非常不美观。</p><p>例子： 九九乘法表</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;table border=&quot;1&quot;&gt;</span><br><span class="line">    &lt;?php for ($i = 1; $i &lt; 10; $i++) &#123; ?&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;?php for ($j = 1; $j &lt;= $i; $j++) &#123; ?&gt;</span><br><span class="line">        &lt;td&gt;</span><br><span class="line">            &lt;?php echo $i . &#x27; * &#x27; . $j . &#x27; = &#x27; . $i * $j ?&gt;</span><br><span class="line">        &lt;/td&gt;</span><br><span class="line">        &lt;?php &#125; ?&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">    &lt;?php &#125; ?&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628160755681.png" class><p>在 PHP 书写到 HTML 中的这些大括号{}非常不美观，所以 PHP 提供了一种替代机制，让其可以不用书写大括号：</p><ul><li>For(;;){ –&gt; for(;;):</li><li>} –&gt; endfor;</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628161032944.png" class><p>PHP 中具体有哪些替代语法呢？</p><p>PHP 应该在 HTML 中只做数据输出，输出通常伴有条件判断和循环操作，因此 PHP 提供了对应分支结构和循环结构的替代语法：全部都是对应的一个模式：</p><ul><li>左大括号 <code>&#123;</code> 使用 <code>:</code> 替代：</li><li>右大括号 <code>&#125;</code> 使用 <code>end+对应的起始标记</code> 替代</li></ul><table><thead><tr><th>标记</th><th>起始</th><th>结束</th></tr></thead><tbody><tr><td>if</td><td>if() :</td><td>endif;</td></tr><tr><td>switch</td><td>switch() :</td><td>endswitch;</td></tr><tr><td>for</td><td>for(;;) :</td><td>endfor;</td></tr><tr><td>while</td><td>while() :</td><td>endwhile;</td></tr><tr><td>foreach</td><td></td><td></td></tr></tbody></table><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>在一个 PHP 脚本中，去将另外一个文件（PHP）包含进来，去合作完成一件事情。</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>文件包含的意义：</p><ol><li><p>要么使用被包含文件中的内容，实现代码的共享（重用）：向上包含（索要）</p><p>向上包含：在当前脚本要用某个代码之前包含别的文件</p></li><li><p>要么自己有东西可以给别的文件使用，实现代码的共享（重用）：向下包含（给予）</p><p>向下包含：在自己有某个东西的时候，需要别的脚本来显示（自己代码写完之后包含其他文件）</p></li></ol><p>最大的作用：<strong>分工协作</strong>，每个脚本做的事情不一样，因此可以使用协作方式，让多个脚本共同完成一件事情。</p><h4 id="文件包含四种形式"><a href="#文件包含四种形式" class="headerlink" title="文件包含四种形式"></a>文件包含四种形式</h4><p>在 PHP 中文件的包含有四种形式（两种大形式）：</p><ul><li><p>Include：包含文件</p></li><li><p>Include_once：系统会自动判断文件包含过程中，是否已经包含过（一个文件最多被包含一次）</p></li><li><p>Require：与 include 相同</p></li><li><p>Require_once：与 include_once 相同</p></li></ul><p>包含基本语法</p><ul><li><p>Include ‘文件名字’;</p></li><li><p>Include(‘文件名字’); //文件名字：路径问题</p></li></ul><p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628163927572.png" alt="image-20210628163927572"></p><p>以上方式：是先包含文件，后使用文件中的内容（向上包含）</p><p>向下包含：先准备内容，然后包含另外的文件，在另外的文件中，使用当前的内容</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628164455678.png" class><h4 id="文件加载原理"><a href="#文件加载原理" class="headerlink" title="文件加载原理"></a>文件加载原理</h4><p>PHP 代码的执行流程：</p><ol><li>读取代码文件（PHP 程序）</li><li>编译：将 PHP 代码转换成字节码（生成 opcode）</li><li>zendengine 引擎来解析 opcode，按照字节码去进行逻辑运算</li><li>转换成对应的 HTML 代码</li></ol><p>文件加载原理：</p><ol><li><p>在文件加载（include 或者 require）的时候，系统会自动的将被包含文件中的代码相当于嵌入到当前文件中</p></li><li><p>加载位置：在哪加载，对应的文件中的代码嵌入的位置就是对应的 include 位置</p></li><li><p>在 PHP 中被包含的文件是单独进行编译的</p><p>PHP 文件在编译的过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含文件有错误的时候，系统会在执行到包含 include 这条语句的时候才会报错。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628165803659.png" class></li></ol><h4 id="include-和-requist-的区别"><a href="#include-和-requist-的区别" class="headerlink" title="include 和 requist 的区别"></a>include 和 requist 的区别</h4><p>Include 和 include_once 的区别：</p><ul><li><p>Include 系统会碰到一次，执行一次；如果对统一个文件进行多次加载，那么系统会执行多次；</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170242685.png" class></li><li><p>Include_once：系统碰到多次，也只会执行一次。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170333116.png" class></li></ul><p>Require 和 include 的区别：本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样</p><ul><li><p>include 的错误级别比较轻：不会阻止代码执行</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170614796.png" class></li><li><p>require 要求较高：如果包含出错代码不再执行（require 后面的代码）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628170729389.png" class></li></ul><h4 id="文件加载路径"><a href="#文件加载路径" class="headerlink" title="文件加载路径"></a>文件加载路径</h4><p>文件在加载的时候需要指定文件路径才能保证 PHP 正确的找到对应的文件。</p><p>文件的加载路径包含两大类：</p><ol><li><p>绝对路径</p><ol><li><p>从磁盘的根目录开始（本地绝对路径）</p><ul><li>Windows：盘符 C:/路径/PHP 文件</li><li>Linux：/路径/PHP 文件</li></ul></li><li><p>从网站根目录开始（网络绝对路径）</p><ul><li><p>/ ：相对于网站主机名字对应的路径</p><p>Localhost/index.php -&gt; E:/server/apache/htdocs/index.php</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628172146092.png" class></li></ol></li><li><p>相对路径：从当前文件所在目录开始的路径</p><ul><li><code>.</code> 或 <code>./</code> ：表示当前文件夹</li><li><code>../</code> ：上级目录（当前文件夹的上一层文件夹）</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628172039596.png" class></li></ol><p>绝对路径和相对路径的加载区别：</p><ol><li>绝对路径相对效率偏低，但是相对安全（路径不会出问题）</li><li>相对路径相对效率高些，但是容易出错（相对路径会发生改变）</li></ol><h4 id="文件嵌套包含"><a href="#文件嵌套包含" class="headerlink" title="文件嵌套包含"></a>文件嵌套包含</h4><p>文件嵌套包含：一个文件包含另外一个文件，同时被包含的文件又包含了另外一个文件。</p><p>嵌套包含的时候就很容易出现相对路径出错的问题：相对路径会因为文件的包含而改变（./和../），原因：windows 下面，每一个文件夹下都有.和..的文件夹。</p><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>function，是一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用（复用）。</p><h4 id="定义语法"><a href="#定义语法" class="headerlink" title="定义语法"></a>定义语法</h4><p>函数有几个对应的关键点：function 关键字、函数名、参数（形参和实参）、函数体和返回值</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">[参数]</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">    <span class="comment">//返回值：return 结果;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义函数的目的：是为了实现代码的重复利用，一个功能一个函数（简单明了）</p><p>函数的使用：<code>函数名();</code> //如果函数在定义的过程中有参数，那么在调用的时候就必须传入对应的参数：函数是一种结构不会自动运行，必须通过调用才会执行</p><p>函数的调用特点：只要系统在内存中能够找到对应的函数，就可以执行（函数的调用可以在函数定义之前）</p><p>函数执行的内存分析：</p><ol><li>读取代码进入到代码段（编译：将代码变成字节码存储到内存）。此时 function 已经在内存里</li><li>根据代码逐行执行</li></ol><h4 id="命名规范"><a href="#命名规范" class="headerlink" title="命名规范"></a>命名规范</h4><p>命名规范：由字母、数字和下划线组成，但是不能以数字开头</p><ol><li>驼峰法：除了左边第一个单词外，后面所有的单词首字母都大写：showParentInfo()</li><li>下划线法：单词之间通过下划线连接，单词都是小写：show_parent_info()</li></ol><p>函数名字：在一个脚本周期中，不允许出现同名函数（通常在一个系统开发中都不会使用同名函数）</p><h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><p>函数的参数分为两种：形参和实参</p><p><strong>形参</strong>：形式参数，不具有实际意义的参数，是在函数定义时使用的参数</p><p><strong>实参</strong>：实际参数，具有实际数据意义的参数，是在函数调用时使用的参数</p><p>形参是实参的载体：实参在调用时通常是需要传入到函数内部参与计算（运算），那么需要在函数内部去找到实际数据所在的位置才能找到数据本身：需要实际调用的时候，将数据以实参的形式传递给形参：给形参赋值，从而使得函数内部可以用到外部数据。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628173503789.png" class><p>注意：</p><ol><li><p>在 PHP 中允许实参多余形参（个数）：函数内部不用而已</p></li><li><p>在 PHP 中理论上形参个数没有限制（实际开发不会太多）</p></li><li><p>实参不能少于形参个数</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628173519627.png" class></li></ol><h5 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h5><p>default value，指的是形参的默认值</p><p>在函数定义的时候，就给形参进行一个初始赋值：如果实际调用传入的参数（实参）没有提供，那么形参就会使用定义时的值来进入函数内部参与运算。</p><p>通常默认值是用在一些，一定会有某个数据参与，但是可能通常是某个我们知道的值。</p><p>注意事项：</p><ol><li>默认值的定义是放在最右边的，不能左边形参有默认值，但是右边没有</li><li>函数外部定义的变量名字与函数定义的形参名字冲突（同名）是没有任何关联关系的；如果多个函数使用同样的形参名字也不冲突</li></ol><h5 id="引用传递"><a href="#引用传递" class="headerlink" title="引用传递"></a>引用传递</h5><p>引用传值注意事项：在传入实参的时候，必须传入变量</p><h4 id="函数体"><a href="#函数体" class="headerlink" title="函数体"></a>函数体</h4><p>函数内部（大括号{}里面）的所有代码都称之为函数体</p><p>基本上所有的代码都可以实现</p><ol><li>定义变量</li><li>定义常量</li><li>使用流程控制（分支、循环）</li><li>可以调用函数</li></ol><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>return，指的是将函数实现的结果，通过 return 关键字，返回给函数外部（函数调用处）：在 PHP 中所有的函数都有返回值。（如果没有明确 return 使用，那么系统默认返回 NULL）</p><p>返回值作用：将计算结果返回给调用处</p><p>注意：函数的返回值可以是任意数据类型</p><p>return 关键字：</p><ol><li><p>return 在函数内部存在的价值：返回当前函数的结果、结束当前函数运行</p></li><li><p>return 还可以在文件中直接使用（不在函数里面）：代表文件将结果 return 后面跟的内容，转交给包含当前文件的位置。（通常在系统配置文件中使用较多），在文件中也代表中终止文件后面的代码：return 之后的内容不会执行。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628174307294.png" class></li></ol><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>变量（常量）能够被访问的区域</p><ol><li>变量可以在普通代码中定义</li><li>变量也可以在函数内部定义</li></ol><p>在 PHP 中作用域严格来说分为两种，但是 PHP 内部还定义一些在严格意义之外的一种，所以总共算三种：</p><ol><li><p>全局变量：就是用户普通定义的变量（函数外部定义）</p><p>所属全局空间：在 PHP 中只允许在全局空间使用：<strong>理论上函数内部不可访问</strong>（与 js 不同）</p><p>脚本周期：直到脚本运行结束（最后一行代码执行完）</p></li><li><p>局部变量：就是在函数内部定义的变量</p><p>所属当前函数空间：在 PHP 中只允许在当前函数自己内部使用</p><p>函数周期：函数执行结束（函数是在栈区中开辟独立内存空间运行）</p></li><li><p>超全局变量：系统定义的变量（预定义变量：$_SERVER、$_POST 等）</p><p>所属超全局空间：没有访问限制（函数内外都可以访问）</p></li></ol><p>超全局变量会将全局变量自动纳入到 $GLOBALS 里面，而 $GLOBALS 没有作用域限制，所以能够帮助局部去访问全局变量：但是必须使用数组方式</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628174933758.png" class><p>除了$GLOBALS 之外，通过参数传值（如果要同步变化还可以使用引用传值）</p><p>在 PHP 中，其实还有一种方式，能够实现全局访问局部，同时局部也可以访问全局：<strong>global 关键字</strong></p><p>global 关键字：是一种在函数里面定义变量的一种方式</p><ol><li>如果使用 global 定义的变量名在外部存在（全局变量），那么系统在函数内部定义的变量直接指向外部全局变量所指向的内存空间（等同于一个变量）；</li><li>如果使用 global 定义的变量名在外部不存在（全局变量），系统会自动在全局空间（外部）定义一个与局部变量同名的全局变量</li></ol><p>本质的形式：在函数的内部和外部，对一个同名变量（全局和局部）使用同一块内存地址保存数据，从而实现共同拥有。</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">global</span> 变量名; <span class="comment">// 不能赋值</span></span><br><span class="line">变量名 = 值;<span class="comment">//修改</span></span><br></pre></td></tr></table></figure><p>虽然以上方式可以实现局部与全局的互访，但是通常不会这么用。一般如果会存在特殊使用，也会使用参数的形式来访问（还可以使用常量：define 定义的）。</p><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>static，是在函数内部定义的变量，使用 static 关键字修饰，用来实现跨函数共享数据的变量：函数运行结束所有局部变量都会清空，如果重新运行一下函数，所有的局部变量又会重新初始化。</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//定义变量</span></span><br><span class="line">    <span class="built_in">static</span> $变量名 = 值;<span class="comment">//通常会在定义的时候就直接赋值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>静态变量的作用是为了跨函数共享数据（同一个函数被多次调用）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628180343510.png" class><p>函数在调用的时候，会自动跳过 static 关键字这一行：(即不再执行重新赋值为 1)</p><p>静态变量的使用：</p><ol><li>为了统计：当前函数被调用的次数</li><li>为了统筹函数多次调用得到的不同结果（递归思想）</li></ol><h4 id="可变函数"><a href="#可变函数" class="headerlink" title="可变函数"></a>可变函数</h4><p>当前有一个变量所保存到值，刚好是一个函数的名字，那么就可以使用<code>变量()</code> 来充当函数名使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$变量 = ‘display’;</span><br><span class="line"><span class="function"><span class="keyword">Function</span> <span class="title">display</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//可变函数</span></span><br><span class="line">$变量(); <span class="comment">// 等价于 display();</span></span><br></pre></td></tr></table></figure><p>可变函数在系统使用的过程中还是比较多的，尤其是使用很多系统函数的时候：需要用户在外部定义一个自定义函数，但是是需要传入到系统函数内部使用。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628181551870.png" class><h4 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h4><h5 id="基本概念-1"><a href="#基本概念-1" class="headerlink" title="基本概念"></a>基本概念</h5><p>匿名函数：没有名字的函数</p><p>基本语法：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">变量名 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    函数体</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>变量保存匿名函数，本质得到的是一个对象（Closure）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628224942148.png" class><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>closure，一词来源于以下两者的结合：要执行的代码块（由于自由变量被包含在代码块中，这些自由变量以及它们引用的对象没有被释放）和为自由变量提供绑定的计算环境（作用域）</p><p>简单理解：函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用（就是函数的内部函数：匿名函数）</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628225513934.png" class><p>证明：函数的局部变量在函数使用完之后没有被释放？</p><ol><li>使用内部匿名函数；</li><li>匿名函数使用局部变量：use；</li><li>匿名函数被返回给外部使用；</li></ol><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628225901656.png" class><h4 id="伪类型"><a href="#伪类型" class="headerlink" title="伪类型"></a>伪类型</h4><p>假类型，实际上在 PHP 中不存在的类型。但是通过伪类型可以帮助程序员去更好的查看操作手册从而更方便学习。</p><p>伪类型主要有两种：在三大类八小类之外</p><ol><li>Mixed：混合的，可以是多种 PHP 中的数据类型</li><li>Number：数值的，可以是任意数值类型（整形和浮点型）</li></ol><h4 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h4><h5 id="有关输出的函数"><a href="#有关输出的函数" class="headerlink" title="有关输出的函数"></a>有关输出的函数</h5><ul><li><p>print()：类似于 echo 输出提供的内容，本质是一种结构（不是函数），返回 1，可以不需要使用括号(因为是结构不是函数)</p></li><li><p>print_r()：类似于 var_dump，但是比 var_dump 简单，不会输出数据的类型，只会输出值（数组打印使用比较多）</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628231543632.png" class><h5 id="有关时间的函数"><a href="#有关时间的函数" class="headerlink" title="有关时间的函数"></a>有关时间的函数</h5><ul><li>date()：按照指定格式对对应的时间戳（从 1970 年格林威治时间开始计算的秒数）转换成对应的格式，如果没有指定特定的时间戳，那么就是默认解释当前时间戳</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628231813625.png" class><ul><li><p>time()：获取当前时间对应的时间戳</p></li><li><p>microtime()：获取微秒级别的时间</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628234013522.png" class><ul><li>strtotime()：按照规定格式的字符串转换成时间戳 (中文不行)</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210628234426704.png" class><h5 id="关于数学的函数"><a href="#关于数学的函数" class="headerlink" title="关于数学的函数"></a>关于数学的函数</h5><ul><li><p>max()：指定参数中最大的值</p></li><li><p>min()：比较两个数中较小的值</p></li><li><p>rand()：得到一个随机数，指定区间的随机整数</p></li><li><p>mt_rand()：与 rand 一样，只是底层结构不一样，效率比 rand 高（建议使用）</p></li><li><p>round()：四舍五入</p></li><li><p>ceil()：向上取整</p></li><li><p>floor()：向下取整</p></li><li><p>pow()：求指定数字的指定指数次结果：pow(2,8) == 2^8 == 256</p></li><li><p>abs()：绝对值</p></li><li><p>sqrt()：求平方根</p></li></ul><h5 id="有关函数的函数"><a href="#有关函数的函数" class="headerlink" title="有关函数的函数"></a>有关函数的函数</h5><ul><li><p>function_exists()：判断指定的函数名字是否在内存中存在（帮助用户不去使用一个不存在的函数，让代码安全性更高）</p></li><li><p>func_get_arg()：在自定义函数中去获取指定数值对应的参数 – 实参位置</p></li><li><p>func_get_args()：在自定义函数中获取所有的参数（数组）– 所有实参</p></li><li><p>func_num_args()：获取当前自定义函数的参数数量 – 实参数量</p></li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629000146909.png" class><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>指的是系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员。</p><h5 id="错误分类"><a href="#错误分类" class="headerlink" title="错误分类"></a>错误分类</h5><ol><li><p>语法错误：语法错误会导致代码在编译过程中不通过，所以代码不会执行（<strong>Parse error</strong>）</p></li><li><p>运行时错误：代码编译通过，但是代码在执行的过程中会出现一些条件不满足导致的错误（<strong>runtime error</strong>）</p></li><li><p>逻辑错误：程序员在写代码时不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$a</span> = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$a</span> = <span class="number">1</span>) &#123; <span class="comment">// 最常见问题：把 == 写成 =</span></span><br><span class="line">    <span class="comment">// 执行代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="错误代号"><a href="#错误代号" class="headerlink" title="错误代号"></a>错误代号</h5><p>所有看到的错误代号在 PHP 中都被定义成了系统常量（可以直接使用）</p><ol><li><p>系统错误：</p><ul><li>E_PARSE ：<strong>Parse error</strong>，编译错误，代码不会执行</li><li>E_ERROR ：<strong>Fatal error</strong>，致命错误，会导致代码不能正确继续执行（出错的位置断掉）</li><li>E_WARNING ：<strong>Warning</strong>，警告错误，不会影响代码执行，但是可能得到意想不到的结果</li><li>E_NOTICE ：<strong>Notice</strong>，通知错误，不会影响代码执行</li></ul></li><li><p>用户错误：</p><p>E_USER_ERROR , E_USER_WARNING , E_USER_NOTICE</p><p>用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到）</p></li><li><p>其他：</p><p>E_ALL，代表着所有的错误（通常在进行错误控制的时候使用比较多），建议在开发过程中（开发环境）使用</p></li></ol><p>所有以 E 开头的错误常量（代号）其实都是由一个字节存储，<strong>每一种错误占据一个对应的位</strong>(比如 0000 0001 表示 E_ERROR，0000 0010 表示 E_WARNING)，如果想进行一些错误的控制，可以使用位运算进行操作</p><ul><li>排除通知级别 notice ：<code>E_ALL &amp; ~E_NOTICE</code></li><li>只要警告和通知：<code>E_WARNING | E_NOTICE</code></li></ul><h5 id="错误触发"><a href="#错误触发" class="headerlink" title="错误触发"></a>错误触发</h5><p>程序运行时触发：系统自动根据错误发生后，对比对应的错误信息，输出给用户：主要针对代码的语法错误和运行时错误。</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629185803983.png" class><p>人为触发：知道某些逻辑可能会出错，从而使用对应的判断代码来触发响应的错误提示</p><p><code>Trigger_error(错误提示)</code>：产生一个用户级别的 error/warning/notice 信息</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629190645937.png" class><p>可以通过第二个参数进行严格性控制</p><ul><li>E_USER_ERROR</li><li>E_USER_WARNING</li><li>E_USER_NOTICE</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629190943882.png" class><h5 id="错误显示设置"><a href="#错误显示设置" class="headerlink" title="错误显示设置"></a>错误显示设置</h5><p>错误显示设置：哪些错误该显示，以及该如何显示</p><p>在 PHP 中，其实有两种方式来设置当前脚本的错误处理：</p><ol><li><p>PHP 的配置文件：全局配置：php.ini 文件</p><ul><li>display_errors：是否显示错误</li><li>error_reporting：显示什么级别的错误</li></ul><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629192249764.png" class></li><li><p>可以在运行的 PHP 脚本中去设置：在脚本中定义的配置项级别比配置文件高（通常在开发当中都会在代码中去进行控制和配置）</p><p>error_reporting()：设置对应的错误显示级别,没有参数表示获取当前系统错误处理对应的级别</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error_reporting(E_ERROR | E_WARNING | E_PARSE);</span><br></pre></td></tr></table></figure><p>ini_set(‘配置文件中的配置项’,配置值)</p><p>ini_set(‘error_reporting’,E_ALL);</p><p>ini_set(‘display_errors’,1);</p></li></ol><h5 id="错误日志设置"><a href="#错误日志设置" class="headerlink" title="错误日志设置"></a>错误日志设置</h5><p>在实际生产环境中，不会直接让错误赤裸裸的展示给用户：</p><ol><li>不友好</li><li>不安全：错误会暴露网站很多信息（路径、文件名）</li></ol><p>所以在生产环境中，一般不显示错误（错误也比较少），但是不可能避免会出现错误（测试的时候不会发现所有的问题），这个时候不希望看到，但是又希望捕捉到可以让后台程序员去修改：需要保存到日志文件中，需要在 PHP 配置文件中或者代码中（ini_set）设置对应 error_log 配置项:</p><ol><li><p>开启日志功能</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193034111.png" class></li><li><p>指定路径 (指定文件不会自动生成，必须手动创建)</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629192910558.png" class></li></ol><h5 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h5><p>最简单的错误处理：<code>trigger_errors()</code> 函数，但是该函数不会阻止系统报错</p><p>PHP 系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加操系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。</p><ol><li><p>如何将用户自定义的函数放到系统中？</p><p><code>set_error_handler()</code></p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193323858.png" class></li><li><p>自定义错误处理函数，系统有要求</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629193429192.png" class></li></ol><p>代码实现：</p><ol><li><p>自定义错误处理函数：注意参数</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629194719236.png" class></li><li><p>注册自定义函数：修改错误处理机制</p><img src="/2021/07/29/php%E7%AC%94%E8%AE%B0/image-20210629195100688.png" class><p>当前属于简单自定义模式，如果要复杂，可以在某些影响代码功能的错误发生后，让用户跳转到某个指定界面。</p></li></ol><p>笔记 CSDN 博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118691660?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_58163927/article/details/118691660?spm=1001.2014.3001.5502</a></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> php </tag>
            
            <tag> Apache </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm笔记</title>
      <link href="/2021/07/29/npm%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/29/npm%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、NPM-简介"><a href="#一、NPM-简介" class="headerlink" title="一、NPM 简介"></a>一、NPM 简介</h2><h3 id="1-1-是什么"><a href="#1-1-是什么" class="headerlink" title="1.1 是什么"></a>1.1 是什么</h3><p>npm（node package manager）：是一个命令行工具</p><h3 id="1-2-能干嘛"><a href="#1-2-能干嘛" class="headerlink" title="1.2 能干嘛"></a>1.2 能干嘛</h3><p>下载 node 所需第三方模块，npm 是 NodeJS 项目模块管理工具</p><h3 id="1-3-去哪儿下"><a href="#1-3-去哪儿下" class="headerlink" title="1.3 去哪儿下"></a>1.3 去哪儿下</h3><p>安装 Node.JS 自带 npm 所以不用重新安装，直接使用。</p><p>检查版本，是否安装：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure><h2 id="二、NPM-语法"><a href="#二、NPM-语法" class="headerlink" title="二、NPM 语法"></a>二、NPM 语法</h2><h4 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h4><ul><li>查看：npm list list 可以简写为 ls</li><li>安装：npm install 模块 或 模块@版本号 [安装可选参数] install 可以简写为 i</li><li>卸载：npm uninstall 模块</li></ul><h4 id="安装参数"><a href="#安装参数" class="headerlink" title="安装参数"></a>安装参数</h4><ul><li>–save 记录生产环境所需模块（默认） 简写为 -S</li><li>–save-dev 记录开发环境所需模块 简写为 -D</li><li>-g 该模块可在命令行运行（global）</li></ul><p>多学一招：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 都安装</span></span><br><span class="line">npm install</span><br><span class="line"><span class="comment">// 只安装生产环境</span></span><br><span class="line">npm install --production</span><br><span class="line"><span class="comment">// 看全局目录所在位置</span></span><br><span class="line">npm config <span class="keyword">list</span></span><br></pre></td></tr></table></figure><h2 id="三、NPM-使用"><a href="#三、NPM-使用" class="headerlink" title="三、NPM 使用"></a>三、NPM 使用</h2><h3 id="3-1-初体验"><a href="#3-1-初体验" class="headerlink" title="3.1 初体验"></a>3.1 初体验</h3><p>初始化 npm</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>安装 MIME 模块</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mime</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入第三方模块 mime （判断文件 MIME 类型）</span></span><br><span class="line"><span class="keyword">var</span> mime = <span class="built_in">require</span>(<span class="string">&quot;mime&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 使用</span></span><br><span class="line"><span class="keyword">var</span> img = <span class="string">&quot;xxx.png&quot;</span>;</span><br><span class="line"><span class="comment">// 获取MIME类型</span></span><br><span class="line"><span class="built_in">console</span>.log(mime.getType(img)); <span class="comment">// ⇨ &#x27;image/png&#x27;</span></span><br><span class="line"><span class="comment">// 获取文件扩展名</span></span><br><span class="line"><span class="built_in">console</span>.log(mime.getExtension(mime.getType(img))); <span class="comment">// ⇨ &#x27;null&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="全局使用"><a href="#全局使用" class="headerlink" title="全局使用"></a>全局使用</h4><p>查看全局目录，命令行输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="keyword">list</span></span><br></pre></td></tr></table></figure><p>找到全局路径：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prefix = <span class="string">&quot;C:\\Users\\AgoniLay\\AppData\\Roaming\\npm&quot;</span></span><br></pre></td></tr></table></figure><p>安装全局：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mime -g</span><br></pre></td></tr></table></figure><p>安装在生产环境中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install mime --save</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;mime&quot;</span>: <span class="string">&quot;^2.5.2&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装在开发环境中：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install jquery --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;jquery&quot;</span>: <span class="string">&quot;^3.6.0&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仅安装生产环境中的依赖：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --production</span><br></pre></td></tr></table></figure><h2 id="四、NPM-模块版本控制（了解）"><a href="#四、NPM-模块版本控制（了解）" class="headerlink" title="四、NPM 模块版本控制（了解）"></a>四、NPM 模块版本控制（了解）</h2><h3 id="科普软件版本含义："><a href="#科普软件版本含义：" class="headerlink" title="科普软件版本含义："></a>科普软件版本含义：</h3><ul><li>aplha 版 - 内测版（功能不全，bug 多）</li><li>beta 版 - 公测版（功能不全，发骚友准备，依旧存在 bug）</li><li>rc 版 - 预览版（功能不再增减）</li><li>stable 版 - 用户可用</li></ul><p>主版本号.次版本号.修改版本号</p><ul><li>^ ：用户使用该版本后，最多升级到【修改版】最新</li><li>～ ：用户使用该版本后，最多升级到【次版本】最新</li><li>* ：用户使用该版本后，最多升级到最新版本</li></ul><h2 id="五、NPM-源管理"><a href="#五、NPM-源管理" class="headerlink" title="五、NPM 源管理"></a>五、NPM 源管理</h2><p>通过 npm 命令下载会到国外服务器获取</p><p>缺点：下载速度慢</p><p>解决：切换到国内服务器</p><h3 id="nrm"><a href="#nrm" class="headerlink" title="nrm"></a>nrm</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install nrm -g</span><br><span class="line"><span class="comment">// 查看  ls 为 list 缩写</span></span><br><span class="line">nrm ls</span><br><span class="line"><span class="comment">// 切换服务器名</span></span><br><span class="line">nrm <span class="keyword">use</span> 服务器名</span><br><span class="line">// 测速</span><br><span class="line"><span class="title">nrm</span> <span class="title">test</span></span><br></pre></td></tr></table></figure><h2 id="六、NPM-自定义脚本命令（重点，难点）"><a href="#六、NPM-自定义脚本命令（重点，难点）" class="headerlink" title="六、NPM 自定义脚本命令（重点，难点）"></a>六、NPM 自定义脚本命令（重点，难点）</h2><p>通过修改 package.json 文件的 scripts 自定义脚本命令</p><p>必须严格遵循格式</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;a&quot;</span>: <span class="string">&quot;echo 666&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;start&quot;</span>: <span class="string">&quot;node ./mime_text.js&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">npm run a</span><br><span class="line">    <span class="comment">// 666</span></span><br><span class="line">npm start</span><br><span class="line">    <span class="comment">// 运行</span></span><br></pre></td></tr></table></figure><h2 id="七、NPM-包自定义发布（能跟着笔记敲）"><a href="#七、NPM-包自定义发布（能跟着笔记敲）" class="headerlink" title="七、NPM 包自定义发布（能跟着笔记敲）"></a>七、NPM 包自定义发布（能跟着笔记敲）</h2><ol><li><p>自定义模块，创建文件夹，打开终端 cd 到该文件夹下 初始化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure><p>index.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;phpopenfather&quot;</span>,</span><br><span class="line">  <span class="attr">school</span>: <span class="string">&quot;php@itcast&quot;</span>,</span><br><span class="line">  <span class="attr">say</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;悟空&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> un;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = fn;</span><br></pre></td></tr></table></figure></li><li><p>设置 package</p><ul><li>name - 模块名</li><li>description - 描述</li><li>keywords - 关键词</li></ul><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;itcast-php-agonilay&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;this is demo2&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span>: [<span class="string">&quot;itcast&quot;</span>, <span class="string">&quot;phpdemo&quot;</span>],</span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>打开 <a href="http://npmjs.com/">http://npmjs.com</a> 注册/登录 账号</p><p>本地登录提交（切记提交自己的包必须切换到国外服务器，下载再切换过来）</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 切换到国外服务器</span></span><br><span class="line">nrm <span class="keyword">use</span> <span class="title">npm</span></span><br><span class="line">// 登录</span><br><span class="line"><span class="title">npm</span> <span class="title">login</span></span><br><span class="line">&gt;<span class="title">Username</span>: <span class="title">agonilay</span></span><br><span class="line">&gt;<span class="title">Password</span>:</span><br><span class="line">&gt;<span class="title">Email</span>: (<span class="title">this</span> <span class="title">IS</span> <span class="title">public</span>) 1394310259@<span class="title">qq</span>.<span class="title">com</span></span><br><span class="line">&gt;<span class="title">Logged</span> <span class="title">in</span> <span class="title">as</span> <span class="title">agonilay</span> <span class="title">on</span> <span class="title">https</span>://<span class="title">registry</span>.<span class="title">npmjs</span>.<span class="title">org</span>/.</span><br><span class="line">// 提交</span><br><span class="line"><span class="title">npm</span> <span class="title">publish</span></span><br><span class="line">    // 版本号不能是 1.0.0</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i itcast-php-agonilay</span><br></pre></td></tr></table></figure><p>test.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = <span class="built_in">require</span>(<span class="string">&quot;itcast-php-agonilay&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test);</span><br><span class="line"><span class="built_in">console</span>.log(test.name);</span><br><span class="line">test.say();</span><br></pre></td></tr></table></figure><p>测试运行：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm text.js</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">&#123; name: <span class="string">&#x27;phpopenfather&#x27;</span>, school: <span class="string">&#x27;php@itcast&#x27;</span>, say: [<span class="function"><span class="keyword">Function</span>: <span class="title">say</span>] &#125;</span></span><br><span class="line"><span class="function"><span class="title">phpopenfather</span></span></span><br><span class="line"><span class="function">悟空</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="nodemon-自动重启服务（第三方模块）"><a href="#nodemon-自动重启服务（第三方模块）" class="headerlink" title="nodemon 自动重启服务（第三方模块）"></a>nodemon 自动重启服务（第三方模块）</h2><h3 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h3><p>通过 nodemon 检测文件修改自动重启</p><h3 id="2、使用"><a href="#2、使用" class="headerlink" title="2、使用"></a>2、使用</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 安装</span></span><br><span class="line">npm install nodemon --save-dev</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 运行</span></span><br><span class="line">nodemon index.js</span><br></pre></td></tr></table></figure><h2 id="moment-日期处理模块（第三方模块）"><a href="#moment-日期处理模块（第三方模块）" class="headerlink" title="moment 日期处理模块（第三方模块）"></a>moment 日期处理模块（第三方模块）</h2><h3 id="1、简介-1"><a href="#1、简介-1" class="headerlink" title="1、简介"></a>1、简介</h3><p>自己封装模块或使用第三方模块（<a href="http://momentjs.cn/%EF%BC%89">http://momentjs.cn/）</a></p><h3 id="2、使用-1"><a href="#2、使用-1" class="headerlink" title="2、使用"></a>2、使用</h3><ol><li><p>初始化项目</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>安装 moment</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moment = <span class="built_in">require</span>(<span class="string">&quot;moment&quot;</span>);</span><br><span class="line">moment().format();</span><br></pre></td></tr></table></figure><p>需要使用哪种格式去 <a href="http://momentjs.cn/">http://momentjs.cn/</a> 查看</p></li></ol><p>笔记 CSDN 博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118678133?spm=1001.2014.3001.5502">https://blog.csdn.net/qq_58163927/article/details/118678133?spm=1001.2014.3001.5502</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> nodemon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodeJS笔记</title>
      <link href="/2021/07/29/NodeJS%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/29/NodeJS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="一、NodeJS-简介"><a href="#一、NodeJS-简介" class="headerlink" title="一、NodeJS 简介"></a>一、NodeJS 简介</h3><h4 id="1-1-Node-js-是什么"><a href="#1-1-Node-js-是什么" class="headerlink" title="1.1 Node.js 是什么"></a>1.1 Node.js 是什么</h4><p>Node.js 是 JavaScript 运行环境</p><p>可以直接通过浏览器访问 JavaScript 代码</p><h4 id="1-2-能干什么"><a href="#1-2-能干什么" class="headerlink" title="1.2 能干什么"></a>1.2 能干什么</h4><p>作用：让 JavaScript 成为与 PHP、Python 等平起平坐的语言</p><p>概括：前端脱离后端，直接通过 JS 写项目</p><h4 id="1-3-下载"><a href="#1-3-下载" class="headerlink" title="1.3 下载"></a>1.3 下载</h4><p>官网：<a href="http://nodejs.org/">http://nodejs.org</a></p><p>中文网址：<a href="http://nodejs.cn/">http://nodejs.cn</a></p><p>学习社区：condjs.org</p><ul><li>nvm 工具：实现 nodejs 任意版本的切换</li><li>npm 工具：下载 nodejs 所需模块（工具库）</li><li>nrm 工具：切换 npm 下载源</li></ul><h3 id="二、安装-NodeJS"><a href="#二、安装-NodeJS" class="headerlink" title="二、安装 NodeJS"></a>二、安装 NodeJS</h3><h3 id="三、初体验-REPL-（了解）"><a href="#三、初体验-REPL-（了解）" class="headerlink" title="三、初体验 REPL （了解）"></a>三、初体验 REPL （了解）</h3><ul><li>R read 读取（读取用户输入的 JS 代码）</li><li>E exec 执行（执行用户输入的 JS 代码）</li><li>P print 打印（打印用户输入的 JS 代码）</li><li>L loop 循环（后续所有的 JS 代码执行都会循环以上命令）</li><li><pre><code>          退出（按两下 ctrl + c）</code></pre></li></ul><h4 id="仿谷歌控制台"><a href="#仿谷歌控制台" class="headerlink" title="仿谷歌控制台"></a>仿谷歌控制台</h4><p>cmd 窗口输入 node 回车开启仿谷歌控制台</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cls <span class="comment">// 清屏</span></span><br></pre></td></tr></table></figure><h4 id="初体验"><a href="#初体验" class="headerlink" title="初体验"></a>初体验</h4><p>cmd 窗口中 cd 到该目录下输入：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node hello.js</span><br></pre></td></tr></table></figure><h3 id="四、模块系统"><a href="#四、模块系统" class="headerlink" title="四、模块系统"></a>四、模块系统</h3><h4 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1 简介"></a>4.1 简介</h4><h5 id="使用-NodeJS-编写应用程序主要使用："><a href="#使用-NodeJS-编写应用程序主要使用：" class="headerlink" title="使用 NodeJS 编写应用程序主要使用："></a>使用 NodeJS 编写应用程序主要使用：</h5><ul><li>ECMAScript 语法：变量、判断、循环等语法（JS 三大组成部分：ECMA/DOM/BOM）</li><li>内置/核心模块：http 服务、fs 文件操作、url 路径、 path 路径处理、os 操作系统</li><li>第三方模块：</li><li>自定义模块：自己创建的 js 文件</li></ul><h5 id="CommonJS-模块规范"><a href="#CommonJS-模块规范" class="headerlink" title="CommonJS 模块规范"></a>CommonJS 模块规范</h5><ul><li>一个文件就是一个模块</li><li>通过 exports 和 module.exports 来导出模块中的成员（声明模块中那些功能可以使用）</li><li>通过 require 来加载模块</li></ul><h4 id="4-2-自定义-Node-js-模块"><a href="#4-2-自定义-Node-js-模块" class="headerlink" title="4.2 自定义 Node.js 模块"></a>4.2 自定义 Node.js 模块</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：导出成员（声明模块/文件中那些方法可以被外部使用）</span></span><br><span class="line"><span class="comment">// 写法1</span></span><br><span class="line"><span class="built_in">exports</span>.属性/方法名 = 功能</span><br><span class="line"><span class="comment">// 写法2</span></span><br><span class="line"><span class="built_in">module</span>.exports.属性/方法名 = 变量名</span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：导出成员（声明模块/文件中那些方法可以被外部使用）</span></span><br><span class="line"><span class="keyword">var</span> 对象 = <span class="built_in">require</span>(<span class="string">&#x27;路径及文件名&#x27;</span>);</span><br><span class="line">对象.属性或方法名;</span><br></pre></td></tr></table></figure><h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p>b.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：定义</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is add&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">del</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is del&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">edit</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is edit&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">select</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;this is select&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 步骤二：导出（语法：exports/module.exports.成员名 = 值）</span></span><br><span class="line"><span class="built_in">exports</span>.add = add;</span><br><span class="line"><span class="built_in">exports</span>.del = del;</span><br><span class="line"><span class="built_in">exports</span>.edit = edit;</span><br><span class="line"><span class="built_in">exports</span>.select = select;</span><br></pre></td></tr></table></figure><p>a.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入自定义模块</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">&quot;./b&quot;</span>); <span class="comment">// 注：.js不用写</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b);</span><br><span class="line"></span><br><span class="line">b.add();</span><br><span class="line">b.del();</span><br></pre></td></tr></table></figure><p>exports 就是 module.exports 的简写</p><h4 id="4-3-第三方-Node-js-模块"><a href="#4-3-第三方-Node-js-模块" class="headerlink" title="4.3 第三方 Node.js 模块"></a>4.3 第三方 Node.js 模块</h4><h4 id="4-4-内置-Node-js-模块"><a href="#4-4-内置-Node-js-模块" class="headerlink" title="4.4 内置 Node.js 模块"></a>4.4 内置 Node.js 模块</h4><h5 id="os-模块：操作系统-（了解）"><a href="#os-模块：操作系统-（了解）" class="headerlink" title="os 模块：操作系统 （了解）"></a>os 模块：操作系统 （了解）</h5><p>提供了一些操作系统相关的实用方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入</span></span><br><span class="line"><span class="keyword">const</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建os对象（引入ondejs内置os对象）</span></span><br><span class="line"><span class="keyword">var</span> os = <span class="built_in">require</span>(<span class="string">&quot;os&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 调用os对象方法获取系统数据</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;hello，&quot;</span> + os.EOL + <span class="string">&quot;itcast&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;主机名：&quot;</span> + os.hostname());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;操作系统名：&quot;</span> + os.type());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;操作系统平台：&quot;</span> + os.platform());</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;内存总量：&quot;</span> + os.totalmem() + <span class="string">&quot; 字节.&quot;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;空闲内存：&quot;</span> + os.freemem() + <span class="string">&quot; 字节.&quot;</span>);</span><br></pre></td></tr></table></figure><h6 id="字节概念："><a href="#字节概念：" class="headerlink" title="字节概念："></a>字节概念：</h6><p>1 字节（Byte）= 8 位（bit）</p><p>1KB = 1024Byte（字节）</p><p>1M = 1024KB</p><p>1G = 1024M</p><h5 id="path-模块：路径处理"><a href="#path-模块：路径处理" class="headerlink" title="path 模块：路径处理"></a>path 模块：路径处理</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// dirname后去一层</span></span><br><span class="line"><span class="comment">// basename 取最后一层</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 引入内置模块</span></span><br><span class="line"><span class="keyword">var</span> path = <span class="built_in">require</span>(<span class="string">&quot;path&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 练习</span></span><br><span class="line"><span class="keyword">var</span> testData = <span class="string">&quot;c:/Users/AgoniLay/Desktop/zbw/work/index.html&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(testData)); <span class="comment">// index.html</span></span><br><span class="line">testData = path.dirname(testData);</span><br><span class="line"><span class="built_in">console</span>.log(testData); <span class="comment">// c:/Users/AgoniLay/Desktop/zbw/work</span></span><br><span class="line"><span class="built_in">console</span>.log(path.basename(testData)); <span class="comment">// work</span></span><br></pre></td></tr></table></figure><h5 id="url-模块：网址处理"><a href="#url-模块：网址处理" class="headerlink" title="url 模块：网址处理"></a>url 模块：网址处理</h5><p>需求：获取网址 <a href="http://itcast.cn/?name=AgoniLay&amp;age=19">http://itcast.cn?name=AgoniLay&amp;age=19</a> 中的参数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入url内置模块</span></span><br><span class="line"><span class="keyword">var</span> url = <span class="built_in">require</span>(<span class="string">&quot;url&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 使用</span></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">&quot;http://itcast.cn?name=AgoniLay&amp;age=19&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(data);</span><br><span class="line"><span class="built_in">console</span>.log(url.parse(data));</span><br><span class="line"><span class="built_in">console</span>.log(url.parse(data, <span class="literal">true</span>)); <span class="comment">// query值转换为对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> urlQueryObj = url.parse(data, <span class="literal">true</span>);</span><br><span class="line"><span class="built_in">console</span>.log(urlQueryObj.query); <span class="comment">// &#123; name: &#x27;AgoniLay&#x27;, age: &#x27;19&#x27; &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(urlQueryObj.query.name); <span class="comment">// AgoniLay</span></span><br><span class="line"><span class="built_in">console</span>.log(urlQueryObj.query.age); <span class="comment">// 19</span></span><br></pre></td></tr></table></figure><h5 id="fs-模块：文件系统"><a href="#fs-模块：文件系统" class="headerlink" title="fs 模块：文件系统"></a>fs 模块：文件系统</h5><h6 id="1-写入文件"><a href="#1-写入文件" class="headerlink" title="1. 写入文件"></a>1. 写入文件</h6><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 fs 内置对象</span></span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 调用函数写数据进文件</span></span><br><span class="line">fs.writeFile(<span class="string">&quot;路径及文件名&quot;</span>, <span class="string">&quot;数据&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// err   为 null -则写入成功</span></span><br><span class="line">  <span class="comment">// err 不为 null -则写入失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>练习：通过 write.js 创建 a.txt 写入 你好，AgoniLay</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">fs.writeFile(<span class="string">&quot;./a.txt&quot;</span>, <span class="string">&quot;你好，AgoniLay&quot;</span>, <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// err 为null     成功</span></span><br><span class="line">  <span class="comment">// err 不为null   有瑕疵</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;success&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="2-读取文件"><a href="#2-读取文件" class="headerlink" title="2. 读取文件"></a>2. 读取文件</h6><p>语法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用函数从文件读数据</span></span><br><span class="line">fs.writeFile(<span class="string">&quot;路径及文件名&quot;</span>, <span class="string">&quot;数据&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// err   为 null -则读取成功</span></span><br><span class="line">  <span class="comment">// err  不为 null -则读取失败</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>练习：通过 read.js 文件读取 a.txt 内容</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">&quot;./a.txt&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// err 为null     成功</span></span><br><span class="line">  <span class="comment">// err 不为null   有瑕疵</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data); <span class="comment">// 默认不是我们可识别的内容</span></span><br><span class="line">  <span class="comment">// 而是 Buffer对象</span></span><br><span class="line">  <span class="comment">// 通过 Buffer对象.toString() 转化为字符显示</span></span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>省去转换，提前声明：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多学一招：前期读的时候就声明</span></span><br><span class="line">fs.readFile(<span class="string">&quot;./a.txt&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// err 为null     成功</span></span><br><span class="line">  <span class="comment">// err 不为null   有瑕疵</span></span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="http-模块（构建-http-服务器）"><a href="#http-模块（构建-http-服务器）" class="headerlink" title="http 模块（构建 http 服务器）"></a>http 模块（构建 http 服务器）</h5><h6 id="1-创建-http-服务器"><a href="#1-创建-http-服务器" class="headerlink" title="1. 创建 http 服务器"></a>1. 创建 http 服务器</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  1. 引入 http 模块</span></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建web服务器</span></span><br><span class="line"><span class="keyword">var</span> server = http.createServer();</span><br><span class="line"><span class="comment">// 3. 监听请求</span></span><br><span class="line">server.on(<span class="string">&quot;request&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// req - request 请求  res - response 响应</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;收到客户端请求，请求地址：&quot;</span> + req.url);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 响应数据</span></span><br><span class="line">  res.write(<span class="string">&quot;hello AgoniLay&quot;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4. 启动服务</span></span><br><span class="line">server.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务启动成功，访问：http://localhost:8080&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="2-响应不同数据"><a href="#2-响应不同数据" class="headerlink" title="2. 响应不同数据"></a>2. 响应不同数据</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解决乱码</span></span><br><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br></pre></td></tr></table></figure><p>判断用户访问的是首页还是登录页</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断请求的地址</span></span><br><span class="line"><span class="keyword">if</span> (req.url == <span class="string">&quot;/&quot;</span> || req.url == <span class="string">&quot;/index&quot;</span>) &#123;</span><br><span class="line">  $msg = <span class="string">&quot;this is index&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.url == <span class="string">&quot;/login&quot;</span>) &#123;</span><br><span class="line">  $msg = <span class="string">&quot;this is login&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  $msg = <span class="string">&quot;404&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、请求和响应对象"><a href="#五、请求和响应对象" class="headerlink" title="五、请求和响应对象"></a>五、请求和响应对象</h3><h4 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h4><h5 id="请求对象（request）"><a href="#请求对象（request）" class="headerlink" title="请求对象（request）"></a>请求对象（request）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">req.headers获取请求头信息（对象）</span><br><span class="line">req.rawHeaders获取请求头信息（数组）</span><br><span class="line">req.httpVersion获取 HTTP 版本</span><br><span class="line">req.method获取请求方法</span><br><span class="line">req.url获取请求路径（注：不含网址）</span><br></pre></td></tr></table></figure><h5 id="响应对象（response）"><a href="#响应对象（response）" class="headerlink" title="响应对象（response）"></a>响应对象（response）</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">res.statusCode = <span class="number">404</span>;</span><br><span class="line">res.statusMessage = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line">res.setHeader(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;text/html;charset=utf-8&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简化版</span></span><br><span class="line">res.writeHeader(<span class="string">&quot;404&quot;</span>, <span class="string">&quot;Not Found&quot;</span>, &#123;</span><br><span class="line">  <span class="string">&quot;Content-Type&quot;</span>: <span class="string">&quot;text/html;charset=utf-8&quot;</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">res.write(<span class="string">&quot;数据&quot;</span>);</span><br><span class="line">res.end();</span><br></pre></td></tr></table></figure><h4 id="检测静态资源并响应"><a href="#检测静态资源并响应" class="headerlink" title="检测静态资源并响应"></a>检测静态资源并响应</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (currentUrl.indexOf(<span class="string">&quot;/public&quot;</span>) === <span class="number">0</span>) &#123;</span><br><span class="line">  <span class="comment">// 检测静态资源并响应（略难）</span></span><br><span class="line">  fs.readFile(<span class="string">&quot;./&quot;</span> + currentUrl, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) res.end(<span class="string">&quot;404 Not Found&quot;</span>);</span><br><span class="line">    res.write(data);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六、表单提交数据处理（留言板案例）"><a href="#六、表单提交数据处理（留言板案例）" class="headerlink" title="六、表单提交数据处理（留言板案例）"></a>六、表单提交数据处理（留言板案例）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 表单提交数据处理</span></span><br><span class="line"><span class="keyword">if</span> (req.method == <span class="string">&quot;POST&quot;</span>) &#123;</span><br><span class="line">  <span class="comment">//明确：表单post提交的数据可能会非常大，所以分片获取</span></span><br><span class="line">  <span class="comment">//说明：data事件-数据传输中，end事件-数据传输完毕</span></span><br><span class="line">  <span class="keyword">var</span> postData = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  req.on(<span class="string">&quot;data&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">chunk</span>) </span>&#123;</span><br><span class="line">    postData += chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(<span class="string">&quot;end&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//通过querystring模块将字符串数据转化为对象</span></span><br><span class="line">    paramObj = querystring.parse(postData);</span><br><span class="line">    <span class="comment">// 2. 入库（压入到数组中 push pop）</span></span><br><span class="line">    <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="keyword">var</span> date =</span><br><span class="line">      d.getFullYear() +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      d.getMonth() +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      d.getDate() +</span><br><span class="line">      <span class="string">&quot; &quot;</span> +</span><br><span class="line">      d.getHours() +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      d.getMinutes() +</span><br><span class="line">      <span class="string">&quot;-&quot;</span> +</span><br><span class="line">      d.getSeconds();</span><br><span class="line">    <span class="keyword">var</span> msg = &#123;</span><br><span class="line">      <span class="attr">name</span>: paramObj.name,</span><br><span class="line">      <span class="attr">content</span>: paramObj.content,</span><br><span class="line">      <span class="attr">create_at</span>: date,</span><br><span class="line">    &#125;;</span><br><span class="line">    msgs.push(msg);</span><br><span class="line">    <span class="comment">// 3. 跳转</span></span><br><span class="line">    res.statusCode = <span class="number">302</span>;</span><br><span class="line">    res.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 1. 接收数据</span></span><br><span class="line">  <span class="keyword">var</span> paramObj = url.parse(req.url, <span class="literal">true</span>).query;</span><br><span class="line">  <span class="comment">// 2. 入库（压入到数组中 push pop）</span></span><br><span class="line">  <span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">  <span class="keyword">var</span> date =</span><br><span class="line">    d.getFullYear() +</span><br><span class="line">    <span class="string">&quot;-&quot;</span> +</span><br><span class="line">    d.getMonth() +</span><br><span class="line">    <span class="string">&quot;-&quot;</span> +</span><br><span class="line">    d.getDate() +</span><br><span class="line">    <span class="string">&quot; &quot;</span> +</span><br><span class="line">    d.getHours() +</span><br><span class="line">    <span class="string">&quot;-&quot;</span> +</span><br><span class="line">    d.getMinutes() +</span><br><span class="line">    <span class="string">&quot;-&quot;</span> +</span><br><span class="line">    d.getSeconds();</span><br><span class="line">  <span class="keyword">var</span> msg = &#123; <span class="attr">name</span>: paramObj.name, <span class="attr">content</span>: paramObj.content, <span class="attr">create_at</span>: date &#125;;</span><br><span class="line">  msgs.push(msg);</span><br><span class="line">  <span class="comment">// 3. 跳转</span></span><br><span class="line">  res.statusCode = <span class="number">302</span>;</span><br><span class="line">  res.setHeader(<span class="string">&quot;Location&quot;</span>, <span class="string">&quot;/&quot;</span>);</span><br><span class="line">  res.end();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="⭐-扩展"><a href="#⭐-扩展" class="headerlink" title="⭐ 扩展"></a>⭐ 扩展</h3><h4 id="1-自定义网站图标"><a href="#1-自定义网站图标" class="headerlink" title="1. 自定义网站图标"></a>1. 自定义网站图标</h4><h4 id="2-MIME"><a href="#2-MIME" class="headerlink" title="2. MIME"></a>2. MIME</h4><p>MIME(Multipurpose Internet Mail Extensions) 是描述消息内容类型的英特网标准。</p><p>text/html - html 文件 text/javascript - javascript 文件 image/png - png 文件</p><h4 id="3-状态码-301-amp-302"><a href="#3-状态码-301-amp-302" class="headerlink" title="3. 状态码 301 &amp; 302"></a>3. 状态码 301 &amp; 302</h4>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express笔记</title>
      <link href="/2021/07/29/Express%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/29/Express%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="一、Express-简介"><a href="#一、Express-简介" class="headerlink" title="一、Express 简介"></a>一、Express 简介</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>基于 nodejs 开发的一个框架</p><h4 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h4><p>加快项目开发，便于团队协作</p><h2 id="二、使用（初体验）"><a href="#二、使用（初体验）" class="headerlink" title="二、使用（初体验）"></a>二、使用（初体验）</h2><ol><li><p>创建开发目录，初始化</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm init -y</span><br></pre></td></tr></table></figure></li><li><p>安装 express</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li><li><p>使用</p><p>app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入模块</span></span><br><span class="line"><span class="keyword">var</span> experss = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 创建 web服务器</span></span><br><span class="line"><span class="keyword">var</span> app = experss();</span><br><span class="line"><span class="comment">// 3. 路由</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// end()    响应字符串（乱码）</span></span><br><span class="line">  <span class="comment">// send()   响应字符串（自动识别）</span></span><br><span class="line">  <span class="comment">// render() 响应字符串（自动识别，只能获取指定文件字符串并响应，注：必须配合模板引擎使用）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// res.end(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;)</span></span><br><span class="line">  res.send(<span class="string">&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 4. 启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;启动成功，访问：http://localhost:8080&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><h2 id="三、配置模板引擎（art）"><a href="#三、配置模板引擎（art）" class="headerlink" title="三、配置模板引擎（art）"></a>三、配置模板引擎（art）</h2><ul><li>默认通过公 end 或 send 渲染，无法加载视图，所以得自己配置默认模板引擎官方以前推荐用 jade 现在升级为 pug 也有用 ejs 个人推荐 art 模板引擎</li><li>文档：<a href="http://aui.github.io/art-template/zh-cn/express/">http://aui.github.io/art-template/zh-cn/express/</a></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;express-art-template&quot;</span>));</span><br></pre></td></tr></table></figure><h4 id="安装使用"><a href="#安装使用" class="headerlink" title="安装使用"></a>安装使用</h4><p>安装</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install art-template</span><br><span class="line">npm install express-art-template</span><br></pre></td></tr></table></figure><p>创建 views 目录</p><p>test1.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;username&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;age&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;if age &gt; 18&#125;&#125; 妹妹哥哥来了 &#123;&#123;else&#125;&#125; 你走吧 &#123;&#123;/if&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      &#123;&#123;each orders as order index&#125;&#125; &#123;&#123;index&#125;&#125; &#123;&#123;order.title&#125;&#125; &#123;&#123;/each&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>app2.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入模块</span></span><br><span class="line"><span class="keyword">var</span> experss = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 创建 web服务器</span></span><br><span class="line"><span class="keyword">var</span> app = experss();</span><br><span class="line"><span class="comment">// 3. 配置</span></span><br><span class="line"><span class="comment">// 声明所使用的模板引擎（ps. 使用render方法必须）</span></span><br><span class="line">app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;express-art-template&quot;</span>));</span><br><span class="line"><span class="comment">// 4. 路由</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// end()    响应字符串（乱码）</span></span><br><span class="line">  <span class="comment">// send()   响应字符串（自动识别）</span></span><br><span class="line">  <span class="comment">// render() 响应字符串（自动识别，只能获取指定文件字符串并响应，注：必须配合模板引擎使用）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// res.end(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;)</span></span><br><span class="line">  <span class="comment">// res.send(&quot;哥哥来抓我呀，&lt;a href=&#x27;http://nn.com&#x27;&gt;点击进入我的世界&lt;/a&gt;&quot;);</span></span><br><span class="line">  res.render(<span class="string">&quot;test1.html&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;张艺兴&quot;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">5</span>,</span><br><span class="line">    <span class="attr">orders</span>: [</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">1</span>, <span class="attr">title</span>: <span class="string">&quot;标题1&quot;</span>, <span class="attr">price</span>: <span class="number">30</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">2</span>, <span class="attr">title</span>: <span class="string">&quot;标题2&quot;</span>, <span class="attr">price</span>: <span class="number">33</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">id</span>: <span class="number">3</span>, <span class="attr">title</span>: <span class="string">&quot;标题3&quot;</span>, <span class="attr">price</span>: <span class="number">12</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 5. 启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;启动成功，访问：http://localhost:8080&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h5 id="扩展：HTTP-请求类型"><a href="#扩展：HTTP-请求类型" class="headerlink" title="扩展：HTTP 请求类型"></a>扩展：HTTP 请求类型</h5><pre><code>OPTIONS、GET、HEAD、POST、PUT、DELETE、TRACEa</code></pre><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul><li>什么是路由：就是网址</li><li>什么是路由参数：就是网址参数</li><li>在 PHP 中作用：声明交给哪个控制器的哪个方法处理</li><li>在 NodeJS 中作用：交给指定匿名函数处理</li></ul><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>**<em>普通语法</em>**：app.HTTP 请求类型（请求路径，回调函数）</p><p>发送**<em>GET</em><strong>请求：app.</strong><em>get</em>**（请求路径，回调函数）</p><p>发送**<em>POST</em><strong>请求：app.</strong><em>post</em>**（请求路径，回调函数）</p><p>发送**<em>任意</em><strong>请求：app.</strong><em>all</em>**（请求路径，回调函数）</p><p>**<em>特殊语法：</em><strong>app.</strong><em>use</em>**（请求路径，回调函数）</p><p>区别 1：use 匹配任意类型请求</p><p>区别 2：**<em>use 非完全匹配</em><strong>（ps. 只需要</strong><em>url 前面匹配</em>**请求路径即可匹配）</p><p>**<em>路由参数：</em><strong>app.</strong><em>HTTP 请求类型</em>**（请求路径/:参数 1/…/:参数 n，回调函数）</p><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>app3.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入express框架模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">//2.创建框架核心app对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//3.路由</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//注：修改method=get 或者 method=post查看结果</span></span><br><span class="line">  <span class="keyword">var</span> formHtml = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/test&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;  /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">  res.send(formHtml);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;this is get submit&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.post(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;this is post submit&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="特殊语法练习"><a href="#特殊语法练习" class="headerlink" title="特殊语法练习"></a>特殊语法练习</h4><p>app4.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入express框架模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">//2.创建框架核心app对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//3.路由</span></span><br><span class="line">app.get(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> formHtml = <span class="string">`</span></span><br><span class="line"><span class="string">&lt;form action=&quot;/test/a/b/c&quot; method=&quot;post&quot;&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;text&quot; name=&quot;uname&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;text&quot; name=&quot;age&quot; /&gt;</span></span><br><span class="line"><span class="string">&lt;input type=&quot;submit&quot;  /&gt;</span></span><br><span class="line"><span class="string">&lt;/form&gt;</span></span><br><span class="line"><span class="string">`</span>;</span><br><span class="line">  res.send(formHtml);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.use(<span class="string">&quot;/test&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;this is /test&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h4 id="路由参数练习"><a href="#路由参数练习" class="headerlink" title="路由参数练习"></a>路由参数练习</h4><p>app5.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入express框架模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">//2.创建框架核心app对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//3.路由</span></span><br><span class="line">app.get(<span class="string">&quot;/stu/:name/:age&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.params);</span><br><span class="line">  res.send(<span class="string">&quot;匹配成功，快去看控制台有没有获取数据..&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//4.启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="五、利用-Express-托管静态文件"><a href="#五、利用-Express-托管静态文件" class="headerlink" title="五、利用 Express 托管静态文件"></a>五、利用 Express 托管静态文件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&quot;/public&quot;</span>, express.static(<span class="string">&quot;public&quot;</span>));</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.引入express框架模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="comment">//2.创建框架核心app对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//3.路由</span></span><br><span class="line"><span class="comment">// 响应指定静态资源</span></span><br><span class="line">app.get(<span class="string">&quot;/public/css/a.css&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;./public/css/a.css&quot;</span>, <span class="string">&quot;utf8&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) res.send(err);</span><br><span class="line">    res.send(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 响应多个静态资源</span></span><br><span class="line"><span class="comment">// app.use(&#x27;/public&#x27;, function(req, res)&#123;</span></span><br><span class="line"><span class="comment">// fs.readFile(&#x27;./public/&#x27; + req.url , &#x27;utf8&#x27;, function (err, data) &#123;</span></span><br><span class="line"><span class="comment">// if (err) res.send(err);</span></span><br><span class="line"><span class="comment">// res.send(data)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// 在express中</span></span><br><span class="line"><span class="comment">// 作用：允许指定目录下的文件被外访问</span></span><br><span class="line"><span class="comment">// 语法：express.static(&#x27;目录名&#x27;)</span></span><br><span class="line"><span class="comment">// 返回：一个函数，可理解为读取URL需要读取的文件</span></span><br><span class="line">app.use(<span class="string">&quot;/public&quot;</span>, express.static(<span class="string">&quot;public&quot;</span>));</span><br><span class="line"><span class="comment">//4.启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h2 id="六、案例"><a href="#六、案例" class="headerlink" title="六、案例"></a>六、案例</h2><h3 id="NodeJS-each-循环"><a href="#NodeJS-each-循环" class="headerlink" title="NodeJS each 循环"></a>NodeJS each 循环</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- node.js each循环 --&gt;</span></span><br><span class="line">&#123;&#123;each msgs as msg index&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;list-group-item&quot;</span>&gt;</span></span><br><span class="line">  &#123;&#123;msg.name&#125;&#125;说:&#123;&#123;msg.content&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">&quot;pull-right&quot;</span>&gt;</span>&#123;&#123;msg.create_at&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">&#123;&#123;/each&#125;&#125;</span><br></pre></td></tr></table></figure><h3 id="切换-NodeJS-版本"><a href="#切换-NodeJS-版本" class="headerlink" title="切换 NodeJS 版本"></a>切换 NodeJS 版本</h3><h4 id="nvm"><a href="#nvm" class="headerlink" title="nvm"></a>nvm</h4><p>通过 nvm 工具可以实现 node.js 任意版本切换</p><h5 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h5><p><a href="http://github.com/coreybutler/nvm-windows/releases">http://github.com/coreybutler/nvm-windows/releases</a></p><h5 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h5><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">nvm version</span><br><span class="line">nvm install   latest</span><br><span class="line">nvm install   版本号</span><br><span class="line">nvm uninstall 版本号</span><br><span class="line">nvm <span class="keyword">list</span></span><br><span class="line">nvm <span class="keyword">use</span>      版本号</span><br></pre></td></tr></table></figure><h2 id="七、优化"><a href="#七、优化" class="headerlink" title="七、优化"></a>七、优化</h2><p>通过应用生成器工具 <code>express-generator</code> 可以快速创建一个应用的骨架。</p><p>网站：<a href="http://www.expressjs.com.cn/">http://www.expressjs.com.cn</a></p><h3 id="7-1-路由优化（理解）"><a href="#7-1-路由优化（理解）" class="headerlink" title="7.1 路由优化（理解）"></a>7.1 路由优化（理解）</h3><h4 id="方法-1：（不推荐）"><a href="#方法-1：（不推荐）" class="headerlink" title="方法 1：（不推荐）"></a>方法 1：（不推荐）</h4><p>创建 routes 目录，在中创建 stu.js 文件，专门负责路由管理</p><p>stu.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">app, fs</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 路由部分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>app.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 4. 路由</span></span><br><span class="line"><span class="comment">// var indexRouter = require(&#x27;./routes/index&#x27;);</span></span><br><span class="line"><span class="comment">// var orderRouter = require(&#x27;./routes/order&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> stuRouter = <span class="built_in">require</span>(<span class="string">&quot;./routes/stu&quot;</span>);</span><br><span class="line"><span class="comment">// indexRouter(app, fs)</span></span><br><span class="line"><span class="comment">// orderRouter(app, fs)</span></span><br><span class="line">stuRouter(app, fs);</span><br></pre></td></tr></table></figure><h4 id="方法-2："><a href="#方法-2：" class="headerlink" title="方法 2："></a>方法 2：</h4><ol><li><p>修改 app.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var indexRouter = require(&#x27;./routes/index&#x27;);</span></span><br><span class="line"><span class="comment">// var orderRouter = require(&#x27;./routes/order&#x27;);</span></span><br><span class="line"><span class="keyword">var</span> stuRouter = <span class="built_in">require</span>(<span class="string">&quot;./routes/stu&quot;</span>);</span><br><span class="line"><span class="comment">// app.use(&#x27;/&#x27;,     indexRouter);</span></span><br><span class="line"><span class="comment">// app.use(&#x27;/order&#x27;, orderRouter);</span></span><br><span class="line">app.use(<span class="string">&quot;/stu&quot;</span>, stuRouter);</span><br></pre></td></tr></table></figure></li><li><p>stu.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&quot;fs&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> router = express.Router();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 路由部分</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = router;</span><br></pre></td></tr></table></figure></li></ol><h3 id="7-2-数据操作优化（理解）"><a href="#7-2-数据操作优化（理解）" class="headerlink" title="7.2 数据操作优化（理解）"></a>7.2 数据操作优化（理解）</h3><p>创建 models 文件夹，新建 stu.js</p><p>在其中创建模型</p><p>然后再路由当中调用，避免冗余，便于后期扩展开发</p><h2 id="八、Express-框架"><a href="#八、Express-框架" class="headerlink" title="八、Express 框架"></a>八、Express 框架</h2><h3 id="8-1-中间件"><a href="#8-1-中间件" class="headerlink" title="8.1 中间件"></a>8.1 中间件</h3><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>HTTP 请求中的过滤层（HTTP 请求交给方法处理前，先交给另一个方法过滤）</p><ul><li>PHP 中：BaseController</li><li>NodeJS 中：app.use()</li></ul><h5 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h5><p>判断登录状态、检测 RBAC 权限、错误捕捉等</p><h3 id="8-3-路由中间件"><a href="#8-3-路由中间件" class="headerlink" title="8.3 路由中间件"></a>8.3 路由中间件</h3><ol><li><p>创建 day3 目录</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">npm init -y</span><br><span class="line"><span class="comment">// 安装 express 以及 art</span></span><br><span class="line">npm install express art-template express-art-template</span><br></pre></td></tr></table></figure></li><li><p>app.js 中：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 express 模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 创建 app 对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 3. 配置</span></span><br><span class="line"><span class="comment">// 4. 路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">  next(); <span class="comment">// 继续向后访问</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">app.get(<span class="string">&quot;/stu&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;stu list&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;stu list&quot;</span>); <span class="comment">// end send render</span></span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/stu/create&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;stu add&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;stu add&quot;</span>); <span class="comment">// end send render</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 5. 启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;启动成功...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>中间件匹配成功后，不会继续往下寻找，需要使用 <code>next()</code>继续访问</p><p>使用<code>next()</code>函数需要添加 next 形参</p><p><code>function (req, res, next) &#123;&#125;</code></p></li></ol><h3 id="8-4-错误处理"><a href="#8-4-错误处理" class="headerlink" title="8.4 错误处理"></a>8.4 错误处理</h3><h5 id="中间件灵活使用"><a href="#中间件灵活使用" class="headerlink" title="中间件灵活使用"></a>中间件灵活使用</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">app.get(<span class="string">&quot;/stu&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  fs.readFile(<span class="string">&quot;./aaaa.txt&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (err) next(err); <span class="comment">// next如果不传递参数 只匹配下一个URL</span></span><br><span class="line">    <span class="comment">// next传递err 则匹配第一个含有err的中间件</span></span><br><span class="line">    res.send(data); <span class="comment">// end send render</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中间件灵活使用（404）</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;404 Page&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 错误统一处理</span></span><br><span class="line"><span class="comment">// 脚下留心：（形参可以不写，但顺序不能改变）</span></span><br><span class="line"><span class="comment">// &#x27;/&#x27; 可以省略不写，等价</span></span><br><span class="line"><span class="comment">// app.use(function (err, req, res, next) &#123;</span></span><br><span class="line">app.use(<span class="string">&quot;/&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, req, res, next</span>) </span>&#123;</span><br><span class="line">  res.send(<span class="string">&quot;网络异常... 请稍后重试&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>形参可以不写，但顺序不能改变</li><li>‘/‘ 可以省略不写，与写上等价</li><li>next 如果不传递参数 只匹配下一个 URL；next 传递 err 则匹配第一个含有 err 的中间件</li></ul><h2 id="九、会话技术"><a href="#九、会话技术" class="headerlink" title="九、会话技术"></a>九、会话技术</h2><h3 id="9-1-cookie"><a href="#9-1-cookie" class="headerlink" title="9.1 cookie"></a>9.1 cookie</h3><h5 id="手册"><a href="#手册" class="headerlink" title="手册"></a>手册</h5><p><a href="https://www.npmjs.com/package/cookie-parser">https://www.npmjs.com/package/cookie-parser</a></p><h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><ol><li><p> 安装 cookie 模块，语法：<code>npm install cookie-parser</code></p></li><li><p> 引入 cookie 模块，语法：<code>var cookieParser = require(&#39;cookie-parser&#39;)</code></p></li><li><p>初始化 cookie，语法：<code>app.use(cookieParser())</code></p><pre><code>                    相当于：`app.user(&#39;/&#39;, cookieParser())`</code></pre><p> <strong>作用</strong>：http 传入的 cookie 进行解析后赋值给 req.cookies</p><p> <strong>其次</strong>：cookieParser 加参数，并且设置是 signed=true 则加密存储（推荐）</p></li></ol><h6 id="设置"><a href="#设置" class="headerlink" title="设置"></a>设置</h6><p><code>res.cookie(键, 值, &#123;signed: 是否加密true-是,false-否默认,maxAge: 时间/毫秒&#125;)</code></p><p>获取（未加密）：<code>req.cookies</code></p><p>获取（ 加密）：<code>req.signedCookies</code></p><p>清除：<code>res.clearCookie(键)</code></p><h5 id="代码测试"><a href="#代码测试" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求：设置cookie数据a=1永久，b=2（1分钟）c=3（加密）d=4（删除）</span></span><br><span class="line"><span class="comment">//1.引入express框架模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> cookieParser = <span class="built_in">require</span>(<span class="string">&quot;cookie-parser&quot;</span>);</span><br><span class="line"><span class="comment">//2.创建框架核心app对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">//3.配置</span></span><br><span class="line"><span class="comment">//http传入的cookie进行解析后赋值给req.cookies</span></span><br><span class="line">app.use(cookieParser(<span class="string">&quot;itcast&quot;</span>));</span><br><span class="line"><span class="comment">//4.路由</span></span><br><span class="line">app.get(<span class="string">&quot;/set&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//res.cookie(键, 值, &#123;signed: 是否加密true-是,false-否默认,maxAge: 时间/毫秒&#125;)</span></span><br><span class="line">  res.cookie(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  res.cookie(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, &#123; <span class="attr">maxAge</span>: <span class="number">60</span> * <span class="number">1000</span> &#125;);</span><br><span class="line">  res.cookie(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, &#123; <span class="attr">signed</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">  res.cookie(<span class="string">&quot;d&quot;</span>, <span class="number">4</span>);</span><br><span class="line">  res.send(<span class="string">&quot;设置成功&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/get&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;未加密&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(req.cookies);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;加密&quot;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(req.signedCookies);</span><br><span class="line">  res.send(<span class="string">&quot;打开控制台查看&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/del&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//res.clearCookie(键)</span></span><br><span class="line">  res.clearCookie(<span class="string">&quot;d&quot;</span>);</span><br><span class="line">  res.send(<span class="string">&quot;删除成功，重新访问/get验证&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//5.启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;Running...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="9-2-session"><a href="#9-2-session" class="headerlink" title="9.2 session"></a>9.2 session</h3><h5 id="手册-1"><a href="#手册-1" class="headerlink" title="手册"></a>手册</h5><p><a href="https://www.npmjs.com/package/express-session">https://www.npmjs.com/package/express-session</a></p><h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><ol><li>安装 session 模块，语法：<code>npm install express-session</code></li><li>引入 session 模块，语法：<code>var session = require(&#39;express-session&#39;)</code></li><li>初始化 session，语法：</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&quot;itcast&quot;</span>, <span class="comment">// 加密存储</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>, <span class="comment">// 客户端并行请求是否覆盖:true-是,false-否</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span>, <span class="comment">// 初始化session存储</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>设置：<code>req.session.键 = 值</code></p><p>获取：<code>req.session.键</code></p><p>清除：<code>req.session.键 = null</code></p><h5 id="代码测试-1"><a href="#代码测试-1" class="headerlink" title="代码测试"></a>代码测试</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入 express 模块</span></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> session = <span class="built_in">require</span>(<span class="string">&quot;express-session&quot;</span>);</span><br><span class="line"><span class="comment">// 2. 创建 app 对象</span></span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"><span class="comment">// 3. 配置</span></span><br><span class="line">app.use(</span><br><span class="line">  session(&#123;</span><br><span class="line">    <span class="attr">secret</span>: <span class="string">&quot;itcast&quot;</span>, <span class="comment">//加密存储</span></span><br><span class="line">    <span class="attr">resave</span>: <span class="literal">false</span>, <span class="comment">//客户端并行请求是否覆盖:true-是,false-否</span></span><br><span class="line">    <span class="attr">saveUninitialized</span>: <span class="literal">true</span>, <span class="comment">//初始化session存储</span></span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br><span class="line"><span class="comment">// 4. 路由（需  求：设置session数据a=1，b=2，c=3 最后删除c）</span></span><br><span class="line">app.get(<span class="string">&quot;/set&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  req.session.a = <span class="number">1</span>;</span><br><span class="line">  req.session.b = <span class="number">2</span>;</span><br><span class="line">  req.session.c = <span class="number">3</span>;</span><br><span class="line">  res.send(<span class="string">&quot;设置成功，通过/get获取&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/get&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(req.session.a);</span><br><span class="line">  <span class="built_in">console</span>.log(req.session.b);</span><br><span class="line">  <span class="built_in">console</span>.log(req.session.c);</span><br><span class="line">  res.send(<span class="string">&quot;获取成功，请通过控制台查看&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">app.get(<span class="string">&quot;/del&quot;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</span><br><span class="line">  req.session.c = <span class="literal">null</span>;</span><br><span class="line">  res.send(<span class="string">&quot;删除成功，请通过/get重新查看&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 5. 启动服务</span></span><br><span class="line">app.listen(<span class="number">8080</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;启动成功...&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>cookie 在客户端；session 在服务端</p><h2 id="十、总结"><a href="#十、总结" class="headerlink" title="十、总结"></a>十、总结</h2><h4 id="如何展示静态页面"><a href="#如何展示静态页面" class="headerlink" title="如何展示静态页面"></a>如何展示静态页面</h4><h6 id="在-PHP-中"><a href="#在-PHP-中" class="headerlink" title="在 PHP 中"></a>在 PHP 中</h6><ol><li>确定路由</li><li>根据路由创建控制器方法 -&gt; 加载视图 display 或 view 函数</li><li>创建视图 -&gt; 修改静态资源路径</li></ol><h6 id="在-NodeJS-中"><a href="#在-NodeJS-中" class="headerlink" title="在 NodeJS 中"></a>在 NodeJS 中</h6><ol><li>定义路由 -&gt; 通过 render 加载视图传递数据</li><li>创建视图 -&gt; 修改静态资源路径</li></ol><h4 id="如何数据处理"><a href="#如何数据处理" class="headerlink" title="如何数据处理"></a>如何数据处理</h4><ol><li>修改表单属性值</li><li>接受数据</li><li>逻辑数据</li><li>数据库操作</li><li>判断跳转</li></ol><h4 id="如何显示列表"><a href="#如何显示列表" class="headerlink" title="如何显示列表"></a>如何显示列表</h4><ol><li>控制器方法获取数据 -&gt; 传递给视图</li><li>调用模板标签循环显示</li></ol><h4 id="如何实现-增删改"><a href="#如何实现-增删改" class="headerlink" title="如何实现 增删改"></a>如何实现 增删改</h4><ol><li>修改静态页面（前：修改表单 action name 后：修改 a 标签 id）</li><li>数据处理（1-接受数据，2-数据过滤，3-入库，4-判断跳转）</li></ol><h3 id="express-模板框架生成器"><a href="#express-模板框架生成器" class="headerlink" title="express 模板框架生成器"></a>express 模板框架生成器</h3><p>全局安装</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g express-<span class="built_in">generator</span></span><br></pre></td></tr></table></figure><p>在想要生成项目的目录下终端输入</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">express 项目名</span><br></pre></td></tr></table></figure><p>即可自动生成</p><p>然后</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd 项目名</span><br><span class="line">npm install</span><br><span class="line">npm install art-template express-art-template</span><br></pre></td></tr></table></figure><p>激活默认模板引擎</p><p>替换</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.set(&#x27;views&#x27;, path.join(__dirname, &#x27;views&#x27;));</span></span><br><span class="line"><span class="comment">// app.set(&#x27;view engine&#x27;, &#x27;jade&#x27;);</span></span><br></pre></td></tr></table></figure><p>为</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.use(<span class="string">&quot;/public&quot;</span>, express.static(<span class="string">&quot;public&quot;</span>));</span><br><span class="line">app.set(<span class="string">&quot;views&quot;</span>, path.join(__dirname, <span class="string">&quot;views&quot;</span>));</span><br><span class="line">app.engine(<span class="string">&quot;html&quot;</span>, <span class="built_in">require</span>(<span class="string">&quot;express-art-template&quot;</span>));</span><br><span class="line">app.set(<span class="string">&quot;view engine&quot;</span>, <span class="string">&quot;html&quot;</span>);</span><br></pre></td></tr></table></figure><p>即可进行后续开发</p><h1 id="ES6-扩展"><a href="#ES6-扩展" class="headerlink" title="ES6 扩展"></a>ES6 扩展</h1><h2 id="数组扩展新语法"><a href="#数组扩展新语法" class="headerlink" title="数组扩展新语法"></a>数组扩展新语法</h2><h4 id="find-搜索"><a href="#find-搜索" class="headerlink" title="find() 搜索"></a><code>find()</code> 搜索</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var arr = [</span></span><br><span class="line"><span class="comment">// &#123;name:&#x27;test1&#x27;, age: 1&#125;,</span></span><br><span class="line"><span class="comment">// &#123;name:&#x27;test2&#x27;, age: 2&#125;,</span></span><br><span class="line"><span class="comment">// &#123;name:&#x27;test3&#x27;, age: 3&#125;</span></span><br><span class="line"><span class="comment">// ];</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// //需求：获取name=test3的元素下标</span></span><br><span class="line"><span class="comment">// var index = arr.findIndex(function(item)&#123;</span></span><br><span class="line"><span class="comment">// return item.name == &#x27;test3&#x27;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// console.log(index)</span></span><br><span class="line"><span class="comment">// //需求：获取name=test3的元素</span></span><br><span class="line"><span class="comment">// var obj = arr.find(function(item)&#123;</span></span><br><span class="line"><span class="comment">// return item.name == &#x27;test3&#x27;</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"><span class="comment">// console.log(obj)</span></span><br><span class="line"><span class="comment">// console.log(&#x27;------------&#x27;)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原理</span></span><br><span class="line"><span class="comment">//JS面向对象：封装 、 继承、 多态</span></span><br><span class="line"><span class="comment">//JS封装：this 私有的  var 公开的 （类控制成员只保留部分的成员和方法供外部使用 通过修饰符 public private protected）</span></span><br><span class="line"><span class="comment">//JS继承：prototype        （extend）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//var xx = [1,2] 相当于 var xx  = new Array(1,2)</span></span><br><span class="line"><span class="comment">//var xx = &#x27;aaa&#x27; 相当于 var xx  = new String(&#x27;aaa&#x27;)</span></span><br><span class="line"><span class="comment">//Array是系统类</span></span><br><span class="line"><span class="comment">//现在通过原先继承，给他增加一个myFind方法</span></span><br><span class="line"><span class="built_in">Array</span>.prototype.myFind = <span class="function"><span class="keyword">function</span> (<span class="params">conditionFunc</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//conditionFunc == function(item) &#123; return item.name == &#x27;test3&#x27; &#125;</span></span><br><span class="line">  <span class="comment">//this指调用当前方法的对象（注：下述代码 arr调用myFind）</span></span><br><span class="line">  <span class="comment">//所以this指arr</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.length; i++) &#123;</span><br><span class="line">    <span class="comment">//判断条件是否成立，成立就返回（注：this指数组，this[i] 数组中的元素）</span></span><br><span class="line">    <span class="keyword">if</span> (conditionFunc(<span class="built_in">this</span>[i])) &#123;</span><br><span class="line">      <span class="comment">//return this[i]  //相当于 es6中的find</span></span><br><span class="line">      <span class="keyword">return</span> i; <span class="comment">//相当于 es6中的findIndex</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;test1&quot;</span>, <span class="attr">age</span>: <span class="number">1</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;test2&quot;</span>, <span class="attr">age</span>: <span class="number">2</span> &#125;,</span><br><span class="line">  &#123; <span class="attr">name</span>: <span class="string">&quot;test3&quot;</span>, <span class="attr">age</span>: <span class="number">3</span> &#125;,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">var</span> result = arr.myFind(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item.name == <span class="string">&quot;test2&quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(result);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> nodejs </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ajax笔记</title>
      <link href="/2021/07/28/ajax%E7%AC%94%E8%AE%B0/"/>
      <url>/2021/07/28/ajax%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="零、基本概述"><a href="#零、基本概述" class="headerlink" title="零、基本概述"></a>零、基本概述</h3><h4 id="0-1-服务器"><a href="#0-1-服务器" class="headerlink" title="0.1 服务器"></a>0.1 服务器</h4><p>提供了某种服务的电脑，一般没有显示器，没有输入设备</p><p>服务器主要提供的服务：</p><ul><li>文件服务器（提供文件下载任务）</li><li>邮件服务器（提供邮件服务）</li><li>游戏服务器</li><li>web 服务器</li></ul><h4 id="0-2-web-服务器"><a href="#0-2-web-服务器" class="headerlink" title="0.2 web 服务器"></a>0.2 web 服务器</h4><h5 id="如何成为-web-服务器："><a href="#如何成为-web-服务器：" class="headerlink" title="如何成为 web 服务器："></a>如何成为 web 服务器：</h5><p>装一个软件：</p><ul><li>apache – 阿帕奇：开源的 web 服务器软件，目前使用人数最多的 web 服务器软件</li><li>IIS – 微软的 web 服务器软件，不开源 –&gt; 开源</li><li>tomcat – web 服务器软件</li><li>Nqinx – web 服务器软件</li></ul><h3 id="一、原生-Ajax"><a href="#一、原生-Ajax" class="headerlink" title="一、原生 Ajax"></a>一、原生 Ajax</h3><h4 id="1-1-AJAX-简介"><a href="#1-1-AJAX-简介" class="headerlink" title="1.1 AJAX 简介"></a>1.1 AJAX 简介</h4><p>页面内加载数据，不进行刷新界面</p><h4 id="1-2-XML-简介"><a href="#1-2-XML-简介" class="headerlink" title="1.2 XML 简介"></a>1.2 XML 简介</h4><p>XML 可扩展标记语言，被设计用来传输和存储数据</p><p>比如说我有一个学生数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;孙悟空&quot;</span>; age = <span class="number">18</span>; gender=<span class="string">&quot;男&quot;</span>;</span><br></pre></td></tr></table></figure><p>用 XML 表示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>孙悟空<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">gender</span>&gt;</span>男<span class="tag">&lt;/<span class="name">gender</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在已经被 JSON 取代了</p><p>用 JOSN 表示：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;孙悟空&quot;</span>, <span class="attr">&quot;age&quot;</span>: <span class="number">18</span>, <span class="attr">&quot;gender&quot;</span>: <span class="string">&quot;男&quot;</span> &#125;</span><br></pre></td></tr></table></figure><h4 id="1-3-AJAX-的特点"><a href="#1-3-AJAX-的特点" class="headerlink" title="1.3 AJAX 的特点"></a>1.3 AJAX 的特点</h4><h5 id="1-3-1-优点"><a href="#1-3-1-优点" class="headerlink" title="1.3.1 优点"></a>1.3.1 优点</h5><ol><li>可以无需刷新页面而与服务器端进行通信</li><li>允许你根据用户事件来更新部分页面内容</li></ol><h5 id="1-3-2-缺点"><a href="#1-3-2-缺点" class="headerlink" title="1.3.2 缺点"></a>1.3.2 缺点</h5><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO 不友好</li></ol><h4 id="1-4-http-协议"><a href="#1-4-http-协议" class="headerlink" title="1.4 http 协议"></a>1.4 http 协议</h4><p>HTTP (hypertext transport protocol) 协议【超文本传输协议】</p><p>详细规定了浏览器和万维网服务器之间互相通信的规则。</p><p>以下报文可以在</p><h5 id="1-4-1-请求报文"><a href="#1-4-1-请求报文" class="headerlink" title="1.4.1 请求报文"></a>1.4.1 请求报文</h5><p>格式与参数：</p><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">行POST /s?ie=utf-8  HTTP/1.1</span><br><span class="line">头Host: atguigu.com</span><br><span class="line"> Cookie: name=guigu</span><br><span class="line"> Content-type: application/x-www-form-urlencoded</span><br><span class="line"> User-Agent: chrome 83</span><br><span class="line">空行</span><br><span class="line">体GET(为空) POST(可以不为空) username=admin&amp;admin&amp;password=admin</span><br></pre></td></tr></table></figure><h5 id="1-4-2-响应报文"><a href="#1-4-2-响应报文" class="headerlink" title="1.4.2 响应报文"></a>1.4.2 响应报文</h5><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">行HTTP/1.1  200 (404,403,401,500,200)  OK</span><br><span class="line">头Content-Type: texy/html;charset=utf-8</span><br><span class="line"> Content-length: 2048</span><br><span class="line"> Content-encoding: gzip</span><br><span class="line">空行</span><br><span class="line">体&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;张艺兴&lt;/h1&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>安装 node.js</p><p>安装 Express：基于 Node.js 的 web 开发框架</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 初始化npm</span><br><span class="line">npm init --yes</span><br><span class="line">// 安装 express 框架</span><br><span class="line">npm install express</span><br></pre></td></tr></table></figure><p>设置服务端 server.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 引入express</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&quot;express&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 创建应用对象</span></span><br><span class="line"><span class="keyword">const</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 创建路由规则</span></span><br><span class="line"><span class="comment">// request  对请求报文的封装</span></span><br><span class="line"><span class="comment">// response 对相应报文的封装</span></span><br><span class="line">app.get(<span class="string">&quot;/server&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置相应头 设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// 响应头 设置允许接受自定义相应头</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// 设置响应</span></span><br><span class="line">  <span class="comment">// response.send(&#x27;HELLO EXPRESS&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span> &#125;;</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4. 监听端口启动服务</span></span><br><span class="line">app.listen(<span class="number">8000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;服务已经启动， 8000 端口接听中....&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>启动 web 服务端 cd 到对应文件夹打开终端</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node server<span class="selector-class">.js</span></span><br></pre></td></tr></table></figure><p>nodemon 工具：帮助我们重启服务</p><p><a href="https://www.npmjs.com/package/nodemon">https://www.npmjs.com/package/nodemon</a> 官网</p><p>终端输入 安装</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><h3 id="二、jQuery-AJAX"><a href="#二、jQuery-AJAX" class="headerlink" title="二、jQuery AJAX"></a>二、jQuery AJAX</h3><h4 id="2-1-导入-jQuery"><a href="#2-1-导入-jQuery" class="headerlink" title="2.1 导入 jQuery"></a>2.1 导入 jQuery</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/jquery/3.6.0/jquery.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="2-2-jQuery-发送-AJAX"><a href="#2-2-jQuery-发送-AJAX" class="headerlink" title="2.2 jQuery 发送 AJAX"></a>2.2 jQuery 发送 AJAX</h4><h5 id="get"><a href="#get" class="headerlink" title="get"></a>get</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.get(</span><br><span class="line">  <span class="string">&quot;http://127.0.0.1:8000/jquery-serve&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">&quot;json&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="post"><a href="#post" class="headerlink" title="post"></a>post</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.post(</span><br><span class="line">  <span class="string">&quot;http://127.0.0.1:8000/jquery-serve&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h5 id="ajax"><a href="#ajax" class="headerlink" title="ajax"></a>ajax</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  <span class="comment">// url</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;http://127.0.0.1:8000/jquery-serve&quot;</span>,</span><br><span class="line">  <span class="comment">// 参数</span></span><br><span class="line">  <span class="attr">data</span>: &#123; <span class="attr">a</span>: <span class="number">100</span>, <span class="attr">b</span>: <span class="number">200</span> &#125;,</span><br><span class="line">  <span class="comment">// 请求类型</span></span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;GET&quot;</span>,</span><br><span class="line">  <span class="comment">// 响应体结果</span></span><br><span class="line">  <span class="attr">dataType</span>: <span class="string">&quot;json&quot;</span>,</span><br><span class="line">  <span class="comment">// 成功的回调</span></span><br><span class="line">  <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 超时时间</span></span><br><span class="line">  <span class="attr">timeout</span>: <span class="number">2000</span>,</span><br><span class="line">  <span class="comment">// 失败的回调</span></span><br><span class="line">  <span class="attr">error</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 头信息</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="attr">c</span>: <span class="number">300</span>,</span><br><span class="line">    <span class="attr">d</span>: <span class="number">400</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jQuery 服务</span></span><br><span class="line">app.all(<span class="string">&quot;/jquery-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置相应头 设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello jQuery AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span> &#125;;</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="三、Axios"><a href="#三、Axios" class="headerlink" title="三、Axios"></a>三、Axios</h3><h4 id="3-1-引入-Axios"><a href="#3-1-引入-Axios" class="headerlink" title="3.1 引入 Axios"></a>3.1 引入 Axios</h4><h5 id="script-标签引入-Axios"><a href="#script-标签引入-Axios" class="headerlink" title="script 标签引入 Axios"></a>script 标签引入 Axios</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// crossorigin=&quot;anonymous&quot; 页面报错可以加</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span></span></span><br><span class="line"><span class="tag">  <span class="attr">crossorigin</span>=<span class="string">&quot;anonymous&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">src</span>=<span class="string">&quot;https://cdn.bootcdn.net/ajax/libs/axios/0.21.1/axios.min.js&quot;</span></span></span><br><span class="line"><span class="tag">&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="npm-下载"><a href="#npm-下载" class="headerlink" title="npm 下载"></a>npm 下载</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><h4 id="3-2-发送-AJAX-请求"><a href="#3-2-发送-AJAX-请求" class="headerlink" title="3.2 发送 AJAX 请求"></a>3.2 发送 AJAX 请求</h4><h5 id="get-1"><a href="#get-1" class="headerlink" title="get"></a>get</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">axios</span><br><span class="line">  .get(<span class="string">&quot;http://127.0.0.1:8000/axios-serve&quot;</span>, &#123;</span><br><span class="line">    <span class="comment">// url参数</span></span><br><span class="line">    <span class="attr">params</span>: &#123;</span><br><span class="line">      <span class="attr">id</span>: <span class="number">100</span>,</span><br><span class="line">      <span class="attr">vip</span>: <span class="number">7</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 请求头信息</span></span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">      <span class="attr">name</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">      <span class="attr">age</span>: <span class="number">20</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">value</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h5 id="post-1"><a href="#post-1" class="headerlink" title="post"></a>post</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">btns[<span class="number">1</span>].onclick = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  axios.post(</span><br><span class="line">    <span class="string">&quot;/axios-serve&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">      <span class="attr">password</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// url参数</span></span><br><span class="line">      <span class="attr">params</span>: &#123;</span><br><span class="line">        <span class="attr">id</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">vip</span>: <span class="number">9</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="comment">// 请求头信息</span></span><br><span class="line">      <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="attr">height</span>: <span class="number">180</span>,</span><br><span class="line">        <span class="attr">weight</span>: <span class="number">180</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="ajax-1"><a href="#ajax-1" class="headerlink" title="ajax"></a>ajax</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">axios(&#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="comment">// url</span></span><br><span class="line">  <span class="attr">url</span>: <span class="string">&quot;/axios-serve&quot;</span>,</span><br><span class="line">  <span class="comment">// url参数</span></span><br><span class="line">  <span class="attr">params</span>: &#123;</span><br><span class="line">    <span class="attr">vip</span>: <span class="number">10</span>,</span><br><span class="line">    <span class="attr">leave</span>: <span class="number">30</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 头信息</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="attr">a</span>: <span class="number">100</span>,</span><br><span class="line">    <span class="attr">b</span>: <span class="number">200</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 请求体参数</span></span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">username</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">    <span class="attr">password</span>: <span class="string">&quot;admin&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;).then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(response);</span><br><span class="line">  <span class="comment">// 响应状态码</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.status);</span><br><span class="line">  <span class="comment">// 响应状态字符串</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.statusText);</span><br><span class="line">  <span class="comment">// 响应头信息</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.headers);</span><br><span class="line">  <span class="comment">// 响应体</span></span><br><span class="line">  <span class="built_in">console</span>.log(response.data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Axios 服务</span></span><br><span class="line">app.all(<span class="string">&quot;/axios-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置相应头 设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.send(<span class="string">&quot;Hello Axios AJAX&quot;</span>);</span><br><span class="line">  <span class="comment">// const data = &#123;name: &#x27;张艺兴&#x27;&#125;</span></span><br><span class="line">  <span class="comment">// response.send(JSON.stringify(data));</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="四、使用-fetch-函数"><a href="#四、使用-fetch-函数" class="headerlink" title="四、使用 fetch 函数"></a>四、使用 fetch 函数</h3><h4 id="使用-fetch-请求"><a href="#使用-fetch-请求" class="headerlink" title="使用 fetch 请求"></a>使用 fetch 请求</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">&quot;http://127.0.0.1:8000/fetch-serve?vip=10&quot;</span>, &#123;</span><br><span class="line">  <span class="comment">// 请求方法</span></span><br><span class="line">  <span class="attr">method</span>: <span class="string">&quot;POST&quot;</span>,</span><br><span class="line">  <span class="comment">// 请求头</span></span><br><span class="line">  <span class="attr">headers</span>: &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;AgoniLay&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 请求体</span></span><br><span class="line">  <span class="attr">body</span>: <span class="string">&quot;username=admin&amp;password=admin&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// return response.text();</span></span><br><span class="line">    <span class="keyword">return</span> response.json();</span><br><span class="line">  &#125;)</span><br><span class="line">  .then(<span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(response);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fetch 服务</span></span><br><span class="line">app.all(<span class="string">&quot;/fetch-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置相应头 设置允许跨域</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// response.send(&#x27;Hello Fetch AJAX&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123; <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span> &#125;;</span><br><span class="line">  response.send(<span class="built_in">JSON</span>.stringify(data));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="五、跨域"><a href="#五、跨域" class="headerlink" title="五、跨域"></a>五、跨域</h3><h4 id="5-1-同源策略-Same-Origin-Policy"><a href="#5-1-同源策略-Same-Origin-Policy" class="headerlink" title="5.1 同源策略 (Same-Origin Policy)"></a>5.1 同源策略 (Same-Origin Policy)</h4><p>最早由 Netscape 公司提出，是浏览器的一种安全策略。</p><p>同源：协议、域名、端口号 必须完全相同。</p><p>违背同源策略就是跨域。</p><h4 id="5-2-如何解决跨域"><a href="#5-2-如何解决跨域" class="headerlink" title="5.2 如何解决跨域"></a>5.2 如何解决跨域</h4><h5 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h5><ol><li><p>JSONP 是什么</p><p>JSONP(JSONP with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持 get 请求。</p></li><li><p>JSONP 怎么工作的？</p><p>在网页有一些标签天生具有跨域能力，比如：img link iframe script</p><p>利用 script 标签的跨域能力来发送请求的。</p></li></ol><h6 id="使用-jsonp-跨域"><a href="#使用-jsonp-跨域" class="headerlink" title="使用 jsonp 跨域"></a>使用 jsonp 跨域</h6><p>index.html：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">  <span class="comment">// 处理数据</span></span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">handle</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="comment">// 获取 result 元素</span></span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> result = <span class="built_in">document</span>.getElementById(<span class="string">&quot;result&quot;</span>);</span></span><br><span class="line"><span class="javascript">    result.innerHTML = data.name;</span></span><br><span class="line"><span class="javascript">  &#125;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;script src=&quot;./js/app.js&quot;&gt;&lt;/script&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://127.0.0.1:8000/jsonp-serve&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>app.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> data = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;张艺兴帅&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">handle(data);</span><br></pre></td></tr></table></figure><p>server.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// jsonp 服务</span></span><br><span class="line">app.all(<span class="string">&quot;/jsonp-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张艺兴帅&quot;</span>,</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 见这个字符串转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  response.end(<span class="string">`handle(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h6 id="jQuery-发送-JSONP-请求"><a href="#jQuery-发送-JSONP-请求" class="headerlink" title="jQuery 发送 JSONP 请求"></a>jQuery 发送 JSONP 请求</h6><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.getJSON(</span><br><span class="line">  <span class="string">&quot;http://127.0.0.1:8000/jquery-jsonp-serve?callback=?&quot;</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">&quot;#result&quot;</span>).html(<span class="string">`</span></span><br><span class="line"><span class="string">        名称：<span class="subst">$&#123;data.name&#125;</span>&lt;br&gt;</span></span><br><span class="line"><span class="string">        校区：<span class="subst">$&#123;data.city&#125;</span></span></span><br><span class="line"><span class="string">    `</span>);</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">&quot;/jquery-jsonp-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// response.send(&#x27;console.log(&quot;hello jsonp&quot;)&#x27;);</span></span><br><span class="line">  <span class="keyword">const</span> data = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&quot;张艺兴&quot;</span>,</span><br><span class="line">    <span class="attr">city</span>: [<span class="string">&quot;LAY&quot;</span>, <span class="string">&quot;AGONI&quot;</span>, <span class="string">&quot;AGONILAY&quot;</span>],</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 见这个字符串转化为字符串</span></span><br><span class="line">  <span class="keyword">let</span> str = <span class="built_in">JSON</span>.stringify(data);</span><br><span class="line">  <span class="comment">// 接收 callback 参数</span></span><br><span class="line">  <span class="keyword">let</span> cb = request.query.callback;</span><br><span class="line">  <span class="comment">// 返回结果</span></span><br><span class="line">  response.end(<span class="string">`<span class="subst">$&#123;cb&#125;</span>(<span class="subst">$&#123;str&#125;</span>)`</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h5 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h5><ol><li><p>CORS 是什么</p><p>CORS (Cross-Origin Resource Sharing)，跨域资源共享。是官方的跨域解决方案。</p><p>特点：不需要再客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 请求。</p></li><li><p>CORS 是怎么工作的</p><p>通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p></li><li><p>CORS 的使用</p><p>主要是服务器端的设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">app.all(<span class="string">&quot;/cors-serve&quot;</span>, <span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 设置响应头</span></span><br><span class="line">  response.setHeader(<span class="string">&quot;Access-Control-Allow-Origin&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">  <span class="comment">// response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;http://127.0.0.1:5500&#x27;)</span></span><br><span class="line"></span><br><span class="line">  response.send(<span class="string">&quot;hello cors&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>一般还会设置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置响应头部</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line"><span class="comment">// 设置响应方法</span></span><br><span class="line">response.setHeader(<span class="string">&quot;Access-Control-Allow-Method&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br></pre></td></tr></table></figure></li></ol><p>笔记 CSDN 博客地址：<a href="https://blog.csdn.net/qq_58163927/article/details/118693841">https://blog.csdn.net/qq_58163927/article/details/118693841</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> Ajax </tag>
            
            <tag> axios </tag>
            
            <tag> 跨域 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
